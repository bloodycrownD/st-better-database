(function(){"use strict";try{if(typeof document<"u"){var a=document.createElement("style");a.appendChild(document.createTextNode('.st-card-unified[data-v-5b66fbc1]{min-height:48px;display:flex;align-items:center;transition:background-color var(--animation-duration, 125ms)}.st-card-unified>div[data-v-5b66fbc1]{width:100%}.st-toggle-switch[data-v-f73e4a93]{position:relative;display:inline-block;width:40px;height:22px;transform:scale(.9)}.st-toggle-switch input[data-v-f73e4a93]{opacity:0;width:0;height:0}.st-toggle-slider[data-v-f73e4a93]{position:absolute;cursor:pointer;inset:0;background-color:var(--SmartThemeEmColor);transition:var(--animation-duration, 125ms);border-radius:22px}.st-toggle-slider[data-v-f73e4a93]:before{position:absolute;content:"";height:16px;width:16px;left:3px;bottom:3px;background-color:var(--SmartThemeBodyColor);transition:var(--animation-duration, 125ms);border-radius:50%;box-shadow:0 2px 4px var(--SmartThemeShadowColor)}input:checked+.st-toggle-slider[data-v-f73e4a93]{background-color:var(--SmartThemeBodyColor)}input:checked+.st-toggle-slider[data-v-f73e4a93]:before{transform:translate(18px);background-color:var(--SmartThemeBlurTintColor)}.button-wrapper[data-v-8b9ccff3]{display:inline-flex;align-items:center;justify-content:center;flex-direction:row}.button-content[data-v-8b9ccff3]{display:flex;align-items:center;gap:6px;flex-direction:row;white-space:nowrap}.popup-modal-overlay[data-v-546209e7]{position:fixed;inset:0;background:#00000080;display:flex;align-items:center;justify-content:center;z-index:9999;padding:20px}.popup-modal[data-v-546209e7]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:8px;box-shadow:0 4px 20px var(--SmartThemeShadowColor);max-width:1200px;width:100%;max-height:90vh;display:flex;flex-direction:column}.popup-modal-header[data-v-546209e7]{display:flex;justify-content:space-between;align-items:center;padding:16px 20px;border-bottom:1px solid var(--SmartThemeBorderColor)}.popup-modal-title[data-v-546209e7]{font-size:18px;font-weight:600;color:var(--SmartThemeBodyColor);display:flex;align-items:center;gap:8px}.popup-modal-close[data-v-546209e7]{width:32px;height:32px;display:flex;align-items:center;justify-content:center;cursor:pointer;border-radius:4px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);transition:all .2s}.popup-modal-close[data-v-546209e7]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.popup-modal-close i[data-v-546209e7]{font-size:18px}.popup-modal-body[data-v-546209e7]{flex:1;overflow:auto;padding:20px}.popup-modal-footer[data-v-546209e7]{padding:16px 20px;border-top:1px solid var(--SmartThemeBorderColor);display:flex;justify-content:flex-end;gap:10px}.modal-enter-active[data-v-546209e7],.modal-leave-active[data-v-546209e7]{transition:opacity .3s ease}.modal-enter-from[data-v-546209e7],.modal-leave-to[data-v-546209e7]{opacity:0}.modal-enter-active .popup-modal[data-v-546209e7],.modal-leave-active .popup-modal[data-v-546209e7]{transition:transform .3s ease,opacity .3s ease}.modal-enter-from .popup-modal[data-v-546209e7],.modal-leave-to .popup-modal[data-v-546209e7]{transform:scale(.9);opacity:0}@media(max-width:768px){.popup-modal-overlay[data-v-546209e7]{padding:10px}.popup-modal[data-v-546209e7]{height:90vh;border-radius:8px 8px 0 0;margin-top:auto}.popup-modal-header[data-v-546209e7]{padding:12px 16px}.popup-modal-title[data-v-546209e7]{font-size:16px}.popup-modal-body[data-v-546209e7]{padding:16px}.popup-modal-footer[data-v-546209e7]{padding:12px 16px}}.table-list-drawer[data-v-02fb0397]{display:flex;flex-direction:column;height:100%;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);border-right:1px solid var(--SmartThemeBorderColor)}.drawer-header[data-v-02fb0397]{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor)}.drawer-title[data-v-02fb0397]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.header-actions[data-v-02fb0397]{display:flex;align-items:center;gap:6px}.sync-btn[data-v-02fb0397],.push-btn[data-v-02fb0397]{display:flex;align-items:center;justify-content:center;width:28px;height:28px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);cursor:pointer;transition:all .2s}.sync-btn[data-v-02fb0397]:hover,.push-btn[data-v-02fb0397]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.sync-btn i[data-v-02fb0397],.push-btn i[data-v-02fb0397]{font-size:13px}.create-table-btn[data-v-02fb0397]{display:flex;align-items:center;justify-content:center;width:28px;height:28px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);cursor:pointer;transition:all .2s}.create-table-btn[data-v-02fb0397]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.create-table-btn i[data-v-02fb0397]{font-size:13px}.drawer-body[data-v-02fb0397]{flex:1;overflow-y:auto;padding:8px}.empty-state[data-v-02fb0397]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:200px;gap:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.empty-state i[data-v-02fb0397]{font-size:32px}.empty-state span[data-v-02fb0397]{font-size:14px}.empty-create-btn[data-v-02fb0397]{display:flex;align-items:center;gap:6px;padding:8px 16px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s;margin-top:8px}.empty-create-btn[data-v-02fb0397]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.empty-create-btn i[data-v-02fb0397]{font-size:12px}.table-list[data-v-02fb0397]{display:flex;flex-direction:column;gap:4px}.table-item[data-v-02fb0397]{padding:12px;border-radius:6px;cursor:pointer;transition:all .2s;border:1px solid transparent}.table-item[data-v-02fb0397]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.table-item.active[data-v-02fb0397]{background:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent);border-color:var(--SmartThemeBorderColor)}.table-item-main[data-v-02fb0397]{display:flex;align-items:center;gap:8px;margin-bottom:4px}.table-icon[data-v-02fb0397]{font-size:14px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.table-name[data-v-02fb0397]{font-size:14px;font-weight:500;color:var(--SmartThemeBodyColor);flex:1;word-break:break-all}.table-comment[data-v-02fb0397]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);margin-left:22px;word-break:break-all}@media(max-width:768px){.drawer-header[data-v-02fb0397],.drawer-body[data-v-02fb0397]{padding:12px}.empty-state[data-v-02fb0397]{height:auto;min-height:150px;padding:20px}.table-list[data-v-02fb0397]{gap:8px}.table-item[data-v-02fb0397]{padding:14px 12px}.table-name[data-v-02fb0397]{font-size:15px}.table-comment[data-v-02fb0397]{font-size:13px;margin-top:4px;margin-left:0}}.table-drawer-layout[data-v-c00243da]{display:flex;flex-direction:column;height:100%;min-height:500px}.layout-content[data-v-c00243da]{flex:1;display:flex;overflow:hidden;position:relative}.layout-drawer[data-v-c00243da]{width:240px;flex-shrink:0;border-right:1px solid var(--SmartThemeBorderColor)}.layout-main[data-v-c00243da]{flex:1;overflow:hidden}.drawer-slide-enter-active[data-v-c00243da],.drawer-slide-leave-active[data-v-c00243da]{transition:all .3s ease}.drawer-slide-enter-from[data-v-c00243da],.drawer-slide-leave-to[data-v-c00243da]{width:0;opacity:0}@media(max-width:768px){.table-drawer-layout[data-v-c00243da]{min-height:400px}.layout-drawer[data-v-c00243da]{width:100%}}.tab-container[data-v-9d94b988]{display:flex;flex-direction:column;height:100%}.tab-header[data-v-9d94b988]{display:flex;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);overflow-x:auto;scrollbar-width:none}.tab-header[data-v-9d94b988]::-webkit-scrollbar{display:none}.tab-item[data-v-9d94b988]{padding:12px 24px;cursor:pointer;border-bottom:2px solid transparent;transition:all .2s;display:flex;align-items:center;gap:8px;font-size:14px;color:var(--SmartThemeEmColor)}.tab-item[data-v-9d94b988]:hover{color:var(--SmartThemeBodyColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.tab-item.active[data-v-9d94b988]{color:var(--SmartThemeBodyColor);border-bottom-color:var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.tab-item i[data-v-9d94b988]{font-size:14px}.tab-body[data-v-9d94b988]{flex:1;overflow:hidden}@media(max-width:768px){.tab-header .tab-item[data-v-9d94b988]{width:40vw;flex-shrink:0;justify-content:center;padding:14px 16px;font-size:13px;white-space:nowrap}.tab-item[data-v-9d94b988]{gap:6px}}.drawer-toggle[data-v-2b5f8ef8]{background:none;border:none;cursor:pointer;padding:7.2px;display:flex;align-items:center;justify-content:center;color:var(--SmartThemeBodyColor);transition:all .2s;border-radius:3.6px;transform:scale(.9)}.drawer-toggle[data-v-2b5f8ef8]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.drawer-toggle[data-v-2b5f8ef8]:active{transform:scale(.855)}.drawer-toggle.fab[data-v-2b5f8ef8]{position:fixed;bottom:80px;right:20px;width:56px;height:56px;border-radius:50%;background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);box-shadow:0 4px 12px var(--SmartThemeShadowColor);z-index:1001}.drawer-toggle.fab[data-v-2b5f8ef8]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.drawer-toggle.fab .hamburger-icon[data-v-2b5f8ef8]{width:24px;height:24px}@media(min-width:769px){.drawer-toggle.fab[data-v-2b5f8ef8]{display:none}}.hamburger-icon[data-v-2b5f8ef8]{width:21.6px;height:16.2px;display:flex;flex-direction:column;justify-content:space-between;position:relative}.line[data-v-2b5f8ef8]{width:100%;height:1.8px;background:var(--SmartThemeBodyColor);border-radius:1.8px;transition:all .3s ease}.toast-notification[data-v-76c92735]{position:fixed;top:20px;left:50%;transform:translate(-50%);display:flex;align-items:center;gap:10px;padding:12px 20px;border-radius:6px;font-size:14px;font-weight:500;z-index:10000;box-shadow:0 4px 12px #00000026}.toast-notification.success[data-v-76c92735]{background:#10b981;color:#fff}.toast-notification.error[data-v-76c92735]{background:#ef4444;color:#fff}.toast-notification i[data-v-76c92735]{font-size:16px}.toast-enter-active[data-v-76c92735],.toast-leave-active[data-v-76c92735]{transition:all .3s ease}.toast-enter-from[data-v-76c92735],.toast-leave-to[data-v-76c92735]{opacity:0;transform:translate(-50%) translateY(-20px)}@media(max-width:768px){.toast-notification[data-v-76c92735]{left:16px;right:16px;transform:none;justify-content:center}.toast-enter-from[data-v-76c92735],.toast-leave-to[data-v-76c92735]{transform:translateY(-20px)}}.empty-state[data-v-5ddb0dfd]{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.empty-state span[data-v-5ddb0dfd]{font-size:14px}.empty-state.compact[data-v-5ddb0dfd]{gap:12px;padding:40px 20px}.empty-state.compact span[data-v-5ddb0dfd]{font-size:14px}.auto-resize-wrapper[data-v-fd129974]{position:relative;width:100%;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);transition:all .25s cubic-bezier(.4,0,.2,1)}.auto-resize-wrapper[data-v-fd129974]:hover:not(.disabled){border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.auto-resize-wrapper.focused[data-v-fd129974]{border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.auto-resize-wrapper.disabled[data-v-fd129974]{opacity:.6;cursor:not-allowed}.textarea-mirror[data-v-fd129974]{position:absolute;top:0;left:0;visibility:hidden;pointer-events:none;height:auto;overflow:hidden;z-index:-1}.auto-resize-textarea[data-v-fd129974]{display:block;width:100%;padding:12px 16px;border:none;outline:none;background:transparent;font-family:inherit;font-size:14px;line-height:1.5;color:var(--SmartThemeBodyColor);resize:none;overflow:hidden;box-sizing:border-box;transition:height .15s ease}.auto-resize-textarea[data-v-fd129974]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.auto-resize-textarea[data-v-fd129974]:disabled{cursor:not-allowed}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar{width:8px}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-track{background:transparent}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-thumb{background:color-mix(in srgb,var(--SmartThemeBorderColor) 60%,transparent);border-radius:4px}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-thumb:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 80%,transparent)}.textarea-footer[data-v-fd129974]{display:flex;justify-content:flex-end;padding:2px 14px 8px;margin-top:-4px}.char-count[data-v-fd129974]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);transition:color .2s}.char-count.warning[data-v-fd129974]{color:#ef4444;font-weight:600}@media(max-width:768px){.auto-resize-textarea[data-v-fd129974]{padding:14px 16px;font-size:16px}}.form-wrapper[data-v-08eccbfb]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-08eccbfb]{display:flex;flex-direction:column;gap:24px;max-height:65vh;overflow-y:auto}.form-section[data-v-08eccbfb]{display:flex;flex-direction:column;gap:16px}.form-item[data-v-08eccbfb]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-08eccbfb]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);display:flex;align-items:center;gap:4px;letter-spacing:.3px}.required[data-v-08eccbfb]{color:#ef4444;margin-left:4px}.form-input[data-v-08eccbfb],.form-select[data-v-08eccbfb]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-08eccbfb]:hover,.form-select[data-v-08eccbfb]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-08eccbfb]:focus,.form-select[data-v-08eccbfb]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-08eccbfb]::placeholder,.form-select[data-v-08eccbfb]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input.has-error[data-v-08eccbfb],.form-select.has-error[data-v-08eccbfb]{border-color:#ef4444}.form-input.has-error[data-v-08eccbfb]:focus,.form-select.has-error[data-v-08eccbfb]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-08eccbfb]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-08eccbfb]{font-size:14px}.section-error[data-v-08eccbfb]{padding:10px 12px;background:#ef44441a;border-radius:6px;margin-bottom:8px}.field-hint[data-v-08eccbfb]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.columns-section[data-v-08eccbfb]{border-top:1.5px solid var(--SmartThemeBorderColor);padding-top:20px}.section-header[data-v-08eccbfb]{display:flex;justify-content:space-between;align-items:center}.column-count[data-v-08eccbfb]{font-size:13px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);padding:4px 10px;border-radius:12px}.columns-list[data-v-08eccbfb]{display:flex;flex-direction:column;gap:12px}.column-card[data-v-08eccbfb]{background:var(--SmartThemeBlurTintColor);border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;overflow:hidden}.column-card.has-error[data-v-08eccbfb]{border-color:#ef4444}.column-card-header[data-v-08eccbfb]{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:color-mix(in srgb,var(--SmartThemeBorderColor) 20%,transparent);border-bottom:1.5px solid var(--SmartThemeBorderColor)}.column-number[data-v-08eccbfb]{font-size:12px;font-weight:600;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.remove-btn[data-v-08eccbfb]{background:none;border:none;cursor:pointer;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);padding:6px;border-radius:4px;transition:all .2s}.remove-btn[data-v-08eccbfb]:hover{color:#ef4444;background:#ef44441a}.remove-btn i[data-v-08eccbfb]{font-size:14px}.column-card-body[data-v-08eccbfb]{padding:16px;display:flex;flex-direction:column;gap:12px}.form-row[data-v-08eccbfb]{display:flex;gap:12px}.form-col[data-v-08eccbfb]{display:flex;flex-direction:column;gap:6px}.form-col.form-col-name[data-v-08eccbfb]{flex:2}.form-col.form-col-type[data-v-08eccbfb],.form-col.form-col-default[data-v-08eccbfb],.form-col.form-col-comment[data-v-08eccbfb]{flex:1}.field-label[data-v-08eccbfb]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 70%,transparent)}.field-label .required[data-v-08eccbfb]{font-size:12px;margin-left:4px}.checkbox-label[data-v-08eccbfb]{display:flex;align-items:center;gap:8px;color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;width:fit-content}.checkbox-label input[data-v-08eccbfb]{cursor:pointer;width:16px;height:16px}.add-column-btn[data-v-08eccbfb]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px;border:2px dashed var(--SmartThemeBorderColor);border-radius:8px;background:transparent;color:color-mix(in srgb,var(--SmartThemeBodyColor) 70%,transparent);font-size:14px;cursor:pointer;transition:all .2s}.add-column-btn[data-v-08eccbfb]:hover{border-color:var(--SmartThemeBorderColor);color:var(--SmartThemeBodyColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 10%,transparent)}.add-column-btn i[data-v-08eccbfb]{font-size:14px}.form-actions[data-v-08eccbfb]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-08eccbfb]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-08eccbfb]{--form-modal-width: 100%}.form-container[data-v-08eccbfb]{gap:20px}.form-row[data-v-08eccbfb]{flex-direction:column;gap:12px}.form-col.form-col-name[data-v-08eccbfb],.form-col.form-col-type[data-v-08eccbfb],.form-col.form-col-default[data-v-08eccbfb],.form-col.form-col-comment[data-v-08eccbfb]{flex:1}.column-card-body[data-v-08eccbfb]{padding:12px}.form-actions[data-v-08eccbfb]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-08eccbfb]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-58e374f4]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-58e374f4]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-58e374f4]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-58e374f4]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-58e374f4]{color:#ef4444;margin-left:4px}.form-input[data-v-58e374f4]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-58e374f4]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-58e374f4]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-58e374f4]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-58e374f4]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-input.has-error[data-v-58e374f4]{border-color:#ef4444}.form-input.has-error[data-v-58e374f4]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-58e374f4]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-58e374f4]{font-size:14px}.field-hint[data-v-58e374f4]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.form-actions[data-v-58e374f4]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-58e374f4]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-58e374f4]{--form-modal-width: 100%}.form-container[data-v-58e374f4]{gap:16px}.form-item[data-v-58e374f4]{gap:8px}.form-label[data-v-58e374f4]{font-size:15px}.form-input[data-v-58e374f4]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-58e374f4]::placeholder{font-size:15px}.field-hint[data-v-58e374f4]{font-size:13px}.form-actions[data-v-58e374f4]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-58e374f4]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-03532044]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-03532044]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-03532044]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-03532044]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.form-actions[data-v-03532044]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-03532044]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-03532044]{--form-modal-width: 100%}.form-container[data-v-03532044]{gap:16px}.form-item[data-v-03532044]{gap:8px}.form-label[data-v-03532044]{font-size:15px}.form-actions[data-v-03532044]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-03532044]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.drop-table-confirm-wrapper[data-v-4629727b]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-4629727b]{padding:24px 20px;text-align:center}.confirm-icon-wrapper[data-v-4629727b]{margin-bottom:16px}.warning-icon[data-v-4629727b]{font-size:48px;color:#f59e0b}.confirm-content[data-v-4629727b]{margin-bottom:24px}.confirm-message[data-v-4629727b]{font-size:16px;color:var(--SmartThemeBodyColor);margin-bottom:12px;line-height:1.5}.confirm-message strong[data-v-4629727b]{color:#ef4444;font-weight:600}.confirm-warning[data-v-4629727b]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#ef44441a;border-radius:6px;font-size:13px;color:#ef4444;text-align:left}.confirm-warning i[data-v-4629727b]{font-size:14px;flex-shrink:0}.form-actions[data-v-4629727b]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.drop-table-confirm-wrapper[data-v-4629727b]{--confirm-modal-width: 90vw}.confirm-container[data-v-4629727b]{padding:20px 16px}.warning-icon[data-v-4629727b]{font-size:40px}.confirm-message[data-v-4629727b]{font-size:15px}.form-actions[data-v-4629727b]{flex-direction:column-reverse}.form-actions[data-v-4629727b]>*{width:100%}}.form-wrapper[data-v-019138f2]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-019138f2]{display:flex;flex-direction:column;gap:20px;max-height:70vh;overflow-y:auto}.form-item[data-v-019138f2]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-019138f2]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-019138f2]{color:#ef4444;margin-left:4px}.form-input[data-v-019138f2],.form-select[data-v-019138f2]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-019138f2]:hover,.form-select[data-v-019138f2]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-019138f2]:focus,.form-select[data-v-019138f2]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-019138f2]::placeholder,.form-select[data-v-019138f2]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input.has-error[data-v-019138f2],.form-select.has-error[data-v-019138f2]{border-color:#ef4444}.form-input.has-error[data-v-019138f2]:focus,.form-select.has-error[data-v-019138f2]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-019138f2]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-019138f2]{font-size:14px}.field-hint[data-v-019138f2]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.checkbox-label[data-v-019138f2]{display:flex;align-items:center;gap:8px;color:var(--SmartThemeEmColor);font-size:14px;cursor:pointer;width:fit-content}.checkbox-label input[data-v-019138f2]{cursor:pointer;width:18px;height:18px}.checkbox-label span[data-v-019138f2]{cursor:pointer}.form-actions[data-v-019138f2]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-019138f2]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-019138f2]{--form-modal-width: 100%}.form-container[data-v-019138f2]{gap:16px}.form-item[data-v-019138f2]{gap:8px}.form-label[data-v-019138f2]{font-size:15px}.form-input[data-v-019138f2],.form-select[data-v-019138f2]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-019138f2]::placeholder,.form-select[data-v-019138f2]::placeholder{font-size:15px}.field-hint[data-v-019138f2]{font-size:13px}.form-actions[data-v-019138f2]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-019138f2]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-36708f97]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-36708f97]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-36708f97]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-36708f97]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-36708f97]{color:#ef4444;margin-left:4px}.form-input[data-v-36708f97]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-36708f97]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-36708f97]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-36708f97]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-36708f97]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-input.has-error[data-v-36708f97]{border-color:#ef4444}.form-input.has-error[data-v-36708f97]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-36708f97]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-36708f97]{font-size:14px}.field-hint[data-v-36708f97]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.form-actions[data-v-36708f97]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-36708f97]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-36708f97]{--form-modal-width: 100%}.form-container[data-v-36708f97]{gap:16px}.form-item[data-v-36708f97]{gap:8px}.form-label[data-v-36708f97]{font-size:15px}.form-input[data-v-36708f97]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-36708f97]::placeholder{font-size:15px}.field-hint[data-v-36708f97]{font-size:13px}.form-actions[data-v-36708f97]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-36708f97]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-1f79f493]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-1f79f493]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-1f79f493]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-1f79f493]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.form-input[data-v-1f79f493]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-1f79f493]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-1f79f493]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-1f79f493]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-1f79f493]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-actions[data-v-1f79f493]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-1f79f493]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-1f79f493]{--form-modal-width: 100%}.form-container[data-v-1f79f493]{gap:16px}.form-item[data-v-1f79f493]{gap:8px}.form-label[data-v-1f79f493]{font-size:15px}.form-input[data-v-1f79f493]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-1f79f493]::placeholder{font-size:15px}.form-actions[data-v-1f79f493]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-1f79f493]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.drop-column-confirm-wrapper[data-v-7565defa]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-7565defa]{padding:24px 20px;text-align:center}.confirm-icon-wrapper[data-v-7565defa]{margin-bottom:16px}.warning-icon[data-v-7565defa]{font-size:48px;color:#f59e0b}.confirm-content[data-v-7565defa]{margin-bottom:24px}.confirm-message[data-v-7565defa]{font-size:16px;color:var(--SmartThemeBodyColor);margin-bottom:12px;line-height:1.5}.confirm-message strong[data-v-7565defa]{color:#ef4444;font-weight:600}.confirm-warning[data-v-7565defa]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#ef44441a;border-radius:6px;font-size:13px;color:#ef4444;text-align:left}.confirm-warning i[data-v-7565defa]{font-size:14px;flex-shrink:0}.form-actions[data-v-7565defa]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.drop-column-confirm-wrapper[data-v-7565defa]{--confirm-modal-width: 90vw}.confirm-container[data-v-7565defa]{padding:20px 16px}.warning-icon[data-v-7565defa]{font-size:40px}.confirm-message[data-v-7565defa]{font-size:15px}.form-actions[data-v-7565defa]{flex-direction:column-reverse}.form-actions[data-v-7565defa]>*{width:100%}}.ddl-container[data-v-da039aee]{padding:20px}.ddl-header[data-v-da039aee]{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.ddl-title[data-v-da039aee]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.copy-btn[data-v-da039aee]{display:flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--SmartThemeBorderColor);border-radius:4px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s}.copy-btn[data-v-da039aee]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.copy-btn i[data-v-da039aee]{font-size:12px}.ddl-content[data-v-da039aee]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:6px;padding:16px;margin-bottom:20px;max-height:400px;overflow:auto}.ddl-code[data-v-da039aee]{margin:0;font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;color:var(--SmartThemeBodyColor);white-space:pre-wrap;word-wrap:break-word}.form-actions[data-v-da039aee]{display:flex;gap:12px;justify-content:flex-end}@media(max-width:768px){.ddl-container[data-v-da039aee]{padding:16px}.ddl-content[data-v-da039aee]{padding:12px;max-height:300px}.ddl-code[data-v-da039aee]{font-size:12px}.form-actions[data-v-da039aee]>*{width:100%}}.table-management-tab[data-v-f00e195b]{display:flex;flex-direction:column;height:100%;overflow:hidden}.table-detail[data-v-f00e195b]{flex:1;display:flex;flex-direction:column;overflow:hidden}.table-header[data-v-f00e195b]{padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.table-title-section[data-v-f00e195b]{margin-bottom:12px}.table-name-row[data-v-f00e195b],.table-comment-row[data-v-f00e195b]{display:flex;align-items:center;gap:8px;margin-bottom:8px}.table-name-row[data-v-f00e195b]:last-child,.table-comment-row[data-v-f00e195b]:last-child{margin-bottom:0}.table-label[data-v-f00e195b]{font-size:13px;color:var(--SmartThemeEmColor);min-width:50px;flex-shrink:0}.table-name[data-v-f00e195b]{font-size:15px;font-weight:600;color:var(--SmartThemeBodyColor);flex:1;word-break:break-all}.table-comment[data-v-f00e195b]{font-size:14px;color:var(--SmartThemeEmColor);flex:1;word-break:break-all}.table-comment.placeholder[data-v-f00e195b]{color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent);font-style:italic}.table-actions[data-v-f00e195b]{display:flex;gap:8px}.columns-section[data-v-f00e195b]{flex:1;display:flex;flex-direction:column;overflow:hidden}.section-header[data-v-f00e195b]{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.section-title[data-v-f00e195b]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.columns-list[data-v-f00e195b]{flex:1;overflow-y:auto;padding:12px}.column-item[data-v-f00e195b]{display:flex;justify-content:space-between;align-items:flex-start;padding:12px;border-radius:6px;background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);margin-bottom:8px;transition:all .2s}.column-item[data-v-f00e195b]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent)}.column-main[data-v-f00e195b]{flex:1;min-width:0;margin-right:12px}.column-first-row[data-v-f00e195b]{display:flex;align-items:center;gap:24px;margin-bottom:6px}.column-name-wrapper[data-v-f00e195b]{display:flex;align-items:center;gap:6px;min-width:0}.column-icon[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);flex-shrink:0}.column-name[data-v-f00e195b]{font-size:14px;font-weight:500;color:var(--SmartThemeBodyColor);word-break:break-all;min-width:0}.type-badge[data-v-f00e195b]{display:inline-block;padding:2px 8px;border-radius:4px;font-size:12px;font-weight:500;background:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent);color:var(--SmartThemeEmColor);flex-shrink:0}.primary-key-badge[data-v-f00e195b]{display:inline-flex;align-items:center;justify-content:center;width:24px;height:24px;border-radius:4px;background:#f59e0b26;border:1px solid rgba(245,158,11,.3);flex-shrink:0}.primary-key-badge i[data-v-f00e195b]{font-size:12px;color:#f59e0b}.column-comment[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);word-break:break-all;line-height:1.4;max-height:2.8em;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical}.default-value[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);margin-top:4px}.column-actions[data-v-f00e195b]{display:flex;gap:4px;flex-shrink:0}@media(max-width:768px){.tab-toolbar[data-v-f00e195b]{flex-wrap:wrap;padding:10px 12px}.table-header[data-v-f00e195b]{padding:12px}.table-name-row[data-v-f00e195b],.table-comment-row[data-v-f00e195b]{flex-wrap:wrap}.table-actions[data-v-f00e195b]{width:100%;justify-content:stretch;margin-top:12px}.table-actions>button[data-v-f00e195b]{flex:1}.section-header[data-v-f00e195b]{padding:10px 12px}.columns-list[data-v-f00e195b]{padding:8px}.column-item[data-v-f00e195b]{flex-direction:column;gap:10px;padding:10px}.column-main[data-v-f00e195b]{margin-right:0}.column-first-row[data-v-f00e195b]{flex-wrap:wrap;gap:6px}.column-name-wrapper[data-v-f00e195b]{flex:1;min-width:0}.column-actions[data-v-f00e195b]{gap:2px;width:100%;justify-content:flex-end;border-top:1px solid var(--SmartThemeBorderColor);padding-top:8px;margin-top:4px}}.sql-panel-tab[data-v-34ac73ac]{display:flex;flex-direction:column;height:100%;gap:16px;overflow:hidden}.sql-editor-container[data-v-34ac73ac]{display:flex;flex-direction:column;height:100%;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.sql-toolbar[data-v-34ac73ac]{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-bottom:1px solid var(--SmartThemeBorderColor)}.toolbar-title[data-v-34ac73ac]{font-size:13px;font-weight:500;color:var(--SmartThemeEmColor)}.sql-editor[data-v-34ac73ac]{min-height:200px;max-height:400px;padding:16px;background:var(--SmartThemeBlurTintColor);border:none;outline:none;color:var(--SmartThemeBodyColor);font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;resize:vertical;overflow-y:auto;height:100%}.sql-editor[data-v-34ac73ac]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.sql-footer[data-v-34ac73ac]{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-top:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.result-status[data-v-34ac73ac]{font-size:12px;font-weight:500;color:var(--SmartThemeBodyColor)}.editor-stats[data-v-34ac73ac]{display:flex;gap:16px}.stat-item[data-v-34ac73ac]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.result-message[data-v-34ac73ac]{padding:10px 16px;font-size:12px;border-top:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.result-message.error[data-v-34ac73ac]{background:color-mix(in srgb,#e74c3c 20%,transparent);color:#e74c3c}@media(max-width:768px){.sql-panel-tab[data-v-34ac73ac]{gap:12px}.sql-editor[data-v-34ac73ac]{font-size:12px;min-height:150px;height:100%}.sql-footer[data-v-34ac73ac]{gap:8px}}.data-form-wrapper[data-v-dd6bd7a8]{--form-modal-width: 50vw;--form-modal-height: auto}.data-form[data-v-dd6bd7a8]{display:flex;flex-direction:column;gap:24px;max-height:65vh}.form-content[data-v-dd6bd7a8]{display:flex;flex-direction:column;gap:20px;overflow-y:auto;padding:8px 4px}.form-item[data-v-dd6bd7a8]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-dd6bd7a8]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required-mark[data-v-dd6bd7a8]{color:#ef4444;margin-left:4px;font-size:14px}.form-input[data-v-dd6bd7a8]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-dd6bd7a8]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-dd6bd7a8]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-dd6bd7a8]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-dd6bd7a8]:disabled{opacity:.6;cursor:not-allowed}.form-hint[data-v-dd6bd7a8]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);margin-top:-4px;line-height:1.5;padding-left:2px}.form-actions[data-v-dd6bd7a8]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-dd6bd7a8]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.data-form-wrapper[data-v-dd6bd7a8]{--form-modal-width: 100%}.data-form[data-v-dd6bd7a8]{gap:20px;max-height:70vh}.form-content[data-v-dd6bd7a8]{gap:16px;padding:4px}.form-item[data-v-dd6bd7a8]{gap:8px}.form-label[data-v-dd6bd7a8]{font-size:15px}.form-input[data-v-dd6bd7a8]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-dd6bd7a8]::placeholder{font-size:15px}.form-hint[data-v-dd6bd7a8]{font-size:13px}.form-actions[data-v-dd6bd7a8]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-dd6bd7a8]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.delete-data-confirm-wrapper[data-v-b672c047]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-b672c047]{padding:20px}.confirm-content[data-v-b672c047]{display:flex;flex-direction:column;align-items:center;gap:16px;padding:20px 0}.warning-icon[data-v-b672c047]{font-size:48px;color:#f59e0b}.confirm-message[data-v-b672c047]{font-size:14px;color:var(--SmartThemeBodyColor);text-align:center;line-height:1.6;margin:0}.form-actions[data-v-b672c047]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.delete-data-confirm-wrapper[data-v-b672c047]{--confirm-modal-width: 90vw}.confirm-container[data-v-b672c047]{padding:16px}.form-actions[data-v-b672c047]{flex-direction:column-reverse}.form-actions>button[data-v-b672c047]{width:100%}}.export-container[data-v-affef56e]{padding:20px}.export-header[data-v-affef56e]{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.export-title[data-v-affef56e]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.copy-btn[data-v-affef56e]{display:flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--SmartThemeBorderColor);border-radius:4px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s}.copy-btn[data-v-affef56e]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.copy-btn i[data-v-affef56e]{font-size:12px}.export-content[data-v-affef56e]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:6px;padding:16px;margin-bottom:20px;max-height:400px;overflow:auto}.export-code[data-v-affef56e]{margin:0;font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;color:var(--SmartThemeBodyColor);white-space:pre-wrap;word-wrap:break-word}.form-actions[data-v-affef56e]{display:flex;gap:12px;justify-content:flex-end}@media(max-width:768px){.export-container[data-v-affef56e]{padding:16px}.export-content[data-v-affef56e]{padding:12px;max-height:300px}.export-code[data-v-affef56e]{font-size:12px}.form-actions[data-v-affef56e]>*{width:100%}}.chat-data-management-tab[data-v-1747acc7]{display:flex;flex-direction:column;height:100%;overflow:hidden}.data-detail[data-v-1747acc7]{flex:1;display:flex;flex-direction:column;overflow:hidden}.data-toolbar[data-v-1747acc7]{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.data-title[data-v-1747acc7]{display:flex;flex-direction:column;gap:4px}.table-name[data-v-1747acc7]{font-size:15px;font-weight:600;color:var(--SmartThemeBodyColor)}.table-comment[data-v-1747acc7]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.data-actions[data-v-1747acc7]{display:flex;gap:8px}.data-list[data-v-1747acc7]{flex:1;overflow:hidden;display:flex;flex-direction:column}.table-container[data-v-1747acc7]{flex:1;overflow:auto}.data-table[data-v-1747acc7]{width:100%;border-collapse:collapse;font-size:13px}thead[data-v-1747acc7]{position:sticky;top:0;z-index:30;background:var(--SmartThemeBlurTintColor)}thead th[data-v-1747acc7]{padding:12px 16px;border-bottom:2px solid var(--SmartThemeBorderColor);font-weight:600;color:var(--SmartThemeBodyColor);white-space:nowrap;background:var(--SmartThemeBlurTintColor)}tbody th[data-v-1747acc7]{text-align:left;padding:12px 16px;font-weight:600;color:var(--SmartThemeBodyColor);white-space:nowrap}.checkbox-header[data-v-1747acc7]{width:50px;text-align:center;padding:12px 8px}.column-header[data-v-1747acc7]{min-width:120px}.actions-header[data-v-1747acc7]{width:100px;text-align:center;padding:12px 8px}.sticky-col[data-v-1747acc7]{position:sticky;background:var(--SmartThemeBlurTintColor);z-index:20;left:0}thead th.sticky-col[data-v-1747acc7]{z-index:32;left:0}.primary-key[data-v-1747acc7]{background:color-mix(in srgb,rgba(218,165,32,.15) 50%,var(--SmartThemeBlurTintColor));border-right:2px solid color-mix(in srgb,rgba(218,165,32,.3) 50%,var(--SmartThemeBorderColor))}thead th.primary-key[data-v-1747acc7]{background:color-mix(in srgb,rgba(218,165,32,.2) 50%,var(--SmartThemeBlurTintColor))}thead th.actions-header.sticky-col[data-v-1747acc7]{z-index:31}thead th.checkbox-header.sticky-col[data-v-1747acc7]{z-index:32}.table-row[data-v-1747acc7]{border-bottom:1px solid var(--SmartThemeBorderColor);transition:background-color .2s}.table-row[data-v-1747acc7]:hover{background-color:color-mix(in srgb,var(--SmartThemeBorderColor) 20%,transparent)}.table-row[data-v-1747acc7]:last-child{border-bottom:none}.table-cell[data-v-1747acc7]{padding:10px 16px;border-right:1px solid var(--SmartThemeBorderColor);max-width:300px;min-width:120px;background:var(--SmartThemeBlurTintColor);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.table-cell[data-v-1747acc7]:last-child{border-right:none}.table-cell.primary-key[data-v-1747acc7]{background:color-mix(in srgb,rgba(59,130,246,.1) 50%,var(--SmartThemeBlurTintColor));border-right:2px solid color-mix(in srgb,rgba(59,130,246,.3) 50%,var(--SmartThemeBorderColor))}.cell-value[data-v-1747acc7]{color:var(--SmartThemeBodyColor);text-align:center;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;line-height:1.5}.checkbox-cell[data-v-1747acc7]{width:50px;text-align:center;padding:10px 8px;border-right:1px solid var(--SmartThemeBorderColor)}.actions-cell[data-v-1747acc7]{width:100px;padding:10px 8px;text-align:center;border-right:1px solid var(--SmartThemeBorderColor)}.actions-cell.sticky-col[data-v-1747acc7]{box-shadow:3px 0 10px -3px #00000040}.checkbox-cell.sticky-col[data-v-1747acc7]{box-shadow:2px 0 10px -3px #00000026}.checkbox-wrapper[data-v-1747acc7]{display:flex;align-items:center;justify-content:center;cursor:pointer}.checkbox-wrapper input[type=checkbox][data-v-1747acc7]{width:16px;height:16px;cursor:pointer}.row-actions[data-v-1747acc7]{display:flex;gap:4px;justify-content:center}@media(max-width:768px){.data-toolbar[data-v-1747acc7]{flex-direction:column;align-items:stretch;gap:12px;padding:12px}.data-title[data-v-1747acc7]{align-items:flex-start}.data-actions[data-v-1747acc7]{width:100%}.data-actions>button[data-v-1747acc7]{flex:1}thead th[data-v-1747acc7],.table-cell[data-v-1747acc7]{padding:8px 10px}.column-header[data-v-1747acc7]{min-width:80px}.table-cell[data-v-1747acc7]{max-width:150px;min-width:80px}.actions-header[data-v-1747acc7],.actions-cell[data-v-1747acc7]{width:70px}}.translation_settings[data-v-d18c04a2],.inline-drawer[data-v-d18c04a2]{width:100%}.inline-drawer-toggle[data-v-d18c04a2]{cursor:pointer}.inline-drawer-icon[data-v-d18c04a2]{transition:transform .2s}.inline-drawer-icon.down[data-v-d18c04a2]{transform:rotate(0)}.inline-drawer-icon.up[data-v-d18c04a2]{transform:rotate(180deg)}')),document.head.appendChild(a)}}catch(r){console.error("vite-plugin-css-injected-by-js",r)}})();
var Lr = {};
// @__NO_SIDE_EFFECTS__
function Xt(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const s of t.split(",")) e[s] = 1;
  return (s) => s in e;
}
const ye = Lr.NODE_ENV !== "production" ? Object.freeze({}) : {}, Ds = Lr.NODE_ENV !== "production" ? Object.freeze([]) : [], qe = () => {
}, kr = () => !1, ln = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter
(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), Ln = (t) => t.startsWith("onUpdate:"), Ve = Object.assign, Ki = (t, e) => {
  const s = t.indexOf(e);
  s > -1 && t.splice(s, 1);
}, pl = Object.prototype.hasOwnProperty, Ee = (t, e) => pl.call(t, e), z = Array.isArray, ms = (t) => cn(t) === "[object Map]", Ls = (t) => cn(t) === "[object Set]", $o = (t) => cn(t) === "[object Date]", te = (t) => typeof t == "function", Re = (t) => typeof t == "string", Et = (t) => typeof t == "symbol", be = (t) => t !== null && typeof t == "object", zi = (t) => (be(t) || te(t)) && te(t.then) && te(t.catch), Pr = Object.prototype.toString, cn = (t) => Pr.call(t), Gi = (t) => cn(t).slice(8, -1), Br = (t) => cn(t) === "[object Object]", Yi = (t) => Re(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, zs = /* @__PURE__ */ Xt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), hl = /* @__PURE__ */ Xt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), Xn = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return ((s) => e[s] || (e[s] = t(s)));
}, ml = /-\w/g, ut = Xn(
  (t) => t.replace(ml, (e) => e.slice(1).toUpperCase())
), vl = /\B([A-Z])/g, Qt = Xn(
  (t) => t.replace(vl, "-$1").toLowerCase()
), Zn = Xn((t) => t.charAt(0).toUpperCase() + t.slice(1)), ds = Xn(
  (t) => t ? `on${Zn(t)}` : ""
), nt = (t, e) => !Object.is(t, e), Ss = (t, ...e) => {
  for (let s = 0; s < t.length; s++)
    t[s](...e);
}, kn = (t, e, s, n = !1) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    writable: n,
    value: s
  });
}, ei = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, bl = (t) => {
  const e = Re(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let Ao;
const un = () => Ao || (Ao = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {});
function Ke(t) {
  if (z(t)) {
    const e = {};
    for (let s = 0; s < t.length; s++) {
      const n = t[s], i = Re(n) ? _l(n) : Ke(n);
      if (i)
        for (const o in i)
          e[o] = i[o];
    }
    return e;
  } else if (Re(t) || be(t))
    return t;
}
const gl = /;(?![^(]*\))/g, El = /:([^]+)/, yl = /\/\*[^]*?\*\//g;
function _l(t) {
  const e = {};
  return t.replace(yl, "").split(gl).forEach((s) => {
    if (s) {
      const n = s.split(El);
      n.length > 1 && (e[n[0].trim()] = n[1].trim());
    }
  }), e;
}
function Me(t) {
  let e = "";
  if (Re(t))
    e = t;
  else if (z(t))
    for (let s = 0; s < t.length; s++) {
      const n = Me(t[s]);
      n && (e += n + " ");
    }
  else if (be(t))
    for (const s in t)
      t[s] && (e += s + " ");
  return e.trim();
}
const Nl = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Tl = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", xl = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", wl = /* @__PURE__ */ Xt(Nl), Sl = /* @__PURE__ */ Xt(Tl), Cl = /* @__PURE__ */ Xt(xl), Dl = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Ol = /* @__PURE__ */ Xt(Dl);
function Ur(t) {
  return !!t || t === "";
}
function $l(t, e) {
  if (t.length !== e.length) return !1;
  let s = !0;
  for (let n = 0; s && n < t.length; n++)
    s = os(t[n], e[n]);
  return s;
}
function os(t, e) {
  if (t === e) return !0;
  let s = $o(t), n = $o(e);
  if (s || n)
    return s && n ? t.getTime() === e.getTime() : !1;
  if (s = Et(t), n = Et(e), s || n)
    return t === e;
  if (s = z(t), n = z(e), s || n)
    return s && n ? $l(t, e) : !1;
  if (s = be(t), n = be(e), s || n) {
    if (!s || !n)
      return !1;
    const i = Object.keys(t).length, o = Object.keys(e).length;
    if (i !== o)
      return !1;
    for (const r in t) {
      const a = t.hasOwnProperty(r), l = e.hasOwnProperty(r);
      if (a && !l || !a && l || !os(t[r], e[r]))
        return !1;
    }
  }
  return String(t) === String(e);
}
function Ji(t, e) {
  return t.findIndex((s) => os(s, e));
}
const Fr = (t) => !!(t && t.__v_isRef === !0), fe = (t) => Re(t) ? t : t == null ? "" : z(t) || be(t) && (t.toString === Pr || !te(t.toString)) ? Fr(t) ? fe(t.value) : JSON.stringify(t, jr, 2) : String(t), jr = (t, e) => Fr(e) ? jr(t, e.value) : ms(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (s, [n, i], o) => (s[hi(n, o) + " =>"] = i, s),
    {}
  )
} : Ls(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((s) => hi(s))
} : Et(e) ? hi(e) : be(e) && !z(e) && !Br(e) ? String(e) : e, hi = (t, e = "") => {
  var s;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Et(t) ? `Symbol(${(s = t.description) != null ? s : e})` : t
  );
};
var Se = {};
function yt(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
let tt;
class Al {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.__v_skip = !0, this.parent = tt, !e && tt && (this.index = (tt.scopes || (tt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, s;
      if (this.scopes)
        for (e = 0, s = this.scopes.length; e < s; e++)
          this.scopes[e].pause();
      for (e = 0, s = this.effects.length; e < s; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, s;
      if (this.scopes)
        for (e = 0, s = this.scopes.length; e < s; e++)
          this.scopes[e].resume();
      for (e = 0, s = this.effects.length; e < s; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const s = tt;
      try {
        return tt = this, e();
      } finally {
        tt = s;
      }
    } else Se.NODE_ENV !== "production" && yt("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = tt, tt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (tt = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let s, n;
      for (s = 0, n = this.effects.length; s < n; s++)
        this.effects[s].stop();
      for (this.effects.length = 0, s = 0, n = this.cleanups.length; s < n; s++)
        this.cleanups[s]();
      if (this.cleanups.length = 0, this.scopes) {
        for (s = 0, n = this.scopes.length; s < n; s++)
          this.scopes[s].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Vl() {
  return tt;
}
let Ne;
const mi = /* @__PURE__ */ new WeakSet();
class qr {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, tt && tt.active && tt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, mi.has(this) && (mi.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Hr(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Vo(this), Kr(this);
    const e = Ne, s = vt;
    Ne = this, vt = !0;
    try {
      return this.fn();
    } finally {
      Se.NODE_ENV !== "production" && Ne !== this && yt(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), zr(this), Ne = e, vt = s, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        Zi(e);
      this.deps = this.depsTail = void 0, Vo(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? mi.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Si(this) && this.run();
  }
  get dirty() {
    return Si(this);
  }
}
let Wr = 0, Gs, Ys;
function Hr(t, e = !1) {
  if (t.flags |= 8, e) {
    t.next = Ys, Ys = t;
    return;
  }
  t.next = Gs, Gs = t;
}
function Qi() {
  Wr++;
}
function Xi() {
  if (--Wr > 0)
    return;
  if (Ys) {
    let e = Ys;
    for (Ys = void 0; e; ) {
      const s = e.next;
      e.next = void 0, e.flags &= -9, e = s;
    }
  }
  let t;
  for (; Gs; ) {
    let e = Gs;
    for (Gs = void 0; e; ) {
      const s = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (n) {
          t || (t = n);
        }
      e = s;
    }
  }
  if (t) throw t;
}
function Kr(t) {
  for (let e = t.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function zr(t) {
  let e, s = t.depsTail, n = s;
  for (; n; ) {
    const i = n.prevDep;
    n.version === -1 ? (n === s && (s = i), Zi(n), Rl(n)) : e = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = i;
  }
  t.deps = e, t.depsTail = s;
}
function Si(t) {
  for (let e = t.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (Gr(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!t._dirty;
}
function Gr(t) {
  if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17, t.globalVersion === en) || (t.globalVersion = en, !t.isSSR && t.flags & 128 && (!t.deps && !t._dirty || !Si(t))))
    return;
  t.flags |= 2;
  const e = t.dep, s = Ne, n = vt;
  Ne = t, vt = !0;
  try {
    Kr(t);
    const i = t.fn(t._value);
    (e.version === 0 || nt(i, t._value)) && (t.flags |= 128, t._value = i, e.version++);
  } catch (i) {
    throw e.version++, i;
  } finally {
    Ne = s, vt = n, zr(t), t.flags &= -3;
  }
}
function Zi(t, e = !1) {
  const { dep: s, prevSub: n, nextSub: i } = t;
  if (n && (n.nextSub = i, t.prevSub = void 0), i && (i.prevSub = n, t.nextSub = void 0), Se.NODE_ENV !== "production" && s.subsHead === t && (s.subsHead = i), s.subs === t && (s.subs = n, !n && s.computed)) {
    s.computed.flags &= -5;
    for (let o = s.computed.deps; o; o = o.nextDep)
      Zi(o, !0);
  }
  !e && !--s.sc && s.map && s.map.delete(s.key);
}
function Rl(t) {
  const { prevDep: e, nextDep: s } = t;
  e && (e.nextDep = s, t.prevDep = void 0), s && (s.prevDep = e, t.nextDep = void 0);
}
let vt = !0;
const Yr = [];
function _t() {
  Yr.push(vt), vt = !1;
}
function Nt() {
  const t = Yr.pop();
  vt = t === void 0 ? !0 : t;
}
function Vo(t) {
  const { cleanup: e } = t;
  if (t.cleanup = void 0, e) {
    const s = Ne;
    Ne = void 0;
    try {
      e();
    } finally {
      Ne = s;
    }
  }
}
let en = 0;
class Il {
  constructor(e, s) {
    this.sub = e, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class ti {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0, Se.NODE_ENV !== "production" && (this.subsHead = void 0);
  }
  track(e) {
    if (!Ne || !vt || Ne === this.computed)
      return;
    let s = this.activeLink;
    if (s === void 0 || s.sub !== Ne)
      s = this.activeLink = new Il(Ne, this), Ne.deps ? (s.prevDep = Ne.depsTail, Ne.depsTail.nextDep = s, Ne.depsTail = s) : Ne.deps = Ne.depsTail = s, Jr(s);
    else if (s.version === -1 && (s.version = this.version, s.nextDep)) {
      const n = s.nextDep;
      n.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = n), s.prevDep = Ne.depsTail, s.nextDep = void 0, Ne.depsTail.nextDep = s, Ne.depsTail = s, Ne.deps === s && (Ne.deps = n);
    }
    return Se.NODE_ENV !== "production" && Ne.onTrack && Ne.onTrack(
      Ve(
        {
          effect: Ne
        },
        e
      )
    ), s;
  }
  trigger(e) {
    this.version++, en++, this.notify(e);
  }
  notify(e) {
    Qi();
    try {
      if (Se.NODE_ENV !== "production")
        for (let s = this.subsHead; s; s = s.nextSub)
          s.sub.onTrigger && !(s.sub.flags & 8) && s.sub.onTrigger(
            Ve(
              {
                effect: s.sub
              },
              e
            )
          );
      for (let s = this.subs; s; s = s.prevSub)
        s.sub.notify() && s.sub.dep.notify();
    } finally {
      Xi();
    }
  }
}
function Jr(t) {
  if (t.dep.sc++, t.sub.flags & 4) {
    const e = t.dep.computed;
    if (e && !t.dep.subs) {
      e.flags |= 20;
      for (let n = e.deps; n; n = n.nextDep)
        Jr(n);
    }
    const s = t.dep.subs;
    s !== t && (t.prevSub = s, s && (s.nextSub = t)), Se.NODE_ENV !== "production" && t.dep.subsHead === void 0 && (t.dep.subsHead = t), t.dep.subs = t;
  }
}
const Ci = /* @__PURE__ */ new WeakMap(), vs = /* @__PURE__ */ Symbol(
  Se.NODE_ENV !== "production" ? "Object iterate" : ""
), Di = /* @__PURE__ */ Symbol(
  Se.NODE_ENV !== "production" ? "Map keys iterate" : ""
), tn = /* @__PURE__ */ Symbol(
  Se.NODE_ENV !== "production" ? "Array iterate" : ""
);
function je(t, e, s) {
  if (vt && Ne) {
    let n = Ci.get(t);
    n || Ci.set(t, n = /* @__PURE__ */ new Map());
    let i = n.get(s);
    i || (n.set(s, i = new ti()), i.map = n, i.key = s), Se.NODE_ENV !== "production" ? i.track({
      target: t,
      type: e,
      key: s
    }) : i.track();
  }
}
function It(t, e, s, n, i, o) {
  const r = Ci.get(t);
  if (!r) {
    en++;
    return;
  }
  const a = (l) => {
    l && (Se.NODE_ENV !== "production" ? l.trigger({
      target: t,
      type: e,
      key: s,
      newValue: n,
      oldValue: i,
      oldTarget: o
    }) : l.trigger());
  };
  if (Qi(), e === "clear")
    r.forEach(a);
  else {
    const l = z(t), u = l && Yi(s);
    if (l && s === "length") {
      const c = Number(n);
      r.forEach((d, m) => {
        (m === "length" || m === tn || !Et(m) && m >= c) && a(d);
      });
    } else
      switch ((s !== void 0 || r.has(void 0)) && a(r.get(s)), u && a(r.get(tn)), e) {
        case "add":
          l ? u && a(r.get("length")) : (a(r.get(vs)), ms(t) && a(r.get(Di)));
          break;
        case "delete":
          l || (a(r.get(vs)), ms(t) && a(r.get(Di)));
          break;
        case "set":
          ms(t) && a(r.get(vs));
          break;
      }
  }
  Xi();
}
function Ts(t) {
  const e = /* @__PURE__ */ de(t);
  return e === t ? e : (je(e, "iterate", tn), /* @__PURE__ */ Xe(t) ? e : e.map(xt));
}
function si(t) {
  return je(t = /* @__PURE__ */ de(t), "iterate", tn), t;
}
function ss(t, e) {
  return /* @__PURE__ */ Tt(t) ? Rs(/* @__PURE__ */ is(t) ? xt(e) : e) : xt(e);
}
const Ml = {
  __proto__: null,
  [Symbol.iterator]() {
    return vi(this, Symbol.iterator, (t) => ss(this, t));
  },
  concat(...t) {
    return Ts(this).concat(
      ...t.map((e) => z(e) ? Ts(e) : e)
    );
  },
  entries() {
    return vi(this, "entries", (t) => (t[1] = ss(this, t[1]), t));
  },
  every(t, e) {
    return qt(this, "every", t, e, void 0, arguments);
  },
  filter(t, e) {
    return qt(
      this,
      "filter",
      t,
      e,
      (s) => s.map((n) => ss(this, n)),
      arguments
    );
  },
  find(t, e) {
    return qt(
      this,
      "find",
      t,
      e,
      (s) => ss(this, s),
      arguments
    );
  },
  findIndex(t, e) {
    return qt(this, "findIndex", t, e, void 0, arguments);
  },
  findLast(t, e) {
    return qt(
      this,
      "findLast",
      t,
      e,
      (s) => ss(this, s),
      arguments
    );
  },
  findLastIndex(t, e) {
    return qt(this, "findLastIndex", t, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(t, e) {
    return qt(this, "forEach", t, e, void 0, arguments);
  },
  includes(...t) {
    return bi(this, "includes", t);
  },
  indexOf(...t) {
    return bi(this, "indexOf", t);
  },
  join(t) {
    return Ts(this).join(t);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...t) {
    return bi(this, "lastIndexOf", t);
  },
  map(t, e) {
    return qt(this, "map", t, e, void 0, arguments);
  },
  pop() {
    return Fs(this, "pop");
  },
  push(...t) {
    return Fs(this, "push", t);
  },
  reduce(t, ...e) {
    return Ro(this, "reduce", t, e);
  },
  reduceRight(t, ...e) {
    return Ro(this, "reduceRight", t, e);
  },
  shift() {
    return Fs(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(t, e) {
    return qt(this, "some", t, e, void 0, arguments);
  },
  splice(...t) {
    return Fs(this, "splice", t);
  },
  toReversed() {
    return Ts(this).toReversed();
  },
  toSorted(t) {
    return Ts(this).toSorted(t);
  },
  toSpliced(...t) {
    return Ts(this).toSpliced(...t);
  },
  unshift(...t) {
    return Fs(this, "unshift", t);
  },
  values() {
    return vi(this, "values", (t) => ss(this, t));
  }
};
function vi(t, e, s) {
  const n = si(t), i = n[e]();
  return n !== t && !/* @__PURE__ */ Xe(t) && (i._next = i.next, i.next = () => {
    const o = i._next();
    return o.done || (o.value = s(o.value)), o;
  }), i;
}
const Ll = Array.prototype;
function qt(t, e, s, n, i, o) {
  const r = si(t), a = r !== t && !/* @__PURE__ */ Xe(t), l = r[e];
  if (l !== Ll[e]) {
    const d = l.apply(t, o);
    return a ? xt(d) : d;
  }
  let u = s;
  r !== t && (a ? u = function(d, m) {
    return s.call(this, ss(t, d), m, t);
  } : s.length > 2 && (u = function(d, m) {
    return s.call(this, d, m, t);
  }));
  const c = l.call(r, u, n);
  return a && i ? i(c) : c;
}
function Ro(t, e, s, n) {
  const i = si(t);
  let o = s;
  return i !== t && (/* @__PURE__ */ Xe(t) ? s.length > 3 && (o = function(r, a, l) {
    return s.call(this, r, a, l, t);
  }) : o = function(r, a, l) {
    return s.call(this, r, ss(t, a), l, t);
  }), i[e](o, ...n);
}
function bi(t, e, s) {
  const n = /* @__PURE__ */ de(t);
  je(n, "iterate", tn);
  const i = n[e](...s);
  return (i === -1 || i === !1) && /* @__PURE__ */ Pn(s[0]) ? (s[0] = /* @__PURE__ */ de(s[0]), n[e](...s)) : i;
}
function Fs(t, e, s = []) {
  _t(), Qi();
  const n = (/* @__PURE__ */ de(t))[e].apply(t, s);
  return Xi(), Nt(), n;
}
const kl = /* @__PURE__ */ Xt("__proto__,__v_isRef,__isVue"), Qr = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(Et)
);
function Pl(t) {
  Et(t) || (t = String(t));
  const e = /* @__PURE__ */ de(this);
  return je(e, "has", t), e.hasOwnProperty(t);
}
class Xr {
  constructor(e = !1, s = !1) {
    this._isReadonly = e, this._isShallow = s;
  }
  get(e, s, n) {
    if (s === "__v_skip") return e.__v_skip;
    const i = this._isReadonly, o = this._isShallow;
    if (s === "__v_isReactive")
      return !i;
    if (s === "__v_isReadonly")
      return i;
    if (s === "__v_isShallow")
      return o;
    if (s === "__v_raw")
      return n === (i ? o ? ia : na : o ? sa : ta).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
    const r = z(e);
    if (!i) {
      let l;
      if (r && (l = Ml[s]))
        return l;
      if (s === "hasOwnProperty")
        return Pl;
    }
    const a = Reflect.get(
      e,
      s,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      /* @__PURE__ */ Ue(e) ? e : n
    );
    if ((Et(s) ? Qr.has(s) : kl(s)) || (i || je(e, "get", s), o))
      return a;
    if (/* @__PURE__ */ Ue(a)) {
      const l = r && Yi(s) ? a : a.value;
      return i && be(l) ? /* @__PURE__ */ $i(l) : l;
    }
    return be(a) ? i ? /* @__PURE__ */ $i(a) : /* @__PURE__ */ Ns(a) : a;
  }
}
class Zr extends Xr {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, s, n, i) {
    let o = e[s];
    const r = z(e) && Yi(s);
    if (!this._isShallow) {
      const u = /* @__PURE__ */ Tt(o);
      if (!/* @__PURE__ */ Xe(n) && !/* @__PURE__ */ Tt(n) && (o = /* @__PURE__ */ de(o), n = /* @__PURE__ */ de(n)), !r && /* @__PURE__ */ Ue(o) && !/* @__PURE__ */ Ue(n))
        return u ? (Se.NODE_ENV !== "production" && yt(
          `Set operation on key "${String(s)}" failed: target is readonly.`,
          e[s]
        ), !0) : (o.value = n, !0);
    }
    const a = r ? Number(s) < e.length : Ee(e, s), l = Reflect.set(
      e,
      s,
      n,
      /* @__PURE__ */ Ue(e) ? e : i
    );
    return e === /* @__PURE__ */ de(i) && (a ? nt(n, o) && It(e, "set", s, n, o) : It(e, "add", s, n)), l;
  }
  deleteProperty(e, s) {
    const n = Ee(e, s), i = e[s], o = Reflect.deleteProperty(e, s);
    return o && n && It(e, "delete", s, void 0, i), o;
  }
  has(e, s) {
    const n = Reflect.has(e, s);
    return (!Et(s) || !Qr.has(s)) && je(e, "has", s), n;
  }
  ownKeys(e) {
    return je(
      e,
      "iterate",
      z(e) ? "length" : vs
    ), Reflect.ownKeys(e);
  }
}
class ea extends Xr {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, s) {
    return Se.NODE_ENV !== "production" && yt(
      `Set operation on key "${String(s)}" failed: target is readonly.`,
      e
    ), !0;
  }
  deleteProperty(e, s) {
    return Se.NODE_ENV !== "production" && yt(
      `Delete operation on key "${String(s)}" failed: target is readonly.`,
      e
    ), !0;
  }
}
const Bl = /* @__PURE__ */ new Zr(), Ul = /* @__PURE__ */ new ea(), Fl = /* @__PURE__ */ new Zr(!0), jl = /* @__PURE__ */ new ea(!0), Oi = (t) => t, yn = (t) => Reflect.getPrototypeOf(t);
function ql(t, e, s) {
  return function(...n) {
    const i = this.__v_raw, o = /* @__PURE__ */ de(i), r = ms(o), a = t === "entries" || t === Symbol.iterator && r, l = t === "keys" && r, u = i[t](...n), c = s ? Oi : e ? Rs : xt;
    return !e && je(
      o,
      "iterate",
      l ? Di : vs
    ), Ve(
      // inheriting all iterator properties
      Object.create(u),
      {
        // iterator protocol
        next() {
          const { value: d, done: m } = u.next();
          return m ? { value: d, done: m } : {
            value: a ? [c(d[0]), c(d[1])] : c(d),
            done: m
          };
        }
      }
    );
  };
}
function _n(t) {
  return function(...e) {
    if (Se.NODE_ENV !== "production") {
      const s = e[0] ? `on key "${e[0]}" ` : "";
      yt(
        `${Zn(t)} operation ${s}failed: target is readonly.`,
        /* @__PURE__ */ de(this)
      );
    }
    return t === "delete" ? !1 : t === "clear" ? void 0 : this;
  };
}
function Wl(t, e) {
  const s = {
    get(i) {
      const o = this.__v_raw, r = /* @__PURE__ */ de(o), a = /* @__PURE__ */ de(i);
      t || (nt(i, a) && je(r, "get", i), je(r, "get", a));
      const { has: l } = yn(r), u = e ? Oi : t ? Rs : xt;
      if (l.call(r, i))
        return u(o.get(i));
      if (l.call(r, a))
        return u(o.get(a));
      o !== r && o.get(i);
    },
    get size() {
      const i = this.__v_raw;
      return !t && je(/* @__PURE__ */ de(i), "iterate", vs), i.size;
    },
    has(i) {
      const o = this.__v_raw, r = /* @__PURE__ */ de(o), a = /* @__PURE__ */ de(i);
      return t || (nt(i, a) && je(r, "has", i), je(r, "has", a)), i === a ? o.has(i) : o.has(i) || o.has(a);
    },
    forEach(i, o) {
      const r = this, a = r.__v_raw, l = /* @__PURE__ */ de(a), u = e ? Oi : t ? Rs : xt;
      return !t && je(l, "iterate", vs), a.forEach((c, d) => i.call(o, u(c), u(d), r));
    }
  };
  return Ve(
    s,
    t ? {
      add: _n("add"),
      set: _n("set"),
      delete: _n("delete"),
      clear: _n("clear")
    } : {
      add(i) {
        !e && !/* @__PURE__ */ Xe(i) && !/* @__PURE__ */ Tt(i) && (i = /* @__PURE__ */ de(i));
        const o = /* @__PURE__ */ de(this);
        return yn(o).has.call(o, i) || (o.add(i), It(o, "add", i, i)), this;
      },
      set(i, o) {
        !e && !/* @__PURE__ */ Xe(o) && !/* @__PURE__ */ Tt(o) && (o = /* @__PURE__ */ de(o));
        const r = /* @__PURE__ */ de(this), { has: a, get: l } = yn(r);
        let u = a.call(r, i);
        u ? Se.NODE_ENV !== "production" && Io(r, a, i) : (i = /* @__PURE__ */ de(i), u = a.call(r, i));
        const c = l.call(r, i);
        return r.set(i, o), u ? nt(o, c) && It(r, "set", i, o, c) : It(r, "add", i, o), this;
      },
      delete(i) {
        const o = /* @__PURE__ */ de(this), { has: r, get: a } = yn(o);
        let l = r.call(o, i);
        l ? Se.NODE_ENV !== "production" && Io(o, r, i) : (i = /* @__PURE__ */ de(i), l = r.call(o, i));
        const u = a ? a.call(o, i) : void 0, c = o.delete(i);
        return l && It(o, "delete", i, void 0, u), c;
      },
      clear() {
        const i = /* @__PURE__ */ de(this), o = i.size !== 0, r = Se.NODE_ENV !== "production" ? ms(i) ? new Map(i) : new Set(i) : void 0, a = i.clear();
        return o && It(
          i,
          "clear",
          void 0,
          void 0,
          r
        ), a;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((i) => {
    s[i] = ql(i, t, e);
  }), s;
}
function ni(t, e) {
  const s = Wl(t, e);
  return (n, i, o) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? n : Reflect.get(
    Ee(s, i) && i in n ? s : n,
    i,
    o
  );
}
const Hl = {
  get: /* @__PURE__ */ ni(!1, !1)
}, Kl = {
  get: /* @__PURE__ */ ni(!1, !0)
}, zl = {
  get: /* @__PURE__ */ ni(!0, !1)
}, Gl = {
  get: /* @__PURE__ */ ni(!0, !0)
};
function Io(t, e, s) {
  const n = /* @__PURE__ */ de(s);
  if (n !== s && e.call(t, n)) {
    const i = Gi(t);
    yt(
      `Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const ta = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap(), na = /* @__PURE__ */ new WeakMap(), ia = /* @__PURE__ */ new WeakMap();
function Yl(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Jl(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : Yl(Gi(t));
}
// @__NO_SIDE_EFFECTS__
function Ns(t) {
  return /* @__PURE__ */ Tt(t) ? t : ii(
    t,
    !1,
    Bl,
    Hl,
    ta
  );
}
// @__NO_SIDE_EFFECTS__
function Ql(t) {
  return ii(
    t,
    !1,
    Fl,
    Kl,
    sa
  );
}
// @__NO_SIDE_EFFECTS__
function $i(t) {
  return ii(
    t,
    !0,
    Ul,
    zl,
    na
  );
}
// @__NO_SIDE_EFFECTS__
function Lt(t) {
  return ii(
    t,
    !0,
    jl,
    Gl,
    ia
  );
}
function ii(t, e, s, n, i) {
  if (!be(t))
    return Se.NODE_ENV !== "production" && yt(
      `value cannot be made ${e ? "readonly" : "reactive"}: ${String(
        t
      )}`
    ), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const o = Jl(t);
  if (o === 0)
    return t;
  const r = i.get(t);
  if (r)
    return r;
  const a = new Proxy(
    t,
    o === 2 ? n : s
  );
  return i.set(t, a), a;
}
// @__NO_SIDE_EFFECTS__
function is(t) {
  return /* @__PURE__ */ Tt(t) ? /* @__PURE__ */ is(t.__v_raw) : !!(t && t.__v_isReactive);
}
// @__NO_SIDE_EFFECTS__
function Tt(t) {
  return !!(t && t.__v_isReadonly);
}
// @__NO_SIDE_EFFECTS__
function Xe(t) {
  return !!(t && t.__v_isShallow);
}
// @__NO_SIDE_EFFECTS__
function Pn(t) {
  return t ? !!t.__v_raw : !1;
}
// @__NO_SIDE_EFFECTS__
function de(t) {
  const e = t && t.__v_raw;
  return e ? /* @__PURE__ */ de(e) : t;
}
function Xl(t) {
  return !Ee(t, "__v_skip") && Object.isExtensible(t) && kn(t, "__v_skip", !0), t;
}
const xt = (t) => be(t) ? /* @__PURE__ */ Ns(t) : t, Rs = (t) => be(t) ? /* @__PURE__ */ $i(t) : t;
// @__NO_SIDE_EFFECTS__
function Ue(t) {
  return t ? t.__v_isRef === !0 : !1;
}
// @__NO_SIDE_EFFECTS__
function j(t) {
  return Zl(t, !1);
}
function Zl(t, e) {
  return /* @__PURE__ */ Ue(t) ? t : new ec(t, e);
}
class ec {
  constructor(e, s) {
    this.dep = new ti(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? e : /* @__PURE__ */ de(e), this._value = s ? e : xt(e), this.__v_isShallow = s;
  }
  get value() {
    return Se.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track(), this._value;
  }
  set value(e) {
    const s = this._rawValue, n = this.__v_isShallow || /* @__PURE__ */ Xe(e) || /* @__PURE__ */ Tt(e);
    e = n ? e : /* @__PURE__ */ de(e), nt(e, s) && (this._rawValue = e, this._value = n ? e : xt(e), Se.NODE_ENV !== "production" ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: e,
      oldValue: s
    }) : this.dep.trigger());
  }
}
function Q(t) {
  return /* @__PURE__ */ Ue(t) ? t.value : t;
}
const tc = {
  get: (t, e, s) => e === "__v_raw" ? t : Q(Reflect.get(t, e, s)),
  set: (t, e, s, n) => {
    const i = t[e];
    return /* @__PURE__ */ Ue(i) && !/* @__PURE__ */ Ue(s) ? (i.value = s, !0) : Reflect.set(t, e, s, n);
  }
};
function oa(t) {
  return /* @__PURE__ */ is(t) ? t : new Proxy(t, tc);
}
class sc {
  constructor(e) {
    this.__v_isRef = !0, this._value = void 0;
    const s = this.dep = new ti(), { get: n, set: i } = e(s.track.bind(s), s.trigger.bind(s));
    this._get = n, this._set = i;
  }
  get value() {
    return this._value = this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function nc(t) {
  return new sc(t);
}
class ic {
  constructor(e, s, n) {
    this.fn = e, this.setter = s, this._value = void 0, this.dep = new ti(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = en - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !s, this.isSSR = n;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Ne !== this)
      return Hr(this, !0), !0;
  }
  get value() {
    const e = Se.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    return Gr(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter ? this.setter(e) : Se.NODE_ENV !== "production" && yt("Write operation failed: computed value is readonly");
  }
}
// @__NO_SIDE_EFFECTS__
function oc(t, e, s = !1) {
  let n, i;
  return te(t) ? n = t : (n = t.get, i = t.set), new ic(n, i, s);
}
const Nn = {}, Bn = /* @__PURE__ */ new WeakMap();
let fs;
function rc(t, e = !1, s = fs) {
  if (s) {
    let n = Bn.get(s);
    n || Bn.set(s, n = []), n.push(t);
  } else Se.NODE_ENV !== "production" && !e && yt(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function ac(t, e, s = ye) {
  const { immediate: n, deep: i, once: o, scheduler: r, augmentJob: a, call: l } = s, u = (P) => {
    (s.onWarn || yt)(
      "Invalid watch source: ",
      P,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, c = (P) => i ? P : /* @__PURE__ */ Xe(P) || i === !1 || i === 0 ? Gt(P, 1) : Gt(P);
  let d, m, h, b, y = !1, E = !1;
  if (/* @__PURE__ */ Ue(t) ? (m = () => t.value, y = /* @__PURE__ */ Xe(t)) : /* @__PURE__ */ is(t) ? (m = () => c(t), y = !0) : z(t) ? (E = !0, y = t.some((P) => /* @__PURE__ */ is(P) || /* @__PURE__ */ Xe(P)), m = () => t.map((P) => {
    if (/* @__PURE__ */ Ue(P))
      return P.value;
    if (/* @__PURE__ */ is(P))
      return c(P);
    if (te(P))
      return l ? l(P, 2) : P();
    Se.NODE_ENV !== "production" && u(P);
  })) : te(t) ? e ? m = l ? () => l(t, 2) : t : m = () => {
    if (h) {
      _t();
      try {
        h();
      } finally {
        Nt();
      }
    }
    const P = fs;
    fs = d;
    try {
      return l ? l(t, 3, [b]) : t(b);
    } finally {
      fs = P;
    }
  } : (m = qe, Se.NODE_ENV !== "production" && u(t)), e && i) {
    const P = m, H = i === !0 ? 1 / 0 : i;
    m = () => Gt(P(), H);
  }
  const _ = Vl(), S = () => {
    d.stop(), _ && _.active && Ki(_.effects, d);
  };
  if (o && e) {
    const P = e;
    e = (...H) => {
      P(...H), S();
    };
  }
  let N = E ? new Array(t.length).fill(Nn) : Nn;
  const R = (P) => {
    if (!(!(d.flags & 1) || !d.dirty && !P))
      if (e) {
        const H = d.run();
        if (i || y || (E ? H.some((pe, he) => nt(pe, N[he])) : nt(H, N))) {
          h && h();
          const pe = fs;
          fs = d;
          try {
            const he = [
              H,
              // pass undefined as the old value when it's changed for the first time
              N === Nn ? void 0 : E && N[0] === Nn ? [] : N,
              b
            ];
            N = H, l ? l(e, 3, he) : (
              // @ts-expect-error
              e(...he)
            );
          } finally {
            fs = pe;
          }
        }
      } else
        d.run();
  };
  return a && a(R), d = new qr(m), d.scheduler = r ? () => r(R, !1) : R, b = (P) => rc(P, !1, d), h = d.onStop = () => {
    const P = Bn.get(d);
    if (P) {
      if (l)
        l(P, 4);
      else
        for (const H of P) H();
      Bn.delete(d);
    }
  }, Se.NODE_ENV !== "production" && (d.onTrack = s.onTrack, d.onTrigger = s.onTrigger), e ? n ? R(!0) : N = d.run() : r ? r(R.bind(null, !0), !0) : d.run(), S.pause = d.pause.bind(d), S.resume = d.resume.bind(d), S.stop = S, S;
}
function Gt(t, e = 1 / 0, s) {
  if (e <= 0 || !be(t) || t.__v_skip || (s = s || /* @__PURE__ */ new Map(), (s.get(t) || 0) >= e))
    return t;
  if (s.set(t, e), e--, /* @__PURE__ */ Ue(t))
    Gt(t.value, e, s);
  else if (z(t))
    for (let n = 0; n < t.length; n++)
      Gt(t[n], e, s);
  else if (Ls(t) || ms(t))
    t.forEach((n) => {
      Gt(n, e, s);
    });
  else if (Br(t)) {
    for (const n in t)
      Gt(t[n], e, s);
    for (const n of Object.getOwnPropertySymbols(t))
      Object.prototype.propertyIsEnumerable.call(t, n) && Gt(t[n], e, s);
  }
  return t;
}
var g = {};
const bs = [];
function Dn(t) {
  bs.push(t);
}
function On() {
  bs.pop();
}
let gi = !1;
function V(t, ...e) {
  if (gi) return;
  gi = !0, _t();
  const s = bs.length ? bs[bs.length - 1].component : null, n = s && s.appContext.config.warnHandler, i = lc();
  if (n)
    ks(
      n,
      s,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        t + e.map((o) => {
          var r, a;
          return (a = (r = o.toString) == null ? void 0 : r.call(o)) != null ? a : JSON.stringify(o);
        }).join(""),
        s && s.proxy,
        i.map(
          ({ vnode: o }) => `at <${bn(s, o.type)}>`
        ).join(`
`),
        i
      ]
    );
  else {
    const o = [`[Vue warn]: ${t}`, ...e];
    i.length && o.push(`
`, ...cc(i)), console.warn(...o);
  }
  Nt(), gi = !1;
}
function lc() {
  let t = bs[bs.length - 1];
  if (!t)
    return [];
  const e = [];
  for (; t; ) {
    const s = e[0];
    s && s.vnode === t ? s.recurseCount++ : e.push({
      vnode: t,
      recurseCount: 0
    });
    const n = t.component && t.component.parent;
    t = n && n.vnode;
  }
  return e;
}
function cc(t) {
  const e = [];
  return t.forEach((s, n) => {
    e.push(...n === 0 ? [] : [`
`], ...uc(s));
  }), e;
}
function uc({ vnode: t, recurseCount: e }) {
  const s = e > 0 ? `... (${e} recursive calls)` : "", n = t.component ? t.component.parent == null : !1, i = ` at <${bn(
    t.component,
    t.type,
    n
  )}`, o = ">" + s;
  return t.props ? [i, ...dc(t.props), o] : [i + o];
}
function dc(t) {
  const e = [], s = Object.keys(t);
  return s.slice(0, 3).forEach((n) => {
    e.push(...ra(n, t[n]));
  }), s.length > 3 && e.push(" ..."), e;
}
function ra(t, e, s) {
  return Re(e) ? (e = JSON.stringify(e), s ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? s ? e : [`${t}=${e}`] : /* @__PURE__ */ Ue(e) ? (e = ra(t, /* @__PURE__ */ de(e.value), !0), s ? e : [`${t}=Ref<`, e, ">"]) : te(e) ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`] : (e = /* @__PURE__ */ de(e), s ? e : [`${t}=`, e]);
}
function fc(t, e) {
  g.NODE_ENV !== "production" && t !== void 0 && (typeof t != "number" ? V(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && V(`${e} is NaN - the duration expression might be incorrect.`));
}
const eo = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function ks(t, e, s, n) {
  try {
    return n ? t(...n) : t();
  } catch (i) {
    dn(i, e, s);
  }
}
function wt(t, e, s, n) {
  if (te(t)) {
    const i = ks(t, e, s, n);
    return i && zi(i) && i.catch((o) => {
      dn(o, e, s);
    }), i;
  }
  if (z(t)) {
    const i = [];
    for (let o = 0; o < t.length; o++)
      i.push(wt(t[o], e, s, n));
    return i;
  } else g.NODE_ENV !== "production" && V(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof t}`
  );
}
function dn(t, e, s, n = !0) {
  const i = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: r } = e && e.appContext.config || ye;
  if (e) {
    let a = e.parent;
    const l = e.proxy, u = g.NODE_ENV !== "production" ? eo[s] : `https://vuejs.org/error-reference/#runtime-${s}`;
    for (; a; ) {
      const c = a.ec;
      if (c) {
        for (let d = 0; d < c.length; d++)
          if (c[d](t, l, u) === !1)
            return;
      }
      a = a.parent;
    }
    if (o) {
      _t(), ks(o, null, 10, [
        t,
        l,
        u
      ]), Nt();
      return;
    }
  }
  pc(t, s, i, n, r);
}
function pc(t, e, s, n = !0, i = !1) {
  if (g.NODE_ENV !== "production") {
    const o = eo[e];
    if (s && Dn(s), V(`Unhandled error${o ? ` during execution of ${o}` : ""}`), s && On(), n)
      throw t;
    console.error(t);
  } else {
    if (i)
      throw t;
    console.error(t);
  }
}
const Qe = [];
let At = -1;
const Os = [];
let ns = null, Cs = 0;
const aa = /* @__PURE__ */ Promise.resolve();
let Un = null;
const hc = 100;
function Pt(t) {
  const e = Un || aa;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function mc(t) {
  let e = At + 1, s = Qe.length;
  for (; e < s; ) {
    const n = e + s >>> 1, i = Qe[n], o = sn(i);
    o < t || o === t && i.flags & 2 ? e = n + 1 : s = n;
  }
  return e;
}
function oi(t) {
  if (!(t.flags & 1)) {
    const e = sn(t), s = Qe[Qe.length - 1];
    !s || // fast path when the job id is larger than the tail
    !(t.flags & 2) && e >= sn(s) ? Qe.push(t) : Qe.splice(mc(e), 0, t), t.flags |= 1, la();
  }
}
function la() {
  Un || (Un = aa.then(da));
}
function ca(t) {
  z(t) ? Os.push(...t) : ns && t.id === -1 ? ns.splice(Cs + 1, 0, t) : t.flags & 1 || (Os.push(t), t.flags |= 1), la();
}
function Mo(t, e, s = At + 1) {
  for (g.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()); s < Qe.length; s++) {
    const n = Qe[s];
    if (n && n.flags & 2) {
      if (t && n.id !== t.uid || g.NODE_ENV !== "production" && to(e, n))
        continue;
      Qe.splice(s, 1), s--, n.flags & 4 && (n.flags &= -2), n(), n.flags & 4 || (n.flags &= -2);
    }
  }
}
function ua(t) {
  if (Os.length) {
    const e = [...new Set(Os)].sort(
      (s, n) => sn(s) - sn(n)
    );
    if (Os.length = 0, ns) {
      ns.push(...e);
      return;
    }
    for (ns = e, g.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), Cs = 0; Cs < ns.length; Cs++) {
      const s = ns[Cs];
      g.NODE_ENV !== "production" && to(t, s) || (s.flags & 4 && (s.flags &= -2), s.flags & 8 || s(), s.flags &= -2);
    }
    ns = null, Cs = 0;
  }
}
const sn = (t) => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id;
function da(t) {
  g.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map());
  const e = g.NODE_ENV !== "production" ? (s) => to(t, s) : qe;
  try {
    for (At = 0; At < Qe.length; At++) {
      const s = Qe[At];
      if (s && !(s.flags & 8)) {
        if (g.NODE_ENV !== "production" && e(s))
          continue;
        s.flags & 4 && (s.flags &= -2), ks(
          s,
          s.i,
          s.i ? 15 : 14
        ), s.flags & 4 || (s.flags &= -2);
      }
    }
  } finally {
    for (; At < Qe.length; At++) {
      const s = Qe[At];
      s && (s.flags &= -2);
    }
    At = -1, Qe.length = 0, ua(t), Un = null, (Qe.length || Os.length) && da(t);
  }
}
function to(t, e) {
  const s = t.get(e) || 0;
  if (s > hc) {
    const n = e.i, i = n && sl(n.type);
    return dn(
      `Maximum recursive updates exceeded${i ? ` in component <${i}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), !0;
  }
  return t.set(e, s + 1), !1;
}
let ht = !1;
const $n = /* @__PURE__ */ new Map();
g.NODE_ENV !== "production" && (un().__VUE_HMR_RUNTIME__ = {
  createRecord: Ei(fa),
  rerender: Ei(gc),
  reload: Ei(Ec)
});
const ys = /* @__PURE__ */ new Map();
function vc(t) {
  const e = t.type.__hmrId;
  let s = ys.get(e);
  s || (fa(e, t.type), s = ys.get(e)), s.instances.add(t);
}
function bc(t) {
  ys.get(t.type.__hmrId).instances.delete(t);
}
function fa(t, e) {
  return ys.has(t) ? !1 : (ys.set(t, {
    initialDef: Fn(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Fn(t) {
  return nl(t) ? t.__vccOpts : t;
}
function gc(t, e) {
  const s = ys.get(t);
  s && (s.initialDef.render = e, [...s.instances].forEach((n) => {
    e && (n.render = e, Fn(n.type).render = e), n.renderCache = [], ht = !0, n.job.flags & 8 || n.update(), ht = !1;
  }));
}
function Ec(t, e) {
  const s = ys.get(t);
  if (!s) return;
  e = Fn(e), Lo(s.initialDef, e);
  const n = [...s.instances];
  for (let i = 0; i < n.length; i++) {
    const o = n[i], r = Fn(o.type);
    let a = $n.get(r);
    a || (r !== s.initialDef && Lo(r, e), $n.set(r, a = /* @__PURE__ */ new Set())), a.add(o), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (a.add(o), o.ceReload(e.styles), a.delete(o)) : o.parent ? oi(() => {
      o.job.flags & 8 || (ht = !0, o.parent.update(), ht = !1, a.delete(o));
    }) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), o.root.ce && o !== o.root && o.root.ce._removeChildStyle(r);
  }
  ca(() => {
    $n.clear();
  });
}
function Lo(t, e) {
  Ve(t, e);
  for (const s in t)
    s !== "__file" && !(s in e) && delete t[s];
}
function Ei(t) {
  return (e, s) => {
    try {
      return t(e, s);
    } catch (n) {
      console.error(n), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let Mt, Hs = [], Ai = !1;
function fn(t, ...e) {
  Mt ? Mt.emit(t, ...e) : Ai || Hs.push({ event: t, args: e });
}
function pa(t, e) {
  var s, n;
  Mt = t, Mt ? (Mt.enabled = !0, Hs.forEach(({ event: i, args: o }) => Mt.emit(i, ...o)), Hs = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((n = (s = window.navigator) == null ? void 0 : s.userAgent) != null && n.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((o) => {
    pa(o, e);
  }), setTimeout(() => {
    Mt || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Ai = !0, Hs = []);
  }, 3e3)) : (Ai = !0, Hs = []);
}
function yc(t, e) {
  fn("app:init", t, e, {
    Fragment: Ae,
    Text: mn,
    Comment: Be,
    Static: Rn
  });
}
function _c(t) {
  fn("app:unmount", t);
}
const Nc = /* @__PURE__ */ so(
  "component:added"
  /* COMPONENT_ADDED */
), ha = /* @__PURE__ */ so(
  "component:updated"
  /* COMPONENT_UPDATED */
), Tc = /* @__PURE__ */ so(
  "component:removed"
  /* COMPONENT_REMOVED */
), xc = (t) => {
  Mt && typeof Mt.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !Mt.cleanupBuffer(t) && Tc(t);
};
// @__NO_SIDE_EFFECTS__
function so(t) {
  return (e) => {
    fn(
      t,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const wc = /* @__PURE__ */ ma(
  "perf:start"
  /* PERFORMANCE_START */
), Sc = /* @__PURE__ */ ma(
  "perf:end"
  /* PERFORMANCE_END */
);
function ma(t) {
  return (e, s, n) => {
    fn(t, e.appContext.app, e.uid, e, s, n);
  };
}
function Cc(t, e, s) {
  fn(
    "component:emit",
    t.appContext.app,
    t,
    e,
    s
  );
}
let We = null, va = null;
function jn(t) {
  const e = We;
  return We = t, va = t && t.type.__scopeId || null, e;
}
function k(t, e = We, s) {
  if (!e || t._n)
    return t;
  const n = (...i) => {
    n._d && Gn(-1);
    const o = jn(e);
    let r;
    try {
      r = t(...i);
    } finally {
      jn(o), n._d && Gn(1);
    }
    return g.NODE_ENV !== "production" && ha(e), r;
  };
  return n._n = !0, n._c = !0, n._d = !0, n;
}
function ba(t) {
  hl(t) && V("Do not use built-in directive ids as custom directive id: " + t);
}
function it(t, e) {
  if (We === null)
    return g.NODE_ENV !== "production" && V("withDirectives can only be used inside render functions."), t;
  const s = ci(We), n = t.dirs || (t.dirs = []);
  for (let i = 0; i < e.length; i++) {
    let [o, r, a, l = ye] = e[i];
    o && (te(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Gt(r), n.push({
      dir: o,
      instance: s,
      value: r,
      oldValue: void 0,
      arg: a,
      modifiers: l
    }));
  }
  return t;
}
function as(t, e, s, n) {
  const i = t.dirs, o = e && e.dirs;
  for (let r = 0; r < i.length; r++) {
    const a = i[r];
    o && (a.oldValue = o[r].value);
    let l = a.dir[n];
    l && (_t(), wt(l, s, 8, [
      t.el,
      a,
      t,
      e
    ]), Nt());
  }
}
function Dc(t, e) {
  if (g.NODE_ENV !== "production" && (!Fe || Fe.isMounted) && V("provide() can only be used inside setup()."), Fe) {
    let s = Fe.provides;
    const n = Fe.parent && Fe.parent.provides;
    n === s && (s = Fe.provides = Object.create(n)), s[t] = e;
  }
}
function An(t, e, s = !1) {
  const n = li();
  if (n || As) {
    let i = As ? As._context.provides : n ? n.parent == null || n.ce ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0;
    if (i && t in i)
      return i[t];
    if (arguments.length > 1)
      return s && te(e) ? e.call(n && n.proxy) : e;
    g.NODE_ENV !== "production" && V(`injection "${String(t)}" not found.`);
  } else g.NODE_ENV !== "production" && V("inject() can only be used inside setup() or functional components.");
}
const Oc = /* @__PURE__ */ Symbol.for("v-scx"), $c = () => {
  {
    const t = An(Oc);
    return t || g.NODE_ENV !== "production" && V(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), t;
  }
};
function Ac(t, e) {
  return no(
    t,
    null,
    g.NODE_ENV !== "production" ? Ve({}, e, { flush: "sync" }) : { flush: "sync" }
  );
}
function lt(t, e, s) {
  return g.NODE_ENV !== "production" && !te(e) && V(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), no(t, e, s);
}
function no(t, e, s = ye) {
  const { immediate: n, deep: i, flush: o, once: r } = s;
  g.NODE_ENV !== "production" && !e && (n !== void 0 && V(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), i !== void 0 && V(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), r !== void 0 && V(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const a = Ve({}, s);
  g.NODE_ENV !== "production" && (a.onWarn = V);
  const l = e && n || !e && o !== "post";
  let u;
  if (rn) {
    if (o === "sync") {
      const h = $c();
      u = h.__watcherHandles || (h.__watcherHandles = []);
    } else if (!l) {
      const h = () => {
      };
      return h.stop = qe, h.resume = qe, h.pause = qe, h;
    }
  }
  const c = Fe;
  a.call = (h, b, y) => wt(h, c, b, y);
  let d = !1;
  o === "post" ? a.scheduler = (h) => {
    ze(h, c && c.suspense);
  } : o !== "sync" && (d = !0, a.scheduler = (h, b) => {
    b ? h() : oi(h);
  }), a.augmentJob = (h) => {
    e && (h.flags |= 4), d && (h.flags |= 2, c && (h.id = c.uid, h.i = c));
  };
  const m = ac(t, e, a);
  return rn && (u ? u.push(m) : l && m()), m;
}
function Vc(t, e, s) {
  const n = this.proxy, i = Re(t) ? t.includes(".") ? ga(n, t) : () => n[t] : t.bind(n, n);
  let o;
  te(e) ? o = e : (o = e.handler, s = e);
  const r = vn(this), a = no(i, o.bind(n), s);
  return r(), a;
}
function ga(t, e) {
  const s = e.split(".");
  return () => {
    let n = t;
    for (let i = 0; i < s.length && n; i++)
      n = n[s[i]];
    return n;
  };
}
const Ea = /* @__PURE__ */ Symbol("_vte"), ya = (t) => t.__isTeleport, gs = (t) => t && (t.disabled || t.disabled === ""), ko = (t) => t && (t.defer || t.defer === ""), Po = (t) => typeof SVGElement < "u" && t instanceof SVGElement, Bo = (t) => typeof MathMLElement == "function" && t instanceof MathMLElement, Vi = (t, e) => {
  const s = t && t.to;
  if (Re(s))
    if (e) {
      const n = e(s);
      return g.NODE_ENV !== "production" && !n && !gs(t) && V(
        `Failed to locate Teleport target with selector "${s}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), n;
    } else
      return g.NODE_ENV !== "production" && V(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return g.NODE_ENV !== "production" && !s && !gs(t) && V(`Invalid Teleport target: ${s}`), s;
}, _a = {
  name: "Teleport",
  __isTeleport: !0,
  process(t, e, s, n, i, o, r, a, l, u) {
    const {
      mc: c,
      pc: d,
      pbc: m,
      o: { insert: h, querySelector: b, createText: y, createComment: E }
    } = u, _ = gs(e.props);
    let { shapeFlag: S, children: N, dynamicChildren: R } = e;
    if (g.NODE_ENV !== "production" && ht && (l = !1, R = null), t == null) {
      const P = e.el = g.NODE_ENV !== "production" ? E("teleport start") : y(""), H = e.anchor = g.NODE_ENV !== "production" ? E("teleport end") : y("");
      h(P, s, n), h(H, s, n);
      const pe = (W, ae) => {
        S & 16 && c(
          N,
          W,
          ae,
          i,
          o,
          r,
          a,
          l
        );
      }, he = () => {
        const W = e.target = Vi(e.props, b), ae = Ri(W, e, y, h);
        W ? (r !== "svg" && Po(W) ? r = "svg" : r !== "mathml" && Bo(W) && (r = "mathml"), i && i.isCE && (i.ce._teleportTargets || (i.ce._teleportTargets = /* @__PURE__ */ new Set())).add(W), _ || (pe(W, ae), Vn(e, !1))) : g.NODE_ENV !== "production" && !_ && V(
          "Invalid Teleport target on mount:",
          W,
          `(${typeof W})`
        );
      };
      _ && (pe(s, H), Vn(e, !0)), ko(e.props) ? (e.el.__isMounted = !1, ze(() => {
        he(), delete e.el.__isMounted;
      }, o)) : he();
    } else {
      if (ko(e.props) && t.el.__isMounted === !1) {
        ze(() => {
          _a.process(
            t,
            e,
            s,
            n,
            i,
            o,
            r,
            a,
            l,
            u
          );
        }, o);
        return;
      }
      e.el = t.el, e.targetStart = t.targetStart;
      const P = e.anchor = t.anchor, H = e.target = t.target, pe = e.targetAnchor = t.targetAnchor, he = gs(t.props), W = he ? s : H, ae = he ? P : pe;
      if (r === "svg" || Po(H) ? r = "svg" : (r === "mathml" || Bo(H)) && (r = "mathml"), R ? (m(
        t.dynamicChildren,
        R,
        W,
        i,
        o,
        r,
        a
      ), Qs(t, e, g.NODE_ENV === "production")) : l || d(
        t,
        e,
        W,
        ae,
        i,
        o,
        r,
        a,
        !1
      ), _)
        he ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : Tn(
          e,
          s,
          P,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
        const me = e.target = Vi(
          e.props,
          b
        );
        me ? Tn(
          e,
          me,
          null,
          u,
          0
        ) : g.NODE_ENV !== "production" && V(
          "Invalid Teleport target on update:",
          H,
          `(${typeof H})`
        );
      } else he && Tn(
        e,
        H,
        pe,
        u,
        1
      );
      Vn(e, _);
    }
  },
  remove(t, e, s, { um: n, o: { remove: i } }, o) {
    const {
      shapeFlag: r,
      children: a,
      anchor: l,
      targetStart: u,
      targetAnchor: c,
      target: d,
      props: m
    } = t;
    if (d && (i(u), i(c)), o && i(l), r & 16) {
      const h = o || !gs(m);
      for (let b = 0; b < a.length; b++) {
        const y = a[b];
        n(
          y,
          e,
          s,
          h,
          !!y.dynamicChildren
        );
      }
    }
  },
  move: Tn,
  hydrate: Rc
};
function Tn(t, e, s, { o: { insert: n }, m: i }, o = 2) {
  o === 0 && n(t.targetAnchor, e, s);
  const { el: r, anchor: a, shapeFlag: l, children: u, props: c } = t, d = o === 2;
  if (d && n(r, e, s), (!d || gs(c)) && l & 16)
    for (let m = 0; m < u.length; m++)
      i(
        u[m],
        e,
        s,
        2
      );
  d && n(a, e, s);
}
function Rc(t, e, s, n, i, o, {
  o: { nextSibling: r, parentNode: a, querySelector: l, insert: u, createText: c }
}, d) {
  function m(E, _) {
    let S = _;
    for (; S; ) {
      if (S && S.nodeType === 8) {
        if (S.data === "teleport start anchor")
          e.targetStart = S;
        else if (S.data === "teleport anchor") {
          e.targetAnchor = S, E._lpa = e.targetAnchor && r(e.targetAnchor);
          break;
        }
      }
      S = r(S);
    }
  }
  function h(E, _) {
    _.anchor = d(
      r(E),
      _,
      a(E),
      s,
      n,
      i,
      o
    );
  }
  const b = e.target = Vi(
    e.props,
    l
  ), y = gs(e.props);
  if (b) {
    const E = b._lpa || b.firstChild;
    e.shapeFlag & 16 && (y ? (h(t, e), m(b, E), e.targetAnchor || Ri(
      b,
      e,
      c,
      u,
      // if target is the same as the main view, insert anchors before current node
      // to avoid hydrating mismatch
      a(t) === b ? t : null
    )) : (e.anchor = r(t), m(b, E), e.targetAnchor || Ri(b, e, c, u), d(
      E && r(E),
      e,
      b,
      s,
      n,
      i,
      o
    ))), Vn(e, y);
  } else y && e.shapeFlag & 16 && (h(t, e), e.targetStart = t, e.targetAnchor = r(t));
  return e.anchor && r(e.anchor);
}
const Na = _a;
function Vn(t, e) {
  const s = t.ctx;
  if (s && s.ut) {
    let n, i;
    for (e ? (n = t.el, i = t.anchor) : (n = t.targetStart, i = t.targetAnchor); n && n !== i; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", s.uid), n = n.nextSibling;
    s.ut();
  }
}
function Ri(t, e, s, n, i = null) {
  const o = e.targetStart = s(""), r = e.targetAnchor = s("");
  return o[Ea] = r, t && (n(o, t, i), n(r, t, i)), r;
}
const Rt = /* @__PURE__ */ Symbol("_leaveCb"), js = /* @__PURE__ */ Symbol("_enterCb");
function Ic() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return ot(() => {
    t.isMounted = !0;
  }), jt(() => {
    t.isUnmounting = !0;
  }), t;
}
const ct = [Function, Array], Ta = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: ct,
  onEnter: ct,
  onAfterEnter: ct,
  onEnterCancelled: ct,
  // leave
  onBeforeLeave: ct,
  onLeave: ct,
  onAfterLeave: ct,
  onLeaveCancelled: ct,
  // appear
  onBeforeAppear: ct,
  onAppear: ct,
  onAfterAppear: ct,
  onAppearCancelled: ct
}, xa = (t) => {
  const e = t.subTree;
  return e.component ? xa(e.component) : e;
}, Mc = {
  name: "BaseTransition",
  props: Ta,
  setup(t, { slots: e }) {
    const s = li(), n = Ic();
    return () => {
      const i = e.default && Ca(e.default(), !0);
      if (!i || !i.length)
        return;
      const o = wa(i), r = /* @__PURE__ */ de(t), { mode: a } = r;
      if (g.NODE_ENV !== "production" && a && a !== "in-out" && a !== "out-in" && a !== "default" && V(`invalid <transition> mode: ${a}`), n.isLeaving)
        return yi(o);
      const l = Uo(o);
      if (!l)
        return yi(o);
      let u = Ii(
        l,
        r,
        n,
        s,
        // #11061, ensure enterHooks is fresh after clone
        (d) => u = d
      );
      l.type !== Be && nn(l, u);
      let c = s.subTree && Uo(s.subTree);
      if (c && c.type !== Be && !hs(c, l) && xa(s).type !== Be) {
        let d = Ii(
          c,
          r,
          n,
          s
        );
        if (nn(c, d), a === "out-in" && l.type !== Be)
          return n.isLeaving = !0, d.afterLeave = () => {
            n.isLeaving = !1, s.job.flags & 8 || s.update(), delete d.afterLeave, c = void 0;
          }, yi(o);
        a === "in-out" && l.type !== Be ? d.delayLeave = (m, h, b) => {
          const y = Sa(
            n,
            c
          );
          y[String(c.key)] = c, m[Rt] = () => {
            h(), m[Rt] = void 0, delete u.delayedLeave, c = void 0;
          }, u.delayedLeave = () => {
            b(), delete u.delayedLeave, c = void 0;
          };
        } : c = void 0;
      } else c && (c = void 0);
      return o;
    };
  }
};
function wa(t) {
  let e = t[0];
  if (t.length > 1) {
    let s = !1;
    for (const n of t)
      if (n.type !== Be) {
        if (g.NODE_ENV !== "production" && s) {
          V(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        if (e = n, s = !0, g.NODE_ENV === "production") break;
      }
  }
  return e;
}
const Lc = Mc;
function Sa(t, e) {
  const { leavingVNodes: s } = t;
  let n = s.get(e.type);
  return n || (n = /* @__PURE__ */ Object.create(null), s.set(e.type, n)), n;
}
function Ii(t, e, s, n, i) {
  const {
    appear: o,
    mode: r,
    persisted: a = !1,
    onBeforeEnter: l,
    onEnter: u,
    onAfterEnter: c,
    onEnterCancelled: d,
    onBeforeLeave: m,
    onLeave: h,
    onAfterLeave: b,
    onLeaveCancelled: y,
    onBeforeAppear: E,
    onAppear: _,
    onAfterAppear: S,
    onAppearCancelled: N
  } = e, R = String(t.key), P = Sa(s, t), H = (W, ae) => {
    W && wt(
      W,
      n,
      9,
      ae
    );
  }, pe = (W, ae) => {
    const me = ae[1];
    H(W, ae), z(W) ? W.every((q) => q.length <= 1) && me() : W.length <= 1 && me();
  }, he = {
    mode: r,
    persisted: a,
    beforeEnter(W) {
      let ae = l;
      if (!s.isMounted)
        if (o)
          ae = E || l;
        else
          return;
      W[Rt] && W[Rt](
        !0
        /* cancelled */
      );
      const me = P[R];
      me && hs(t, me) && me.el[Rt] && me.el[Rt](), H(ae, [W]);
    },
    enter(W) {
      let ae = u, me = c, q = d;
      if (!s.isMounted)
        if (o)
          ae = _ || u, me = S || c, q = N || d;
        else
          return;
      let K = !1;
      W[js] = (ue) => {
        K || (K = !0, ue ? H(q, [W]) : H(me, [W]), he.delayedLeave && he.delayedLeave(), W[js] = void 0);
      };
      const G = W[js].bind(null, !1);
      ae ? pe(ae, [W, G]) : G();
    },
    leave(W, ae) {
      const me = String(t.key);
      if (W[js] && W[js](
        !0
        /* cancelled */
      ), s.isUnmounting)
        return ae();
      H(m, [W]);
      let q = !1;
      W[Rt] = (G) => {
        q || (q = !0, ae(), G ? H(y, [W]) : H(b, [W]), W[Rt] = void 0, P[me] === t && delete P[me]);
      };
      const K = W[Rt].bind(null, !1);
      P[me] = t, h ? pe(h, [W, K]) : K();
    },
    clone(W) {
      const ae = Ii(
        W,
        e,
        s,
        n,
        i
      );
      return i && i(ae), ae;
    }
  };
  return he;
}
function yi(t) {
  if (pn(t))
    return t = Ft(t), t.children = null, t;
}
function Uo(t) {
  if (!pn(t))
    return ya(t.type) && t.children ? wa(t.children) : t;
  if (t.component)
    return t.component.subTree;
  const { shapeFlag: e, children: s } = t;
  if (s) {
    if (e & 16)
      return s[0];
    if (e & 32 && te(s.default))
      return s.default();
  }
}
function nn(t, e) {
  t.shapeFlag & 6 && t.component ? (t.transition = e, nn(t.component.subTree, e)) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function Ca(t, e = !1, s) {
  let n = [], i = 0;
  for (let o = 0; o < t.length; o++) {
    let r = t[o];
    const a = s == null ? r.key : String(s) + String(r.key != null ? r.key : o);
    r.type === Ae ? (r.patchFlag & 128 && i++, n = n.concat(
      Ca(r.children, e, a)
    )) : (e || r.type !== Be) && n.push(a != null ? Ft(r, { key: a }) : r);
  }
  if (i > 1)
    for (let o = 0; o < n.length; o++)
      n[o].patchFlag = -2;
  return n;
}
// @__NO_SIDE_EFFECTS__
function _e(t, e) {
  return te(t) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Ve({ name: t.name }, e, { setup: t })
  ) : t;
}
function Da(t) {
  t.ids = [t.ids[0] + t.ids[2]++ + "-", 0, 0];
}
const Fo = /* @__PURE__ */ new WeakSet();
function jo(t, e) {
  let s;
  return !!((s = Object.getOwnPropertyDescriptor(t, e)) && !s.configurable);
}
const qn = /* @__PURE__ */ new WeakMap();
function Js(t, e, s, n, i = !1) {
  if (z(t)) {
    t.forEach(
      (y, E) => Js(
        y,
        e && (z(e) ? e[E] : e),
        s,
        n,
        i
      )
    );
    return;
  }
  if ($s(n) && !i) {
    n.shapeFlag & 512 && n.type.__asyncResolved && n.component.subTree.component && Js(t, e, s, n.component.subTree);
    return;
  }
  const o = n.shapeFlag & 4 ? ci(n.component) : n.el, r = i ? null : o, { i: a, r: l } = t;
  if (g.NODE_ENV !== "production" && !a) {
    V(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const u = e && e.r, c = a.refs === ye ? a.refs = {} : a.refs, d = a.setupState, m = /* @__PURE__ */ de(d), h = d === ye ? kr : (y) => g.NODE_ENV !== "production" && (Ee(m, y) && !/* @__PURE__ */ Ue(m[y]) && V(
    `Template ref "${y}" used on a non-ref value. It will not work in the production build.`
  ), Fo.has(m[y])) || jo(c, y) ? !1 : Ee(m, y), b = (y, E) => !(g.NODE_ENV !== "production" && Fo.has(y) || E && jo(c, E));
  if (u != null && u !== l) {
    if (qo(e), Re(u))
      c[u] = null, h(u) && (d[u] = null);
    else if (/* @__PURE__ */ Ue(u)) {
      const y = e;
      b(u, y.k) && (u.value = null), y.k && (c[y.k] = null);
    }
  }
  if (te(l))
    ks(l, a, 12, [r, c]);
  else {
    const y = Re(l), E = /* @__PURE__ */ Ue(l);
    if (y || E) {
      const _ = () => {
        if (t.f) {
          const S = y ? h(l) ? d[l] : c[l] : b(l) || !t.k ? l.value : c[t.k];
          if (i)
            z(S) && Ki(S, o);
          else if (z(S))
            S.includes(o) || S.push(o);
          else if (y)
            c[l] = [o], h(l) && (d[l] = c[l]);
          else {
            const N = [o];
            b(l, t.k) && (l.value = N), t.k && (c[t.k] = N);
          }
        } else y ? (c[l] = r, h(l) && (d[l] = r)) : E ? (b(l, t.k) && (l.value = r), t.k && (c[t.k] = r)) : g.NODE_ENV !== "production" && V("Invalid template ref type:", l, `(${typeof l})`);
      };
      if (r) {
        const S = () => {
          _(), qn.delete(t);
        };
        S.id = -1, qn.set(t, S), ze(S, s);
      } else
        qo(t), _();
    } else g.NODE_ENV !== "production" && V("Invalid template ref type:", l, `(${typeof l})`);
  }
}
function qo(t) {
  const e = qn.get(t);
  e && (e.flags |= 8, qn.delete(t));
}
un().requestIdleCallback;
un().cancelIdleCallback;
const $s = (t) => !!t.type.__asyncLoader, pn = (t) => t.type.__isKeepAlive;
function kc(t, e) {
  Oa(t, "a", e);
}
function Pc(t, e) {
  Oa(t, "da", e);
}
function Oa(t, e, s = Fe) {
  const n = t.__wdc || (t.__wdc = () => {
    let i = s;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return t();
  });
  if (ri(e, n, s), s) {
    let i = s.parent;
    for (; i && i.parent; )
      pn(i.parent.vnode) && Bc(n, e, s, i), i = i.parent;
  }
}
function Bc(t, e, s, n) {
  const i = ri(
    e,
    t,
    n,
    !0
    /* prepend */
  );
  hn(() => {
    Ki(n[e], i);
  }, s);
}
function ri(t, e, s = Fe, n = !1) {
  if (s) {
    const i = s[t] || (s[t] = []), o = e.__weh || (e.__weh = (...r) => {
      _t();
      const a = vn(s), l = wt(e, s, t, r);
      return a(), Nt(), l;
    });
    return n ? i.unshift(o) : i.push(o), o;
  } else if (g.NODE_ENV !== "production") {
    const i = ds(eo[t].replace(/ hook$/, ""));
    V(
      `${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const Zt = (t) => (e, s = Fe) => {
  (!rn || t === "sp") && ri(t, (...n) => e(...n), s);
}, Uc = Zt("bm"), ot = Zt("m"), Fc = Zt(
  "bu"
), jc = Zt("u"), jt = Zt(
  "bum"
), hn = Zt("um"), qc = Zt(
  "sp"
), Wc = Zt("rtg"), Hc = Zt("rtc");
function Kc(t, e = Fe) {
  ri("ec", t, e);
}
const zc = /* @__PURE__ */ Symbol.for("v-ndc");
function Jt(t, e, s, n) {
  let i;
  const o = s, r = z(t);
  if (r || Re(t)) {
    const a = r && /* @__PURE__ */ is(t);
    let l = !1, u = !1;
    a && (l = !/* @__PURE__ */ Xe(t), u = /* @__PURE__ */ Tt(t), t = si(t)), i = new Array(t.length);
    for (let c = 0, d = t.length; c < d; c++)
      i[c] = e(
        l ? u ? Rs(xt(t[c])) : xt(t[c]) : t[c],
        c,
        void 0,
        o
      );
  } else if (typeof t == "number") {
    g.NODE_ENV !== "production" && !Number.isInteger(t) && V(`The v-for range expect an integer value but got ${t}.`), i = new Array(t);
    for (let a = 0; a < t; a++)
      i[a] = e(a + 1, a, void 0, o);
  } else if (be(t))
    if (t[Symbol.iterator])
      i = Array.from(
        t,
        (a, l) => e(a, l, void 0, o)
      );
    else {
      const a = Object.keys(t);
      i = new Array(a.length);
      for (let l = 0, u = a.length; l < u; l++) {
        const c = a[l];
        i[l] = e(t[c], c, l, o);
      }
    }
  else
    i = [];
  return i;
}
function bt(t, e, s = {}, n, i) {
  if (We.ce || We.parent && $s(We.parent) && We.parent.ce) {
    const u = Object.keys(s).length > 0;
    return e !== "default" && (s.name = e), x(), Ie(
      Ae,
      null,
      [w("slot", s, n)],
      u ? -2 : 64
    );
  }
  let o = t[e];
  g.NODE_ENV !== "production" && o && o.length > 1 && (V(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), o = () => []), o && o._c && (o._d = !1), x();
  const r = o && $a(o(s)), a = s.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  r && r.key, l = Ie(
    Ae,
    {
      key: (a && !Et(a) ? a : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!r && n ? "_fb" : "")
    },
    r || [],
    r && t._ === 1 ? 64 : -2
  );
  return !i && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), o && o._c && (o._d = !0), l;
}
function $a(t) {
  return t.some((e) => _s(e) ? !(e.type === Be || e.type === Ae && !$a(e.children)) : !0) ? t : null;
}
const Mi = (t) => t ? el(t) ? ci(t) : Mi(t.parent) : null, Es = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Ve(/* @__PURE__ */ Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ Lt(t.props) : t.props,
    $attrs: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ Lt(t.attrs) : t.attrs,
    $slots: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ Lt(t.slots) : t.slots,
    $refs: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ Lt(t.refs) : t.refs,
    $parent: (t) => Mi(t.parent),
    $root: (t) => Mi(t.root),
    $host: (t) => t.ce,
    $emit: (t) => t.emit,
    $options: (t) => Ra(t),
    $forceUpdate: (t) => t.f || (t.f = () => {
      oi(t.update);
    }),
    $nextTick: (t) => t.n || (t.n = Pt.bind(t.proxy)),
    $watch: (t) => Vc.bind(t)
  })
), io = (t) => t === "_" || t === "$", _i = (t, e) => t !== ye && !t.__isScriptSetup && Ee(t, e), Aa = {
  get({ _: t }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: s, setupState: n, data: i, props: o, accessCache: r, type: a, appContext: l } = t;
    if (g.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    if (e[0] !== "$") {
      const m = r[e];
      if (m !== void 0)
        switch (m) {
          case 1:
            return n[e];
          case 2:
            return i[e];
          case 4:
            return s[e];
          case 3:
            return o[e];
        }
      else {
        if (_i(n, e))
          return r[e] = 1, n[e];
        if (i !== ye && Ee(i, e))
          return r[e] = 2, i[e];
        if (Ee(o, e))
          return r[e] = 3, o[e];
        if (s !== ye && Ee(s, e))
          return r[e] = 4, s[e];
        Li && (r[e] = 0);
      }
    }
    const u = Es[e];
    let c, d;
    if (u)
      return e === "$attrs" ? (je(t.attrs, "get", ""), g.NODE_ENV !== "production" && Kn()) : g.NODE_ENV !== "production" && e === "$slots" && je(t, "get", e), u(t);
    if (
      // css module (injected by vue-loader)
      (c = a.__cssModules) && (c = c[e])
    )
      return c;
    if (s !== ye && Ee(s, e))
      return r[e] = 4, s[e];
    if (
      // global properties
      d = l.config.globalProperties, Ee(d, e)
    )
      return d[e];
    g.NODE_ENV !== "production" && We && (!Re(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (i !== ye && io(e[0]) && Ee(i, e) ? V(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : t === We && V(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: t }, e, s) {
    const { data: n, setupState: i, ctx: o } = t;
    return _i(i, e) ? (i[e] = s, !0) : g.NODE_ENV !== "production" && i.__isScriptSetup && Ee(i, e) ? (V(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : n !== ye && Ee(n, e) ? (n[e] = s, !0) : Ee(t.props, e) ? (g.NODE_ENV !== "production" && V(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (g.NODE_ENV !== "production" && V(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : (g.NODE_ENV !== "production" && e in t.appContext.config.globalProperties ? Object.defineProperty(o, e, {
      enumerable: !0,
      configurable: !0,
      value: s
    }) : o[e] = s, !0);
  },
  has({
    _: { data: t, setupState: e, accessCache: s, ctx: n, appContext: i, props: o, type: r }
  }, a) {
    let l;
    return !!(s[a] || t !== ye && a[0] !== "$" && Ee(t, a) || _i(e, a) || Ee(o, a) || Ee(n, a) || Ee(Es, a) || Ee(i.config.globalProperties, a) || (l = r.__cssModules) && l[a]);
  },
  defineProperty(t, e, s) {
    return s.get != null ? t._.accessCache[e] = 0 : Ee(s, "value") && this.set(t, e, s.value, null), Reflect.defineProperty(t, e, s);
  }
};
g.NODE_ENV !== "production" && (Aa.ownKeys = (t) => (V(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(t)));
function Gc(t) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => t
  }), Object.keys(Es).forEach((s) => {
    Object.defineProperty(e, s, {
      configurable: !0,
      enumerable: !1,
      get: () => Es[s](t),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: qe
    });
  }), e;
}
function Yc(t) {
  const {
    ctx: e,
    propsOptions: [s]
  } = t;
  s && Object.keys(s).forEach((n) => {
    Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[n],
      set: qe
    });
  });
}
function Jc(t) {
  const { ctx: e, setupState: s } = t;
  Object.keys(/* @__PURE__ */ de(s)).forEach((n) => {
    if (!s.__isScriptSetup) {
      if (io(n[0])) {
        V(
          `setup() return property ${JSON.stringify(
            n
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, n, {
        enumerable: !0,
        configurable: !0,
        get: () => s[n],
        set: qe
      });
    }
  });
}
function Wn(t) {
  return z(t) ? t.reduce(
    (e, s) => (e[s] = null, e),
    {}
  ) : t;
}
function oo(t, e) {
  return !t || !e ? t || e : z(t) && z(e) ? t.concat(e) : Ve({}, Wn(t), Wn(e));
}
function Qc() {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, s) => {
    t[s] ? V(`${e} property "${s}" is already defined in ${t[s]}.`) : t[s] = e;
  };
}
let Li = !0;
function Xc(t) {
  const e = Ra(t), s = t.proxy, n = t.ctx;
  Li = !1, e.beforeCreate && Wo(e.beforeCreate, t, "bc");
  const {
    // state
    data: i,
    computed: o,
    methods: r,
    watch: a,
    provide: l,
    inject: u,
    // lifecycle
    created: c,
    beforeMount: d,
    mounted: m,
    beforeUpdate: h,
    updated: b,
    activated: y,
    deactivated: E,
    beforeDestroy: _,
    beforeUnmount: S,
    destroyed: N,
    unmounted: R,
    render: P,
    renderTracked: H,
    renderTriggered: pe,
    errorCaptured: he,
    serverPrefetch: W,
    // public API
    expose: ae,
    inheritAttrs: me,
    // assets
    components: q,
    directives: K,
    filters: G
  } = e, ue = g.NODE_ENV !== "production" ? Qc() : null;
  if (g.NODE_ENV !== "production") {
    const [Y] = t.propsOptions;
    if (Y)
      for (const le in Y)
        ue("Props", le);
  }
  if (u && Zc(u, n, ue), r)
    for (const Y in r) {
      const le = r[Y];
      te(le) ? (g.NODE_ENV !== "production" ? Object.defineProperty(n, Y, {
        value: le.bind(s),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : n[Y] = le.bind(s), g.NODE_ENV !== "production" && ue("Methods", Y)) : g.NODE_ENV !== "production" && V(
        `Method "${Y}" has type "${typeof le}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (i) {
    g.NODE_ENV !== "production" && !te(i) && V(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const Y = i.call(s, s);
    if (g.NODE_ENV !== "production" && zi(Y) && V(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !be(Y))
      g.NODE_ENV !== "production" && V("data() should return an object.");
    else if (t.data = /* @__PURE__ */ Ns(Y), g.NODE_ENV !== "production")
      for (const le in Y)
        ue("Data", le), io(le[0]) || Object.defineProperty(n, le, {
          configurable: !0,
          enumerable: !0,
          get: () => Y[le],
          set: qe
        });
  }
  if (Li = !0, o)
    for (const Y in o) {
      const le = o[Y], X = te(le) ? le.bind(s, s) : te(le.get) ? le.get.bind(s, s) : qe;
      g.NODE_ENV !== "production" && X === qe && V(`Computed property "${Y}" has no getter.`);
      const I = !te(le) && te(le.set) ? le.set.bind(s) : g.NODE_ENV !== "production" ? () => {
        V(
          `Write operation failed: computed property "${Y}" is readonly.`
        );
      } : qe, Oe = ie({
        get: X,
        set: I
      });
      Object.defineProperty(n, Y, {
        enumerable: !0,
        configurable: !0,
        get: () => Oe.value,
        set: (He) => Oe.value = He
      }), g.NODE_ENV !== "production" && ue("Computed", Y);
    }
  if (a)
    for (const Y in a)
      Va(a[Y], n, s, Y);
  if (l) {
    const Y = te(l) ? l.call(s) : l;
    Reflect.ownKeys(Y).forEach((le) => {
      Dc(le, Y[le]);
    });
  }
  c && Wo(c, t, "c");
  function ve(Y, le) {
    z(le) ? le.forEach((X) => Y(X.bind(s))) : le && Y(le.bind(s));
  }
  if (ve(Uc, d), ve(ot, m), ve(Fc, h), ve(jc, b), ve(kc, y), ve(Pc, E), ve(Kc, he), ve(Hc, H), ve(Wc, pe), ve(jt, S), ve(hn, R), ve(qc, W), z(ae))
    if (ae.length) {
      const Y = t.exposed || (t.exposed = {});
      ae.forEach((le) => {
        Object.defineProperty(Y, le, {
          get: () => s[le],
          set: (X) => s[le] = X,
          enumerable: !0
        });
      });
    } else t.exposed || (t.exposed = {});
  P && t.render === qe && (t.render = P), me != null && (t.inheritAttrs = me), q && (t.components = q), K && (t.directives = K), W && Da(t);
}
function Zc(t, e, s = qe) {
  z(t) && (t = ki(t));
  for (const n in t) {
    const i = t[n];
    let o;
    be(i) ? "default" in i ? o = An(
      i.from || n,
      i.default,
      !0
    ) : o = An(i.from || n) : o = An(i), /* @__PURE__ */ Ue(o) ? Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (r) => o.value = r
    }) : e[n] = o, g.NODE_ENV !== "production" && s("Inject", n);
  }
}
function Wo(t, e, s) {
  wt(
    z(t) ? t.map((n) => n.bind(e.proxy)) : t.bind(e.proxy),
    e,
    s
  );
}
function Va(t, e, s, n) {
  let i = n.includes(".") ? ga(s, n) : () => s[n];
  if (Re(t)) {
    const o = e[t];
    te(o) ? lt(i, o) : g.NODE_ENV !== "production" && V(`Invalid watch handler specified by key "${t}"`, o);
  } else if (te(t))
    lt(i, t.bind(s));
  else if (be(t))
    if (z(t))
      t.forEach((o) => Va(o, e, s, n));
    else {
      const o = te(t.handler) ? t.handler.bind(s) : e[t.handler];
      te(o) ? lt(i, o, t) : g.NODE_ENV !== "production" && V(`Invalid watch handler specified by key "${t.handler}"`, o);
    }
  else g.NODE_ENV !== "production" && V(`Invalid watch option: "${n}"`, t);
}
function Ra(t) {
  const e = t.type, { mixins: s, extends: n } = e, {
    mixins: i,
    optionsCache: o,
    config: { optionMergeStrategies: r }
  } = t.appContext, a = o.get(e);
  let l;
  return a ? l = a : !i.length && !s && !n ? l = e : (l = {}, i.length && i.forEach(
    (u) => Hn(l, u, r, !0)
  ), Hn(l, e, r)), be(e) && o.set(e, l), l;
}
function Hn(t, e, s, n = !1) {
  const { mixins: i, extends: o } = e;
  o && Hn(t, o, s, !0), i && i.forEach(
    (r) => Hn(t, r, s, !0)
  );
  for (const r in e)
    if (n && r === "expose")
      g.NODE_ENV !== "production" && V(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const a = eu[r] || s && s[r];
      t[r] = a ? a(t[r], e[r]) : e[r];
    }
  return t;
}
const eu = {
  data: Ho,
  props: Ko,
  emits: Ko,
  // objects
  methods: Ks,
  computed: Ks,
  // lifecycle
  beforeCreate: Je,
  created: Je,
  beforeMount: Je,
  mounted: Je,
  beforeUpdate: Je,
  updated: Je,
  beforeDestroy: Je,
  beforeUnmount: Je,
  destroyed: Je,
  unmounted: Je,
  activated: Je,
  deactivated: Je,
  errorCaptured: Je,
  serverPrefetch: Je,
  // assets
  components: Ks,
  directives: Ks,
  // watch
  watch: su,
  // provide / inject
  provide: Ho,
  inject: tu
};
function Ho(t, e) {
  return e ? t ? function() {
    return Ve(
      te(t) ? t.call(this, this) : t,
      te(e) ? e.call(this, this) : e
    );
  } : e : t;
}
function tu(t, e) {
  return Ks(ki(t), ki(e));
}
function ki(t) {
  if (z(t)) {
    const e = {};
    for (let s = 0; s < t.length; s++)
      e[t[s]] = t[s];
    return e;
  }
  return t;
}
function Je(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function Ks(t, e) {
  return t ? Ve(/* @__PURE__ */ Object.create(null), t, e) : e;
}
function Ko(t, e) {
  return t ? z(t) && z(e) ? [.../* @__PURE__ */ new Set([...t, ...e])] : Ve(
    /* @__PURE__ */ Object.create(null),
    Wn(t),
    Wn(e ?? {})
  ) : e;
}
function su(t, e) {
  if (!t) return e;
  if (!e) return t;
  const s = Ve(/* @__PURE__ */ Object.create(null), t);
  for (const n in e)
    s[n] = Je(t[n], e[n]);
  return s;
}
function Ia() {
  return {
    app: null,
    config: {
      isNativeTag: kr,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let nu = 0;
function iu(t, e) {
  return function(n, i = null) {
    te(n) || (n = Ve({}, n)), i != null && !be(i) && (g.NODE_ENV !== "production" && V("root props passed to app.mount() must be an object."), i = null);
    const o = Ia(), r = /* @__PURE__ */ new WeakSet(), a = [];
    let l = !1;
    const u = o.app = {
      _uid: nu++,
      _component: n,
      _props: i,
      _container: null,
      _context: o,
      _instance: null,
      version: nr,
      get config() {
        return o.config;
      },
      set config(c) {
        g.NODE_ENV !== "production" && V(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(c, ...d) {
        return r.has(c) ? g.NODE_ENV !== "production" && V("Plugin has already been applied to target app.") : c && te(c.install) ? (r.add(c), c.install(u, ...d)) : te(c) ? (r.add(c), c(u, ...d)) : g.NODE_ENV !== "production" && V(
          'A plugin must either be a function or an object with an "install" function.'
        ), u;
      },
      mixin(c) {
        return o.mixins.includes(c) ? g.NODE_ENV !== "production" && V(
          "Mixin has already been applied to target app" + (c.name ? `: ${c.name}` : "")
        ) : o.mixins.push(c), u;
      },
      component(c, d) {
        return g.NODE_ENV !== "production" && ji(c, o.config), d ? (g.NODE_ENV !== "production" && o.components[c] && V(`Component "${c}" has already been registered in target app.`), o.components[c] = d, u) : o.components[c];
      },
      directive(c, d) {
        return g.NODE_ENV !== "production" && ba(c), d ? (g.NODE_ENV !== "production" && o.directives[c] && V(`Directive "${c}" has already been registered in target app.`), o.directives[c] = d, u) : o.directives[c];
      },
      mount(c, d, m) {
        if (l)
          g.NODE_ENV !== "production" && V(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          g.NODE_ENV !== "production" && c.__vue_app__ && V(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const h = u._ceVNode || w(n, i);
          return h.appContext = o, m === !0 ? m = "svg" : m === !1 && (m = void 0), g.NODE_ENV !== "production" && (o.reload = () => {
            const b = Ft(h);
            b.el = null, t(b, c, m);
          }), t(h, c, m), l = !0, u._container = c, c.__vue_app__ = u, g.NODE_ENV !== "production" && (u._instance = h.component, yc(u, nr)), ci(h.component);
        }
      },
      onUnmount(c) {
        g.NODE_ENV !== "production" && typeof c != "function" && V(
          `Expected function as first argument to app.onUnmount(), but got ${typeof c}`
        ), a.push(c);
      },
      unmount() {
        l ? (wt(
          a,
          u._instance,
          16
        ), t(null, u._container), g.NODE_ENV !== "production" && (u._instance = null, _c(u)), delete u._container.__vue_app__) : g.NODE_ENV !== "production" && V("Cannot unmount an app that is not mounted.");
      },
      provide(c, d) {
        return g.NODE_ENV !== "production" && c in o.provides && (Ee(o.provides, c) ? V(
          `App already provides property with key "${String(c)}". It will be overwritten with the new value.`
        ) : V(
          `App already provides property with key "${String(c)}" inherited from its parent element. It will be overwritten with the new value.`
        )), o.provides[c] = d, u;
      },
      runWithContext(c) {
        const d = As;
        As = u;
        try {
          return c();
        } finally {
          As = d;
        }
      }
    };
    return u;
  };
}
let As = null;
function ro(t, e, s = ye) {
  const n = li();
  if (g.NODE_ENV !== "production" && !n)
    return V("useModel() called without active instance."), /* @__PURE__ */ j();
  const i = ut(e);
  if (g.NODE_ENV !== "production" && !n.propsOptions[0][i])
    return V(`useModel() called with prop "${e}" which is not declared.`), /* @__PURE__ */ j();
  const o = Qt(e), r = Ma(t, i), a = nc((l, u) => {
    let c, d = ye, m;
    return Ac(() => {
      const h = t[i];
      nt(c, h) && (c = h, u());
    }), {
      get() {
        return l(), s.get ? s.get(c) : c;
      },
      set(h) {
        const b = s.set ? s.set(h) : h;
        if (!nt(b, c) && !(d !== ye && nt(h, d)))
          return;
        const y = n.vnode.props;
        y && // check if parent has passed v-model
        (e in y || i in y || o in y) && (`onUpdate:${e}` in y || `onUpdate:${i}` in y || `onUpdate:${o}` in y) || (c = h, u()), n.emit(`update:${e}`, b), nt(h, b) && nt(h, d) && !nt(b, m) && u(), d = h, m = b;
      }
    };
  });
  return a[Symbol.iterator] = () => {
    let l = 0;
    return {
      next() {
        return l < 2 ? { value: l++ ? r || ye : a, done: !1 } : { done: !0 };
      }
    };
  }, a;
}
const Ma = (t, e) => e === "modelValue" || e === "model-value" ? t.modelModifiers : t[`${e}Modifiers`] || t[`${ut(e)}Modifiers`] || t[`${Qt(e)}Modifiers`];
function ou(t, e, ...s) {
  if (t.isUnmounted) return;
  const n = t.vnode.props || ye;
  if (g.NODE_ENV !== "production") {
    const {
      emitsOptions: c,
      propsOptions: [d]
    } = t;
    if (c)
      if (!(e in c))
        (!d || !(ds(ut(e)) in d)) && V(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${ds(ut(e))}" prop.`
        );
      else {
        const m = c[e];
        te(m) && (m(...s) || V(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let i = s;
  const o = e.startsWith("update:"), r = o && Ma(n, e.slice(7));
  if (r && (r.trim && (i = s.map((c) => Re(c) ? c.trim() : c)), r.number && (i = s.map(ei))), g.NODE_ENV !== "production" && Cc(t, e, i), g.NODE_ENV !== "production") {
    const c = e.toLowerCase();
    c !== e && n[ds(c)] && V(
      `Event "${c}" is emitted in component ${bn(
        t,
        t.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Qt(
        e
      )}" instead of "${e}".`
    );
  }
  let a, l = n[a = ds(e)] || // also try camelCase event handler (#2249)
  n[a = ds(ut(e))];
  !l && o && (l = n[a = ds(Qt(e))]), l && wt(
    l,
    t,
    6,
    i
  );
  const u = n[a + "Once"];
  if (u) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[a])
      return;
    t.emitted[a] = !0, wt(
      u,
      t,
      6,
      i
    );
  }
}
const ru = /* @__PURE__ */ new WeakMap();
function La(t, e, s = !1) {
  const n = s ? ru : e.emitsCache, i = n.get(t);
  if (i !== void 0)
    return i;
  const o = t.emits;
  let r = {}, a = !1;
  if (!te(t)) {
    const l = (u) => {
      const c = La(u, e, !0);
      c && (a = !0, Ve(r, c));
    };
    !s && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l);
  }
  return !o && !a ? (be(t) && n.set(t, null), null) : (z(o) ? o.forEach((l) => r[l] = null) : Ve(r, o), be(t) && n.set(t, r), r);
}
function ai(t, e) {
  return !t || !ln(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Ee(t, e[0].toLowerCase() + e.slice(1)) || Ee(t, Qt(e)) || Ee(t, e));
}
let Pi = !1;
function Kn() {
  Pi = !0;
}
function zo(t) {
  const {
    type: e,
    vnode: s,
    proxy: n,
    withProxy: i,
    propsOptions: [o],
    slots: r,
    attrs: a,
    emit: l,
    render: u,
    renderCache: c,
    props: d,
    data: m,
    setupState: h,
    ctx: b,
    inheritAttrs: y
  } = t, E = jn(t);
  let _, S;
  g.NODE_ENV !== "production" && (Pi = !1);
  try {
    if (s.shapeFlag & 4) {
      const P = i || n, H = g.NODE_ENV !== "production" && h.__isScriptSetup ? new Proxy(P, {
        get(pe, he, W) {
          return V(
            `Property '${String(
              he
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(pe, he, W);
        }
      }) : P;
      _ = pt(
        u.call(
          H,
          P,
          c,
          g.NODE_ENV !== "production" ? /* @__PURE__ */ Lt(d) : d,
          h,
          m,
          b
        )
      ), S = a;
    } else {
      const P = e;
      g.NODE_ENV !== "production" && a === d && Kn(), _ = pt(
        P.length > 1 ? P(
          g.NODE_ENV !== "production" ? /* @__PURE__ */ Lt(d) : d,
          g.NODE_ENV !== "production" ? {
            get attrs() {
              return Kn(), /* @__PURE__ */ Lt(a);
            },
            slots: r,
            emit: l
          } : { attrs: a, slots: r, emit: l }
        ) : P(
          g.NODE_ENV !== "production" ? /* @__PURE__ */ Lt(d) : d,
          null
        )
      ), S = e.props ? a : au(a);
    }
  } catch (P) {
    Xs.length = 0, dn(P, t, 1), _ = w(Be);
  }
  let N = _, R;
  if (g.NODE_ENV !== "production" && _.patchFlag > 0 && _.patchFlag & 2048 && ([N, R] = ka(_)), S && y !== !1) {
    const P = Object.keys(S), { shapeFlag: H } = N;
    if (P.length) {
      if (H & 7)
        o && P.some(Ln) && (S = lu(
          S,
          o
        )), N = Ft(N, S, !1, !0);
      else if (g.NODE_ENV !== "production" && !Pi && N.type !== Be) {
        const pe = Object.keys(a), he = [], W = [];
        for (let ae = 0, me = pe.length; ae < me; ae++) {
          const q = pe[ae];
          ln(q) ? Ln(q) || he.push(q[2].toLowerCase() + q.slice(3)) : W.push(q);
        }
        W.length && V(
          `Extraneous non-props attributes (${W.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
        ), he.length && V(
          `Extraneous non-emits event listeners (${he.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return s.dirs && (g.NODE_ENV !== "production" && !Go(N) && V(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), N = Ft(N, null, !1, !0), N.dirs = N.dirs ? N.dirs.concat(s.dirs) : s.dirs), s.transition && (g.NODE_ENV !== "production" && !Go(N) && V(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), nn(N, s.transition)), g.NODE_ENV !== "production" && R ? R(N) : _ = N, jn(E), _;
}
const ka = (t) => {
  const e = t.children, s = t.dynamicChildren, n = ao(e, !1);
  if (n) {
    if (g.NODE_ENV !== "production" && n.patchFlag > 0 && n.patchFlag & 2048)
      return ka(n);
  } else return [t, void 0];
  const i = e.indexOf(n), o = s ? s.indexOf(n) : -1, r = (a) => {
    e[i] = a, s && (o > -1 ? s[o] = a : a.patchFlag > 0 && (t.dynamicChildren = [...s, a]));
  };
  return [pt(n), r];
};
function ao(t, e = !0) {
  let s;
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    if (_s(i)) {
      if (i.type !== Be || i.children === "v-if") {
        if (s)
          return;
        if (s = i, g.NODE_ENV !== "production" && e && s.patchFlag > 0 && s.patchFlag & 2048)
          return ao(s.children);
      }
    } else
      return;
  }
  return s;
}
const au = (t) => {
  let e;
  for (const s in t)
    (s === "class" || s === "style" || ln(s)) && ((e || (e = {}))[s] = t[s]);
  return e;
}, lu = (t, e) => {
  const s = {};
  for (const n in t)
    (!Ln(n) || !(n.slice(9) in e)) && (s[n] = t[n]);
  return s;
}, Go = (t) => t.shapeFlag & 7 || t.type === Be;
function cu(t, e, s) {
  const { props: n, children: i, component: o } = t, { props: r, children: a, patchFlag: l } = e, u = o.emitsOptions;
  if (g.NODE_ENV !== "production" && (i || a) && ht || e.dirs || e.transition)
    return !0;
  if (s && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return n ? Yo(n, r, u) : !!r;
    if (l & 8) {
      const c = e.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        const m = c[d];
        if (Pa(r, n, m) && !ai(u, m))
          return !0;
      }
    }
  } else
    return (i || a) && (!a || !a.$stable) ? !0 : n === r ? !1 : n ? r ? Yo(n, r, u) : !0 : !!r;
  return !1;
}
function Yo(t, e, s) {
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !0;
  for (let i = 0; i < n.length; i++) {
    const o = n[i];
    if (Pa(e, t, o) && !ai(s, o))
      return !0;
  }
  return !1;
}
function Pa(t, e, s) {
  const n = t[s], i = e[s];
  return s === "style" && be(n) && be(i) ? !os(n, i) : n !== i;
}
function uu({ vnode: t, parent: e }, s) {
  for (; e; ) {
    const n = e.subTree;
    if (n.suspense && n.suspense.activeBranch === t && (n.el = t.el), n === t)
      (t = e.vnode).el = s, e = e.parent;
    else
      break;
  }
}
const Ba = {}, Ua = () => Object.create(Ba), Fa = (t) => Object.getPrototypeOf(t) === Ba;
function du(t, e, s, n = !1) {
  const i = {}, o = Ua();
  t.propsDefaults = /* @__PURE__ */ Object.create(null), ja(t, e, i, o);
  for (const r in t.propsOptions[0])
    r in i || (i[r] = void 0);
  g.NODE_ENV !== "production" && Wa(e || {}, i, t), s ? t.props = n ? i : /* @__PURE__ */ Ql(i) : t.type.props ? t.props = i : t.props = o, t.attrs = o;
}
function fu(t) {
  for (; t; ) {
    if (t.type.__hmrId) return !0;
    t = t.parent;
  }
}
function pu(t, e, s, n) {
  const {
    props: i,
    attrs: o,
    vnode: { patchFlag: r }
  } = t, a = /* @__PURE__ */ de(i), [l] = t.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(g.NODE_ENV !== "production" && fu(t)) && (n || r > 0) && !(r & 16)
  ) {
    if (r & 8) {
      const c = t.vnode.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        let m = c[d];
        if (ai(t.emitsOptions, m))
          continue;
        const h = e[m];
        if (l)
          if (Ee(o, m))
            h !== o[m] && (o[m] = h, u = !0);
          else {
            const b = ut(m);
            i[b] = Bi(
              l,
              a,
              b,
              h,
              t,
              !1
            );
          }
        else
          h !== o[m] && (o[m] = h, u = !0);
      }
    }
  } else {
    ja(t, e, i, o) && (u = !0);
    let c;
    for (const d in a)
      (!e || // for camelCase
      !Ee(e, d) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((c = Qt(d)) === d || !Ee(e, c))) && (l ? s && // for camelCase
      (s[d] !== void 0 || // for kebab-case
      s[c] !== void 0) && (i[d] = Bi(
        l,
        a,
        d,
        void 0,
        t,
        !0
      )) : delete i[d]);
    if (o !== a)
      for (const d in o)
        (!e || !Ee(e, d)) && (delete o[d], u = !0);
  }
  u && It(t.attrs, "set", ""), g.NODE_ENV !== "production" && Wa(e || {}, i, t);
}
function ja(t, e, s, n) {
  const [i, o] = t.propsOptions;
  let r = !1, a;
  if (e)
    for (let l in e) {
      if (zs(l))
        continue;
      const u = e[l];
      let c;
      i && Ee(i, c = ut(l)) ? !o || !o.includes(c) ? s[c] = u : (a || (a = {}))[c] = u : ai(t.emitsOptions, l) || (!(l in n) || u !== n[l]) && (n[l] = u, r = !0);
    }
  if (o) {
    const l = /* @__PURE__ */ de(s), u = a || ye;
    for (let c = 0; c < o.length; c++) {
      const d = o[c];
      s[d] = Bi(
        i,
        l,
        d,
        u[d],
        t,
        !Ee(u, d)
      );
    }
  }
  return r;
}
function Bi(t, e, s, n, i, o) {
  const r = t[s];
  if (r != null) {
    const a = Ee(r, "default");
    if (a && n === void 0) {
      const l = r.default;
      if (r.type !== Function && !r.skipFactory && te(l)) {
        const { propsDefaults: u } = i;
        if (s in u)
          n = u[s];
        else {
          const c = vn(i);
          n = u[s] = l.call(
            null,
            e
          ), c();
        }
      } else
        n = l;
      i.ce && i.ce._setProp(s, n);
    }
    r[
      0
      /* shouldCast */
    ] && (o && !a ? n = !1 : r[
      1
      /* shouldCastTrue */
    ] && (n === "" || n === Qt(s)) && (n = !0));
  }
  return n;
}
const hu = /* @__PURE__ */ new WeakMap();
function qa(t, e, s = !1) {
  const n = s ? hu : e.propsCache, i = n.get(t);
  if (i)
    return i;
  const o = t.props, r = {}, a = [];
  let l = !1;
  if (!te(t)) {
    const c = (d) => {
      l = !0;
      const [m, h] = qa(d, e, !0);
      Ve(r, m), h && a.push(...h);
    };
    !s && e.mixins.length && e.mixins.forEach(c), t.extends && c(t.extends), t.mixins && t.mixins.forEach(c);
  }
  if (!o && !l)
    return be(t) && n.set(t, Ds), Ds;
  if (z(o))
    for (let c = 0; c < o.length; c++) {
      g.NODE_ENV !== "production" && !Re(o[c]) && V("props must be strings when using array syntax.", o[c]);
      const d = ut(o[c]);
      Jo(d) && (r[d] = ye);
    }
  else if (o) {
    g.NODE_ENV !== "production" && !be(o) && V("invalid props options", o);
    for (const c in o) {
      const d = ut(c);
      if (Jo(d)) {
        const m = o[c], h = r[d] = z(m) || te(m) ? { type: m } : Ve({}, m), b = h.type;
        let y = !1, E = !0;
        if (z(b))
          for (let _ = 0; _ < b.length; ++_) {
            const S = b[_], N = te(S) && S.name;
            if (N === "Boolean") {
              y = !0;
              break;
            } else N === "String" && (E = !1);
          }
        else
          y = te(b) && b.name === "Boolean";
        h[
          0
          /* shouldCast */
        ] = y, h[
          1
          /* shouldCastTrue */
        ] = E, (y || Ee(h, "default")) && a.push(d);
      }
    }
  }
  const u = [r, a];
  return be(t) && n.set(t, u), u;
}
function Jo(t) {
  return t[0] !== "$" && !zs(t) ? !0 : (g.NODE_ENV !== "production" && V(`Invalid prop name: "${t}" is a reserved property.`), !1);
}
function mu(t) {
  return t === null ? "null" : typeof t == "function" ? t.name || "" : typeof t == "object" && t.constructor && t.constructor.name || "";
}
function Wa(t, e, s) {
  const n = /* @__PURE__ */ de(e), i = s.propsOptions[0], o = Object.keys(t).map((r) => ut(r));
  for (const r in i) {
    let a = i[r];
    a != null && vu(
      r,
      n[r],
      a,
      g.NODE_ENV !== "production" ? /* @__PURE__ */ Lt(n) : n,
      !o.includes(r)
    );
  }
}
function vu(t, e, s, n, i) {
  const { type: o, required: r, validator: a, skipCheck: l } = s;
  if (r && i) {
    V('Missing required prop: "' + t + '"');
    return;
  }
  if (!(e == null && !r)) {
    if (o != null && o !== !0 && !l) {
      let u = !1;
      const c = z(o) ? o : [o], d = [];
      for (let m = 0; m < c.length && !u; m++) {
        const { valid: h, expectedType: b } = gu(e, c[m]);
        d.push(b || ""), u = h;
      }
      if (!u) {
        V(Eu(t, e, d));
        return;
      }
    }
    a && !a(e, n) && V('Invalid prop: custom validator check failed for prop "' + t + '".');
  }
}
const bu = /* @__PURE__ */ Xt(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function gu(t, e) {
  let s;
  const n = mu(e);
  if (n === "null")
    s = t === null;
  else if (bu(n)) {
    const i = typeof t;
    s = i === n.toLowerCase(), !s && i === "object" && (s = t instanceof e);
  } else n === "Object" ? s = be(t) : n === "Array" ? s = z(t) : s = t instanceof e;
  return {
    valid: s,
    expectedType: n
  };
}
function Eu(t, e, s) {
  if (s.length === 0)
    return `Prop type [] for prop "${t}" won't match anything. Did you mean to use type Array instead?`;
  let n = `Invalid prop: type check failed for prop "${t}". Expected ${s.map(Zn).join(" | ")}`;
  const i = s[0], o = Gi(e), r = Qo(e, i), a = Qo(e, o);
  return s.length === 1 && Xo(i) && !yu(i, o) && (n += ` with value ${r}`), n += `, got ${o} `, Xo(o) && (n += `with value ${a}.`), n;
}
function Qo(t, e) {
  return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`;
}
function Xo(t) {
  return ["string", "number", "boolean"].some((s) => t.toLowerCase() === s);
}
function yu(...t) {
  return t.some((e) => e.toLowerCase() === "boolean");
}
const lo = (t) => t === "_" || t === "_ctx" || t === "$stable", co = (t) => z(t) ? t.map(pt) : [pt(t)], _u = (t, e, s) => {
  if (e._n)
    return e;
  const n = k((...i) => (g.NODE_ENV !== "production" && Fe && !(s === null && We) && !(s && s.root !== Fe.root) && V(
    `Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), co(e(...i))), s);
  return n._c = !1, n;
}, Ha = (t, e, s) => {
  const n = t._ctx;
  for (const i in t) {
    if (lo(i)) continue;
    const o = t[i];
    if (te(o))
      e[i] = _u(i, o, n);
    else if (o != null) {
      g.NODE_ENV !== "production" && V(
        `Non-function value encountered for slot "${i}". Prefer function slots for better performance.`
      );
      const r = co(o);
      e[i] = () => r;
    }
  }
}, Ka = (t, e) => {
  g.NODE_ENV !== "production" && !pn(t.vnode) && V(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const s = co(e);
  t.slots.default = () => s;
}, Ui = (t, e, s) => {
  for (const n in e)
    (s || !lo(n)) && (t[n] = e[n]);
}, Nu = (t, e, s) => {
  const n = t.slots = Ua();
  if (t.vnode.shapeFlag & 32) {
    const i = e._;
    i ? (Ui(n, e, s), s && kn(n, "_", i, !0)) : Ha(e, n);
  } else e && Ka(t, e);
}, Tu = (t, e, s) => {
  const { vnode: n, slots: i } = t;
  let o = !0, r = ye;
  if (n.shapeFlag & 32) {
    const a = e._;
    a ? g.NODE_ENV !== "production" && ht ? (Ui(i, e, s), It(t, "set", "$slots")) : s && a === 1 ? o = !1 : Ui(i, e, s) : (o = !e.$stable, Ha(e, i)), r = e;
  } else e && (Ka(t, e), r = { default: 1 });
  if (o)
    for (const a in i)
      !lo(a) && r[a] == null && delete i[a];
};
let qs, Kt;
function xs(t, e) {
  t.appContext.config.performance && zn() && Kt.mark(`vue-${e}-${t.uid}`), g.NODE_ENV !== "production" && wc(t, e, zn() ? Kt.now() : Date.now());
}
function ws(t, e) {
  if (t.appContext.config.performance && zn()) {
    const s = `vue-${e}-${t.uid}`, n = s + ":end", i = `<${bn(t, t.type)}> ${e}`;
    Kt.mark(n), Kt.measure(i, s, n), Kt.clearMeasures(i), Kt.clearMarks(s), Kt.clearMarks(n);
  }
  g.NODE_ENV !== "production" && Sc(t, e, zn() ? Kt.now() : Date.now());
}
function zn() {
  return qs !== void 0 || (typeof window < "u" && window.performance ? (qs = !0, Kt = window.performance) : qs = !1), qs;
}
function xu() {
  const t = [];
  if (g.NODE_ENV !== "production" && t.length) {
    const e = t.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${t.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const ze = Ou;
function wu(t) {
  return Su(t);
}
function Su(t, e) {
  xu();
  const s = un();
  s.__VUE__ = !0, g.NODE_ENV !== "production" && pa(s.__VUE_DEVTOOLS_GLOBAL_HOOK__, s);
  const {
    insert: n,
    remove: i,
    patchProp: o,
    createElement: r,
    createText: a,
    createComment: l,
    setText: u,
    setElementText: c,
    parentNode: d,
    nextSibling: m,
    setScopeId: h = qe,
    insertStaticContent: b
  } = t, y = (p, v, T, A = null, C = null, D = null, U = void 0, B = null, L = g.NODE_ENV !== "production" && ht ? !1 : !!v.dynamicChildren) => {
    if (p === v)
      return;
    p && !hs(p, v) && (A = En(p), ft(p, C, D, !0), p = null), v.patchFlag === -2 && (L = !1, v.dynamicChildren = null);
    const { type: O, ref: ee, shapeFlag: F } = v;
    switch (O) {
      case mn:
        E(p, v, T, A);
        break;
      case Be:
        _(p, v, T, A);
        break;
      case Rn:
        p == null ? S(v, T, A, U) : g.NODE_ENV !== "production" && N(p, v, T, U);
        break;
      case Ae:
        K(
          p,
          v,
          T,
          A,
          C,
          D,
          U,
          B,
          L
        );
        break;
      default:
        F & 1 ? H(
          p,
          v,
          T,
          A,
          C,
          D,
          U,
          B,
          L
        ) : F & 6 ? G(
          p,
          v,
          T,
          A,
          C,
          D,
          U,
          B,
          L
        ) : F & 64 || F & 128 ? O.process(
          p,
          v,
          T,
          A,
          C,
          D,
          U,
          B,
          L,
          Bs
        ) : g.NODE_ENV !== "production" && V("Invalid VNode type:", O, `(${typeof O})`);
    }
    ee != null && C ? Js(ee, p && p.ref, D, v || p, !v) : ee == null && p && p.ref != null && Js(p.ref, null, D, p, !0);
  }, E = (p, v, T, A) => {
    if (p == null)
      n(
        v.el = a(v.children),
        T,
        A
      );
    else {
      const C = v.el = p.el;
      v.children !== p.children && u(C, v.children);
    }
  }, _ = (p, v, T, A) => {
    p == null ? n(
      v.el = l(v.children || ""),
      T,
      A
    ) : v.el = p.el;
  }, S = (p, v, T, A) => {
    [p.el, p.anchor] = b(
      p.children,
      v,
      T,
      A,
      p.el,
      p.anchor
    );
  }, N = (p, v, T, A) => {
    if (v.children !== p.children) {
      const C = m(p.anchor);
      P(p), [v.el, v.anchor] = b(
        v.children,
        T,
        C,
        A
      );
    } else
      v.el = p.el, v.anchor = p.anchor;
  }, R = ({ el: p, anchor: v }, T, A) => {
    let C;
    for (; p && p !== v; )
      C = m(p), n(p, T, A), p = C;
    n(v, T, A);
  }, P = ({ el: p, anchor: v }) => {
    let T;
    for (; p && p !== v; )
      T = m(p), i(p), p = T;
    i(v);
  }, H = (p, v, T, A, C, D, U, B, L) => {
    if (v.type === "svg" ? U = "svg" : v.type === "math" && (U = "mathml"), p == null)
      pe(
        v,
        T,
        A,
        C,
        D,
        U,
        B,
        L
      );
    else {
      const O = p.el && p.el._isVueCE ? p.el : null;
      try {
        O && O._beginPatch(), ae(
          p,
          v,
          C,
          D,
          U,
          B,
          L
        );
      } finally {
        O && O._endPatch();
      }
    }
  }, pe = (p, v, T, A, C, D, U, B) => {
    let L, O;
    const { props: ee, shapeFlag: F, transition: J, dirs: re } = p;
    if (L = p.el = r(
      p.type,
      D,
      ee && ee.is,
      ee
    ), F & 8 ? c(L, p.children) : F & 16 && W(
      p.children,
      L,
      null,
      A,
      C,
      Ni(p, D),
      U,
      B
    ), re && as(p, null, A, "created"), he(L, p, p.scopeId, U, A), ee) {
      for (const Ce in ee)
        Ce !== "value" && !zs(Ce) && o(L, Ce, null, ee[Ce], D, A);
      "value" in ee && o(L, "value", null, ee.value, D), (O = ee.onVnodeBeforeMount) && $t(O, A, p);
    }
    g.NODE_ENV !== "production" && (kn(L, "__vnode", p, !0), kn(L, "__vueParentComponent", A, !0)), re && as(p, null, A, "beforeMount");
    const ge = Cu(C, J);
    ge && J.beforeEnter(L), n(L, v, T), ((O = ee && ee.onVnodeMounted) || ge || re) && ze(() => {
      O && $t(O, A, p), ge && J.enter(L), re && as(p, null, A, "mounted");
    }, C);
  }, he = (p, v, T, A, C) => {
    if (T && h(p, T), A)
      for (let D = 0; D < A.length; D++)
        h(p, A[D]);
    if (C) {
      let D = C.subTree;
      if (g.NODE_ENV !== "production" && D.patchFlag > 0 && D.patchFlag & 2048 && (D = ao(D.children) || D), v === D || Ya(D.type) && (D.ssContent === v || D.ssFallback === v)) {
        const U = C.vnode;
        he(
          p,
          U,
          U.scopeId,
          U.slotScopeIds,
          C.parent
        );
      }
    }
  }, W = (p, v, T, A, C, D, U, B, L = 0) => {
    for (let O = L; O < p.length; O++) {
      const ee = p[O] = B ? zt(p[O]) : pt(p[O]);
      y(
        null,
        ee,
        v,
        T,
        A,
        C,
        D,
        U,
        B
      );
    }
  }, ae = (p, v, T, A, C, D, U) => {
    const B = v.el = p.el;
    g.NODE_ENV !== "production" && (B.__vnode = v);
    let { patchFlag: L, dynamicChildren: O, dirs: ee } = v;
    L |= p.patchFlag & 16;
    const F = p.props || ye, J = v.props || ye;
    let re;
    if (T && ls(T, !1), (re = J.onVnodeBeforeUpdate) && $t(re, T, v, p), ee && as(v, p, T, "beforeUpdate"), T && ls(T, !0), g.NODE_ENV !== "production" && ht && (L = 0, U = !1, O = null), (F.innerHTML && J.innerHTML == null || F.textContent && J.textContent == null) && c(B, ""), O ? (me(
      p.dynamicChildren,
      O,
      B,
      T,
      A,
      Ni(v, C),
      D
    ), g.NODE_ENV !== "production" && Qs(p, v)) : U || X(
      p,
      v,
      B,
      null,
      T,
      A,
      Ni(v, C),
      D,
      !1
    ), L > 0) {
      if (L & 16)
        q(B, F, J, T, C);
      else if (L & 2 && F.class !== J.class && o(B, "class", null, J.class, C), L & 4 && o(B, "style", F.style, J.style, C), L & 8) {
        const ge = v.dynamicProps;
        for (let Ce = 0; Ce < ge.length; Ce++) {
          const Te = ge[Ce], Ze = F[Te], et = J[Te];
          (et !== Ze || Te === "value") && o(B, Te, Ze, et, C, T);
        }
      }
      L & 1 && p.children !== v.children && c(B, v.children);
    } else !U && O == null && q(B, F, J, T, C);
    ((re = J.onVnodeUpdated) || ee) && ze(() => {
      re && $t(re, T, v, p), ee && as(v, p, T, "updated");
    }, A);
  }, me = (p, v, T, A, C, D, U) => {
    for (let B = 0; B < v.length; B++) {
      const L = p[B], O = v[B], ee = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        L.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (L.type === Ae || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !hs(L, O) || // - In the case of a component, it could contain anything.
        L.shapeFlag & 198) ? d(L.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          T
        )
      );
      y(
        L,
        O,
        ee,
        null,
        A,
        C,
        D,
        U,
        !0
      );
    }
  }, q = (p, v, T, A, C) => {
    if (v !== T) {
      if (v !== ye)
        for (const D in v)
          !zs(D) && !(D in T) && o(
            p,
            D,
            v[D],
            null,
            C,
            A
          );
      for (const D in T) {
        if (zs(D)) continue;
        const U = T[D], B = v[D];
        U !== B && D !== "value" && o(p, D, B, U, C, A);
      }
      "value" in T && o(p, "value", v.value, T.value, C);
    }
  }, K = (p, v, T, A, C, D, U, B, L) => {
    const O = v.el = p ? p.el : a(""), ee = v.anchor = p ? p.anchor : a("");
    let { patchFlag: F, dynamicChildren: J, slotScopeIds: re } = v;
    g.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (ht || F & 2048) && (F = 0, L = !1, J = null), re && (B = B ? B.concat(re) : re), p == null ? (n(O, T, A), n(ee, T, A), W(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      v.children || [],
      T,
      ee,
      C,
      D,
      U,
      B,
      L
    )) : F > 0 && F & 64 && J && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    p.dynamicChildren && p.dynamicChildren.length === J.length ? (me(
      p.dynamicChildren,
      J,
      T,
      C,
      D,
      U,
      B
    ), g.NODE_ENV !== "production" ? Qs(p, v) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (v.key != null || C && v === C.subTree) && Qs(
        p,
        v,
        !0
        /* shallow */
      )
    )) : X(
      p,
      v,
      T,
      ee,
      C,
      D,
      U,
      B,
      L
    );
  }, G = (p, v, T, A, C, D, U, B, L) => {
    v.slotScopeIds = B, p == null ? v.shapeFlag & 512 ? C.ctx.activate(
      v,
      T,
      A,
      U,
      L
    ) : ue(
      v,
      T,
      A,
      C,
      D,
      U,
      L
    ) : ve(p, v, L);
  }, ue = (p, v, T, A, C, D, U) => {
    const B = p.component = Lu(
      p,
      A,
      C
    );
    if (g.NODE_ENV !== "production" && B.type.__hmrId && vc(B), g.NODE_ENV !== "production" && (Dn(p), xs(B, "mount")), pn(p) && (B.ctx.renderer = Bs), g.NODE_ENV !== "production" && xs(B, "init"), Pu(B, !1, U), g.NODE_ENV !== "production" && ws(B, "init"), g.NODE_ENV !== "production" && ht && (p.el = null), B.asyncDep) {
      if (C && C.registerDep(B, Y, U), !p.el) {
        const L = B.subTree = w(Be);
        _(null, L, v, T), p.placeholder = L.el;
      }
    } else
      Y(
        B,
        p,
        v,
        T,
        C,
        D,
        U
      );
    g.NODE_ENV !== "production" && (On(), ws(B, "mount"));
  }, ve = (p, v, T) => {
    const A = v.component = p.component;
    if (cu(p, v, T))
      if (A.asyncDep && !A.asyncResolved) {
        g.NODE_ENV !== "production" && Dn(v), le(A, v, T), g.NODE_ENV !== "production" && On();
        return;
      } else
        A.next = v, A.update();
    else
      v.el = p.el, A.vnode = v;
  }, Y = (p, v, T, A, C, D, U) => {
    const B = () => {
      if (p.isMounted) {
        let { next: F, bu: J, u: re, parent: ge, vnode: Ce } = p;
        {
          const Dt = za(p);
          if (Dt) {
            F && (F.el = Ce.el, le(p, F, U)), Dt.asyncDep.then(() => {
              ze(() => {
                p.isUnmounted || O();
              }, C);
            });
            return;
          }
        }
        let Te = F, Ze;
        g.NODE_ENV !== "production" && Dn(F || p.vnode), ls(p, !1), F ? (F.el = Ce.el, le(p, F, U)) : F = Ce, J && Ss(J), (Ze = F.props && F.props.onVnodeBeforeUpdate) && $t(Ze, ge, F, Ce), ls(p, !0), g.NODE_ENV !== "production" && xs(p, "render");
        const et = zo(p);
        g.NODE_ENV !== "production" && ws(p, "render");
        const Ct = p.subTree;
        p.subTree = et, g.NODE_ENV !== "production" && xs(p, "patch"), y(
          Ct,
          et,
          // parent may have changed if it's in a teleport
          d(Ct.el),
          // anchor may have changed if it's in a fragment
          En(Ct),
          p,
          C,
          D
        ), g.NODE_ENV !== "production" && ws(p, "patch"), F.el = et.el, Te === null && uu(p, et.el), re && ze(re, C), (Ze = F.props && F.props.onVnodeUpdated) && ze(
          () => $t(Ze, ge, F, Ce),
          C
        ), g.NODE_ENV !== "production" && ha(p), g.NODE_ENV !== "production" && On();
      } else {
        let F;
        const { el: J, props: re } = v, { bm: ge, m: Ce, parent: Te, root: Ze, type: et } = p, Ct = $s(v);
        ls(p, !1), ge && Ss(ge), !Ct && (F = re && re.onVnodeBeforeMount) && $t(F, Te, v), ls(p, !0);
        {
          Ze.ce && Ze.ce._hasShadowRoot() && Ze.ce._injectChildStyle(et), g.NODE_ENV !== "production" && xs(p, "render");
          const Dt = p.subTree = zo(p);
          g.NODE_ENV !== "production" && ws(p, "render"), g.NODE_ENV !== "production" && xs(p, "patch"), y(
            null,
            Dt,
            T,
            A,
            p,
            C,
            D
          ), g.NODE_ENV !== "production" && ws(p, "patch"), v.el = Dt.el;
        }
        if (Ce && ze(Ce, C), !Ct && (F = re && re.onVnodeMounted)) {
          const Dt = v;
          ze(
            () => $t(F, Te, Dt),
            C
          );
        }
        (v.shapeFlag & 256 || Te && $s(Te.vnode) && Te.vnode.shapeFlag & 256) && p.a && ze(p.a, C), p.isMounted = !0, g.NODE_ENV !== "production" && Nc(p), v = T = A = null;
      }
    };
    p.scope.on();
    const L = p.effect = new qr(B);
    p.scope.off();
    const O = p.update = L.run.bind(L), ee = p.job = L.runIfDirty.bind(L);
    ee.i = p, ee.id = p.uid, L.scheduler = () => oi(ee), ls(p, !0), g.NODE_ENV !== "production" && (L.onTrack = p.rtc ? (F) => Ss(p.rtc, F) : void 0, L.onTrigger = p.rtg ? (F) => Ss(p.rtg, F) : void 0), O();
  }, le = (p, v, T) => {
    v.component = p;
    const A = p.vnode.props;
    p.vnode = v, p.next = null, pu(p, v.props, A, T), Tu(p, v.children, T), _t(), Mo(p), Nt();
  }, X = (p, v, T, A, C, D, U, B, L = !1) => {
    const O = p && p.children, ee = p ? p.shapeFlag : 0, F = v.children, { patchFlag: J, shapeFlag: re } = v;
    if (J > 0) {
      if (J & 128) {
        Oe(
          O,
          F,
          T,
          A,
          C,
          D,
          U,
          B,
          L
        );
        return;
      } else if (J & 256) {
        I(
          O,
          F,
          T,
          A,
          C,
          D,
          U,
          B,
          L
        );
        return;
      }
    }
    re & 8 ? (ee & 16 && Ps(O, C, D), F !== O && c(T, F)) : ee & 16 ? re & 16 ? Oe(
      O,
      F,
      T,
      A,
      C,
      D,
      U,
      B,
      L
    ) : Ps(O, C, D, !0) : (ee & 8 && c(T, ""), re & 16 && W(
      F,
      T,
      A,
      C,
      D,
      U,
      B,
      L
    ));
  }, I = (p, v, T, A, C, D, U, B, L) => {
    p = p || Ds, v = v || Ds;
    const O = p.length, ee = v.length, F = Math.min(O, ee);
    let J;
    for (J = 0; J < F; J++) {
      const re = v[J] = L ? zt(v[J]) : pt(v[J]);
      y(
        p[J],
        re,
        T,
        null,
        C,
        D,
        U,
        B,
        L
      );
    }
    O > ee ? Ps(
      p,
      C,
      D,
      !0,
      !1,
      F
    ) : W(
      v,
      T,
      A,
      C,
      D,
      U,
      B,
      L,
      F
    );
  }, Oe = (p, v, T, A, C, D, U, B, L) => {
    let O = 0;
    const ee = v.length;
    let F = p.length - 1, J = ee - 1;
    for (; O <= F && O <= J; ) {
      const re = p[O], ge = v[O] = L ? zt(v[O]) : pt(v[O]);
      if (hs(re, ge))
        y(
          re,
          ge,
          T,
          null,
          C,
          D,
          U,
          B,
          L
        );
      else
        break;
      O++;
    }
    for (; O <= F && O <= J; ) {
      const re = p[F], ge = v[J] = L ? zt(v[J]) : pt(v[J]);
      if (hs(re, ge))
        y(
          re,
          ge,
          T,
          null,
          C,
          D,
          U,
          B,
          L
        );
      else
        break;
      F--, J--;
    }
    if (O > F) {
      if (O <= J) {
        const re = J + 1, ge = re < ee ? v[re].el : A;
        for (; O <= J; )
          y(
            null,
            v[O] = L ? zt(v[O]) : pt(v[O]),
            T,
            ge,
            C,
            D,
            U,
            B,
            L
          ), O++;
      }
    } else if (O > J)
      for (; O <= F; )
        ft(p[O], C, D, !0), O++;
    else {
      const re = O, ge = O, Ce = /* @__PURE__ */ new Map();
      for (O = ge; O <= J; O++) {
        const Ye = v[O] = L ? zt(v[O]) : pt(v[O]);
        Ye.key != null && (g.NODE_ENV !== "production" && Ce.has(Ye.key) && V(
          "Duplicate keys found during update:",
          JSON.stringify(Ye.key),
          "Make sure keys are unique."
        ), Ce.set(Ye.key, O));
      }
      let Te, Ze = 0;
      const et = J - ge + 1;
      let Ct = !1, Dt = 0;
      const Us = new Array(et);
      for (O = 0; O < et; O++) Us[O] = 0;
      for (O = re; O <= F; O++) {
        const Ye = p[O];
        if (Ze >= et) {
          ft(Ye, C, D, !0);
          continue;
        }
        let Ot;
        if (Ye.key != null)
          Ot = Ce.get(Ye.key);
        else
          for (Te = ge; Te <= J; Te++)
            if (Us[Te - ge] === 0 && hs(Ye, v[Te])) {
              Ot = Te;
              break;
            }
        Ot === void 0 ? ft(Ye, C, D, !0) : (Us[Ot - ge] = O + 1, Ot >= Dt ? Dt = Ot : Ct = !0, y(
          Ye,
          v[Ot],
          T,
          null,
          C,
          D,
          U,
          B,
          L
        ), Ze++);
      }
      const Co = Ct ? Du(Us) : Ds;
      for (Te = Co.length - 1, O = et - 1; O >= 0; O--) {
        const Ye = ge + O, Ot = v[Ye], Do = v[Ye + 1], Oo = Ye + 1 < ee ? (
          // #13559, #14173 fallback to el placeholder for unresolved async component
          Do.el || Ga(Do)
        ) : A;
        Us[O] === 0 ? y(
          null,
          Ot,
          T,
          Oo,
          C,
          D,
          U,
          B,
          L
        ) : Ct && (Te < 0 || O !== Co[Te] ? He(Ot, T, Oo, 2) : Te--);
      }
    }
  }, He = (p, v, T, A, C = null) => {
    const { el: D, type: U, transition: B, children: L, shapeFlag: O } = p;
    if (O & 6) {
      He(p.component.subTree, v, T, A);
      return;
    }
    if (O & 128) {
      p.suspense.move(v, T, A);
      return;
    }
    if (O & 64) {
      U.move(p, v, T, Bs);
      return;
    }
    if (U === Ae) {
      n(D, v, T);
      for (let F = 0; F < L.length; F++)
        He(L[F], v, T, A);
      n(p.anchor, v, T);
      return;
    }
    if (U === Rn) {
      R(p, v, T);
      return;
    }
    if (A !== 2 && O & 1 && B)
      if (A === 0)
        B.beforeEnter(D), n(D, v, T), ze(() => B.enter(D), C);
      else {
        const { leave: F, delayLeave: J, afterLeave: re } = B, ge = () => {
          p.ctx.isUnmounted ? i(D) : n(D, v, T);
        }, Ce = () => {
          D._isLeaving && D[Rt](
            !0
            /* cancelled */
          ), F(D, () => {
            ge(), re && re();
          });
        };
        J ? J(D, ge, Ce) : Ce();
      }
    else
      n(D, v, T);
  }, ft = (p, v, T, A = !1, C = !1) => {
    const {
      type: D,
      props: U,
      ref: B,
      children: L,
      dynamicChildren: O,
      shapeFlag: ee,
      patchFlag: F,
      dirs: J,
      cacheIndex: re
    } = p;
    if (F === -2 && (C = !1), B != null && (_t(), Js(B, null, T, p, !0), Nt()), re != null && (v.renderCache[re] = void 0), ee & 256) {
      v.ctx.deactivate(p);
      return;
    }
    const ge = ee & 1 && J, Ce = !$s(p);
    let Te;
    if (Ce && (Te = U && U.onVnodeBeforeUnmount) && $t(Te, v, p), ee & 6)
      fl(p.component, T, A);
    else {
      if (ee & 128) {
        p.suspense.unmount(T, A);
        return;
      }
      ge && as(p, null, v, "beforeUnmount"), ee & 64 ? p.type.remove(
        p,
        v,
        T,
        Bs,
        A
      ) : O && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !O.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (D !== Ae || F > 0 && F & 64) ? Ps(
        O,
        v,
        T,
        !1,
        !0
      ) : (D === Ae && F & 384 || !C && ee & 16) && Ps(L, v, T), A && fi(p);
    }
    (Ce && (Te = U && U.onVnodeUnmounted) || ge) && ze(() => {
      Te && $t(Te, v, p), ge && as(p, null, v, "unmounted");
    }, T);
  }, fi = (p) => {
    const { type: v, el: T, anchor: A, transition: C } = p;
    if (v === Ae) {
      g.NODE_ENV !== "production" && p.patchFlag > 0 && p.patchFlag & 2048 && C && !C.persisted ? p.children.forEach((U) => {
        U.type === Be ? i(U.el) : fi(U);
      }) : dl(T, A);
      return;
    }
    if (v === Rn) {
      P(p);
      return;
    }
    const D = () => {
      i(T), C && !C.persisted && C.afterLeave && C.afterLeave();
    };
    if (p.shapeFlag & 1 && C && !C.persisted) {
      const { leave: U, delayLeave: B } = C, L = () => U(T, D);
      B ? B(p.el, D, L) : L();
    } else
      D();
  }, dl = (p, v) => {
    let T;
    for (; p !== v; )
      T = m(p), i(p), p = T;
    i(v);
  }, fl = (p, v, T) => {
    g.NODE_ENV !== "production" && p.type.__hmrId && bc(p);
    const { bum: A, scope: C, job: D, subTree: U, um: B, m: L, a: O } = p;
    Zo(L), Zo(O), A && Ss(A), C.stop(), D && (D.flags |= 8, ft(U, p, v, T)), B && ze(B, v), ze(() => {
      p.isUnmounted = !0;
    }, v), g.NODE_ENV !== "production" && xc(p);
  }, Ps = (p, v, T, A = !1, C = !1, D = 0) => {
    for (let U = D; U < p.length; U++)
      ft(p[U], v, T, A, C);
  }, En = (p) => {
    if (p.shapeFlag & 6)
      return En(p.component.subTree);
    if (p.shapeFlag & 128)
      return p.suspense.next();
    const v = m(p.anchor || p.el), T = v && v[Ea];
    return T ? m(T) : v;
  };
  let pi = !1;
  const So = (p, v, T) => {
    let A;
    p == null ? v._vnode && (ft(v._vnode, null, null, !0), A = v._vnode.component) : y(
      v._vnode || null,
      p,
      v,
      null,
      null,
      null,
      T
    ), v._vnode = p, pi || (pi = !0, Mo(A), ua(), pi = !1);
  }, Bs = {
    p: y,
    um: ft,
    m: He,
    r: fi,
    mt: ue,
    mc: W,
    pc: X,
    pbc: me,
    n: En,
    o: t
  };
  return {
    render: So,
    hydrate: void 0,
    createApp: iu(So)
  };
}
function Ni({ type: t, props: e }, s) {
  return s === "svg" && t === "foreignObject" || s === "mathml" && t === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : s;
}
function ls({ effect: t, job: e }, s) {
  s ? (t.flags |= 32, e.flags |= 4) : (t.flags &= -33, e.flags &= -5);
}
function Cu(t, e) {
  return (!t || t && !t.pendingBranch) && e && !e.persisted;
}
function Qs(t, e, s = !1) {
  const n = t.children, i = e.children;
  if (z(n) && z(i))
    for (let o = 0; o < n.length; o++) {
      const r = n[o];
      let a = i[o];
      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[o] = zt(i[o]), a.el = r.el), !s && a.patchFlag !== -2 && Qs(r, a)), a.type === mn && (a.patchFlag === -1 && (a = i[o] = zt(a)), a.el = r.el), a.type === Be && !a.el && (a.el = r.el), g.NODE_ENV !== "production" && a.el && (a.el.__vnode = a);
    }
}
function Du(t) {
  const e = t.slice(), s = [0];
  let n, i, o, r, a;
  const l = t.length;
  for (n = 0; n < l; n++) {
    const u = t[n];
    if (u !== 0) {
      if (i = s[s.length - 1], t[i] < u) {
        e[n] = i, s.push(n);
        continue;
      }
      for (o = 0, r = s.length - 1; o < r; )
        a = o + r >> 1, t[s[a]] < u ? o = a + 1 : r = a;
      u < t[s[o]] && (o > 0 && (e[n] = s[o - 1]), s[o] = n);
    }
  }
  for (o = s.length, r = s[o - 1]; o-- > 0; )
    s[o] = r, r = e[r];
  return s;
}
function za(t) {
  const e = t.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : za(e);
}
function Zo(t) {
  if (t)
    for (let e = 0; e < t.length; e++)
      t[e].flags |= 8;
}
function Ga(t) {
  if (t.placeholder)
    return t.placeholder;
  const e = t.component;
  return e ? Ga(e.subTree) : null;
}
const Ya = (t) => t.__isSuspense;
function Ou(t, e) {
  e && e.pendingBranch ? z(t) ? e.effects.push(...t) : e.effects.push(t) : ca(t);
}
const Ae = /* @__PURE__ */ Symbol.for("v-fgt"), mn = /* @__PURE__ */ Symbol.for("v-txt"), Be = /* @__PURE__ */ Symbol.for("v-cmt"), Rn = /* @__PURE__ */ Symbol.for("v-stc"), Xs = [];
let at = null;
function x(t = !1) {
  Xs.push(at = t ? null : []);
}
function $u() {
  Xs.pop(), at = Xs[Xs.length - 1] || null;
}
let on = 1;
function Gn(t, e = !1) {
  on += t, t < 0 && at && e && (at.hasOnce = !0);
}
function Ja(t) {
  return t.dynamicChildren = on > 0 ? at || Ds : null, $u(), on > 0 && at && at.push(t), t;
}
function M(t, e, s, n, i, o) {
  return Ja(
    f(
      t,
      e,
      s,
      n,
      i,
      o,
      !0
    )
  );
}
function Ie(t, e, s, n, i) {
  return Ja(
    w(
      t,
      e,
      s,
      n,
      i,
      !0
    )
  );
}
function _s(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function hs(t, e) {
  if (g.NODE_ENV !== "production" && e.shapeFlag & 6 && t.component) {
    const s = $n.get(e.type);
    if (s && s.has(t.component))
      return t.shapeFlag &= -257, e.shapeFlag &= -513, !1;
  }
  return t.type === e.type && t.key === e.key;
}
const Au = (...t) => Xa(
  ...t
), Qa = ({ key: t }) => t ?? null, In = ({
  ref: t,
  ref_key: e,
  ref_for: s
}) => (typeof t == "number" && (t = "" + t), t != null ? Re(t) || /* @__PURE__ */ Ue(t) || te(t) ? { i: We, r: t, k: e, f: !!s } : t : null);
function f(t, e = null, s = null, n = 0, i = null, o = t === Ae ? 0 : 1, r = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && Qa(e),
    ref: e && In(e),
    scopeId: va,
    slotScopeIds: null,
    children: s,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: n,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: We
  };
  return a ? (uo(l, s), o & 128 && t.normalize(l)) : s && (l.shapeFlag |= Re(s) ? 8 : 16), g.NODE_ENV !== "production" && l.key !== l.key && V("VNode created with invalid key (NaN). VNode type:", l.type), on > 0 && // avoid a block node from tracking itself
  !r && // has current parent block
  at && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && at.push(l), l;
}
const w = g.NODE_ENV !== "production" ? Au : Xa;
function Xa(t, e = null, s = null, n = 0, i = null, o = !1) {
  if ((!t || t === zc) && (g.NODE_ENV !== "production" && !t && V(`Invalid vnode type when creating vnode: ${t}.`), t = Be), _s(t)) {
    const a = Ft(
      t,
      e,
      !0
      /* mergeRef: true */
    );
    return s && uo(a, s), on > 0 && !o && at && (a.shapeFlag & 6 ? at[at.indexOf(t)] = a : at.push(a)), a.patchFlag = -2, a;
  }
  if (nl(t) && (t = t.__vccOpts), e) {
    e = Vu(e);
    let { class: a, style: l } = e;
    a && !Re(a) && (e.class = Me(a)), be(l) && (/* @__PURE__ */ Pn(l) && !z(l) && (l = Ve({}, l)), e.style = Ke(l));
  }
  const r = Re(t) ? 1 : Ya(t) ? 128 : ya(t) ? 64 : be(t) ? 4 : te(t) ? 2 : 0;
  return g.NODE_ENV !== "production" && r & 4 && /* @__PURE__ */ Pn(t) && (t = /* @__PURE__ */ de(t), V(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    t
  )), f(
    t,
    e,
    s,
    n,
    i,
    r,
    o,
    !0
  );
}
function Vu(t) {
  return t ? /* @__PURE__ */ Pn(t) || Fa(t) ? Ve({}, t) : t : null;
}
function Ft(t, e, s = !1, n = !1) {
  const { props: i, ref: o, patchFlag: r, children: a, transition: l } = t, u = e ? Ru(i || {}, e) : i, c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: u,
    key: u && Qa(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      s && o ? z(o) ? o.concat(In(e)) : [o, In(e)] : In(e)
    ) : o,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: g.NODE_ENV !== "production" && r === -1 && z(a) ? a.map(Za) : a,
    target: t.target,
    targetStart: t.targetStart,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && t.type !== Ae ? r === -1 ? 16 : r | 16 : r,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: l,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && Ft(t.ssContent),
    ssFallback: t.ssFallback && Ft(t.ssFallback),
    placeholder: t.placeholder,
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
  return l && n && nn(
    c,
    l.clone(c)
  ), c;
}
function Za(t) {
  const e = Ft(t);
  return z(t.children) && (e.children = t.children.map(Za)), e;
}
function oe(t = " ", e = 0) {
  return w(mn, null, t, e);
}
function ne(t = "", e = !1) {
  return e ? (x(), Ie(Be, null, t)) : w(Be, null, t);
}
function pt(t) {
  return t == null || typeof t == "boolean" ? w(Be) : z(t) ? w(
    Ae,
    null,
    // #3666, avoid reference pollution when reusing vnode
    t.slice()
  ) : _s(t) ? zt(t) : w(mn, null, String(t));
}
function zt(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : Ft(t);
}
function uo(t, e) {
  let s = 0;
  const { shapeFlag: n } = t;
  if (e == null)
    e = null;
  else if (z(e))
    s = 16;
  else if (typeof e == "object")
    if (n & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), uo(t, i()), i._c && (i._d = !0));
      return;
    } else {
      s = 32;
      const i = e._;
      !i && !Fa(e) ? e._ctx = We : i === 3 && We && (We.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else te(e) ? (e = { default: e, _ctx: We }, s = 32) : (e = String(e), n & 64 ? (s = 16, e = [oe(e)]) : s = 8);
  t.children = e, t.shapeFlag |= s;
}
function Ru(...t) {
  const e = {};
  for (let s = 0; s < t.length; s++) {
    const n = t[s];
    for (const i in n)
      if (i === "class")
        e.class !== n.class && (e.class = Me([e.class, n.class]));
      else if (i === "style")
        e.style = Ke([e.style, n.style]);
      else if (ln(i)) {
        const o = e[i], r = n[i];
        r && o !== r && !(z(o) && o.includes(r)) && (e[i] = o ? [].concat(o, r) : r);
      } else i !== "" && (e[i] = n[i]);
  }
  return e;
}
function $t(t, e, s, n = null) {
  wt(t, e, 7, [
    s,
    n
  ]);
}
const Iu = Ia();
let Mu = 0;
function Lu(t, e, s) {
  const n = t.type, i = (e ? e.appContext : t.appContext) || Iu, o = {
    uid: Mu++,
    vnode: t,
    type: n,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Al(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: qa(n, i),
    emitsOptions: La(n, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: ye,
    // inheritAttrs
    inheritAttrs: n.inheritAttrs,
    // state
    ctx: ye,
    data: ye,
    props: ye,
    attrs: ye,
    slots: ye,
    refs: ye,
    setupState: ye,
    setupContext: null,
    // suspense related
    suspense: s,
    suspenseId: s ? s.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return g.NODE_ENV !== "production" ? o.ctx = Gc(o) : o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = ou.bind(null, o), t.ce && t.ce(o), o;
}
let Fe = null;
const li = () => Fe || We;
let Yn, Fi;
{
  const t = un(), e = (s, n) => {
    let i;
    return (i = t[s]) || (i = t[s] = []), i.push(n), (o) => {
      i.length > 1 ? i.forEach((r) => r(o)) : i[0](o);
    };
  };
  Yn = e(
    "__VUE_INSTANCE_SETTERS__",
    (s) => Fe = s
  ), Fi = e(
    "__VUE_SSR_SETTERS__",
    (s) => rn = s
  );
}
const vn = (t) => {
  const e = Fe;
  return Yn(t), t.scope.on(), () => {
    t.scope.off(), Yn(e);
  };
}, er = () => {
  Fe && Fe.scope.off(), Yn(null);
}, ku = /* @__PURE__ */ Xt("slot,component");
function ji(t, { isNativeTag: e }) {
  (ku(t) || e(t)) && V(
    "Do not use built-in or reserved HTML elements as component id: " + t
  );
}
function el(t) {
  return t.vnode.shapeFlag & 4;
}
let rn = !1;
function Pu(t, e = !1, s = !1) {
  e && Fi(e);
  const { props: n, children: i } = t.vnode, o = el(t);
  du(t, n, o, e), Nu(t, i, s || e);
  const r = o ? Bu(t, e) : void 0;
  return e && Fi(!1), r;
}
function Bu(t, e) {
  const s = t.type;
  if (g.NODE_ENV !== "production") {
    if (s.name && ji(s.name, t.appContext.config), s.components) {
      const i = Object.keys(s.components);
      for (let o = 0; o < i.length; o++)
        ji(i[o], t.appContext.config);
    }
    if (s.directives) {
      const i = Object.keys(s.directives);
      for (let o = 0; o < i.length; o++)
        ba(i[o]);
    }
    s.compilerOptions && Uu() && V(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = new Proxy(t.ctx, Aa), g.NODE_ENV !== "production" && Yc(t);
  const { setup: n } = s;
  if (n) {
    _t();
    const i = t.setupContext = n.length > 1 ? ju(t) : null, o = vn(t), r = ks(
      n,
      t,
      0,
      [
        g.NODE_ENV !== "production" ? /* @__PURE__ */ Lt(t.props) : t.props,
        i
      ]
    ), a = zi(r);
    if (Nt(), o(), (a || t.sp) && !$s(t) && Da(t), a) {
      if (r.then(er, er), e)
        return r.then((l) => {
          tr(t, l, e);
        }).catch((l) => {
          dn(l, t, 0);
        });
      if (t.asyncDep = r, g.NODE_ENV !== "production" && !t.suspense) {
        const l = bn(t, s);
        V(
          `Component <${l}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      tr(t, r, e);
  } else
    tl(t, e);
}
function tr(t, e, s) {
  te(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : be(e) ? (g.NODE_ENV !== "production" && _s(e) && V(
    "setup() should not return VNodes directly - return a render function instead."
  ), g.NODE_ENV !== "production" && (t.devtoolsRawSetupState = e), t.setupState = oa(e), g.NODE_ENV !== "production" && Jc(t)) : g.NODE_ENV !== "production" && e !== void 0 && V(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), tl(t, s);
}
const Uu = () => !0;
function tl(t, e, s) {
  const n = t.type;
  t.render || (t.render = n.render || qe);
  {
    const i = vn(t);
    _t();
    try {
      Xc(t);
    } finally {
      Nt(), i();
    }
  }
  g.NODE_ENV !== "production" && !n.render && t.render === qe && !e && (n.template ? V(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : V("Component is missing template or render function: ", n));
}
const sr = g.NODE_ENV !== "production" ? {
  get(t, e) {
    return Kn(), je(t, "get", ""), t[e];
  },
  set() {
    return V("setupContext.attrs is readonly."), !1;
  },
  deleteProperty() {
    return V("setupContext.attrs is readonly."), !1;
  }
} : {
  get(t, e) {
    return je(t, "get", ""), t[e];
  }
};
function Fu(t) {
  return new Proxy(t.slots, {
    get(e, s) {
      return je(t, "get", "$slots"), e[s];
    }
  });
}
function ju(t) {
  const e = (s) => {
    if (g.NODE_ENV !== "production" && (t.exposed && V("expose() should be called only once per setup()."), s != null)) {
      let n = typeof s;
      n === "object" && (z(s) ? n = "array" : /* @__PURE__ */ Ue(s) && (n = "ref")), n !== "object" && V(
        `expose() should be passed a plain object, received ${n}.`
      );
    }
    t.exposed = s || {};
  };
  if (g.NODE_ENV !== "production") {
    let s, n;
    return Object.freeze({
      get attrs() {
        return s || (s = new Proxy(t.attrs, sr));
      },
      get slots() {
        return n || (n = Fu(t));
      },
      get emit() {
        return (i, ...o) => t.emit(i, ...o);
      },
      expose: e
    });
  } else
    return {
      attrs: new Proxy(t.attrs, sr),
      slots: t.slots,
      emit: t.emit,
      expose: e
    };
}
function ci(t) {
  return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(oa(Xl(t.exposed)), {
    get(e, s) {
      if (s in e)
        return e[s];
      if (s in Es)
        return Es[s](t);
    },
    has(e, s) {
      return s in e || s in Es;
    }
  })) : t.proxy;
}
const qu = /(?:^|[-_])\w/g, Wu = (t) => t.replace(qu, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function sl(t, e = !0) {
  return te(t) ? t.displayName || t.name : t.name || e && t.__name;
}
function bn(t, e, s = !1) {
  let n = sl(e);
  if (!n && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (n = i[1]);
  }
  if (!n && t) {
    const i = (o) => {
      for (const r in o)
        if (o[r] === e)
          return r;
    };
    n = i(t.components) || t.parent && i(
      t.parent.type.components
    ) || i(t.appContext.components);
  }
  return n ? Wu(n) : s ? "App" : "Anonymous";
}
function nl(t) {
  return te(t) && "__vccOpts" in t;
}
const ie = (t, e) => {
  const s = /* @__PURE__ */ oc(t, e, rn);
  if (g.NODE_ENV !== "production") {
    const n = li();
    n && n.appContext.config.warnRecursiveComputed && (s._warnRecursive = !0);
  }
  return s;
};
function Hu(t, e, s) {
  try {
    Gn(-1);
    const n = arguments.length;
    return n === 2 ? be(e) && !z(e) ? _s(e) ? w(t, null, [e]) : w(t, e) : w(t, null, e) : (n > 3 ? s = Array.prototype.slice.call(arguments, 2) : n === 3 && _s(s) && (s = [s]), w(t, e, s));
  } finally {
    Gn(1);
  }
}
function Ku() {
  if (g.NODE_ENV === "production" || typeof window > "u")
    return;
  const t = { style: "color:#3ba776" }, e = { style: "color:#1677ff" }, s = { style: "color:#f5222d" }, n = { style: "color:#eb2f96" }, i = {
    __vue_custom_formatter: !0,
    header(d) {
      if (!be(d))
        return null;
      if (d.__isVue)
        return ["div", t, "VueInstance"];
      if (/* @__PURE__ */ Ue(d)) {
        _t();
        const m = d.value;
        return Nt(), [
          "div",
          {},
          ["span", t, c(d)],
          "<",
          a(m),
          ">"
        ];
      } else {
        if (/* @__PURE__ */ is(d))
          return [
            "div",
            {},
            ["span", t, /* @__PURE__ */ Xe(d) ? "ShallowReactive" : "Reactive"],
            "<",
            a(d),
            `>${/* @__PURE__ */ Tt(d) ? " (readonly)" : ""}`
          ];
        if (/* @__PURE__ */ Tt(d))
          return [
            "div",
            {},
            ["span", t, /* @__PURE__ */ Xe(d) ? "ShallowReadonly" : "Readonly"],
            "<",
            a(d),
            ">"
          ];
      }
      return null;
    },
    hasBody(d) {
      return d && d.__isVue;
    },
    body(d) {
      if (d && d.__isVue)
        return [
          "div",
          {},
          ...o(d.$)
        ];
    }
  };
  function o(d) {
    const m = [];
    d.type.props && d.props && m.push(r("props", /* @__PURE__ */ de(d.props))), d.setupState !== ye && m.push(r("setup", d.setupState)), d.data !== ye && m.push(r("data", /* @__PURE__ */ de(d.data)));
    const h = l(d, "computed");
    h && m.push(r("computed", h));
    const b = l(d, "inject");
    return b && m.push(r("injected", b)), m.push([
      "div",
      {},
      [
        "span",
        {
          style: n.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: d }]
    ]), m;
  }
  function r(d, m) {
    return m = Ve({}, m), Object.keys(m).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        d
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(m).map((h) => [
          "div",
          {},
          ["span", n, h + ": "],
          a(m[h], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function a(d, m = !0) {
    return typeof d == "number" ? ["span", e, d] : typeof d == "string" ? ["span", s, JSON.stringify(d)] : typeof d == "boolean" ? ["span", n, d] : be(d) ? ["object", { object: m ? /* @__PURE__ */ de(d) : d }] : ["span", s, String(d)];
  }
  function l(d, m) {
    const h = d.type;
    if (te(h))
      return;
    const b = {};
    for (const y in d.ctx)
      u(h, y, m) && (b[y] = d.ctx[y]);
    return b;
  }
  function u(d, m, h) {
    const b = d[h];
    if (z(b) && b.includes(m) || be(b) && m in b || d.extends && u(d.extends, m, h) || d.mixins && d.mixins.some((y) => u(y, m, h)))
      return !0;
  }
  function c(d) {
    return /* @__PURE__ */ Xe(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];
}
const nr = "3.5.28", Bt = g.NODE_ENV !== "production" ? V : qe;
var St = {};
let qi;
const ir = typeof window < "u" && window.trustedTypes;
if (ir)
  try {
    qi = /* @__PURE__ */ ir.createPolicy("vue", {
      createHTML: (t) => t
    });
  } catch (t) {
    St.NODE_ENV !== "production" && Bt(`Error creating trusted types policy: ${t}`);
  }
const il = qi ? (t) => qi.createHTML(t) : (t) => t, zu = "http://www.w3.org/2000/svg", Gu = "http://www.w3.org/1998/Math/MathML", Ht = typeof document < "u" ? document : null, or = Ht && /* @__PURE__ */ Ht.createElement("template"), Yu = {
  insert: (t, e, s) => {
    e.insertBefore(t, s || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, s, n) => {
    const i = e === "svg" ? Ht.createElementNS(zu, t) : e === "mathml" ? Ht.createElementNS(Gu, t) : s ? Ht.createElement(t, { is: s }) : Ht.createElement(t);
    return t === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple), i;
  },
  createText: (t) => Ht.createTextNode(t),
  createComment: (t) => Ht.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Ht.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(t, e, s, n, i, o) {
    const r = s ? s.previousSibling : e.lastChild;
    if (i && (i === o || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), s), !(i === o || !(i = i.nextSibling)); )
        ;
    else {
      or.innerHTML = il(
        n === "svg" ? `<svg>${t}</svg>` : n === "mathml" ? `<math>${t}</math>` : t
      );
      const a = or.content;
      if (n === "svg" || n === "mathml") {
        const l = a.firstChild;
        for (; l.firstChild; )
          a.appendChild(l.firstChild);
        a.removeChild(l);
      }
      e.insertBefore(a, s);
    }
    return [
      // first
      r ? r.nextSibling : e.firstChild,
      // last
      s ? s.previousSibling : e.lastChild
    ];
  }
}, es = "transition", Ws = "animation", an = /* @__PURE__ */ Symbol("_vtc"), ol = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, Ju = /* @__PURE__ */ Ve(
  {},
  Ta,
  ol
), Qu = (t) => (t.displayName = "Transition", t.props = Ju, t), fo = /* @__PURE__ */ Qu(
  (t, { slots: e }) => Hu(Lc, Xu(t), e)
), cs = (t, e = []) => {
  z(t) ? t.forEach((s) => s(...e)) : t && t(...e);
}, rr = (t) => t ? z(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function Xu(t) {
  const e = {};
  for (const q in t)
    q in ol || (e[q] = t[q]);
  if (t.css === !1)
    return e;
  const {
    name: s = "v",
    type: n,
    duration: i,
    enterFromClass: o = `${s}-enter-from`,
    enterActiveClass: r = `${s}-enter-active`,
    enterToClass: a = `${s}-enter-to`,
    appearFromClass: l = o,
    appearActiveClass: u = r,
    appearToClass: c = a,
    leaveFromClass: d = `${s}-leave-from`,
    leaveActiveClass: m = `${s}-leave-active`,
    leaveToClass: h = `${s}-leave-to`
  } = t, b = Zu(i), y = b && b[0], E = b && b[1], {
    onBeforeEnter: _,
    onEnter: S,
    onEnterCancelled: N,
    onLeave: R,
    onLeaveCancelled: P,
    onBeforeAppear: H = _,
    onAppear: pe = S,
    onAppearCancelled: he = N
  } = e, W = (q, K, G, ue) => {
    q._enterCancelled = ue, us(q, K ? c : a), us(q, K ? u : r), G && G();
  }, ae = (q, K) => {
    q._isLeaving = !1, us(q, d), us(q, h), us(q, m), K && K();
  }, me = (q) => (K, G) => {
    const ue = q ? pe : S, ve = () => W(K, q, G);
    cs(ue, [K, ve]), ar(() => {
      us(K, q ? l : o), Wt(K, q ? c : a), rr(ue) || lr(K, n, y, ve);
    });
  };
  return Ve(e, {
    onBeforeEnter(q) {
      cs(_, [q]), Wt(q, o), Wt(q, r);
    },
    onBeforeAppear(q) {
      cs(H, [q]), Wt(q, l), Wt(q, u);
    },
    onEnter: me(!1),
    onAppear: me(!0),
    onLeave(q, K) {
      q._isLeaving = !0;
      const G = () => ae(q, K);
      Wt(q, d), q._enterCancelled ? (Wt(q, m), dr(q)) : (dr(q), Wt(q, m)), ar(() => {
        q._isLeaving && (us(q, d), Wt(q, h), rr(R) || lr(q, n, E, G));
      }), cs(R, [q, G]);
    },
    onEnterCancelled(q) {
      W(q, !1, void 0, !0), cs(N, [q]);
    },
    onAppearCancelled(q) {
      W(q, !0, void 0, !0), cs(he, [q]);
    },
    onLeaveCancelled(q) {
      ae(q), cs(P, [q]);
    }
  });
}
function Zu(t) {
  if (t == null)
    return null;
  if (be(t))
    return [Ti(t.enter), Ti(t.leave)];
  {
    const e = Ti(t);
    return [e, e];
  }
}
function Ti(t) {
  const e = bl(t);
  return St.NODE_ENV !== "production" && fc(e, "<transition> explicit duration"), e;
}
function Wt(t, e) {
  e.split(/\s+/).forEach((s) => s && t.classList.add(s)), (t[an] || (t[an] = /* @__PURE__ */ new Set())).add(e);
}
function us(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.remove(n));
  const s = t[an];
  s && (s.delete(e), s.size || (t[an] = void 0));
}
function ar(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let ed = 0;
function lr(t, e, s, n) {
  const i = t._endId = ++ed, o = () => {
    i === t._endId && n();
  };
  if (s != null)
    return setTimeout(o, s);
  const { type: r, timeout: a, propCount: l } = td(t, e);
  if (!r)
    return n();
  const u = r + "end";
  let c = 0;
  const d = () => {
    t.removeEventListener(u, m), o();
  }, m = (h) => {
    h.target === t && ++c >= l && d();
  };
  setTimeout(() => {
    c < l && d();
  }, a + 1), t.addEventListener(u, m);
}
function td(t, e) {
  const s = window.getComputedStyle(t), n = (b) => (s[b] || "").split(", "), i = n(`${es}Delay`), o = n(`${es}Duration`), r = cr(i, o), a = n(`${Ws}Delay`), l = n(`${Ws}Duration`), u = cr(a, l);
  let c = null, d = 0, m = 0;
  e === es ? r > 0 && (c = es, d = r, m = o.length) : e === Ws ? u > 0 && (c = Ws, d = u, m = l.length) : (d = Math.max(r, u), c = d > 0 ? r > u ? es : Ws : null, m = c ? c === es ? o.length : l.length : 0);
  const h = c === es && /\b(?:transform|all)(?:,|$)/.test(
    n(`${es}Property`).toString()
  );
  return {
    type: c,
    timeout: d,
    propCount: m,
    hasTransform: h
  };
}
function cr(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((s, n) => ur(s) + ur(t[n])));
}
function ur(t) {
  return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function dr(t) {
  return (t ? t.ownerDocument : document).body.offsetHeight;
}
function sd(t, e, s) {
  const n = t[an];
  n && (e = (e ? [e, ...n] : [...n]).join(" ")), e == null ? t.removeAttribute("class") : s ? t.setAttribute("class", e) : t.className = e;
}
const fr = /* @__PURE__ */ Symbol("_vod"), nd = /* @__PURE__ */ Symbol("_vsh"), id = /* @__PURE__ */ Symbol(St.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""), od = /(?:^|;)\s*display\s*:/;
function rd(t, e, s) {
  const n = t.style, i = Re(s);
  let o = !1;
  if (s && !i) {
    if (e)
      if (Re(e))
        for (const r of e.split(";")) {
          const a = r.slice(0, r.indexOf(":")).trim();
          s[a] == null && Mn(n, a, "");
        }
      else
        for (const r in e)
          s[r] == null && Mn(n, r, "");
    for (const r in s)
      r === "display" && (o = !0), Mn(n, r, s[r]);
  } else if (i) {
    if (e !== s) {
      const r = n[id];
      r && (s += ";" + r), n.cssText = s, o = od.test(s);
    }
  } else e && t.removeAttribute("style");
  fr in t && (t[fr] = o ? n.display : "", t[nd] && (n.display = "none"));
}
const ad = /[^\\];\s*$/, pr = /\s*!important$/;
function Mn(t, e, s) {
  if (z(s))
    s.forEach((n) => Mn(t, e, n));
  else if (s == null && (s = ""), St.NODE_ENV !== "production" && ad.test(s) && Bt(
    `Unexpected semicolon at the end of '${e}' style value: '${s}'`
  ), e.startsWith("--"))
    t.setProperty(e, s);
  else {
    const n = ld(t, e);
    pr.test(s) ? t.setProperty(
      Qt(n),
      s.replace(pr, ""),
      "important"
    ) : t[n] = s;
  }
}
const hr = ["Webkit", "Moz", "ms"], xi = {};
function ld(t, e) {
  const s = xi[e];
  if (s)
    return s;
  let n = ut(e);
  if (n !== "filter" && n in t)
    return xi[e] = n;
  n = Zn(n);
  for (let i = 0; i < hr.length; i++) {
    const o = hr[i] + n;
    if (o in t)
      return xi[e] = o;
  }
  return e;
}
const mr = "http://www.w3.org/1999/xlink";
function vr(t, e, s, n, i, o = Ol(e)) {
  n && e.startsWith("xlink:") ? s == null ? t.removeAttributeNS(mr, e.slice(6, e.length)) : t.setAttributeNS(mr, e, s) : s == null || o && !Ur(s) ? t.removeAttribute(e) : t.setAttribute(
    e,
    o ? "" : Et(s) ? String(s) : s
  );
}
function br(t, e, s, n, i) {
  if (e === "innerHTML" || e === "textContent") {
    s != null && (t[e] = e === "innerHTML" ? il(s) : s);
    return;
  }
  const o = t.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const a = o === "OPTION" ? t.getAttribute("value") || "" : t.value, l = s == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      t.type === "checkbox" ? "on" : ""
    ) : String(s);
    (a !== l || !("_value" in t)) && (t.value = l), s == null && t.removeAttribute(e), t._value = s;
    return;
  }
  let r = !1;
  if (s === "" || s == null) {
    const a = typeof t[e];
    a === "boolean" ? s = Ur(s) : s == null && a === "string" ? (s = "", r = !0) : a === "number" && (s = 0, r = !0);
  }
  try {
    t[e] = s;
  } catch (a) {
    St.NODE_ENV !== "production" && !r && Bt(
      `Failed setting prop "${e}" on <${o.toLowerCase()}>: value ${s} is invalid.`,
      a
    );
  }
  r && t.removeAttribute(i || e);
}
function Yt(t, e, s, n) {
  t.addEventListener(e, s, n);
}
function cd(t, e, s, n) {
  t.removeEventListener(e, s, n);
}
const gr = /* @__PURE__ */ Symbol("_vei");
function ud(t, e, s, n, i = null) {
  const o = t[gr] || (t[gr] = {}), r = o[e];
  if (n && r)
    r.value = St.NODE_ENV !== "production" ? yr(n, e) : n;
  else {
    const [a, l] = dd(e);
    if (n) {
      const u = o[e] = hd(
        St.NODE_ENV !== "production" ? yr(n, e) : n,
        i
      );
      Yt(t, a, u, l);
    } else r && (cd(t, a, r, l), o[e] = void 0);
  }
}
const Er = /(?:Once|Passive|Capture)$/;
function dd(t) {
  let e;
  if (Er.test(t)) {
    e = {};
    let n;
    for (; n = t.match(Er); )
      t = t.slice(0, t.length - n[0].length), e[n[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : Qt(t.slice(2)), e];
}
let wi = 0;
const fd = /* @__PURE__ */ Promise.resolve(), pd = () => wi || (fd.then(() => wi = 0), wi = Date.now());
function hd(t, e) {
  const s = (n) => {
    if (!n._vts)
      n._vts = Date.now();
    else if (n._vts <= s.attached)
      return;
    wt(
      md(n, s.value),
      e,
      5,
      [n]
    );
  };
  return s.value = t, s.attached = pd(), s;
}
function yr(t, e) {
  return te(t) || z(t) ? t : (Bt(
    `Wrong type passed as event handler to ${e} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof t}.`
  ), qe);
}
function md(t, e) {
  if (z(e)) {
    const s = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      s.call(t), t._stopped = !0;
    }, e.map(
      (n) => (i) => !i._stopped && n && n(i)
    );
  } else
    return e;
}
const _r = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // lowercase letter
t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, vd = (t, e, s, n, i, o) => {
  const r = i === "svg";
  e === "class" ? sd(t, n, r) : e === "style" ? rd(t, s, n) : ln(e) ? Ln(e) || ud(t, e, s, n, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : bd(t, e, n, r)) ? (br(t, e, n), !t.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && vr(t, e, n, r, o, e !== "value")) : /* #11081 force set props for possible async custom element */ t._isVueCE && (/[A-Z]/.test(e) || !Re(n)) ? br(t, ut(e), n, o, e) : (e === "true-value" ? t._trueValue = n : e === "false-value" && (t._falseValue = n), vr(t, e, n, r));
};
function bd(t, e, s, n) {
  if (n)
    return !!(e === "innerHTML" || e === "textContent" || e in t && _r(e) && te(s));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && t.tagName === "IFRAME" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = t.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return _r(e) && Re(s) ? !1 : e in t;
}
const rs = (t) => {
  const e = t.props["onUpdate:modelValue"] || !1;
  return z(e) ? (s) => Ss(e, s) : e;
};
function gd(t) {
  t.target.composing = !0;
}
function Nr(t) {
  const e = t.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const dt = /* @__PURE__ */ Symbol("_assign");
function Tr(t, e, s) {
  return e && (t = t.trim()), s && (t = ei(t)), t;
}
const gt = {
  created(t, { modifiers: { lazy: e, trim: s, number: n } }, i) {
    t[dt] = rs(i);
    const o = n || i.props && i.props.type === "number";
    Yt(t, e ? "change" : "input", (r) => {
      r.target.composing || t[dt](Tr(t.value, s, o));
    }), (s || o) && Yt(t, "change", () => {
      t.value = Tr(t.value, s, o);
    }), e || (Yt(t, "compositionstart", gd), Yt(t, "compositionend", Nr), Yt(t, "change", Nr));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(t, { value: e }) {
    t.value = e ?? "";
  },
  beforeUpdate(t, { value: e, oldValue: s, modifiers: { lazy: n, trim: i, number: o } }, r) {
    if (t[dt] = rs(r), t.composing) return;
    const a = (o || t.type === "number") && !/^0\d/.test(t.value) ? ei(t.value) : t.value, l = e ?? "";
    a !== l && (document.activeElement === t && t.type !== "range" && (n && e === s || i && t.value.trim() === l) || (t.value = l));
  }
}, po = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(t, e, s) {
    t[dt] = rs(s), Yt(t, "change", () => {
      const n = t._modelValue, i = Is(t), o = t.checked, r = t[dt];
      if (z(n)) {
        const a = Ji(n, i), l = a !== -1;
        if (o && !l)
          r(n.concat(i));
        else if (!o && l) {
          const u = [...n];
          u.splice(a, 1), r(u);
        }
      } else if (Ls(n)) {
        const a = new Set(n);
        o ? a.add(i) : a.delete(i), r(a);
      } else
        r(rl(t, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: xr,
  beforeUpdate(t, e, s) {
    t[dt] = rs(s), xr(t, e, s);
  }
};
function xr(t, { value: e, oldValue: s }, n) {
  t._modelValue = e;
  let i;
  if (z(e))
    i = Ji(e, n.props.value) > -1;
  else if (Ls(e))
    i = e.has(n.props.value);
  else {
    if (e === s) return;
    i = os(e, rl(t, !0));
  }
  t.checked !== i && (t.checked = i);
}
const Ed = {
  created(t, { value: e }, s) {
    t.checked = os(e, s.props.value), t[dt] = rs(s), Yt(t, "change", () => {
      t[dt](Is(t));
    });
  },
  beforeUpdate(t, { value: e, oldValue: s }, n) {
    t[dt] = rs(n), e !== s && (t.checked = os(e, n.props.value));
  }
}, ho = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(t, { value: e, modifiers: { number: s } }, n) {
    const i = Ls(e);
    Yt(t, "change", () => {
      const o = Array.prototype.filter.call(t.options, (r) => r.selected).map(
        (r) => s ? ei(Is(r)) : Is(r)
      );
      t[dt](
        t.multiple ? i ? new Set(o) : o : o[0]
      ), t._assigning = !0, Pt(() => {
        t._assigning = !1;
      });
    }), t[dt] = rs(n);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(t, { value: e }) {
    wr(t, e);
  },
  beforeUpdate(t, e, s) {
    t[dt] = rs(s);
  },
  updated(t, { value: e }) {
    t._assigning || wr(t, e);
  }
};
function wr(t, e) {
  const s = t.multiple, n = z(e);
  if (s && !n && !Ls(e)) {
    St.NODE_ENV !== "production" && Bt(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let i = 0, o = t.options.length; i < o; i++) {
    const r = t.options[i], a = Is(r);
    if (s)
      if (n) {
        const l = typeof a;
        l === "string" || l === "number" ? r.selected = e.some((u) => String(u) === String(a)) : r.selected = Ji(e, a) > -1;
      } else
        r.selected = e.has(a);
    else if (os(Is(r), e)) {
      t.selectedIndex !== i && (t.selectedIndex = i);
      return;
    }
  }
  !s && t.selectedIndex !== -1 && (t.selectedIndex = -1);
}
function Is(t) {
  return "_value" in t ? t._value : t.value;
}
function rl(t, e) {
  const s = e ? "_trueValue" : "_falseValue";
  return s in t ? t[s] : e;
}
const yd = {
  created(t, e, s) {
    xn(t, e, s, null, "created");
  },
  mounted(t, e, s) {
    xn(t, e, s, null, "mounted");
  },
  beforeUpdate(t, e, s, n) {
    xn(t, e, s, n, "beforeUpdate");
  },
  updated(t, e, s, n) {
    xn(t, e, s, n, "updated");
  }
};
function _d(t, e) {
  switch (t) {
    case "SELECT":
      return ho;
    case "TEXTAREA":
      return gt;
    default:
      switch (e) {
        case "checkbox":
          return po;
        case "radio":
          return Ed;
        default:
          return gt;
      }
  }
}
function xn(t, e, s, n, i) {
  const r = _d(
    t.tagName,
    s.props && s.props.type
  )[i];
  r && r(t, e, s, n);
}
const Nd = ["ctrl", "shift", "alt", "meta"], Td = {
  stop: (t) => t.stopPropagation(),
  prevent: (t) => t.preventDefault(),
  self: (t) => t.target !== t.currentTarget,
  ctrl: (t) => !t.ctrlKey,
  shift: (t) => !t.shiftKey,
  alt: (t) => !t.altKey,
  meta: (t) => !t.metaKey,
  left: (t) => "button" in t && t.button !== 0,
  middle: (t) => "button" in t && t.button !== 1,
  right: (t) => "button" in t && t.button !== 2,
  exact: (t, e) => Nd.some((s) => t[`${s}Key`] && !e.includes(s))
}, xd = (t, e) => {
  if (!t) return t;
  const s = t._withMods || (t._withMods = {}), n = e.join(".");
  return s[n] || (s[n] = ((i, ...o) => {
    for (let r = 0; r < e.length; r++) {
      const a = Td[e[r]];
      if (a && a(i, e)) return;
    }
    return t(i, ...o);
  }));
}, wd = /* @__PURE__ */ Ve({ patchProp: vd }, Yu);
let Sr;
function Sd() {
  return Sr || (Sr = wu(wd));
}
const Cd = ((...t) => {
  const e = Sd().createApp(...t);
  St.NODE_ENV !== "production" && (Od(e), $d(e));
  const { mount: s } = e;
  return e.mount = (n) => {
    const i = Ad(n);
    if (!i) return;
    const o = e._component;
    !te(o) && !o.render && !o.template && (o.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
    const r = s(i, !1, Dd(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), r;
  }, e;
});
function Dd(t) {
  if (t instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && t instanceof MathMLElement)
    return "mathml";
}
function Od(t) {
  Object.defineProperty(t.config, "isNativeTag", {
    value: (e) => wl(e) || Sl(e) || Cl(e),
    writable: !1
  });
}
function $d(t) {
  {
    const e = t.config.isCustomElement;
    Object.defineProperty(t.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        Bt(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const s = t.config.compilerOptions, n = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(t.config, "compilerOptions", {
      get() {
        return Bt(n), s;
      },
      set() {
        Bt(n);
      }
    });
  }
}
function Ad(t) {
  if (Re(t)) {
    const e = document.querySelector(t);
    return St.NODE_ENV !== "production" && !e && Bt(
      `Failed to mount app: mount target selector "${t}" returned null.`
    ), e;
  }
  return St.NODE_ENV !== "production" && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && Bt(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), t;
}
var Vd = {};
function Rd() {
  Ku();
}
Vd.NODE_ENV !== "production" && Rd();
const De = (t, e) => {
  const s = t.__vccOpts || t;
  for (const [n, i] of e)
    s[n] = i;
  return s;
}, Id = {}, Md = { class: "card st-card-unified" }, Ld = { style: { display: "flex", "align-items": "center", "justify-content": "space-between" } };
function kd(t, e) {
  return x(), M("div", Md, [
    f("div", Ld, [
      bt(t.$slots, "left", {}, void 0, !0),
      bt(t.$slots, "right", {}, void 0, !0)
    ])
  ]);
}
const wn = /* @__PURE__ */ De(Id, [["render", kd], ["__scopeId", "data-v-5b66fbc1"]]), Pd = { class: "st-toggle-switch" }, Bd = ["checked"], Ud = /* @__PURE__ */ _e({
  __name: "ToggleSwitch",
  props: {
    checked: { type: Boolean }
  },
  emits: ["change"],
  setup(t) {
    return (e, s) => (x(), M("label", Pd, [
      f("input", {
        type: "checkbox",
        checked: t.checked,
        onChange: s[0] || (s[0] = (n) => e.$emit("change", n.target.checked))
      }, null, 40, Bd),
      s[1] || (s[1] = f("span", { class: "st-toggle-slider" }, null, -1))
    ]));
  }
}), Cr = /* @__PURE__ */ De(Ud, [["__scopeId", "data-v-f73e4a93"]]), Fd = { class: "button-content" }, jd = /* @__PURE__ */ _e({
  __name: "Button",
  emits: ["click"],
  setup(t) {
    return (e, s) => (x(), M("button", {
      class: "menu_button button-wrapper",
      onClick: s[0] || (s[0] = (n) => e.$emit("click"))
    }, [
      f("span", Fd, [
        bt(e.$slots, "default", {}, void 0, !0)
      ])
    ]));
  }
}), ce = /* @__PURE__ */ De(jd, [["__scopeId", "data-v-8b9ccff3"]]), qd = {
  key: 0,
  class: "popup-modal-header"
}, Wd = { class: "popup-modal-title" }, Hd = { class: "popup-modal-body" }, Kd = {
  key: 1,
  class: "popup-modal-footer"
}, zd = /* @__PURE__ */ _e({
  __name: "PopupModal",
  props: {
    visible: { type: Boolean },
    title: {},
    closable: { type: Boolean, default: !0 },
    maskClosable: { type: Boolean, default: !0 },
    height: {},
    width: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = ie(() => {
      const a = {};
      return s.height && (a.height = s.height, a["max-height"] = s.height), s.width && (a.width = s.width, a["max-width"] = s.width), a;
    }), i = e, o = () => {
      i("close");
    }, r = () => {
      s.maskClosable && o();
    };
    return (a, l) => (x(), Ie(Na, { to: "body" }, [
      w(fo, { name: "modal" }, {
        default: k(() => [
          t.visible ? (x(), M("div", {
            key: 0,
            class: "popup-modal-overlay",
            onClick: xd(r, ["self"])
          }, [
            f("div", {
              class: "popup-modal",
              style: Ke(n.value)
            }, [
              t.title || t.closable || a.$slots.titlePrefix ? (x(), M("div", qd, [
                f("div", Wd, [
                  bt(a.$slots, "titlePrefix", {}, void 0, !0),
                  f("span", null, fe(t.title), 1)
                ]),
                t.closable ? (x(), M("div", {
                  key: 0,
                  class: "popup-modal-close",
                  onClick: o
                }, [...l[0] || (l[0] = [
                  f("i", { class: "fa-solid fa-xmark" }, null, -1)
                ])])) : ne("", !0)
              ])) : ne("", !0),
              f("div", Hd, [
                bt(a.$slots, "default", {}, void 0, !0)
              ]),
              a.$slots.footer ? (x(), M("div", Kd, [
                bt(a.$slots, "footer", {}, void 0, !0)
              ])) : ne("", !0)
            ], 4)
          ])) : ne("", !0)
        ]),
        _: 3
      })
    ]));
  }
}), Ge = /* @__PURE__ */ De(zd, [["__scopeId", "data-v-546209e7"]]), Gd = { class: "drawer-header" }, Yd = { class: "header-actions" }, Jd = { class: "drawer-body" }, Qd = {
  key: 0,
  class: "empty-state"
}, Xd = {
  key: 1,
  class: "table-list"
}, Zd = ["onClick"], ef = { class: "table-item-main" }, tf = { class: "table-name" }, sf = {
  key: 0,
  class: "table-comment"
}, nf = /* @__PURE__ */ _e({
  __name: "TableListDrawer",
  props: {
    tables: {},
    selectedTable: {},
    isDrawer: { type: Boolean, default: !0 },
    showSyncButtons: { type: Boolean, default: !1 }
  },
  emits: ["select", "create", "closeDrawer", "sync", "push"],
  setup(t, { emit: e }) {
    const s = e, n = /* @__PURE__ */ j(window.innerWidth), i = () => {
      n.value = window.innerWidth;
    };
    ot(() => {
      window.addEventListener("resize", i);
    }), hn(() => {
      window.removeEventListener("resize", i);
    });
    const o = () => n.value <= 768, r = (c) => {
      s("select", c), o() && s("closeDrawer");
    }, a = () => {
      s("create");
    }, l = () => {
      s("sync");
    }, u = () => {
      s("push");
    };
    return (c, d) => (x(), M("div", {
      class: Me(["table-list-drawer", { "is-drawer": t.isDrawer }])
    }, [
      f("div", Gd, [
        d[3] || (d[3] = f("span", { class: "drawer-title" }, "", -1)),
        f("div", Yd, [
          t.showSyncButtons ? (x(), M("button", {
            key: 0,
            class: "sync-btn",
            title: "",
            onClick: l
          }, [...d[0] || (d[0] = [
            f("i", { class: "fa-solid fa-rotate" }, null, -1)
          ])])) : ne("", !0),
          t.showSyncButtons ? (x(), M("button", {
            key: 1,
            class: "push-btn",
            title: "",
            onClick: u
          }, [...d[1] || (d[1] = [
            f("i", { class: "fa-solid fa-share-from-square" }, null, -1)
          ])])) : ne("", !0),
          f("button", {
            class: "create-table-btn",
            title: "",
            onClick: a
          }, [...d[2] || (d[2] = [
            f("i", { class: "fa-solid fa-plus" }, null, -1)
          ])])
        ])
      ]),
      f("div", Jd, [
        t.tables.length === 0 ? (x(), M("div", Qd, [
          d[5] || (d[5] = f("i", { class: "fa-solid fa-table" }, null, -1)),
          d[6] || (d[6] = f("span", null, "", -1)),
          f("button", {
            class: "empty-create-btn",
            onClick: a
          }, [...d[4] || (d[4] = [
            f("i", { class: "fa-solid fa-plus" }, null, -1),
            oe("  ", -1)
          ])])
        ])) : (x(), M("div", Xd, [
          (x(!0), M(Ae, null, Jt(t.tables, (m) => (x(), M("div", {
            key: m.tableName,
            class: Me(["table-item", { active: t.selectedTable === m.tableName }]),
            onClick: (h) => r(m.tableName)
          }, [
            f("div", ef, [
              d[7] || (d[7] = f("i", { class: "fa-solid fa-table table-icon" }, null, -1)),
              f("span", tf, fe(m.tableName), 1)
            ]),
            m.comment ? (x(), M("div", sf, fe(m.comment), 1)) : ne("", !0)
          ], 10, Zd))), 128))
        ]))
      ])
    ], 2));
  }
}), of = /* @__PURE__ */ De(nf, [["__scopeId", "data-v-02fb0397"]]), rf = { class: "table-drawer-layout" }, af = { class: "layout-content" }, lf = {
  key: 0,
  class: "layout-drawer"
}, cf = { class: "layout-main" }, uf = /* @__PURE__ */ _e({
  __name: "TableDrawerLayout",
  props: {
    drawerExpanded: { type: Boolean },
    tables: {},
    selectedTable: {},
    showSyncButtons: { type: Boolean, default: !1 }
  },
  emits: ["update:drawerExpanded", "selectTable", "createTable", "sync", "push"],
  setup(t, { emit: e }) {
    const s = e, n = (l) => {
      s("selectTable", l);
    }, i = () => {
      s("createTable");
    }, o = () => {
      s("update:drawerExpanded", !1);
    }, r = () => {
      s("sync");
    }, a = () => {
      s("push");
    };
    return (l, u) => (x(), M("div", rf, [
      f("div", af, [
        w(fo, { name: "drawer-slide" }, {
          default: k(() => [
            t.drawerExpanded ? (x(), M("div", lf, [
              w(of, {
                tables: t.tables,
                "selected-table": t.selectedTable,
                "show-sync-buttons": t.showSyncButtons,
                onSelect: n,
                onCreate: i,
                onCloseDrawer: o,
                onSync: r,
                onPush: a
              }, null, 8, ["tables", "selected-table", "show-sync-buttons"])
            ])) : ne("", !0)
          ]),
          _: 1
        }),
        f("div", cf, [
          bt(l.$slots, "default", {}, void 0, !0)
        ])
      ])
    ]));
  }
}), mo = /* @__PURE__ */ De(uf, [["__scopeId", "data-v-c00243da"]]), df = { class: "tab-container" }, ff = { class: "tab-header" }, pf = ["onClick"], hf = { class: "tab-body" }, mf = /* @__PURE__ */ _e({
  __name: "TabContainer",
  props: {
    tabs: {},
    activeTab: {}
  },
  emits: ["update:activeTab"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ j(window.innerWidth), o = () => {
      i.value = window.innerWidth;
    };
    ot(() => {
      window.addEventListener("resize", o);
    }), hn(() => {
      window.removeEventListener("resize", o);
    });
    const r = ie(() => {
      const l = i.value <= 768;
      return s.tabs.filter((u) => !(u.mobileOnly && !l || u.desktopOnly && l));
    }), a = (l) => {
      n("update:activeTab", l);
    };
    return (l, u) => (x(), M("div", df, [
      f("div", ff, [
        (x(!0), M(Ae, null, Jt(r.value, (c) => (x(), M("div", {
          key: c.key,
          class: Me(["tab-item", { active: t.activeTab === c.key }]),
          onClick: (d) => a(c.key)
        }, [
          c.icon ? (x(), M("i", {
            key: 0,
            class: Me(c.icon)
          }, null, 2)) : ne("", !0),
          f("span", null, fe(c.label), 1)
        ], 10, pf))), 128))
      ]),
      f("div", hf, [
        (x(!0), M(Ae, null, Jt(t.tabs, (c) => (x(), M(Ae, {
          key: c.key
        }, [
          t.activeTab === c.key ? bt(l.$slots, c.key, { key: 0 }, void 0, !0) : ne("", !0)
        ], 64))), 128))
      ])
    ]));
  }
}), vo = /* @__PURE__ */ De(mf, [["__scopeId", "data-v-9d94b988"]]), vf = /* @__PURE__ */ _e({
  __name: "DrawerToggle",
  props: {
    expanded: { type: Boolean },
    fab: { type: Boolean, default: !1 }
  },
  emits: ["toggle"],
  setup(t, { emit: e }) {
    const s = e, n = () => {
      s("toggle");
    };
    return (i, o) => (x(), M("button", {
      class: Me(["drawer-toggle", { fab: t.fab }]),
      onClick: n
    }, [...o[0] || (o[0] = [
      f("div", { class: "hamburger-icon" }, [
        f("span", { class: "line" }),
        f("span", { class: "line" }),
        f("span", { class: "line" })
      ], -1)
    ])], 2));
  }
}), bo = /* @__PURE__ */ De(vf, [["__scopeId", "data-v-2b5f8ef8"]]), bf = /* @__PURE__ */ _e({
  __name: "ToastNotification",
  props: {
    visible: { type: Boolean },
    message: {},
    type: {},
    icon: {}
  },
  setup(t) {
    return (e, s) => (x(), Ie(fo, { name: "toast" }, {
      default: k(() => [
        t.visible ? (x(), M("div", {
          key: 0,
          class: Me(["toast-notification", t.type])
        }, [
          f("i", {
            class: Me(t.icon)
          }, null, 2),
          f("span", null, fe(t.message), 1)
        ], 2)) : ne("", !0)
      ]),
      _: 1
    }));
  }
}), al = /* @__PURE__ */ De(bf, [["__scopeId", "data-v-76c92735"]]), gf = /* @__PURE__ */ _e({
  __name: "EmptyState",
  props: {
    icon: {},
    text: {},
    iconSize: { default: 48 },
    variant: { default: "default" }
  },
  setup(t) {
    return (e, s) => (x(), M("div", {
      class: Me([t.variant, "empty-state"])
    }, [
      f("i", {
        class: Me(t.icon),
        style: Ke({ fontSize: `${t.iconSize}px` })
      }, null, 6),
      f("span", null, fe(t.text), 1)
    ], 2));
  }
}), Jn = /* @__PURE__ */ De(gf, [["__scopeId", "data-v-5ddb0dfd"]]);
function ll() {
  const t = /* @__PURE__ */ Ns({
    visible: !1,
    message: "",
    type: "success",
    icon: "fa-solid fa-check-circle"
  });
  let e = null;
  return {
    toast: t,
    showToast: (n, i = "success") => {
      e && clearTimeout(e), t.message = n, t.type = i, t.icon = i === "success" ? "fa-solid fa-check-circle" : "fa-solid fa-circle-xmark", t.visible = !0, e = setTimeout(() => {
        t.visible = !1;
      }, 3e3);
    }
  };
}
function Ef() {
  return {
    showCreateTableModal: /* @__PURE__ */ j(!1),
    showEditTableNameModal: /* @__PURE__ */ j(!1),
    showEditTableCommentModal: /* @__PURE__ */ j(!1),
    showDropTableModal: /* @__PURE__ */ j(!1),
    showAddColumnModal: /* @__PURE__ */ j(!1),
    showEditColumnNameModal: /* @__PURE__ */ j(!1),
    showEditColumnCommentModal: /* @__PURE__ */ j(!1),
    showDropColumnModal: /* @__PURE__ */ j(!1),
    showDDLModal: /* @__PURE__ */ j(!1),
    editingColumn: /* @__PURE__ */ j(null),
    exportedDDL: /* @__PURE__ */ j("")
  };
}
const yf = ["value", "placeholder", "disabled", "readonly", "maxlength"], _f = {
  key: 0,
  class: "textarea-footer"
}, Nf = /* @__PURE__ */ _e({
  __name: "AutoResizeTextarea",
  props: {
    modelValue: { default: "" },
    placeholder: { default: "..." },
    minRows: { default: 1 },
    maxRows: { default: 15 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    maxlength: { default: void 0 },
    showCount: { type: Boolean, default: !1 },
    submitOnEnter: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "focus", "blur", "submit"],
  setup(t, { expose: e, emit: s }) {
    const n = t, i = s, o = /* @__PURE__ */ j(null), r = /* @__PURE__ */ j(null), a = /* @__PURE__ */ j(!1), l = /* @__PURE__ */ j(24), u = ie(() => (n.modelValue || "").length);
    function c() {
      const S = o.value, N = r.value;
      if (!S || !N) return;
      const R = window.getComputedStyle(S), P = parseFloat(R.lineHeight) || 24;
      l.value = P;
      const H = parseFloat(R.paddingTop) || 0, pe = parseFloat(R.paddingBottom) || 0, he = parseFloat(R.borderTopWidth) || 0, W = parseFloat(R.borderBottomWidth) || 0;
      N.style.width = `${S.clientWidth}px`, N.style.fontSize = R.fontSize, N.style.fontFamily = R.fontFamily, N.style.fontWeight = R.fontWeight, N.style.letterSpacing = R.letterSpacing, N.style.wordSpacing = R.wordSpacing, N.style.lineHeight = R.lineHeight, N.style.paddingTop = R.paddingTop, N.style.paddingBottom = R.paddingBottom, N.style.paddingLeft = R.paddingLeft, N.style.paddingRight = R.paddingRight, N.style.wordBreak = R.wordBreak, N.style.whiteSpace = "pre-wrap", N.style.overflowWrap = "break-word", N.style.boxSizing = "border-box";
      const ae = n.modelValue || "";
      N.textContent = ae + `
`;
      const me = N.scrollHeight, q = P * n.minRows + H + pe, K = P * n.maxRows + H + pe, G = Math.min(Math.max(me, q), K);
      S.style.height = `${G + he + W}px`, S.style.overflowY = me > K ? "auto" : "hidden";
    }
    function d(S) {
      const N = S.target;
      i("update:modelValue", N.value), c(), Pt(c);
    }
    function m(S) {
      a.value = !0, i("focus", S);
    }
    function h(S) {
      a.value = !1, i("blur", S);
    }
    function b(S) {
      n.submitOnEnter && S.key === "Enter" && !S.shiftKey && (S.preventDefault(), i("submit", n.modelValue || ""));
    }
    function y() {
      o.value?.focus();
    }
    function E() {
      o.value?.blur();
    }
    e({ focus: y, blur: E, adjustHeight: c }), lt(() => n.modelValue, () => {
      Pt(c);
    }), lt([() => n.minRows, () => n.maxRows], () => {
      Pt(c);
    });
    let _ = null;
    return ot(() => {
      c(), window.ResizeObserver && o.value && (_ = new ResizeObserver(() => c()), _.observe(o.value.parentElement));
    }), jt(() => {
      _?.disconnect();
    }), (S, N) => (x(), M("div", {
      class: Me(["auto-resize-wrapper", { focused: a.value, disabled: t.disabled }])
    }, [
      f("div", {
        ref_key: "mirrorRef",
        ref: r,
        class: "textarea-mirror",
        "aria-hidden": "true"
      }, null, 512),
      f("textarea", {
        ref_key: "textareaRef",
        ref: o,
        class: "auto-resize-textarea",
        value: t.modelValue,
        placeholder: t.placeholder,
        disabled: t.disabled,
        readonly: t.readonly,
        maxlength: t.maxlength,
        rows: 1,
        onInput: d,
        onFocus: m,
        onBlur: h,
        onKeydown: b
      }, null, 40, yf),
      t.showCount && t.maxlength ? (x(), M("div", _f, [
        f("span", {
          class: Me(["char-count", { warning: u.value > t.maxlength * 0.9 }])
        }, fe(u.value) + " / " + fe(t.maxlength), 3)
      ])) : ne("", !0)
    ], 2));
  }
}), Ms = /* @__PURE__ */ De(Nf, [["__scopeId", "data-v-fd129974"]]);
var Ut = /* @__PURE__ */ ((t) => (t.NUMBER = "NUMBER", t.STRING = "STRING", t))(Ut || {});
function ui() {
  const t = /* @__PURE__ */ j([]), e = ie(() => t.value.length > 0), s = (h) => t.value.find((b) => b.field === h)?.message, n = () => {
    t.value = [];
  }, i = (h, b) => {
    t.value.push({ field: h, message: b });
  }, o = (h, b) => {
    const y = h.trim();
    return y ? y.length > 64 ? (i("tableName", "64"), !1) : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(y) ? b?.checkTableNameExists && b.checkTableNameExists(y) ? b.excludeName && y === b.excludeName ? !0 : (i("tableName", ` "${y}" `), !1) : !0 : (i("tableName", ""), !1) : (i("tableName", ""), !1);
  }, r = (h, b) => {
    const y = h.trim();
    return y ? y.length > 64 ? (i("columnName", "64"), !1) : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(y) ? b?.checkColumnNameExists && b.checkColumnNameExists(y) ? b.excludeName && y === b.excludeName ? !0 : (i("columnName", ` "${y}" `), !1) : !0 : (i("columnName", ""), !1) : (i("columnName", ""), !1);
  }, a = (h) => {
    const b = h.map((_) => _.name.trim()).filter((_) => _), y = [], E = /* @__PURE__ */ new Set();
    for (const _ of b)
      E.has(_) && (y.includes(_) || y.push(_)), E.add(_);
    return y.length > 0 ? (i("columns", `: ${y.join(", ")}`), !1) : !0;
  };
  return {
    errors: t,
    hasErrors: e,
    getFieldError: s,
    clearErrors: n,
    addError: i,
    validateTableName: o,
    validateColumnName: r,
    validateDuplicateColumnNames: a,
    validateCreateTableForm: (h, b, y) => {
      n();
      const E = y.map((_) => _.tableName);
      return o(h, {
        checkTableNameExists: (_) => E.includes(_)
      }), b.length === 0 && i("columns", ""), b.forEach((_, S) => {
        const N = _.name.trim();
        N ? /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(N) || i(`column_${S}`, ` "${N}" `) : i(`column_${S}`, ` ${S + 1} `);
      }), a(b), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateAddColumnForm: (h, b) => {
      n();
      const y = b.map((E) => E.name);
      return r(h, {
        checkColumnNameExists: (E) => y.includes(E)
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateEditTableNameForm: (h, b, y) => {
      n();
      const E = y.map((_) => _.tableName);
      return o(h, {
        checkTableNameExists: (_) => E.includes(_),
        excludeName: b
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateEditColumnNameForm: (h, b, y) => {
      n();
      const E = y.map((_) => _.name);
      return r(h, {
        checkColumnNameExists: (_) => E.includes(_),
        excludeName: b
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateComment: (h, b = 500) => h && h.length > b ? (i("comment", ` ${b} `), !1) : !0
  };
}
const Tf = { class: "form-container" }, xf = { class: "form-section" }, wf = { class: "form-item" }, Sf = {
  key: 0,
  class: "field-error"
}, Cf = { class: "form-item" }, Df = { class: "form-section columns-section" }, Of = { class: "section-header" }, $f = { class: "column-count" }, Af = {
  key: 0,
  class: "field-error section-error"
}, Vf = { class: "columns-list" }, Rf = { class: "column-card-header" }, If = { class: "column-number" }, Mf = ["onClick"], Lf = { class: "column-card-body" }, kf = { class: "form-row" }, Pf = { class: "form-col form-col-name" }, Bf = ["onUpdate:modelValue"], Uf = { class: "form-col form-col-type" }, Ff = ["onUpdate:modelValue"], jf = ["value"], qf = ["value"], Wf = {
  key: 0,
  class: "field-error"
}, Hf = { class: "form-row" }, Kf = { class: "form-col form-col-default" }, zf = ["onUpdate:modelValue"], Gf = { class: "form-col form-col-comment" }, Yf = { class: "checkbox-label" }, Jf = ["onUpdate:modelValue"], Qf = { class: "form-actions" }, Xf = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Zf = "auto", ep = /* @__PURE__ */ _e({
  __name: "CreateTableForm",
  props: {
    existingTables: { default: () => [] }
  },
  emits: ["create", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateCreateTableForm: o, clearErrors: r } = ui(), a = /* @__PURE__ */ j(!1), l = /* @__PURE__ */ j(!1), u = () => {
      l.value = window.innerWidth <= 768;
    };
    ot(() => {
      u(), window.addEventListener("resize", u);
    }), jt(() => {
      window.removeEventListener("resize", u);
    });
    const c = ie(() => l.value ? "100%" : "50vw"), d = ie(() => {
      const S = {};
      return S["--form-modal-width"] = l.value ? "100%" : "50vw", S;
    });
    let m = 0;
    const h = /* @__PURE__ */ Ns({
      tableName: "",
      comment: "",
      columns: []
    }), b = () => {
      h.columns.push({
        id: ++m,
        name: "",
        type: Ut.STRING,
        primitiveKey: !1,
        comment: ""
      });
    }, y = (S) => {
      h.columns.splice(S, 1);
    }, E = () => {
      if (r(), a.value = !0, !o(
        h.tableName,
        h.columns,
        s.existingTables
      ).valid) {
        a.value = !1;
        return;
      }
      const N = h.columns.map((R) => ({
        name: R.name.trim(),
        type: R.type,
        primitiveKey: R.primitiveKey,
        defaultValue: R.defaultValue || void 0,
        comment: R.comment || void 0
      }));
      n("create", {
        tableName: h.tableName.trim(),
        columns: N,
        comment: h.comment.trim() || void 0
      }), a.value = !1;
    }, _ = () => {
      r(), n("cancel");
    };
    return h.columns.length === 0 && b(), (S, N) => (x(), M("div", {
      class: "form-wrapper",
      style: Ke(d.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: c.value,
        height: Zf,
        closable: !1,
        onClose: _
      }, {
        default: k(() => [
          f("div", Tf, [
            f("div", xf, [
              f("div", wf, [
                N[3] || (N[3] = f("label", { class: "form-label" }, [
                  oe("  "),
                  f("span", { class: "required" }, "*")
                ], -1)),
                it(f("input", {
                  "onUpdate:modelValue": N[0] || (N[0] = (R) => h.tableName = R),
                  class: Me(["form-input", { "has-error": Q(i)("tableName") }]),
                  type: "text",
                  placeholder: "user_info"
                }, null, 2), [
                  [gt, h.tableName]
                ]),
                Q(i)("tableName") ? (x(), M("div", Sf, [
                  N[2] || (N[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                  oe(" " + fe(Q(i)("tableName")), 1)
                ])) : ne("", !0),
                N[4] || (N[4] = f("div", { class: "field-hint" }, "", -1))
              ]),
              f("div", Cf, [
                N[5] || (N[5] = f("label", { class: "form-label" }, "", -1)),
                w(Ms, {
                  modelValue: h.comment,
                  "onUpdate:modelValue": N[1] || (N[1] = (R) => h.comment = R),
                  placeholder: "",
                  "min-rows": 2,
                  "max-rows": 6
                }, null, 8, ["modelValue"]),
                N[6] || (N[6] = f("div", { class: "field-hint" }, "", -1))
              ])
            ]),
            f("div", Df, [
              f("div", Of, [
                N[7] || (N[7] = f("label", { class: "form-label" }, [
                  oe("  "),
                  f("span", { class: "required" }, "*")
                ], -1)),
                f("span", $f, fe(h.columns.length) + " ", 1)
              ]),
              Q(i)("columns") ? (x(), M("div", Af, [
                N[8] || (N[8] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                oe(" " + fe(Q(i)("columns")), 1)
              ])) : ne("", !0),
              f("div", Vf, [
                (x(!0), M(Ae, null, Jt(h.columns, (R, P) => (x(), M("div", {
                  key: R.id,
                  class: Me(["column-card", { "has-error": Q(i)(`column_${P}`) }])
                }, [
                  f("div", Rf, [
                    f("span", If, "#" + fe(P + 1), 1),
                    f("button", {
                      class: "remove-btn",
                      onClick: (H) => y(P),
                      title: ""
                    }, [...N[9] || (N[9] = [
                      f("i", { class: "fa-solid fa-trash" }, null, -1)
                    ])], 8, Mf)
                  ]),
                  f("div", Lf, [
                    f("div", kf, [
                      f("div", Pf, [
                        N[10] || (N[10] = f("label", { class: "field-label" }, [
                          oe(" "),
                          f("span", { class: "required" }, "*")
                        ], -1)),
                        it(f("input", {
                          "onUpdate:modelValue": (H) => R.name = H,
                          class: "form-input",
                          type: "text",
                          placeholder: ""
                        }, null, 8, Bf), [
                          [gt, R.name]
                        ])
                      ]),
                      f("div", Uf, [
                        N[11] || (N[11] = f("label", { class: "field-label" }, "", -1)),
                        it(f("select", {
                          "onUpdate:modelValue": (H) => R.type = H,
                          class: "form-select"
                        }, [
                          f("option", {
                            value: Q(Ut).STRING
                          }, "STRING", 8, jf),
                          f("option", {
                            value: Q(Ut).NUMBER
                          }, "NUMBER", 8, qf)
                        ], 8, Ff), [
                          [ho, R.type]
                        ])
                      ])
                    ]),
                    Q(i)(`column_${P}`) ? (x(), M("div", Wf, [
                      N[12] || (N[12] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                      oe(" " + fe(Q(i)(`column_${P}`)), 1)
                    ])) : ne("", !0),
                    f("div", Hf, [
                      f("div", Kf, [
                        N[13] || (N[13] = f("label", { class: "field-label" }, "", -1)),
                        it(f("input", {
                          "onUpdate:modelValue": (H) => R.defaultValue = H,
                          class: "form-input",
                          type: "text",
                          placeholder: ""
                        }, null, 8, zf), [
                          [gt, R.defaultValue]
                        ])
                      ]),
                      f("div", Gf, [
                        N[14] || (N[14] = f("label", { class: "field-label" }, "", -1)),
                        w(Ms, {
                          modelValue: R.comment,
                          "onUpdate:modelValue": (H) => R.comment = H,
                          placeholder: "",
                          "min-rows": 1,
                          "max-rows": 4
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ])
                    ]),
                    f("label", Yf, [
                      it(f("input", {
                        "onUpdate:modelValue": (H) => R.primitiveKey = H,
                        type: "checkbox"
                      }, null, 8, Jf), [
                        [po, R.primitiveKey]
                      ]),
                      N[15] || (N[15] = f("span", null, "", -1))
                    ])
                  ])
                ], 2))), 128)),
                f("button", {
                  class: "add-column-btn",
                  onClick: b
                }, [...N[16] || (N[16] = [
                  f("i", { class: "fa-solid fa-plus" }, null, -1),
                  f("span", null, "", -1)
                ])])
              ])
            ]),
            f("div", Qf, [
              w(ce, { onClick: _ }, {
                default: k(() => [...N[17] || (N[17] = [
                  oe("", -1)
                ])]),
                _: 1
              }),
              w(ce, {
                type: "primary",
                disabled: a.value,
                onClick: E
              }, {
                default: k(() => [
                  a.value ? (x(), M("i", Xf)) : ne("", !0),
                  N[18] || (N[18] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), tp = /* @__PURE__ */ De(ep, [["__scopeId", "data-v-08eccbfb"]]), sp = { class: "form-container" }, np = { class: "form-item" }, ip = ["value"], op = { class: "form-item" }, rp = {
  key: 0,
  class: "field-error"
}, ap = { class: "form-actions" }, lp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, cp = "auto", up = /* @__PURE__ */ _e({
  __name: "EditTableNameForm",
  props: {
    tableName: {},
    existingTables: { default: () => [] }
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateEditTableNameForm: o, clearErrors: r } = ui(), a = /* @__PURE__ */ j(!1), l = /* @__PURE__ */ j(s.tableName), u = /* @__PURE__ */ j(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    ot(() => {
      c(), window.addEventListener("resize", c);
    }), jt(() => {
      window.removeEventListener("resize", c);
    });
    const d = ie(() => u.value ? "100%" : "50vw"), m = ie(() => {
      const E = {};
      return E["--form-modal-width"] = u.value ? "100%" : "50vw", E;
    }), h = ie(() => l.value.trim() !== s.tableName);
    lt(() => s.tableName, (E) => {
      l.value = E, r();
    });
    const b = () => {
      if (r(), a.value = !0, !o(
        l.value,
        s.tableName,
        s.existingTables
      ).valid) {
        a.value = !1;
        return;
      }
      n("save", l.value.trim()), a.value = !1;
    }, y = () => {
      l.value = s.tableName, r(), n("cancel");
    };
    return (E, _) => (x(), M("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: cp,
        closable: !1,
        onClose: y
      }, {
        default: k(() => [
          f("div", sp, [
            f("div", np, [
              _[1] || (_[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.tableName,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, ip)
            ]),
            f("div", op, [
              _[3] || (_[3] = f("label", { class: "form-label" }, [
                oe("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              it(f("input", {
                "onUpdate:modelValue": _[0] || (_[0] = (S) => l.value = S),
                class: Me(["form-input", { "has-error": Q(i)("tableName") }]),
                type: "text",
                placeholder: ""
              }, null, 2), [
                [gt, l.value]
              ]),
              Q(i)("tableName") ? (x(), M("div", rp, [
                _[2] || (_[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                oe(" " + fe(Q(i)("tableName")), 1)
              ])) : ne("", !0),
              _[4] || (_[4] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", ap, [
              w(ce, { onClick: y }, {
                default: k(() => [..._[5] || (_[5] = [
                  oe("", -1)
                ])]),
                _: 1
              }),
              w(ce, {
                type: "primary",
                disabled: a.value || !h.value,
                onClick: b
              }, {
                default: k(() => [
                  a.value ? (x(), M("i", lp)) : ne("", !0),
                  _[6] || (_[6] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), dp = /* @__PURE__ */ De(up, [["__scopeId", "data-v-58e374f4"]]), fp = { class: "form-container" }, pp = { class: "form-item" }, hp = { class: "form-actions" }, mp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, vp = "auto", bp = /* @__PURE__ */ _e({
  __name: "EditTableCommentForm",
  props: {
    comment: {}
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ j(s.comment || ""), o = /* @__PURE__ */ j(!1), r = /* @__PURE__ */ j(!1), a = () => {
      r.value = window.innerWidth <= 768;
    };
    ot(() => {
      a(), window.addEventListener("resize", a);
    }), jt(() => {
      window.removeEventListener("resize", a);
    });
    const l = ie(() => r.value ? "100%" : "50vw"), u = ie(() => {
      const m = {};
      return m["--form-modal-width"] = r.value ? "100%" : "50vw", m;
    }), c = () => {
      o.value = !0, n("save", i.value), o.value = !1;
    }, d = () => {
      i.value = s.comment || "", n("cancel");
    };
    return (m, h) => (x(), M("div", {
      class: "form-wrapper",
      style: Ke(u.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: l.value,
        height: vp,
        closable: !1,
        onClose: d
      }, {
        default: k(() => [
          f("div", fp, [
            f("div", pp, [
              h[1] || (h[1] = f("label", { class: "form-label" }, "", -1)),
              w(Ms, {
                modelValue: i.value,
                "onUpdate:modelValue": h[0] || (h[0] = (b) => i.value = b),
                placeholder: "",
                maxlength: 500,
                "show-count": !0,
                "min-rows": 3,
                "max-rows": 10
              }, null, 8, ["modelValue"])
            ]),
            f("div", hp, [
              w(ce, { onClick: d }, {
                default: k(() => [...h[2] || (h[2] = [
                  oe("", -1)
                ])]),
                _: 1
              }),
              w(ce, {
                type: "primary",
                disabled: o.value,
                onClick: c
              }, {
                default: k(() => [
                  o.value ? (x(), M("i", mp)) : ne("", !0),
                  h[3] || (h[3] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), gp = /* @__PURE__ */ De(bp, [["__scopeId", "data-v-03532044"]]), Ep = { class: "confirm-container" }, yp = { class: "confirm-content" }, _p = { class: "confirm-message" }, Np = { class: "form-actions" }, Tp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, xp = /* @__PURE__ */ _e({
  __name: "DropTableConfirm",
  props: {
    tableName: {},
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ j(!1), o = ie(() => {
      const l = {};
      return s.modalWidth && (l["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (l["--confirm-modal-height"] = s.modalHeight), l;
    }), r = () => {
      i.value = !0, n("confirm");
    }, a = () => {
      n("cancel");
    };
    return (l, u) => (x(), M("div", {
      class: "drop-table-confirm-wrapper",
      style: Ke(o.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: a
      }, {
        default: k(() => [
          f("div", Ep, [
            u[5] || (u[5] = f("div", { class: "confirm-icon-wrapper" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" })
            ], -1)),
            f("div", yp, [
              f("div", _p, [
                u[0] || (u[0] = oe("  ", -1)),
                f("strong", null, fe(t.tableName), 1),
                u[1] || (u[1] = oe("  ", -1))
              ]),
              u[2] || (u[2] = f("div", { class: "confirm-warning" }, [
                f("i", { class: "fa-solid fa-circle-info" }),
                f("span", null, "")
              ], -1))
            ]),
            f("div", Np, [
              w(ce, { onClick: a }, {
                default: k(() => [...u[3] || (u[3] = [
                  oe("", -1)
                ])]),
                _: 1
              }),
              w(ce, {
                type: "danger",
                disabled: i.value,
                onClick: r
              }, {
                default: k(() => [
                  i.value ? (x(), M("i", Tp)) : ne("", !0),
                  u[4] || (u[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), wp = /* @__PURE__ */ De(xp, [["__scopeId", "data-v-4629727b"]]), Sp = { class: "form-container" }, Cp = { class: "form-item" }, Dp = {
  key: 0,
  class: "field-error"
}, Op = { class: "form-item" }, $p = ["value"], Ap = ["value"], Vp = { class: "form-item" }, Rp = { class: "checkbox-label" }, Ip = { class: "form-item" }, Mp = { class: "form-item" }, Lp = { class: "form-actions" }, kp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Pp = "auto", Bp = /* @__PURE__ */ _e({
  __name: "AddColumnForm",
  props: {
    existingColumns: { default: () => [] }
  },
  emits: ["create", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateAddColumnForm: o, clearErrors: r } = ui(), a = /* @__PURE__ */ j(!1), l = /* @__PURE__ */ Ns({
      name: "",
      type: Ut.STRING,
      primitiveKey: !1
    }), u = /* @__PURE__ */ j(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    ot(() => {
      c(), window.addEventListener("resize", c);
    }), jt(() => {
      window.removeEventListener("resize", c);
    });
    const d = ie(() => u.value ? "100%" : "50vw"), m = ie(() => {
      const y = {};
      return y["--form-modal-width"] = u.value ? "100%" : "50vw", y;
    }), h = () => {
      if (r(), a.value = !0, !o(l.name, s.existingColumns).valid) {
        a.value = !1;
        return;
      }
      const E = {
        name: l.name.trim(),
        type: l.type,
        primitiveKey: l.primitiveKey,
        defaultValue: l.defaultValue || void 0,
        comment: l.comment || void 0
      };
      n("create", E), a.value = !1;
    }, b = () => {
      r(), n("cancel");
    };
    return (y, E) => (x(), M("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: Pp,
        closable: !1,
        onClose: b
      }, {
        default: k(() => [
          f("div", Sp, [
            f("div", Cp, [
              E[6] || (E[6] = f("label", { class: "form-label" }, [
                oe("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              it(f("input", {
                "onUpdate:modelValue": E[0] || (E[0] = (_) => l.name = _),
                class: Me(["form-input", { "has-error": Q(i)("columnName") }]),
                type: "text",
                placeholder: "username"
              }, null, 2), [
                [gt, l.name]
              ]),
              Q(i)("columnName") ? (x(), M("div", Dp, [
                E[5] || (E[5] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                oe(" " + fe(Q(i)("columnName")), 1)
              ])) : ne("", !0),
              E[7] || (E[7] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Op, [
              E[8] || (E[8] = f("label", { class: "form-label" }, "", -1)),
              it(f("select", {
                "onUpdate:modelValue": E[1] || (E[1] = (_) => l.type = _),
                class: "form-select"
              }, [
                f("option", {
                  value: Q(Ut).STRING
                }, "STRING", 8, $p),
                f("option", {
                  value: Q(Ut).NUMBER
                }, "NUMBER", 8, Ap)
              ], 512), [
                [ho, l.type]
              ])
            ]),
            f("div", Vp, [
              f("label", Rp, [
                it(f("input", {
                  "onUpdate:modelValue": E[2] || (E[2] = (_) => l.primitiveKey = _),
                  type: "checkbox"
                }, null, 512), [
                  [po, l.primitiveKey]
                ]),
                E[9] || (E[9] = f("span", null, "", -1))
              ])
            ]),
            f("div", Ip, [
              E[10] || (E[10] = f("label", { class: "form-label" }, "", -1)),
              it(f("input", {
                "onUpdate:modelValue": E[3] || (E[3] = (_) => l.defaultValue = _),
                class: "form-input",
                type: "text",
                placeholder: ""
              }, null, 512), [
                [gt, l.defaultValue]
              ]),
              E[11] || (E[11] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Mp, [
              E[12] || (E[12] = f("label", { class: "form-label" }, "", -1)),
              w(Ms, {
                modelValue: l.comment,
                "onUpdate:modelValue": E[4] || (E[4] = (_) => l.comment = _),
                placeholder: "",
                "min-rows": 1,
                "max-rows": 4
              }, null, 8, ["modelValue"])
            ]),
            f("div", Lp, [
              w(ce, { onClick: b }, {
                default: k(() => [...E[13] || (E[13] = [
                  oe("", -1)
                ])]),
                _: 1
              }),
              w(ce, {
                type: "primary",
                disabled: a.value,
                onClick: h
              }, {
                default: k(() => [
                  a.value ? (x(), M("i", kp)) : ne("", !0),
                  E[14] || (E[14] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Up = /* @__PURE__ */ De(Bp, [["__scopeId", "data-v-019138f2"]]), Fp = { class: "form-container" }, jp = { class: "form-item" }, qp = ["value"], Wp = { class: "form-item" }, Hp = {
  key: 0,
  class: "field-error"
}, Kp = { class: "form-actions" }, zp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Gp = "auto", Yp = /* @__PURE__ */ _e({
  __name: "EditColumnNameForm",
  props: {
    column: {},
    existingColumns: { default: () => [] }
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateEditColumnNameForm: o, clearErrors: r } = ui(), a = /* @__PURE__ */ j(!1), l = /* @__PURE__ */ j(s.column.name), u = /* @__PURE__ */ j(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    ot(() => {
      c(), window.addEventListener("resize", c);
    }), jt(() => {
      window.removeEventListener("resize", c);
    });
    const d = ie(() => u.value ? "100%" : "50vw"), m = ie(() => {
      const E = {};
      return E["--form-modal-width"] = u.value ? "100%" : "50vw", E;
    }), h = ie(() => l.value.trim() !== s.column.name);
    lt(() => s.column, (E) => {
      l.value = E.name, r();
    }, { deep: !0 });
    const b = () => {
      if (r(), a.value = !0, !o(
        l.value,
        s.column.name,
        s.existingColumns
      ).valid) {
        a.value = !1;
        return;
      }
      n("save", l.value.trim()), a.value = !1;
    }, y = () => {
      l.value = s.column.name, r(), n("cancel");
    };
    return (E, _) => (x(), M("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: Gp,
        closable: !1,
        onClose: y
      }, {
        default: k(() => [
          f("div", Fp, [
            f("div", jp, [
              _[1] || (_[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.column.name,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, qp)
            ]),
            f("div", Wp, [
              _[3] || (_[3] = f("label", { class: "form-label" }, [
                oe("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              it(f("input", {
                "onUpdate:modelValue": _[0] || (_[0] = (S) => l.value = S),
                class: Me(["form-input", { "has-error": Q(i)("columnName") }]),
                type: "text",
                placeholder: ""
              }, null, 2), [
                [gt, l.value]
              ]),
              Q(i)("columnName") ? (x(), M("div", Hp, [
                _[2] || (_[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                oe(" " + fe(Q(i)("columnName")), 1)
              ])) : ne("", !0),
              _[4] || (_[4] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Kp, [
              w(ce, { onClick: y }, {
                default: k(() => [..._[5] || (_[5] = [
                  oe("", -1)
                ])]),
                _: 1
              }),
              w(ce, {
                type: "primary",
                disabled: a.value || !h.value,
                onClick: b
              }, {
                default: k(() => [
                  a.value ? (x(), M("i", zp)) : ne("", !0),
                  _[6] || (_[6] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Jp = /* @__PURE__ */ De(Yp, [["__scopeId", "data-v-36708f97"]]), Qp = { class: "form-container" }, Xp = { class: "form-item" }, Zp = ["value"], eh = { class: "form-item" }, th = { class: "form-actions" }, sh = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, nh = "auto", ih = /* @__PURE__ */ _e({
  __name: "EditColumnCommentForm",
  props: {
    column: {}
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ j(s.column.comment || ""), o = /* @__PURE__ */ j(!1), r = /* @__PURE__ */ j(!1), a = () => {
      r.value = window.innerWidth <= 768;
    };
    ot(() => {
      a(), window.addEventListener("resize", a);
    }), jt(() => {
      window.removeEventListener("resize", a);
    });
    const l = ie(() => r.value ? "100%" : "50vw"), u = ie(() => {
      const m = {};
      return m["--form-modal-width"] = r.value ? "100%" : "50vw", m;
    }), c = () => {
      o.value = !0, n("save", i.value), o.value = !1;
    }, d = () => {
      i.value = s.column.comment || "", n("cancel");
    };
    return (m, h) => (x(), M("div", {
      class: "form-wrapper",
      style: Ke(u.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: l.value,
        height: nh,
        closable: !1,
        onClose: d
      }, {
        default: k(() => [
          f("div", Qp, [
            f("div", Xp, [
              h[1] || (h[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.column.name,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, Zp)
            ]),
            f("div", eh, [
              h[2] || (h[2] = f("label", { class: "form-label" }, "", -1)),
              w(Ms, {
                modelValue: i.value,
                "onUpdate:modelValue": h[0] || (h[0] = (b) => i.value = b),
                placeholder: "",
                maxlength: 500,
                "show-count": !0,
                "min-rows": 3,
                "max-rows": 10
              }, null, 8, ["modelValue"])
            ]),
            f("div", th, [
              w(ce, { onClick: d }, {
                default: k(() => [...h[3] || (h[3] = [
                  oe("", -1)
                ])]),
                _: 1
              }),
              w(ce, {
                type: "primary",
                disabled: o.value,
                onClick: c
              }, {
                default: k(() => [
                  o.value ? (x(), M("i", sh)) : ne("", !0),
                  h[4] || (h[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), oh = /* @__PURE__ */ De(ih, [["__scopeId", "data-v-1f79f493"]]), rh = { class: "confirm-container" }, ah = { class: "confirm-content" }, lh = { class: "confirm-message" }, ch = { class: "form-actions" }, uh = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, dh = /* @__PURE__ */ _e({
  __name: "DropColumnConfirm",
  props: {
    column: {},
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ j(!1), o = ie(() => {
      const l = {};
      return s.modalWidth && (l["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (l["--confirm-modal-height"] = s.modalHeight), l;
    }), r = () => {
      i.value = !0, n("confirm");
    }, a = () => {
      n("cancel");
    };
    return (l, u) => (x(), M("div", {
      class: "drop-column-confirm-wrapper",
      style: Ke(o.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: a
      }, {
        default: k(() => [
          f("div", rh, [
            u[5] || (u[5] = f("div", { class: "confirm-icon-wrapper" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" })
            ], -1)),
            f("div", ah, [
              f("div", lh, [
                u[0] || (u[0] = oe("  ", -1)),
                f("strong", null, fe(t.column.name), 1),
                u[1] || (u[1] = oe("  ", -1))
              ]),
              u[2] || (u[2] = f("div", { class: "confirm-warning" }, [
                f("i", { class: "fa-solid fa-circle-info" }),
                f("span", null, "")
              ], -1))
            ]),
            f("div", ch, [
              w(ce, { onClick: a }, {
                default: k(() => [...u[3] || (u[3] = [
                  oe("", -1)
                ])]),
                _: 1
              }),
              w(ce, {
                type: "danger",
                disabled: i.value,
                onClick: r
              }, {
                default: k(() => [
                  i.value ? (x(), M("i", uh)) : ne("", !0),
                  u[4] || (u[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), fh = /* @__PURE__ */ De(dh, [["__scopeId", "data-v-7565defa"]]), ph = { class: "ddl-container" }, hh = { class: "ddl-header" }, mh = { class: "ddl-content" }, vh = { class: "ddl-code" }, bh = { class: "form-actions" }, gh = /* @__PURE__ */ _e({
  __name: "DDLDisplay",
  props: {
    ddl: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ j(!1);
    let o = null;
    const r = async () => {
      try {
        await navigator.clipboard.writeText(s.ddl), i.value = !0, o && clearTimeout(o), o = setTimeout(() => {
          i.value = !1;
        }, 2e3);
      } catch (l) {
        console.error(":", l);
      }
    }, a = () => {
      n("close");
    };
    return (l, u) => (x(), M("div", ph, [
      f("div", hh, [
        u[0] || (u[0] = f("span", { class: "ddl-title" }, "DDL ", -1)),
        f("button", {
          class: "copy-btn",
          onClick: r
        }, [
          f("i", {
            class: Me(i.value ? "fa-solid fa-check" : "fa-solid fa-copy")
          }, null, 2),
          oe(" " + fe(i.value ? "" : ""), 1)
        ])
      ]),
      f("div", mh, [
        f("pre", vh, fe(t.ddl), 1)
      ]),
      f("div", bh, [
        w(ce, { onClick: a }, {
          default: k(() => [...u[1] || (u[1] = [
            oe("", -1)
          ])]),
          _: 1
        })
      ])
    ]));
  }
}), Eh = /* @__PURE__ */ De(gh, [["__scopeId", "data-v-da039aee"]]), yh = { class: "table-management-tab" }, _h = {
  key: 1,
  class: "table-detail"
}, Nh = { class: "table-header" }, Th = { class: "table-title-section" }, xh = { class: "table-name-row" }, wh = { class: "table-name" }, Sh = {
  key: 0,
  class: "table-comment-row"
}, Ch = { class: "table-comment" }, Dh = {
  key: 1,
  class: "table-comment-row"
}, Oh = { class: "table-actions" }, $h = { class: "columns-section" }, Ah = { class: "section-header" }, Vh = { class: "columns-list" }, Rh = { key: 1 }, Ih = { class: "column-main" }, Mh = { class: "column-first-row" }, Lh = { class: "column-name-wrapper" }, kh = { class: "column-name" }, Ph = { class: "type-badge" }, Bh = {
  key: 0,
  class: "primary-key-badge",
  title: ""
}, Uh = {
  key: 0,
  class: "column-comment"
}, Fh = {
  key: 1,
  class: "default-value"
}, jh = { class: "column-actions" }, qh = /* @__PURE__ */ _e({
  __name: "TableManagementTab",
  props: {
    tableService: {},
    tables: {},
    selectedTable: {}
  },
  emits: ["refresh", "update:selectedTable"],
  setup(t, { expose: e, emit: s }) {
    const n = t, i = s, o = ie(() => n.tables.find((X) => X.tableName === n.selectedTable) || {}), r = ie(() => o.value.columnSchemas ? Object.entries(o.value.columnSchemas).map(([X, I]) => [parseInt(X), I]) : []), a = ie(() => o.value.columnSchemas ? Object.values(o.value.columnSchemas) : []), l = ie(() => !o.value.columnSchemas || !R.value ? [] : Object.values(o.value.columnSchemas).filter((X) => X.name !== R.value?.column.name)), { toast: u, showToast: c } = ll(), {
      showCreateTableModal: d,
      showEditTableNameModal: m,
      showEditTableCommentModal: h,
      showDropTableModal: b,
      showAddColumnModal: y,
      showEditColumnNameModal: E,
      showEditColumnCommentModal: _,
      showDropColumnModal: S,
      showDDLModal: N,
      editingColumn: R,
      exportedDDL: P
    } = Ef(), H = (X) => X === null ? "NULL" : X === void 0 ? "" : String(X), pe = (X) => {
      const I = n.tableService.createTable(X.tableName, X.columns, X.comment);
      I.success ? (d.value = !1, i("refresh"), c(` "${X.tableName}" `)) : c(I.message || "", "error");
    }, he = (X) => {
      if (o.value.tableName) {
        const I = n.tableService.alterTableName(o.value.tableName, X);
        I.success ? (m.value = !1, i("update:selectedTable", X), i("refresh"), c("")) : c(I.message || "", "error");
      }
    }, W = (X) => {
      if (o.value.tableName) {
        const I = n.tableService.alterTableComment(o.value.tableName, X);
        I.success ? (h.value = !1, i("refresh"), c("")) : c(I.message || "", "error");
      }
    }, ae = () => {
      if (o.value.tableName) {
        const X = n.tableService.dropTable(o.value.tableName);
        X.success ? (b.value = !1, i("update:selectedTable", ""), i("refresh"), c("")) : c(X.message || "", "error");
      }
    }, me = (X) => {
      if (o.value.tableName) {
        const I = n.tableService.addColumn(o.value.tableName, X.name, X);
        I.success ? (y.value = !1, i("refresh"), c(` "${X.name}" `)) : c(I.message || "", "error");
      }
    }, q = (X, I) => {
      R.value = { fieldId: X, column: I }, E.value = !0;
    }, K = (X) => {
      if (o.value.tableName && R.value) {
        const I = n.tableService.alterColumnName(
          o.value.tableName,
          R.value.column.name,
          X
        );
        I.success ? (E.value = !1, R.value = null, i("refresh"), c("")) : c(I.message || "", "error");
      }
    }, G = (X, I) => {
      R.value = { fieldId: X, column: I }, _.value = !0;
    }, ue = (X) => {
      if (o.value.tableName && R.value) {
        const I = n.tableService.alterColumnComment(
          o.value.tableName,
          R.value.column.name,
          X
        );
        I.success ? (_.value = !1, R.value = null, i("refresh"), c("")) : c(I.message || "", "error");
      }
    }, ve = (X, I) => {
      R.value = { fieldId: X, column: I }, S.value = !0;
    }, Y = () => {
      if (o.value.tableName && R.value) {
        const X = n.tableService.dropColumn(
          o.value.tableName,
          R.value.column.name
        );
        X.success ? (S.value = !1, R.value = null, i("refresh"), c("")) : c(X.message || "", "error");
      }
    }, le = () => {
      o.value.tableName && (P.value = n.tableService.exportDDL(o.value.tableName), N.value = !0);
    };
    return e({
      openCreateTableModal: () => {
        d.value = !0;
      }
    }), (X, I) => (x(), M("div", yh, [
      t.selectedTable ? (x(), M("div", _h, [
        f("div", Nh, [
          f("div", Th, [
            f("div", xh, [
              I[16] || (I[16] = f("span", { class: "table-label" }, "", -1)),
              f("span", wh, fe(o.value.tableName), 1),
              w(ce, {
                size: "small",
                onClick: I[0] || (I[0] = (Oe) => m.value = !0)
              }, {
                default: k(() => [...I[15] || (I[15] = [
                  f("i", { class: "fa-solid fa-pen" }, null, -1)
                ])]),
                _: 1
              })
            ]),
            o.value.comment ? (x(), M("div", Sh, [
              I[18] || (I[18] = f("span", { class: "table-label" }, "", -1)),
              f("span", Ch, fe(o.value.comment), 1),
              w(ce, {
                size: "small",
                onClick: I[1] || (I[1] = (Oe) => h.value = !0)
              }, {
                default: k(() => [...I[17] || (I[17] = [
                  f("i", { class: "fa-solid fa-pen" }, null, -1)
                ])]),
                _: 1
              })
            ])) : (x(), M("div", Dh, [
              I[20] || (I[20] = f("span", { class: "table-label" }, "", -1)),
              I[21] || (I[21] = f("span", { class: "table-comment placeholder" }, "", -1)),
              w(ce, {
                size: "small",
                onClick: I[2] || (I[2] = (Oe) => h.value = !0)
              }, {
                default: k(() => [...I[19] || (I[19] = [
                  f("i", { class: "fa-solid fa-plus" }, null, -1)
                ])]),
                _: 1
              })
            ]))
          ]),
          f("div", Oh, [
            w(ce, { onClick: le }, {
              default: k(() => [...I[22] || (I[22] = [
                f("i", {
                  class: "fa-solid fa-download",
                  style: { "margin-right": "6px" }
                }, null, -1),
                oe(" DDL ", -1)
              ])]),
              _: 1
            }),
            w(ce, {
              type: "danger",
              onClick: I[3] || (I[3] = (Oe) => b.value = !0)
            }, {
              default: k(() => [...I[23] || (I[23] = [
                f("i", {
                  class: "fa-solid fa-trash",
                  style: { "margin-right": "6px" }
                }, null, -1),
                oe("  ", -1)
              ])]),
              _: 1
            })
          ])
        ]),
        f("div", $h, [
          f("div", Ah, [
            I[25] || (I[25] = f("span", { class: "section-title" }, "", -1)),
            w(ce, {
              size: "small",
              onClick: I[4] || (I[4] = (Oe) => y.value = !0)
            }, {
              default: k(() => [...I[24] || (I[24] = [
                f("i", {
                  class: "fa-solid fa-plus",
                  style: { "margin-right": "4px" }
                }, null, -1),
                oe("  ", -1)
              ])]),
              _: 1
            })
          ]),
          f("div", Vh, [
            r.value.length === 0 ? (x(), Ie(Jn, {
              key: 0,
              icon: "fa-solid fa-columns",
              text: "",
              variant: "compact"
            })) : (x(), M("div", Rh, [
              (x(!0), M(Ae, null, Jt(r.value, ([Oe, He]) => (x(), M("div", {
                key: Oe,
                class: "column-item"
              }, [
                f("div", Ih, [
                  f("div", Mh, [
                    f("div", Lh, [
                      I[26] || (I[26] = f("i", { class: "fa-solid fa-hashtag column-icon" }, null, -1)),
                      f("span", kh, fe(He.name), 1)
                    ]),
                    f("span", Ph, fe(He.type), 1),
                    He.primitiveKey ? (x(), M("span", Bh, [...I[27] || (I[27] = [
                      f("i", { class: "fa-solid fa-key" }, null, -1)
                    ])])) : ne("", !0)
                  ]),
                  He.comment ? (x(), M("div", Uh, fe(He.comment), 1)) : ne("", !0),
                  He.defaultValue !== void 0 ? (x(), M("div", Fh, " : " + fe(H(He.defaultValue)), 1)) : ne("", !0)
                ]),
                f("div", jh, [
                  w(ce, {
                    size: "small",
                    title: "",
                    onClick: (ft) => q(Oe, He)
                  }, {
                    default: k(() => [...I[28] || (I[28] = [
                      f("i", { class: "fa-solid fa-pen" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"]),
                  w(ce, {
                    size: "small",
                    title: "",
                    onClick: (ft) => G(Oe, He)
                  }, {
                    default: k(() => [...I[29] || (I[29] = [
                      f("i", { class: "fa-solid fa-comment" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"]),
                  w(ce, {
                    type: "danger",
                    size: "small",
                    title: "",
                    onClick: (ft) => ve(Oe, He)
                  }, {
                    default: k(() => [...I[30] || (I[30] = [
                      f("i", { class: "fa-solid fa-trash" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"])
                ])
              ]))), 128))
            ]))
          ])
        ])
      ])) : (x(), Ie(Jn, {
        key: 0,
        icon: "fa-solid fa-table",
        text: ""
      })),
      w(al, {
        visible: Q(u).visible,
        message: Q(u).message,
        type: Q(u).type,
        icon: Q(u).icon
      }, null, 8, ["visible", "message", "type", "icon"]),
      Q(d) ? (x(), Ie(tp, {
        key: 2,
        "existing-tables": t.tables,
        onCreate: pe,
        onCancel: I[5] || (I[5] = (Oe) => d.value = !1)
      }, null, 8, ["existing-tables"])) : ne("", !0),
      Q(m) ? (x(), Ie(dp, {
        key: 3,
        "table-name": o.value.tableName,
        "existing-tables": t.tables,
        onSave: he,
        onCancel: I[6] || (I[6] = (Oe) => m.value = !1)
      }, null, 8, ["table-name", "existing-tables"])) : ne("", !0),
      Q(h) ? (x(), Ie(gp, {
        key: 4,
        comment: o.value.comment,
        onSave: W,
        onCancel: I[7] || (I[7] = (Oe) => h.value = !1)
      }, null, 8, ["comment"])) : ne("", !0),
      Q(b) ? (x(), Ie(wp, {
        key: 5,
        "table-name": o.value.tableName,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: ae,
        onCancel: I[8] || (I[8] = (Oe) => b.value = !1)
      }, null, 8, ["table-name"])) : ne("", !0),
      Q(y) ? (x(), Ie(Up, {
        key: 6,
        "existing-columns": a.value,
        onCreate: me,
        onCancel: I[9] || (I[9] = (Oe) => y.value = !1)
      }, null, 8, ["existing-columns"])) : ne("", !0),
      Q(E) && Q(R) ? (x(), Ie(Jp, {
        key: 7,
        column: Q(R).column,
        "existing-columns": l.value,
        onSave: K,
        onCancel: I[10] || (I[10] = (Oe) => E.value = !1)
      }, null, 8, ["column", "existing-columns"])) : ne("", !0),
      Q(_) && Q(R) ? (x(), Ie(oh, {
        key: 8,
        column: Q(R).column,
        onSave: ue,
        onCancel: I[11] || (I[11] = (Oe) => _.value = !1)
      }, null, 8, ["column"])) : ne("", !0),
      Q(S) && Q(R) ? (x(), Ie(fh, {
        key: 9,
        column: Q(R).column,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: Y,
        onCancel: I[12] || (I[12] = (Oe) => S.value = !1)
      }, null, 8, ["column"])) : ne("", !0),
      Q(N) ? (x(), Ie(Ge, {
        key: 10,
        visible: "",
        title: "DDL",
        onClose: I[14] || (I[14] = (Oe) => N.value = !1)
      }, {
        default: k(() => [
          w(Eh, {
            ddl: Q(P),
            onClose: I[13] || (I[13] = (Oe) => N.value = !1)
          }, null, 8, ["ddl"])
        ]),
        _: 1
      })) : ne("", !0)
    ]));
  }
}), go = /* @__PURE__ */ De(qh, [["__scopeId", "data-v-f00e195b"]]), Wh = { class: "sql-panel-tab" }, Hh = { class: "sql-editor-container" }, Kh = { class: "sql-toolbar" }, zh = { class: "sql-footer" }, Gh = { class: "editor-stats" }, Yh = { class: "stat-item" }, Jh = { class: "stat-item" }, Qh = {
  key: 0,
  class: "result-status"
}, Xh = { key: 0 }, Zh = { key: 1 }, em = /* @__PURE__ */ _e({
  __name: "SqlPanelTab",
  props: {
    sqlExecutorService: {}
  },
  emits: ["refresh"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ j(""), o = /* @__PURE__ */ j({ success: !1, message: "", data: 0, type: "DQL" }), r = ie(() => i.value.split(`
`).length), a = ie(() => i.value.length), l = ie(() => u.value && Array.isArray(o.value.data) ? o.value.data : []), u = ie(() => Array.isArray(o.value.data)), c = ie(() => o.value.success || o.value.message !== ""), d = () => {
      if (!i.value.trim()) {
        o.value = { success: !1, message: "SQL", data: 0, type: "DQL" };
        return;
      }
      try {
        o.value = s.sqlExecutorService.execute(i.value), o.value.success && n("refresh");
      } catch (m) {
        o.value = {
          success: !1,
          message: m instanceof Error ? m.message : "",
          data: 0,
          type: "DQL"
        };
      }
    };
    return (m, h) => (x(), M("div", Wh, [
      f("div", Hh, [
        f("div", Kh, [
          h[2] || (h[2] = f("span", { class: "toolbar-title" }, "SQL", -1)),
          w(ce, { onClick: d }, {
            default: k(() => [...h[1] || (h[1] = [
              f("i", {
                class: "fa-solid fa-play",
                style: { "margin-right": "6px" }
              }, null, -1),
              oe("  ", -1)
            ])]),
            _: 1
          })
        ]),
        it(f("textarea", {
          "onUpdate:modelValue": h[0] || (h[0] = (b) => i.value = b),
          class: "sql-editor",
          placeholder: "SQL...",
          spellcheck: "false"
        }, null, 512), [
          [gt, i.value]
        ]),
        f("div", zh, [
          f("div", Gh, [
            f("span", Yh, ": " + fe(r.value), 1),
            f("span", Jh, ": " + fe(a.value), 1)
          ]),
          c.value ? (x(), M("div", Qh, [
            u.value ? (x(), M("span", Xh, ": " + fe(l.value.length) + " ", 1)) : (x(), M("span", Zh, ": " + fe(o.value.data) + " ", 1))
          ])) : ne("", !0)
        ]),
        o.value.message ? (x(), M("div", {
          key: 0,
          class: Me(["result-message", { error: !o.value.success }])
        }, fe(o.value.message), 3)) : ne("", !0)
      ])
    ]));
  }
}), Eo = /* @__PURE__ */ De(em, [["__scopeId", "data-v-34ac73ac"]]);
var Vt = /* @__PURE__ */ ((t) => (t.INSERT = "insert", t.APPEND = "append", t.UPDATE = "update", t.DELETE = "delete", t))(Vt || {}), se = /* @__PURE__ */ ((t) => (t.DDL = "DDL", t.DML = "DML", t.DQL = "DQL", t.ROW = "ROW", t))(se || {}), st = /* @__PURE__ */ ((t) => (t.INSERT_SQL = "INSERT_SQL", t.ROW_JSON = "ROW_JSON", t.TABLE_SCHEMA = "TABLE_SCHEMA", t.DDL = "DDL", t.MARKDOWN = "MARKDOWN", t.STANDARD_DATA = "STANDARD_DATA", t))(st || {}), Wi = /* @__PURE__ */ ((t) => (t.INNER = "INNER", t.LEFT = "LEFT", t))(Wi || {}), di = /* @__PURE__ */ ((t) => (t.SYNTAX_ERROR = "SYNTAX_ERROR", t.VALIDATION_ERROR = "VALIDATION_ERROR", t.EXECUTION_ERROR = "EXECUTION_ERROR", t.TABLE_NOT_FOUND = "TABLE_NOT_FOUND", t.COLUMN_NOT_FOUND = "COLUMN_NOT_FOUND", t.TYPE_MISMATCH = "TYPE_MISMATCH", t))(di || {});
class yo extends Error {
  /**  */
  code;
  /** SQL */
  position;
  /** SQL */
  sql;
  constructor(e, s, n, i) {
    super(s), this.name = "SqlError", this.code = e, this.position = n, this.sql = i;
  }
}
class Sn extends yo {
  constructor(e, s, n) {
    super(di.SYNTAX_ERROR, e, s, n), this.name = "SqlSyntaxError";
  }
}
class Le extends yo {
  constructor(e, s) {
    super(di.VALIDATION_ERROR, e, void 0, s), this.name = "SqlValidationError";
  }
}
class mt extends yo {
  constructor(e, s) {
    super(di.EXECUTION_ERROR, e, void 0, s), this.name = "SqlExecutionError";
  }
}
var Z = /* @__PURE__ */ ((t) => (t.KEYWORD = "KEYWORD", t.IDENTIFIER = "IDENTIFIER", t.STRING = "STRING", t.NUMBER = "NUMBER", t.OPERATOR = "OPERATOR", t.COMMA = "COMMA", t.SEMICOLON = "SEMICOLON", t.LPAREN = "LPAREN", t.RPAREN = "RPAREN", t.DOT = "DOT", t.EOF = "EOF", t))(Z || {}), $e = /* @__PURE__ */ ((t) => (t.CREATE_TABLE = "CREATE_TABLE", t.ALTER_TABLE = "ALTER_TABLE", t.DROP_TABLE = "DROP_TABLE", t.INSERT = "INSERT", t.UPDATE = "UPDATE", t.DELETE = "DELETE", t.APPEND = "APPEND", t.SELECT = "SELECT", t.ROW = "ROW", t))($e || {}), ts = /* @__PURE__ */ ((t) => (t.ADD_COLUMN = "ADD_COLUMN", t.DROP_COLUMN = "DROP_COLUMN", t.RENAME = "RENAME", t.RENAME_COLUMN = "RENAME_COLUMN", t.MODIFY_COLUMN_COMMENT = "MODIFY_COLUMN_COMMENT", t.MODIFY_COLUMN_PRIMITIVE_KEY = "MODIFY_COLUMN_PRIMITIVE_KEY", t.ALTER_TABLE_COMMENT = "ALTER_TABLE_COMMENT", t))(ts || {});
const tm = /* @__PURE__ */ new Set([
  "SELECT",
  "FROM",
  "WHERE",
  "INSERT",
  "INTO",
  "VALUES",
  "UPDATE",
  "SET",
  "DELETE",
  "CREATE",
  "TABLE",
  "ALTER",
  "DROP",
  "ADD",
  "COLUMN",
  "RENAME",
  "TO",
  "APPEND",
  "AND",
  "OR",
  "NOT",
  "NULL",
  "IS",
  "BETWEEN",
  "IN",
  "ORDER",
  "BY",
  "ASC",
  "DESC",
  "INNER",
  "LEFT",
  "JOIN",
  "ON",
  "DISTINCT",
  "STRING",
  "NUMBER",
  "PRIMARY",
  "KEY",
  "DEFAULT",
  "COMMENT",
  "MODIFY"
]), Dr = ["=", "!=", "<>", ">", "<", ">=", "<="];
class sm {
  input;
  pos = 0;
  length;
  constructor(e) {
    this.input = e, this.length = e.length;
  }
  /**
   * 
   */
  peek(e = 0) {
    const s = this.pos + e;
    return this.input[s] ?? "";
  }
  /**
   * 
   */
  advance() {
    return this.pos >= this.length ? "" : this.input[this.pos++] ?? "";
  }
  /**
   * 
   */
  skipWhitespace() {
    for (; this.pos < this.length && /\s/.test(this.peek()); )
      this.pos++;
  }
  /**
   * 
   */
  skipComment() {
    if (this.peek() === "-" && this.peek(1) === "-")
      for (; this.pos < this.length && this.peek() !== `
`; )
        this.pos++;
  }
  /**
   * 
   */
  readIdentifier() {
    let e = "";
    for (; this.pos < this.length && /[\w]/.test(this.peek()); )
      e += this.advance();
    return e;
  }
  /**
   * 
   */
  readString(e) {
    let s = "";
    for (this.advance(); this.pos < this.length; ) {
      const n = this.peek();
      if (n === e)
        if (this.advance(), this.peek() === e)
          s += e, this.advance();
        else
          break;
      else n === "\\" ? (this.advance(), s += this.advance()) : s += this.advance();
    }
    return s;
  }
  /**
   * 
   */
  readNumber() {
    let e = "";
    for (; this.pos < this.length && /[\d.]/.test(this.peek()); )
      e += this.advance();
    return e;
  }
  /**
   * 
   */
  readOperator() {
    const e = this.peek() + this.peek(1);
    return Dr.includes(e) ? (this.advance(), this.advance(), e) : this.advance();
  }
  /**
   * Token
   */
  nextToken() {
    if (this.skipWhitespace(), this.skipComment(), this.pos >= this.length)
      return { type: Z.EOF, value: "", position: this.pos };
    const e = this.pos, s = this.peek();
    if (s === "(")
      return this.advance(), { type: Z.LPAREN, value: "(", position: e };
    if (s === ")")
      return this.advance(), { type: Z.RPAREN, value: ")", position: e };
    if (s === ",")
      return this.advance(), { type: Z.COMMA, value: ",", position: e };
    if (s === ";")
      return this.advance(), { type: Z.SEMICOLON, value: ";", position: e };
    if (s === ".")
      return this.advance(), { type: Z.DOT, value: ".", position: e };
    if (s === "'") {
      const n = this.readString(s);
      return { type: Z.STRING, value: n, position: e };
    }
    if (s === '"') {
      const n = this.readString(s);
      return { type: Z.STRING, value: n, position: e };
    }
    if (s === "*")
      return this.advance(), { type: Z.KEYWORD, value: "*", position: e };
    if (/[\d]/.test(s)) {
      const n = this.readNumber();
      return { type: Z.NUMBER, value: n, position: e };
    }
    if (/[a-zA-Z_]/.test(s)) {
      const n = this.readIdentifier(), i = n.toUpperCase();
      return tm.has(i) ? { type: Z.KEYWORD, value: i, position: e } : { type: Z.IDENTIFIER, value: n, position: e };
    }
    if (Dr.some((n) => n.startsWith(s))) {
      const n = this.readOperator();
      return { type: Z.OPERATOR, value: n, position: e };
    }
    throw new Error(`Unexpected character: ${s} at position ${e}`);
  }
  /**
   * Token
   */
  tokenize() {
    const e = [];
    let s;
    do
      s = this.nextToken(), e.push(s);
    while (s.type !== Z.EOF);
    return e;
  }
}
class Qn {
  lexer;
  current;
  peekToken;
  errors = [];
  constructor(e) {
    this.lexer = e, this.current = this.lexer.nextToken(), this.peekToken = this.lexer.nextToken();
  }
  /**
   * Token
   */
  nextToken() {
    this.current = this.peekToken, this.peekToken = this.lexer.nextToken();
  }
  /**
   * Token
   */
  isCurrentType(e) {
    return this.current.type === e;
  }
  /**
   * Token
   */
  isCurrentValue(e) {
    return (this.current.type === Z.KEYWORD || this.current.type === Z.OPERATOR) && this.current.value === e;
  }
  /**
   * Token
   */
  expectType(e) {
    if (!this.isCurrentType(e))
      throw this.errors.push(`Expected ${e}, got ${this.current.type} at position ${this.current.position}`), new Error(`Parse error at position ${this.current.position}`);
    const s = this.current;
    return this.nextToken(), s;
  }
  /**
   * Token
   */
  expectValue(e) {
    if (!this.isCurrentValue(e))
      throw this.errors.push(`Expected ${e}, got ${this.current.value} at position ${this.current.position}`), new Error(`Parse error at position ${this.current.position}`);
    const s = this.current;
    return this.nextToken(), s;
  }
  /**
   * Token
   */
  matchValue(e) {
    return this.current.value === e && (this.current.type === Z.KEYWORD || this.current.type === Z.OPERATOR || this.current.type === Z.COMMA || this.current.type === Z.SEMICOLON) ? (this.nextToken(), !0) : !1;
  }
  /**
   * 
   */
  parseIdentifier() {
    if (this.isCurrentType(Z.IDENTIFIER) || this.isCurrentType(Z.KEYWORD)) {
      const e = this.current.value;
      return this.nextToken(), e;
    }
    throw new Error(`Expected identifier at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseFieldType() {
    if (this.isCurrentValue("STRING"))
      return this.nextToken(), Ut.STRING;
    if (this.isCurrentValue("NUMBER"))
      return this.nextToken(), Ut.NUMBER;
    throw new Error(`Expected field type at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseColumnDef() {
    const e = this.parseIdentifier(), s = this.parseFieldType(), n = { name: e, type: s };
    if (this.matchValue("PRIMARY") && (this.expectValue("KEY"), n.primitiveKey = !0), this.matchValue("DEFAULT"))
      if (this.isCurrentType(Z.STRING))
        n.defaultValue = this.current.value, this.nextToken();
      else if (this.isCurrentType(Z.NUMBER))
        n.defaultValue = Number(this.current.value), this.nextToken();
      else if (this.matchValue("NULL"))
        n.defaultValue = null;
      else
        throw new Error(`Expected default value at position ${this.current.position}`);
    if (this.matchValue("COMMENT"))
      if (this.isCurrentType(Z.STRING))
        n.comment = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    return n;
  }
  /**
   * 
   */
  parseExpression() {
    return this.parseLogicalOr();
  }
  /**
   * OR
   */
  parseLogicalOr() {
    let e = this.parseLogicalAnd();
    for (; this.matchValue("OR"); ) {
      const s = this.parseLogicalAnd();
      e = { type: "binary", operator: "OR", left: e, right: s };
    }
    return e;
  }
  /**
   * AND
   */
  parseLogicalAnd() {
    let e = this.parseNot();
    for (; this.matchValue("AND"); ) {
      const s = this.parseNot();
      e = { type: "binary", operator: "AND", left: e, right: s };
    }
    return e;
  }
  /**
   * NOT
   */
  parseNot() {
    if (this.matchValue("NOT")) {
      const e = this.parseNot();
      return e.type === "binary" ? { ...e, operator: `NOT ${e.operator}` } : e;
    }
    return this.parseComparison();
  }
  /**
   * 
   */
  parseComparison() {
    let e = this.parseIs();
    const s = ["=", "!=", "<>", ">", "<", ">=", "<="];
    for (; s.includes(this.current.value); ) {
      const n = this.current.value;
      this.nextToken();
      const i = this.parseIs();
      e = { type: "binary", operator: n, left: e, right: i };
    }
    if (this.matchValue("IN")) {
      this.expectType(Z.LPAREN);
      const n = [];
      for (n.push(this.parseExpression()); this.matchValue(","); )
        n.push(this.parseExpression());
      return this.expectType(Z.RPAREN), { type: "in", value: e, values: n };
    }
    if (this.matchValue("BETWEEN")) {
      const n = this.parseAdditive();
      this.expectValue("AND");
      const i = this.parseAdditive();
      return { type: "between", value: e, min: n, max: i };
    }
    return e;
  }
  /**
   * IS
   */
  parseIs() {
    const e = this.parseAdditive();
    if (this.matchValue("IS"))
      if (this.matchValue("NOT")) {
        const s = this.parseAdditive();
        return s.type === "null" ? { type: "null", value: e, not: !0 } : { type: "binary", operator: "IS NOT", left: e, right: s };
      } else {
        const s = this.parseAdditive();
        return s.type === "null" ? { type: "null", value: e } : { type: "binary", operator: "IS", left: e, right: s };
      }
    return e;
  }
  /**
   * 
   */
  parseAdditive() {
    let e = this.parseMultiplicative();
    for (; this.current.value === "+" || this.current.value === "-"; ) {
      const s = this.current.value;
      this.nextToken();
      const n = this.parseMultiplicative();
      e = { type: "binary", operator: s, left: e, right: n };
    }
    return e;
  }
  /**
   * 
   */
  parseMultiplicative() {
    let e = this.parsePrimary();
    for (; this.current.value === "*" || this.current.value === "/"; ) {
      const s = this.current.value;
      this.nextToken();
      const n = this.parsePrimary();
      e = { type: "binary", operator: s, left: e, right: n };
    }
    return e;
  }
  /**
   * 
   */
  parsePrimary() {
    if (this.isCurrentType(Z.NUMBER)) {
      const e = Number(this.current.value);
      return this.nextToken(), { type: "value", value: e };
    }
    if (this.isCurrentType(Z.STRING)) {
      const e = this.current.value;
      return this.nextToken(), { type: "value", value: e };
    }
    if (this.matchValue("NULL"))
      return { type: "null", value: { type: "value", value: null } };
    if (this.isCurrentType(Z.IDENTIFIER) || this.isCurrentType(Z.KEYWORD))
      return this.parseColumnExpression();
    if (this.isCurrentType(Z.LPAREN)) {
      this.nextToken();
      const e = this.parseExpression();
      return this.expectType(Z.RPAREN), e;
    }
    throw new Error(`Unexpected token at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseColumnExpression() {
    const e = this.parseIdentifier();
    if (this.matchValue(".")) {
      const s = e, n = this.parseIdentifier();
      return { type: "column", tableName: s, name: n };
    }
    return { type: "column", name: e };
  }
  /**
   * CREATE TABLE
   */
  parseCreateTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    this.expectType(Z.LPAREN);
    const s = [];
    for (s.push(this.parseColumnDef()); this.matchValue(","); )
      s.push(this.parseColumnDef());
    this.expectType(Z.RPAREN);
    const n = {
      type: $e.CREATE_TABLE,
      tableName: e,
      columns: s,
      position: this.current.position
    };
    if (this.matchValue("COMMENT"))
      if (this.isCurrentType(Z.STRING))
        n.comment = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    return n;
  }
  /**
   * ALTER TABLE
   */
  parseAlterTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    let s, n, i, o, r, a;
    if (this.matchValue("ADD"))
      this.expectValue("COLUMN"), s = ts.ADD_COLUMN, i = this.parseColumnDef();
    else if (this.matchValue("DROP"))
      this.expectValue("COLUMN"), s = ts.DROP_COLUMN, n = this.parseIdentifier();
    else if (this.matchValue("RENAME"))
      this.matchValue("COLUMN") ? (s = ts.RENAME_COLUMN, n = this.parseIdentifier(), this.expectValue("TO"), r = this.parseIdentifier()) : (this.expectValue("TO"), s = ts.RENAME, o = this.parseIdentifier());
    else if (this.matchValue("MODIFY")) {
      this.expectValue("COLUMN"), n = this.parseIdentifier();
      const l = this.parseFieldType();
      let u = !1;
      if (this.matchValue("PRIMARY") && (this.expectValue("KEY"), u = !0), this.matchValue("COMMENT"))
        if (this.isCurrentType(Z.STRING))
          a = this.current.value, this.nextToken();
        else
          throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
      if (u)
        s = ts.MODIFY_COLUMN_PRIMITIVE_KEY, i = { name: n, type: l, primitiveKey: u, comment: a };
      else if (a !== void 0)
        s = ts.MODIFY_COLUMN_COMMENT;
      else
        throw new Error(`Expected PRIMARY KEY or COMMENT after MODIFY COLUMN at position ${this.current.position}`);
    } else if (this.matchValue("COMMENT"))
      if (s = ts.ALTER_TABLE_COMMENT, this.isCurrentType(Z.STRING))
        a = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    else
      throw new Error(`Expected ADD, DROP, RENAME, MODIFY COLUMN or COMMENT after ALTER TABLE at position ${this.current.position}`);
    return {
      type: $e.ALTER_TABLE,
      tableName: e,
      opType: s,
      columnName: n,
      columnDef: i,
      newTableName: o,
      newColumnName: r,
      comment: a,
      position: this.current.position
    };
  }
  /**
   * DROP TABLE
   */
  parseDropTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    return {
      type: $e.DROP_TABLE,
      tableName: e,
      position: this.current.position
    };
  }
  /**
   * INSERT
   */
  parseInsert() {
    this.expectValue("INTO");
    const e = this.parseIdentifier();
    this.expectType(Z.LPAREN);
    const s = [];
    for (s.push(this.parseIdentifier()); this.matchValue(","); )
      s.push(this.parseIdentifier());
    this.expectType(Z.RPAREN), this.expectValue("VALUES"), this.expectType(Z.LPAREN);
    const n = [], i = [];
    for (i.push(this.parseExpression()); this.matchValue(","); )
      i.push(this.parseExpression());
    for (n.push(i), this.expectType(Z.RPAREN); this.matchValue(","); ) {
      this.expectType(Z.LPAREN);
      const o = [];
      for (o.push(this.parseExpression()); this.matchValue(","); )
        o.push(this.parseExpression());
      n.push(o), this.expectType(Z.RPAREN);
    }
    return {
      type: $e.INSERT,
      tableName: e,
      columns: s,
      values: n,
      position: this.current.position
    };
  }
  /**
   * UPDATE
   */
  parseUpdate() {
    const e = this.parseIdentifier();
    this.expectValue("SET");
    const s = [], n = this.parseIdentifier();
    this.expectValue("=");
    const i = this.parseExpression();
    for (s.push({ column: n, value: i }); this.matchValue(","); ) {
      const r = this.parseIdentifier();
      this.expectValue("=");
      const a = this.parseExpression();
      s.push({ column: r, value: a });
    }
    let o;
    return this.matchValue("WHERE") && (o = this.parseExpression()), {
      type: $e.UPDATE,
      tableName: e,
      sets: s,
      where: o,
      position: this.current.position
    };
  }
  /**
   * DELETE
   */
  parseDelete() {
    this.expectValue("FROM");
    const e = this.parseIdentifier();
    let s;
    return this.matchValue("WHERE") && (s = this.parseExpression()), {
      type: $e.DELETE,
      tableName: e,
      where: s,
      position: this.current.position
    };
  }
  /**
   * APPEND
   */
  parseAppend() {
    this.expectValue("INTO");
    const e = this.parseIdentifier();
    this.expectType(Z.LPAREN);
    const s = this.parseIdentifier();
    this.expectType(Z.RPAREN), this.expectValue("VALUES");
    const n = this.parseExpression();
    let i;
    return this.matchValue("WHERE") && (i = this.parseExpression()), {
      type: $e.APPEND,
      tableName: e,
      column: s,
      value: n,
      where: i,
      position: this.current.position
    };
  }
  /**
   * SELECT
   */
  parseSelectList() {
    const e = [];
    if (this.matchValue("*"))
      e.push({ type: "star" });
    else
      for (e.push(this.parseSelectItem()); this.matchValue(","); )
        e.push(this.parseSelectItem());
    return e;
  }
  /**
   * SELECT
   */
  parseSelectItem() {
    return this.parseColumnExpression();
  }
  /**
   * JOIN
   */
  parseJoin() {
    if (this.matchValue("INNER")) {
      this.expectValue("JOIN");
      const e = this.parseIdentifier();
      this.expectValue("ON");
      const s = this.parseColumnExpression(), n = this.parseColumnExpression();
      return {
        type: Wi.INNER,
        tableName: e,
        on: { left: s, right: n }
      };
    }
    if (this.matchValue("LEFT")) {
      this.expectValue("JOIN");
      const e = this.parseIdentifier();
      this.expectValue("ON");
      const s = this.parseColumnExpression(), n = this.parseColumnExpression();
      return {
        type: Wi.LEFT,
        tableName: e,
        on: { left: s, right: n }
      };
    }
  }
  /**
   * ORDER BY
   */
  parseOrderBy() {
    if (!this.matchValue("ORDER")) return;
    this.expectValue("BY");
    const e = [];
    if (e.push({
      column: this.parseIdentifier(),
      ascending: !this.matchValue("DESC")
    }), this.matchValue("ASC")) {
      const s = e[e.length - 1];
      s && (s.ascending = !0);
    }
    for (; this.matchValue(","); )
      if (e.push({
        column: this.parseIdentifier(),
        ascending: !this.matchValue("DESC")
      }), this.matchValue("ASC")) {
        const s = e[e.length - 1];
        s && (s.ascending = !0);
      }
    return e;
  }
  /**
   * SELECT
   */
  parseSelect() {
    let e = !1;
    this.matchValue("DISTINCT") && (e = !0);
    const s = this.parseSelectList();
    this.expectValue("FROM");
    const n = this.parseIdentifier(), i = [];
    for (; ; ) {
      const a = this.parseJoin();
      if (!a) break;
      i.push(a);
    }
    let o;
    this.matchValue("WHERE") && (o = this.parseExpression());
    let r;
    return this.isCurrentValue("ORDER") && (r = this.parseOrderBy()), {
      type: $e.SELECT,
      distinct: e,
      columns: s,
      from: n,
      joins: i,
      where: o,
      orderBy: r,
      position: this.current.position
    };
  }
  /**
   * 
   */
  parseStatement() {
    return this.isCurrentValue("CREATE") ? (this.nextToken(), this.parseCreateTable()) : this.isCurrentValue("ALTER") ? (this.nextToken(), this.parseAlterTable()) : this.isCurrentValue("DROP") ? (this.nextToken(), this.parseDropTable()) : this.isCurrentValue("INSERT") ? (this.nextToken(), this.parseInsert()) : this.isCurrentValue("UPDATE") ? (this.nextToken(), this.parseUpdate()) : this.isCurrentValue("DELETE") ? (this.nextToken(), this.parseDelete()) : this.isCurrentValue("APPEND") ? (this.nextToken(), this.parseAppend()) : this.isCurrentValue("SELECT") ? (this.nextToken(), this.parseSelect()) : null;
  }
  /**
   * 
   */
  parse() {
    const e = [], s = [];
    for (; !this.isCurrentType(Z.EOF); )
      try {
        const n = this.parseStatement();
        n && e.push(n), this.matchValue(";") || this.isCurrentType(Z.EOF) || s.push(`Expected ';' at position ${this.current.position}`);
      } catch (n) {
        for (s.push(n.message); !this.isCurrentType(Z.EOF) && !this.isCurrentType(Z.SEMICOLON); )
          this.nextToken();
        this.isCurrentType(Z.SEMICOLON) && this.nextToken();
      }
    return { statements: e, errors: s };
  }
  /**
   * SQL
   */
  static parse(e) {
    const s = new sm(e);
    return new Qn(s).parse();
  }
}
class _o {
  evaluateExpression(e, s, n, i) {
    if (e.type === "value")
      return e.value;
    if (e.type === "column") {
      if (i === null)
        throw new Error("Cannot evaluate column expression without row context");
      const o = e.name, r = s.fieldName2id[o];
      if (r === void 0)
        throw new Error(`Column '${o}' does not exist`);
      return i[r];
    }
    if (e.type === "binary") {
      const o = this.evaluateExpression(e.left, s, n, i), r = this.evaluateExpression(e.right, s, n, i);
      switch (e.operator) {
        case "+":
          return Number(o) + Number(r);
        case "-":
          return Number(o) - Number(r);
        case "*":
          return Number(o) * Number(r);
        case "/":
          return Number(o) / Number(r);
        case "=":
          return o === r;
        case "!=":
        case "<>":
          return o !== r;
        case ">":
          return Number(o) > Number(r);
        case "<":
          return Number(o) < Number(r);
        case ">=":
          return Number(o) >= Number(r);
        case "<=":
          return Number(o) <= Number(r);
        case "AND":
          return !!o && !!r;
        case "OR":
          return !!o || !!r;
        case "IS":
          return o === r;
        case "IS NOT":
          return o !== r;
        default:
          throw new Error(`Unknown operator: ${e.operator}`);
      }
    }
    if (e.type === "null") {
      if (e.value && e.value.type === "value" && e.value.value === null)
        return null;
      const o = this.evaluateExpression(e.value, s, n, i);
      return e.not ? o !== null : o === null;
    }
    if (e.type === "in") {
      const o = this.evaluateExpression(e.value, s, n, i);
      return e.values.map((a) => this.evaluateExpression(a, s, n, i)).some((a) => a === o);
    }
    if (e.type === "between") {
      const o = this.evaluateExpression(e.value, s, n, i), r = this.evaluateExpression(e.min, s, n, i), a = this.evaluateExpression(e.max, s, n, i);
      return o >= r && o <= a;
    }
    throw new Error(`Unknown expression type: ${e.type}`);
  }
  evaluateWhere(e, s, n, i) {
    return !!this.evaluateExpression(e, s, n, i);
  }
}
class No {
  static exportTable(e, s) {
    if (s.length === 0)
      return `**${e.tableName}**

*()*`;
    const n = Object.keys(e.id2fieldName).map((a) => parseInt(a)), i = n.map((a) => e.id2fieldName[a]), o = i.map(() => "---"), r = [];
    for (const a of s) {
      const l = [];
      for (const u of n) {
        const c = a[u];
        l.push(No.formatValue(c));
      }
      r.push(l.join(" | "));
    }
    return `**${e.tableName}**

| ${i.join(" | ")} |
| ${o.join(" | ")} |
${r.map((a) => `| ${a} |`).join(`
`)}`;
  }
  static formatValue(e) {
    return e === null ? "*NULL*" : typeof e == "string" ? e.replace(/\n/g, "<br>") : String(e);
  }
}
class nm {
  export(e, s, n, i, o) {
    if (i) {
      if (!o)
        throw new mt("getTableIdxByName function is required when exporting a specific table");
      const a = o(i);
      if (a === void 0)
        throw new mt(`Table '${i}' does not exist`);
      const l = s[a];
      if (!l)
        throw new mt(`Schema for table '${i}' not found`);
      const u = e.getTableData(a);
      return this.exportTable(l, u, n, a);
    }
    if (n === st.STANDARD_DATA) {
      const a = {};
      for (const [l, u] of Object.entries(s)) {
        const c = parseInt(l), d = e.getTableData(c), m = this.exportAsStandardData(u, d), h = JSON.parse(m);
        Object.assign(a, h);
      }
      return JSON.stringify(a, null, 2);
    }
    const r = [];
    for (const [a, l] of Object.entries(s)) {
      const u = parseInt(a), c = e.getTableData(u);
      r.push(this.exportTable(l, c, n, u));
    }
    return r.join(`

`);
  }
  exportTable(e, s, n, i) {
    switch (n) {
      case st.INSERT_SQL:
        return this.exportAsInsertSql(e, s);
      case st.ROW_JSON:
        return this.exportAsRowJson(e, s, i);
      case st.TABLE_SCHEMA:
        return JSON.stringify(e, null, 2);
      case st.DDL:
        return this.exportAsDDL(e);
      case st.MARKDOWN:
        return this.exportAsMarkdown(e, s);
      case st.STANDARD_DATA:
        return this.exportAsStandardData(e, s);
      default:
        throw new mt(`Unknown export format: ${n}`);
    }
  }
  exportAsInsertSql(e, s) {
    const n = [];
    for (const i of s) {
      const o = [];
      for (const [a] of Object.entries(e.id2fieldName)) {
        const l = parseInt(a), u = i[l];
        u === null ? o.push("NULL") : typeof u == "string" ? o.push(`'${u.replace(/'/g, "''")}'`) : o.push(String(u));
      }
      const r = Object.values(e.id2fieldName).join(", ");
      n.push(`INSERT INTO ${e.tableName} (${r}) VALUES (${o.join(", ")});`);
    }
    return n.join(`
`);
  }
  exportAsRowJson(e, s, n) {
    const i = [];
    for (const o of s) {
      const r = {};
      for (const [a] of Object.entries(e.id2fieldName)) {
        const l = parseInt(a);
        r[l] = o[l];
      }
      i.push({
        action: Vt.INSERT,
        tableIdx: n,
        after: r
      });
    }
    return JSON.stringify(i, null, 2);
  }
  exportAsMarkdown(e, s) {
    return No.exportTable(e, s);
  }
  exportAsStandardData(e, s) {
    const n = {}, i = [];
    for (const o of s) {
      const r = {};
      for (const [a, l] of Object.entries(e.id2fieldName)) {
        const u = parseInt(a);
        r[l] = o[u] ?? null;
      }
      i.push(r);
    }
    return n[e.tableName] = i, JSON.stringify(n, null, 2);
  }
  exportAsDDL(e) {
    const s = {}, n = {};
    for (const [r] of Object.entries(e.id2fieldName)) {
      const a = parseInt(r), l = e.columnSchemas[a];
      if (l) {
        const u = l.type + (l.primitiveKey ? " PRIMARY KEY" : "");
        s[l.name] = u, l.comment && (n[l.name] = l.comment);
      }
    }
    const i = new Map(Object.entries(s)), o = new Map(Object.entries(n));
    return rt.ddl().createTable(e.tableName, i, e.comment, o);
  }
}
class im {
  expressionEvaluator;
  constructor() {
    this.expressionEvaluator = new _o();
  }
  toRecord(e) {
    if (e) {
      if (e instanceof Map) {
        const s = {};
        return e.forEach((n, i) => {
          s[i] = n;
        }), s;
      }
      return e;
    }
  }
  dml2row(e, s, n) {
    const i = [];
    for (const o of e)
      switch (o.type) {
        case "INSERT":
          i.push(...this.convertInsertToRow(o, s, n));
          break;
        case "UPDATE":
          i.push(this.convertUpdateToRow(o, s, n));
          break;
        case "DELETE":
          i.push(this.convertDeleteToRow(o, s, n));
          break;
        case "APPEND":
          i.push(this.convertAppendToRow(o, s, n));
          break;
      }
    return i;
  }
  row2dml(e, s, n) {
    const i = [];
    for (const o of e) {
      const r = n(o.tableIdx);
      if (!r)
        throw new mt(`Table with idx ${o.tableIdx} not found`);
      const a = s[o.tableIdx];
      if (!a)
        throw new mt(`Schema for table '${r}' not found`);
      switch (o.action) {
        case Vt.INSERT:
          i.push(this.convertRowToInsert(a, r, o));
          break;
        case Vt.UPDATE:
          i.push(this.convertRowToUpdate(a, r, o));
          break;
        case Vt.DELETE:
          i.push(this.convertRowToDelete(a, r, o));
          break;
        case Vt.APPEND:
          i.push(this.convertRowToAppend(a, r, o));
          break;
      }
    }
    return i.join(`;
`);
  }
  convertInsertToRow(e, s, n) {
    const i = e.tableName, o = n(i), r = s[o], a = [];
    for (const l of e.values) {
      const u = {};
      for (let c = 0; c < e.columns.length; c++) {
        const d = e.columns[c], m = r.fieldName2id[d], h = l[c];
        u[m] = this.expressionEvaluator.evaluateExpression(h, r, o, null);
      }
      a.push({
        action: Vt.INSERT,
        tableIdx: o,
        after: u
      });
    }
    return a;
  }
  convertUpdateToRow(e, s, n) {
    const i = e.tableName, o = n(i), r = s[o], a = {};
    for (const l of e.sets) {
      const u = r.fieldName2id[l.column], c = this.expressionEvaluator.evaluateExpression(l.value, r, o, null);
      a[u] = c;
    }
    return {
      action: Vt.UPDATE,
      tableIdx: o,
      before: e.where ? this.evaluateWhereToRowData(e.where, r, o) : void 0,
      after: a
    };
  }
  convertDeleteToRow(e, s, n) {
    const i = e.tableName, o = n(i), r = s[o];
    return {
      action: Vt.DELETE,
      tableIdx: o,
      before: e.where ? this.evaluateWhereToRowData(e.where, r, o) : void 0
    };
  }
  convertAppendToRow(e, s, n) {
    const i = e.tableName, o = n(i), r = s[o], a = e.column, l = r.fieldName2id[a], u = this.expressionEvaluator.evaluateExpression(e.value, r, o, null), c = {};
    return c[l] = u, {
      action: Vt.APPEND,
      tableIdx: o,
      before: e.where ? this.evaluateWhereToRowData(e.where, r, o) : void 0,
      after: c
    };
  }
  evaluateWhereToRowData(e, s, n) {
    const i = {};
    if (e.type === "binary" && e.left.type === "column" && e.right.type === "value") {
      const o = e.left.name, r = s.fieldName2id[o];
      r !== void 0 && (i[r] = e.right.value);
    }
    return i;
  }
  convertRowToInsert(e, s, n) {
    const i = [], o = [], r = this.toRecord(n.after);
    return r && Object.entries(r).forEach(([a, l]) => {
      const u = parseInt(a), c = e.id2fieldName[u];
      c && (i.push(c), o.push(this.valueToSql(l)));
    }), `INSERT INTO ${s} (${i.join(", ")}) VALUES (${o.join(", ")})`;
  }
  convertRowToUpdate(e, s, n) {
    const i = [], o = this.toRecord(n.after);
    o && Object.entries(o).forEach(([l, u]) => {
      const c = parseInt(l), d = e.id2fieldName[c];
      d && i.push(`${d} = ${this.valueToSql(u)}`);
    });
    let r = `UPDATE ${s} SET ${i.join(", ")}`;
    const a = this.toRecord(n.before);
    if (a && Object.keys(a).length > 0) {
      const l = [];
      Object.entries(a).forEach(([u, c]) => {
        const d = parseInt(u), m = e.id2fieldName[d];
        m && l.push(`${m} = ${this.valueToSql(c)}`);
      }), l.length > 0 && (r += ` WHERE ${l.join(" AND ")}`);
    }
    return r;
  }
  convertRowToDelete(e, s, n) {
    const i = [], o = this.toRecord(n.before);
    o && Object.entries(o).forEach(([a, l]) => {
      const u = parseInt(a), c = e.id2fieldName[u];
      c && i.push(`${c} = ${this.valueToSql(l)}`);
    });
    let r = `DELETE FROM ${s}`;
    return i.length > 0 && (r += ` WHERE ${i.join(" AND ")}`), r;
  }
  convertRowToAppend(e, s, n) {
    const i = this.toRecord(n.after), o = i ? Object.keys(i) : [], r = o.length > 0 ? o[0] : void 0;
    if (r === void 0)
      throw new mt("Invalid APPEND row data");
    const a = parseInt(r), l = e.id2fieldName[a], u = i ? i[a] : void 0;
    let c = `APPEND INTO ${s} (${l}) VALUES (${this.valueToSql(u)})`;
    const d = this.toRecord(n.before);
    if (d && Object.keys(d).length > 0) {
      const m = [];
      Object.entries(d).forEach(([h, b]) => {
        const y = parseInt(h), E = e.id2fieldName[y];
        E && m.push(`${E} = ${this.valueToSql(b)}`);
      }), m.length > 0 && (c += ` WHERE ${m.join(" AND ")}`);
    }
    return c;
  }
  valueToSql(e) {
    return e === null ? "NULL" : typeof e == "string" ? `'${e.replace(/'/g, "''")}'` : String(e);
  }
}
class To {
  structure;
  dataStorage;
  ddlExecutor;
  dmlExecutor;
  dqlExecutor;
  rowConverter;
  dataExporter;
  constructor(e, s) {
    this.dataStorage = e || ps.newStorage(), this.structure = s || this.createEmptyStructure(), this.ddlExecutor = new Or(
      this.structure,
      this.dataStorage,
      this.getTableIdxByName.bind(this)
    ), this.dmlExecutor = new $r(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dqlExecutor = new Ar(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.rowConverter = new im(), this.dataExporter = new nm();
  }
  createEmptyStructure() {
    return {
      tableSchemas: {},
      tableName2Idx: {},
      tableIdxCounter: 0
    };
  }
  getTables() {
    return Object.values(this.structure.tableSchemas).map((s) => ({
      ...s,
      id2fieldName: { ...s.id2fieldName },
      fieldName2id: { ...s.fieldName2id },
      columnSchemas: { ...s.columnSchemas }
    }));
  }
  execute(e, s) {
    try {
      const n = Qn.parse(e);
      if (n.errors.length > 0)
        throw new Sn(
          n.errors.join("; "),
          0,
          e
        );
      const i = n.statements;
      if (i.length === 0)
        throw new Sn("No valid SQL statement found", 0, e);
      let o;
      for (let r = 0; r < i.length; r++) {
        const a = i[r];
        if (!a) continue;
        const l = this.getStatementType(a);
        if (!s.includes(l))
          throw new Le(
            `Expected SQL type ${s.join(" or ")}, got ${l}`,
            e
          );
        o = this.executeStatement(a);
      }
      if (!o)
        throw new Sn("No valid statement executed", 0, e);
      return o;
    } catch (n) {
      throw n instanceof Sn || n instanceof Le || n instanceof mt ? n : new mt(n.message, e);
    }
  }
  getStatementType(e) {
    const s = e.type;
    switch (s) {
      case $e.CREATE_TABLE:
      case $e.ALTER_TABLE:
      case $e.DROP_TABLE:
        return se.DDL;
      case $e.INSERT:
      case $e.UPDATE:
      case $e.DELETE:
      case $e.APPEND:
        return se.DML;
      case $e.SELECT:
        return se.DQL;
      default:
        throw new mt(`Unknown statement type: ${s}`);
    }
  }
  executeStatement(e) {
    switch (e.type) {
      case $e.CREATE_TABLE:
        return this.ddlExecutor.executeCreateTable(e);
      case $e.ALTER_TABLE:
        return this.ddlExecutor.executeAlterTable(e);
      case $e.DROP_TABLE:
        return this.ddlExecutor.executeDropTable(e);
      case $e.INSERT:
        return this.dmlExecutor.executeInsert(e);
      case $e.UPDATE:
        return this.dmlExecutor.executeUpdate(e);
      case $e.DELETE:
        return this.dmlExecutor.executeDelete(e);
      case $e.APPEND:
        return this.dmlExecutor.executeAppend(e);
      case $e.SELECT:
        return this.dqlExecutor.executeSelect(e);
      default:
        throw new mt("Unsupported statement type");
    }
  }
  getTableIdxByName(e) {
    return this.structure.tableName2Idx[e];
  }
  getTableNameByIdx(e) {
    return this.structure.tableSchemas[e]?.tableName;
  }
  validateTableExists(e) {
    const s = this.getTableIdxByName(e);
    if (s === void 0)
      throw new Le(
        `Table '${e}' does not exist`,
        `Table '${e}' does not exist`
      );
    return s;
  }
  getDataStorage() {
    return this.dataStorage;
  }
  setDataStorage(e) {
    this.dataStorage = e;
  }
  export(e, s) {
    return this.dataExporter.export(
      this.dataStorage,
      this.structure.tableSchemas,
      e,
      s,
      this.getTableIdxByName.bind(this)
    );
  }
  dml2row(e) {
    const s = Qn.parse(e);
    return this.rowConverter.dml2row(s.statements, this.structure.tableSchemas, this.getTableIdxByName.bind(this));
  }
  row2dml(e) {
    return this.rowConverter.row2dml(e, this.structure.tableSchemas, this.getTableNameByIdx.bind(this));
  }
  clone() {
    const e = JSON.parse(JSON.stringify(this.structure));
    return new To(void 0, e);
  }
  serialize() {
    return {
      structure: this.structure,
      dataStorage: this.dataStorage.serialize()
    };
  }
  deserialize(e) {
    const s = e;
    s.structure ? this.structure = s.structure : this.structure = this.createEmptyStructure(), s.dataStorage ? this.dataStorage.deserialize(s.dataStorage) : this.dataStorage.clear(), this.rebuildExecutors();
  }
  rebuildExecutors() {
    this.ddlExecutor = new Or(
      this.structure,
      this.dataStorage,
      this.getTableIdxByName.bind(this)
    ), this.dmlExecutor = new $r(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dqlExecutor = new Ar(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    );
  }
}
class xo {
  data = {};
  constructor(e) {
    e && Object.keys(e).forEach((s) => {
      const n = parseInt(s), i = e[n];
      i && (this.data[n] = i.map((o) => ({ ...o })));
    });
  }
  /**
   * 
   */
  clone() {
    const e = {};
    return Object.keys(this.data).forEach((s) => {
      const n = parseInt(s), i = this.data[n];
      i && (e[n] = i.map((o) => ({ ...o })));
    }), new xo(e);
  }
  /**
   * 
   */
  getTableData(e) {
    return this.data[e] || [];
  }
  /**
   * 
   */
  setTableData(e, s) {
    this.data[e] = s.map((n) => ({ ...n }));
  }
  /**
   * 
   */
  clear() {
    this.data = {};
  }
  /**
   * 
   */
  serialize() {
    return this.data;
  }
  /**
   * 
   */
  deserialize(e) {
    this.data = {};
    const s = e;
    Object.keys(s).forEach((n) => {
      const i = parseInt(n), o = s[n];
      Array.isArray(o) ? this.data[i] = o.map((r) => ({ ...r })) : this.data[i] = [];
    });
  }
}
class Or {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.getTableIdxByName = n;
  }
  executeCreateTable(e) {
    const s = e.tableName;
    this.validateTableNotExists(s);
    const n = this.allocateTableIdx(), i = e.columns, o = {}, r = {}, a = {};
    let l = 0;
    for (const c of i) {
      const d = l++;
      o[d] = c.name, r[c.name] = d;
      const m = {
        name: c.name,
        type: c.type,
        primitiveKey: c.primitiveKey || !1,
        defaultValue: c.defaultValue,
        comment: c.comment || ""
      };
      a[d] = m;
    }
    const u = {
      tableName: s,
      id2fieldName: o,
      fieldName2id: r,
      columnSchemas: a,
      counter: l,
      comment: e.comment || ""
    };
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [n]: u }, this.structure.tableName2Idx = { ...this.structure.tableName2Idx, [s]: n }, {
      success: !0,
      message: `Table '${s}' created successfully`,
      data: 0,
      type: se.DDL
    };
  }
  executeAlterTable(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.structure.tableSchemas[n];
    switch (e.opType) {
      case "ADD_COLUMN":
        return this.addColumn(i, s, e.columnDef);
      case "DROP_COLUMN":
        return this.removeColumn(i, s, e.columnName);
      case "RENAME":
        return this.renameTable(i, n, s, e.newTableName);
      case "RENAME_COLUMN":
        return this.renameColumn(i, s, e.columnName, e.newColumnName);
      case "MODIFY_COLUMN_COMMENT":
        return this.modifyColumnComment(i, s, e.columnName, e.comment);
      case "MODIFY_COLUMN_PRIMITIVE_KEY":
        return this.modifyColumnPrimitiveKey(i, s, e.columnName, e.columnDef);
      case "ALTER_TABLE_COMMENT":
        return this.modifyTableComment(i, s, e.comment);
    }
    throw new Error("Invalid ALTER TABLE statement");
  }
  executeDropTable(e) {
    const s = e.tableName, n = this.validateTableExists(s), { [n]: i, ...o } = this.structure.tableSchemas, { [s]: r, ...a } = this.structure.tableName2Idx;
    return this.structure.tableSchemas = o, this.structure.tableName2Idx = a, this.dataStorage.setTableData(n, []), Object.keys(this.structure.tableSchemas).length === 0 && (this.structure.tableIdxCounter = 0), {
      success: !0,
      message: `Table '${s}' dropped`,
      data: 0,
      type: se.DDL
    };
  }
  addColumn(e, s, n) {
    if (e.fieldName2id[n.name] !== void 0)
      throw new Le(
        `Column '${n.name}' already exists in table '${s}'`,
        `ALTER TABLE ${s} ADD COLUMN ${n.name}`
      );
    const i = e.counter, o = {
      name: n.name,
      type: n.type,
      primitiveKey: n.primitiveKey || !1,
      defaultValue: n.defaultValue,
      comment: n.comment || ""
    };
    e.id2fieldName = { ...e.id2fieldName, [i]: o.name }, e.fieldName2id = { ...e.fieldName2id, [o.name]: i }, e.columnSchemas = { ...e.columnSchemas, [i]: o }, e.counter = i + 1;
    const r = { ...e }, a = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [a]: r }, {
      success: !0,
      message: `Column '${n.name}' added to table '${s}'`,
      data: 0,
      type: se.DDL
    };
  }
  removeColumn(e, s, n) {
    const i = e.fieldName2id[n];
    if (i === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} DROP COLUMN ${n}`
      );
    const { [i]: o, ...r } = e.id2fieldName, { [n]: a, ...l } = e.fieldName2id, { [i]: u, ...c } = e.columnSchemas;
    e.id2fieldName = r, e.fieldName2id = l, e.columnSchemas = c;
    const d = { ...e }, m = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [m]: d }, {
      success: !0,
      message: `Column '${n}' dropped from table '${s}'`,
      data: 0,
      type: se.DDL
    };
  }
  renameTable(e, s, n, i) {
    if (!i)
      throw new Le("New table name is required", `ALTER TABLE ${n} RENAME TO`);
    if (this.getTableIdxByName(i) !== void 0)
      throw new Le(
        `Table '${i}' already exists`,
        `ALTER TABLE ${n} RENAME TO ${i}`
      );
    const o = { ...e, tableName: i }, { [n]: r, ...a } = this.structure.tableName2Idx;
    return this.structure.tableName2Idx = { ...a, [i]: s }, this.structure.tableSchemas = { ...this.structure.tableSchemas, [s]: o }, {
      success: !0,
      message: `Table renamed from '${n}' to '${i}'`,
      data: 0,
      type: se.DDL
    };
  }
  renameColumn(e, s, n, i) {
    if (!n || !i)
      throw new Le("Column names are required", `ALTER TABLE ${s} RENAME COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} RENAME COLUMN ${n} TO ${i}`
      );
    if (e.fieldName2id[i] !== void 0)
      throw new Le(
        `Column '${i}' already exists in table '${s}'`,
        `ALTER TABLE ${s} RENAME COLUMN ${n} TO ${i}`
      );
    const { [n]: r, ...a } = e.fieldName2id, l = { ...e.id2fieldName, [o]: i }, u = e.columnSchemas[o], c = {
      name: i,
      type: u.type,
      primitiveKey: u.primitiveKey,
      defaultValue: u.defaultValue,
      comment: u.comment
    }, { [o]: d, ...m } = e.columnSchemas, h = { ...m, [o]: c };
    e.fieldName2id = { ...a, [i]: o }, e.id2fieldName = l, e.columnSchemas = h;
    const b = { ...e }, y = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [y]: b }, {
      success: !0,
      message: `Column '${n}' renamed to '${i}' in table '${s}'`,
      data: 0,
      type: se.DDL
    };
  }
  modifyColumnComment(e, s, n, i) {
    if (!n)
      throw new Le("Column name is required", `ALTER TABLE ${s} MODIFY COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} MODIFY COLUMN ${n}`
      );
    const r = e.columnSchemas[o], a = {
      name: r.name,
      type: r.type,
      primitiveKey: r.primitiveKey,
      defaultValue: r.defaultValue,
      comment: i
    }, { [o]: l, ...u } = e.columnSchemas;
    e.columnSchemas = { ...u, [o]: a };
    const c = { ...e }, d = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [d]: c }, {
      success: !0,
      message: `Column '${n}' comment updated in table '${s}'`,
      data: 0,
      type: se.DDL
    };
  }
  modifyTableComment(e, s, n) {
    const i = { ...e, comment: n }, o = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [o]: i }, {
      success: !0,
      message: `Table '${s}' comment updated`,
      data: 0,
      type: se.DDL
    };
  }
  modifyColumnPrimitiveKey(e, s, n, i) {
    if (!n)
      throw new Le("Column name is required", `ALTER TABLE ${s} MODIFY COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} MODIFY COLUMN ${n}`
      );
    const r = e.columnSchemas[o], a = {
      name: r.name,
      type: r.type,
      primitiveKey: i.primitiveKey,
      defaultValue: r.defaultValue,
      comment: i.comment !== void 0 ? i.comment : r.comment
    }, { [o]: l, ...u } = e.columnSchemas;
    e.columnSchemas = { ...u, [o]: a };
    const c = { ...e }, d = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [d]: c }, {
      success: !0,
      message: `Column '${n}' primary key updated in table '${s}'`,
      data: 0,
      type: se.DDL
    };
  }
  allocateTableIdx() {
    return this.structure.tableIdxCounter++;
  }
  validateTableExists(e) {
    const s = this.getTableIdxByName(e);
    if (s === void 0)
      throw new Le(
        `Table '${e}' does not exist`,
        `Table '${e}' does not exist`
      );
    return s;
  }
  validateTableNotExists(e) {
    if (this.getTableIdxByName(e) !== void 0)
      throw new Le(
        `Table '${e}' already exists`,
        `Table '${e}' already exists`
      );
  }
}
class $r {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.validateTableExists = n, this.expressionEvaluator = new _o();
  }
  expressionEvaluator;
  get tableSchemas() {
    return this.structure.tableSchemas;
  }
  executeInsert(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = 0;
    const r = Object.entries(i.columnSchemas).filter(([a, l]) => l.primitiveKey).map(([a, l]) => parseInt(a)).sort((a, l) => a - l);
    for (const a of e.values) {
      const l = {}, u = {};
      for (let c = 0; c < e.columns.length; c++) {
        const d = e.columns[c];
        if (i.fieldName2id[d] === void 0)
          throw new Le(
            `Column '${d}' does not exist in table '${s}'`,
            `INSERT INTO ${s}`
          );
        u[d] = c;
      }
      for (const [c, d] of Object.entries(i.columnSchemas)) {
        const m = parseInt(c), h = d.name, b = u[h];
        if (b !== void 0) {
          const y = a[b], E = this.expressionEvaluator.evaluateExpression(y, i, n, null);
          E === null && d.defaultValue !== void 0 ? l[m] = d.defaultValue : l[m] = E;
        } else d.defaultValue !== void 0 ? l[m] = d.defaultValue : l[m] = null;
      }
      if (r.length > 0) {
        const c = this.dataStorage.getTableData(n), d = c.find((m) => r.every((h) => JSON.stringify(m[h]) === JSON.stringify(l[h])));
        if (d) {
          for (const [m] of Object.entries(u)) {
            const h = i.fieldName2id[m];
            if (h !== void 0) {
              const b = l[h];
              d[h] = b !== void 0 ? b : null;
            }
          }
          this.dataStorage.setTableData(n, c);
        } else
          c.push(l), this.dataStorage.setTableData(n, c);
      } else {
        const c = this.dataStorage.getTableData(n);
        c.push(l), this.dataStorage.setTableData(n, c);
      }
      o++;
    }
    return {
      success: !0,
      message: `Inserted ${o} row(s) into '${s}'`,
      data: o,
      type: se.DML
    };
  }
  executeUpdate(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = 0;
    const r = this.dataStorage.getTableData(n);
    for (const a of r)
      if (e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, a)) {
        for (const u of e.sets) {
          const c = i.fieldName2id[u.column];
          if (c === void 0)
            throw new Le(
              `Column '${u.column}' does not exist in table '${s}'`,
              `UPDATE ${s}`
            );
          const d = this.expressionEvaluator.evaluateExpression(u.value, i, n, a);
          a[c] = d;
        }
        o++;
      }
    return this.dataStorage.setTableData(n, r), {
      success: !0,
      message: `Updated ${o} row(s) in '${s}'`,
      data: o,
      type: se.DML
    };
  }
  executeDelete(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n], o = this.dataStorage.getTableData(n), r = [];
    for (const l of o)
      e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, l) || r.push(l);
    const a = o.length - r.length;
    return this.dataStorage.setTableData(n, r), {
      success: !0,
      message: `Deleted ${a} row(s) from '${s}'`,
      data: a,
      type: se.DML
    };
  }
  executeAppend(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n], o = e.column, r = i.fieldName2id[o];
    if (r === void 0)
      throw new Le(
        `Column '${o}' does not exist in table '${s}'`,
        `APPEND INTO ${s}`
      );
    const a = i.columnSchemas[r];
    if (!a)
      throw new Le(
        `Column '${o}' does not exist in table '${s}'`,
        `APPEND INTO ${s}`
      );
    if (a.primitiveKey)
      throw new Le(
        `Cannot APPEND to primary key column '${o}'`,
        `APPEND INTO ${s}`
      );
    if (a.type !== Ut.STRING)
      throw new Le(
        `Column '${o}' must be STRING type for APPEND operation`,
        `APPEND INTO ${s}`
      );
    let l = 0;
    const u = this.dataStorage.getTableData(n);
    for (const c of u)
      if (e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, c)) {
        let m = c[r];
        m == null && (m = "");
        const h = this.expressionEvaluator.evaluateExpression(e.value, i, n, c);
        c[r] = m + h, l++;
      }
    return this.dataStorage.setTableData(n, u), {
      success: !0,
      message: `Appended to ${l} row(s) in '${s}'`,
      data: l,
      type: se.DML
    };
  }
}
class Ar {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.validateTableExists = n, this.expressionEvaluator = new _o();
  }
  expressionEvaluator;
  get tableSchemas() {
    return this.structure.tableSchemas;
  }
  executeSelect(e) {
    const s = e.from, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = this.dataStorage.getTableData(n);
    e.where && (o = o.filter(
      (a) => this.expressionEvaluator.evaluateWhere(e.where, i, n, a)
    ));
    const r = [];
    for (const a of o) {
      const l = {};
      for (const u of e.columns)
        if (u.type === "star")
          for (const [c, d] of Object.entries(i.id2fieldName)) {
            const m = parseInt(c);
            l[d] = a[m];
          }
        else if (u.type === "column") {
          const c = (u.tableName, u.name), d = i.fieldName2id[c];
          d !== void 0 && (l[c] = a[d]);
        }
      r.push(l);
    }
    if (e.orderBy) {
      const a = e.orderBy[0];
      if (a) {
        const l = a.column;
        i.fieldName2id[l] !== void 0 && r.sort((c, d) => {
          const m = c[l], h = d[l];
          return m === null && h === null ? 0 : m === null ? a.ascending ? -1 : 1 : h === null ? a.ascending ? 1 : -1 : m < h ? a.ascending ? -1 : 1 : m > h ? a.ascending ? 1 : -1 : 0;
        });
      }
    }
    return {
      success: !0,
      message: `Selected ${r.length} row(s)`,
      data: r,
      type: se.DQL
    };
  }
}
class ps {
  static newExecutor() {
    return new To();
  }
  static newStorage() {
    return new xo();
  }
}
class we {
  static ROW_START_TAG = "<row>";
  static ROW_END_TAG = "</row>";
  static COMMIT_START_TAG = "<commit>";
  static COMMIT_END_TAG = "</commit>";
  static getRows() {
    const s = SillyTavern.getContext()?.chat || [], n = [];
    for (const i of s)
      if (i.mes) {
        const o = this.extractTagContent(i.mes, we.ROW_START_TAG, we.ROW_END_TAG);
        if (o)
          try {
            const r = JSON.parse(o);
            n.push(...r);
          } catch {
          }
      }
    return n;
  }
  static processMessage(e, s, n, i) {
    const o = SillyTavern.getContext(), a = (o?.chat || [])[e];
    if (!a)
      return;
    const l = a.mes || "", u = this.extractTagContent(l, s, n), c = i(u);
    if (u === null)
      a.mes = c;
    else {
      const d = l.lastIndexOf(n), m = l.lastIndexOf(s, d), h = l.substring(0, m), b = l.substring(d + n.length);
      a.mes = h + c + b;
    }
    o?.saveChat();
  }
  static processCommit(e, s) {
    return we.processMessage(e, we.COMMIT_START_TAG, we.COMMIT_END_TAG, s);
  }
  static processRows(e, s) {
    return we.processMessage(e, we.ROW_START_TAG, we.ROW_END_TAG, s);
  }
  static processLastRows(e) {
    const s = SillyTavern.getContext();
    (s?.chat || []).length == 0 && s?.chat.push({
      id: 0,
      name: "",
      role: "assistant",
      mes: "",
      date: Date.now()
    }), this.processRows(s?.chat.length - 1, e);
  }
  static extractCommit(e) {
    return this.extractTagContent(e, we.COMMIT_START_TAG, we.COMMIT_END_TAG);
  }
  static extractRow(e) {
    return this.extractTagContent(e, we.ROW_START_TAG, we.ROW_END_TAG);
  }
  static replaceCommitWithRow(e, s) {
    const n = SillyTavern.getContext(), o = (n?.chat || [])[e];
    if (!o)
      return;
    let r = o.mes || "";
    const a = r.lastIndexOf(we.COMMIT_END_TAG);
    if (a !== -1) {
      const u = r.lastIndexOf(we.COMMIT_START_TAG, a);
      u !== -1 && (r = r.substring(0, u) + r.substring(a + we.COMMIT_END_TAG.length));
    }
    const l = r.lastIndexOf(we.ROW_END_TAG);
    if (l !== -1) {
      const u = r.lastIndexOf(we.ROW_START_TAG, l);
      u !== -1 && (r = r.substring(0, u) + we.ROW_START_TAG + s + we.ROW_END_TAG + r.substring(l + we.ROW_END_TAG.length));
    } else
      r = r + we.ROW_START_TAG + s + we.ROW_END_TAG;
    o.mes = r, n?.saveChat();
  }
  static extractTagContent(e, s, n) {
    const i = e.lastIndexOf(n);
    if (i === -1) return null;
    const o = e.lastIndexOf(s, i);
    return o === -1 ? null : e.substring(o + s.length, i).trim() || null;
  }
}
class Vr {
  /**
   * 
   * @private
   */
  tableTemplate;
  constructor(e) {
    this.tableTemplate = e.clone();
  }
  getTables() {
    return this.tableTemplate.getTables();
  }
  clone() {
    return this.tableTemplate.clone();
  }
  dml2row(e) {
    return this.tableTemplate.dml2row(e);
  }
  execute(e, s) {
    const n = e.split(";").map((a) => a.trim()).filter((a) => a.length > 0);
    if (n.length === 0)
      return { success: !0, message: "SQL", data: 0, type: se.DML };
    let i = 0, o = [], r = [];
    for (const a of n) {
      const l = this.detectSqlType(a);
      if (!s.includes(l))
        throw new Error(`SQL ${s.join("  ")} ${l}`);
      if (l === se.DML)
        r.length > 0 && (this.tableTemplate.execute(r.join(`;
`), [se.DDL]), r = []), o.push(a);
      else if (l === se.DDL)
        o.length > 0 && (i += this.executeDml(o.join(`;
`)), o = []), r.push(a);
      else if (l === se.DQL)
        return r.length > 0 && (this.tableTemplate.execute(r.join(`;
`), [se.DDL]), r = []), o.length > 0 && (i += this.executeDml(o.join(`;
`)), o = []), this.storage.execute(a, [se.DQL]);
    }
    return r.length > 0 && this.tableTemplate.execute(r.join(`;
`), [se.DDL]), o.length > 0 && (i += this.executeDml(o.join(`;
`))), { success: !0, message: "", data: i, type: se.DML };
  }
  detectSqlType(e) {
    const s = e.trim().toUpperCase();
    if (/^CREATE\s+TABLE|^ALTER\s+TABLE|^DROP\s+TABLE/i.test(s))
      return se.DDL;
    if (/^SELECT/i.test(s))
      return se.DQL;
    if (/^INSERT|^UPDATE|^DELETE|^APPEND/i.test(s))
      return se.DML;
    throw new Error(`SQL: ${e}`);
  }
  executeDml(e) {
    const s = this.tableTemplate.dml2row(e);
    return we.processLastRows((n) => {
      const i = n ? JSON.parse(n) : [];
      return i.push(...s), `<row>${JSON.stringify(i)}</row>`;
    }), s.length;
  }
  export(e, s) {
    return this.storage.export(e, s);
  }
  /**
   * 
   * @private
   */
  get storage() {
    const e = we.getRows(), s = this.tableTemplate.row2dml(e), n = this.tableTemplate.clone();
    return s && n.execute(s, [se.DML]), n;
  }
  getDataStorage() {
    return this.storage.getDataStorage();
  }
  getTableIdxByName(e) {
    return this.tableTemplate.getTableIdxByName(e);
  }
  getTableNameByIdx(e) {
    return this.tableTemplate.getTableNameByIdx(e);
  }
  row2dml(e) {
    return this.tableTemplate.row2dml(e);
  }
  setDataStorage(e) {
  }
  serialize() {
    return this.tableTemplate.serialize();
  }
  deserialize(e) {
    this.tableTemplate.deserialize(e);
  }
}
function Hi(t, e) {
  return new Proxy(t, {
    get(s, n) {
      const i = s[n];
      return typeof i == "function" && n === "execute" ? function(...o) {
        const r = i.apply(s, o);
        return e(), r;
      } : i;
    }
  });
}
class xe {
  static MODULE_NAME = "ST_BETTER_DATABASE";
  static _instance = new xe();
  _tableTemplateCache = null;
  _tableTemplateProxy = null;
  _chatStatusBarSwitch = !1;
  _chatStatusBarCode = "";
  _extensionSwitch = !1;
  _systemSqlExecutorCache = null;
  _systemSqlExecutorProxy = null;
  _chatStatusBarChangeListeners = /* @__PURE__ */ new Set();
  constructor() {
    const { extensionSettings: e } = SillyTavern.getContext();
    e[xe.MODULE_NAME] || (e[xe.MODULE_NAME] = {
      tableTemplate: null,
      chatStatusBarSwitch: !1,
      chatStatusBarCode: "",
      extensionSwitch: !1,
      systemSqlExecutor: null
    }), this._loadFromSettings();
  }
  _loadFromSettings() {
    const { extensionSettings: e } = SillyTavern.getContext(), s = e[xe.MODULE_NAME];
    if (s) {
      if (s.tableTemplate)
        try {
          this._tableTemplateCache = ps.newExecutor(), this._tableTemplateCache.deserialize(s.tableTemplate);
        } catch {
          this._tableTemplateCache = null;
        }
      if (this._chatStatusBarSwitch = s.chatStatusBarSwitch ?? !1, this._chatStatusBarCode = s.chatStatusBarCode ?? "", this._extensionSwitch = s.extensionSwitch ?? !1, s.systemSqlExecutor)
        try {
          this._systemSqlExecutorCache = ps.newExecutor(), this._systemSqlExecutorCache.deserialize(s.systemSqlExecutor);
        } catch {
          this._systemSqlExecutorCache = null;
        }
    }
  }
  _saveToSettings() {
    const { extensionSettings: e } = SillyTavern.getContext();
    let s = e[xe.MODULE_NAME];
    s || (s = {
      tableTemplate: null,
      chatStatusBarSwitch: !1,
      chatStatusBarCode: "",
      extensionSwitch: !1,
      systemSqlExecutor: null
    }, e[xe.MODULE_NAME] = s), s.tableTemplate = this._tableTemplateCache?.serialize(), s.chatStatusBarSwitch = this._chatStatusBarSwitch, s.chatStatusBarCode = this._chatStatusBarCode, s.extensionSwitch = this._extensionSwitch, s.systemSqlExecutor = this._systemSqlExecutorCache?.serialize(), SillyTavern.getContext().saveSettingsDebounced();
  }
  get tableTemplate() {
    return this._tableTemplateCache || (this._tableTemplateCache = ps.newExecutor()), this._tableTemplateProxy || (this._tableTemplateProxy = Hi(this._tableTemplateCache, () => this._saveToSettings())), this._tableTemplateProxy;
  }
  set tableTemplate(e) {
    if (typeof e == "object" && "serialize" in e) {
      const s = e.serialize();
      this._tableTemplateCache = ps.newExecutor(), this._tableTemplateCache.deserialize(s);
    } else
      this._tableTemplateCache = e;
    this._tableTemplateProxy = null, this._saveToSettings();
  }
  get chatStatusBarSwitch() {
    return this._chatStatusBarSwitch;
  }
  set chatStatusBarSwitch(e) {
    this._chatStatusBarSwitch !== e && (this._chatStatusBarSwitch = e, this._saveToSettings(), this._notifyChatStatusBarChange());
  }
  onChatStatusBarChange(e) {
    return this._chatStatusBarChangeListeners.add(e), () => this._chatStatusBarChangeListeners.delete(e);
  }
  _notifyChatStatusBarChange() {
    this._chatStatusBarChangeListeners.forEach((e) => e());
  }
  get chatStatusBarCode() {
    return this._chatStatusBarCode;
  }
  set chatStatusBarCode(e) {
    this._chatStatusBarCode = e, this._saveToSettings(), this._notifyChatStatusBarChange();
  }
  get extensionSwitch() {
    return this._extensionSwitch;
  }
  set extensionSwitch(e) {
    this._extensionSwitch = e, this._saveToSettings();
  }
  get systemSqlExecutor() {
    return this._systemSqlExecutorCache || (this._systemSqlExecutorCache = ps.newExecutor()), this._systemSqlExecutorProxy || (this._systemSqlExecutorProxy = Hi(this._systemSqlExecutorCache, () => this._saveToSettings())), this._systemSqlExecutorProxy;
  }
  set systemSqlExecutor(e) {
    if (typeof e == "object" && "serialize" in e) {
      const s = e.serialize();
      this._systemSqlExecutorCache = ps.newExecutor(), this._systemSqlExecutorCache.deserialize(s);
    } else
      this._systemSqlExecutorCache = e;
    this._systemSqlExecutorProxy = null, this._saveToSettings();
  }
  static get instance() {
    return xe._instance;
  }
}
class Pe {
  static MODULE_NAME = "ST_BETTER_DATABASE";
  /**
   *  null 
   *
   * 
   * -  readonly _instance = new ChatMetaManager()
   * -  SillyTavern.getContext() 
   * -  chatMetadata 
   */
  static _instance = null;
  /**
   * 
   *  object  SimpleSqlExecutor.serialize() 
   * 
   */
  _serializedTemplateCache = null;
  /**
   * SqlExecutor 
   *  tableTemplate  _serializedTemplateCache 
   * 
   */
  _tableTemplateCache = null;
  /**
   * 
   *  execute  _saveToMetadata()
   */
  _tableTemplateProxy = null;
  constructor() {
    const { chatMetadata: e } = SillyTavern.getContext();
    e[Pe.MODULE_NAME] || (e[Pe.MODULE_NAME] = {
      tableTemplate: null
    }), this._loadFromMetadata();
  }
  /**
   *  chatMetadata 
   *
   *  SillyTavern.getContext().chatMetadata
   * chatMetadata 
   */
  _loadFromMetadata() {
    const { chatMetadata: e } = SillyTavern.getContext(), s = e[Pe.MODULE_NAME];
    if (!s || !s.tableTemplate) {
      const n = xe.instance.tableTemplate, i = new Vr(n);
      this._serializedTemplateCache = i.serialize();
    } else
      this._serializedTemplateCache = s.tableTemplate;
    this._tableTemplateCache = null, this._tableTemplateProxy = null;
  }
  /**
   *  chatMetadata
   *
   *  SillyTavern.getContext().chatMetadata
   * chatMetadata 
   */
  _saveToMetadata() {
    const { chatMetadata: e } = SillyTavern.getContext(), s = e[Pe.MODULE_NAME] || {};
    s.tableTemplate = this._serializedTemplateCache, e[Pe.MODULE_NAME] = s, SillyTavern.getContext().saveMetadata();
  }
  get tableTemplate() {
    if (!this._tableTemplateCache && this._serializedTemplateCache) {
      const e = xe.instance.tableTemplate;
      this._tableTemplateCache = new Vr(e), this._tableTemplateCache.deserialize(this._serializedTemplateCache);
    }
    return !this._tableTemplateProxy && this._tableTemplateCache && (this._tableTemplateProxy = Hi(this._tableTemplateCache, () => {
      this._saveToMetadata();
    })), this._tableTemplateProxy || xe.instance.tableTemplate;
  }
  set tableTemplate(e) {
    typeof e == "object" && "serialize" in e ? this._serializedTemplateCache = e.serialize() : this._serializedTemplateCache = e, this._tableTemplateCache = null, this._tableTemplateProxy = null, this._saveToMetadata();
  }
  /**
   * 
   *
   * 
   *  SillyTavern.getContext() 
   */
  static get instance() {
    return Pe._instance || (Pe._instance = new Pe()), Pe._instance;
  }
  /**
   * 
   *
   *  chatMetadata 
   *
   * chatMetadata 
   * 
   */
  reload() {
    this._tableTemplateCache = null, this._tableTemplateProxy = null, this._loadFromMetadata();
  }
}
const Cn = "chatTemplateContainer", om = "chat";
class kt {
  static _instance = null;
  constructor() {
  }
  static getInstance() {
    return kt._instance || (kt._instance = new kt()), kt._instance;
  }
  updateChatTemplateDisplay() {
    const e = xe.instance;
    if (!e.chatStatusBarSwitch) {
      this.removeTemplateContainer();
      return;
    }
    const s = e.chatStatusBarCode.trim();
    if (!s) {
      this.removeTemplateContainer();
      return;
    }
    this.renderTemplateToChat(s);
  }
  removeTemplateContainer() {
    const e = document.getElementById(Cn);
    e && e.remove();
  }
  renderTemplateToChat(e) {
    const s = this.escapeIframeContent(e), n = document.getElementById(om);
    if (!n) return;
    const i = document.getElementById(Cn);
    i && i.remove(), n.insertAdjacentHTML("beforeend", `<div class="wide100p" id="${Cn}">${s}</div>`);
    const o = document.getElementById(Cn);
    o && this.attachTouchEventHandlers(o);
  }
  attachTouchEventHandlers(e) {
    const s = (n) => n.stopPropagation();
    e.addEventListener("touchstart", s, { passive: !1 }), e.addEventListener("touchmove", s, { passive: !1 }), e.addEventListener("touchend", s, { passive: !1 });
  }
  escapeIframeContent(e) {
    return e.replace(/<iframe\b([^>]*)>([\s\S]*?)<\/iframe>/gi, (s, n, i) => {
      if (/\bsrcdoc=/i.test(n))
        return s;
      const o = i.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      return `<iframe${n} srcdoc="${o}"></iframe>`;
    });
  }
}
class Zs {
  static instance;
  constructor() {
  }
  static init() {
    if (xe.instance.extensionSwitch && !Zs.instance) {
      const e = new Zs();
      e.registerEventListeners(), Zs.instance = e;
    }
  }
  registerEventListeners() {
    const e = SillyTavern.getContext(), { eventSource: s, event_types: n } = e;
    s.on(n.MESSAGE_RECEIVED, (i) => this.onMessageReceived(i)), s.on(n.MESSAGE_EDITED, (i) => this.onMessageEdited(i)), s.on(n.MESSAGE_DELETED, (i) => this.onMessageDeleted()), s.on(n.CHAT_CHANGED, () => this.onChatChanged());
  }
  onMessageReceived(e) {
    this.processMessage(e), kt.getInstance().updateChatTemplateDisplay();
  }
  onMessageEdited(e) {
    this.processMessage(e), kt.getInstance().updateChatTemplateDisplay();
  }
  onMessageDeleted() {
    kt.getInstance().updateChatTemplateDisplay();
  }
  onChatChanged() {
    Pe.instance.reload(), kt.getInstance().updateChatTemplateDisplay();
  }
  processMessage(e) {
    const i = (SillyTavern.getContext().chat || [])[e];
    if (!i || !i.mes)
      return;
    const o = we.extractCommit(i.mes);
    if (o)
      try {
        const r = Pe.instance.tableTemplate.dml2row(o), a = we.extractRow(i.mes);
        let l = [];
        if (a)
          try {
            l = JSON.parse(a);
          } catch {
            l = [];
          }
        const u = [...l, ...r], c = JSON.stringify(u);
        we.replaceCommitWithRow(e, c);
      } catch (r) {
        console.error("[ChatMessageHandler] Failed to convert commit to row:", r);
        return;
      }
  }
}
class Vs {
  root;
  currentCondition;
  static of() {
    return new Vs();
  }
  eq(e, s) {
    const n = `${e} = ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  ne(e, s) {
    const n = `${e} != ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  gt(e, s) {
    const n = `${e} > ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  lt(e, s) {
    const n = `${e} < ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  ge(e, s) {
    const n = `${e} >= ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  le(e, s) {
    const n = `${e} <= ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  between(e, s, n) {
    const i = `${e} BETWEEN ${this.formatValue(s)} AND ${this.formatValue(n)}`;
    return this.addCondition({ type: "condition", sql: i });
  }
  notBetween(e, s, n) {
    const i = `${e} NOT BETWEEN ${this.formatValue(s)} AND ${this.formatValue(n)}`;
    return this.addCondition({ type: "condition", sql: i });
  }
  in(e, s) {
    const n = s.map((o) => this.formatValue(o)).join(", "), i = `${e} IN (${n})`;
    return this.addCondition({ type: "condition", sql: i });
  }
  notIn(e, s) {
    const n = s.map((o) => this.formatValue(o)).join(", "), i = `${e} NOT IN (${n})`;
    return this.addCondition({ type: "condition", sql: i });
  }
  isNull(e) {
    const s = `${e} IS NULL`;
    return this.addCondition({ type: "condition", sql: s });
  }
  isNotNull(e) {
    const s = `${e} IS NOT NULL`;
    return this.addCondition({ type: "condition", sql: s });
  }
  and(e) {
    return this.combine("and", e);
  }
  or(e) {
    return this.combine("or", e);
  }
  addCondition(e) {
    return this.currentCondition ? this.currentCondition = { type: "and", left: this.currentCondition, right: e } : this.currentCondition = e, this.root = this.currentCondition, this;
  }
  combine(e, s) {
    const n = s.root || s.currentCondition;
    return n ? (this.currentCondition ? this.currentCondition = { type: e, left: this.currentCondition, right: n } : this.currentCondition = n, this.root = this.currentCondition, this) : this;
  }
  formatValue(e) {
    return e === null ? "NULL" : typeof e == "string" ? `"${e}"` : String(e);
  }
  build() {
    const e = this.root || this.currentCondition;
    return e ? this.buildNode(e) : "";
  }
  buildNode(e) {
    if (e.type === "condition")
      return e.sql;
    const s = this.buildNode(e.left), n = this.buildNode(e.right), i = e.type.toUpperCase();
    return `(${s} ${i} ${n})`;
  }
}
class gn {
  whereCondition;
  orderByClauses = [];
  joins = [];
  where(e) {
    return this.whereCondition = e, this;
  }
  orderBy(e, s = !0) {
    return this.orderByClauses.push(`${e} ${s ? "ASC" : "DESC"}`), this;
  }
  formatValue(e) {
    return e === null ? "NULL" : typeof e == "string" ? `"${e}"` : String(e);
  }
  buildWhere() {
    if (!this.whereCondition) return "";
    const e = this.whereCondition.build();
    return e ? ` WHERE ${e}` : "";
  }
}
class rm extends gn {
  tableName;
  columns = [];
  from(e) {
    return this.tableName = e, this;
  }
  select(...e) {
    return this.columns = e, this;
  }
  join(e, s, n, i) {
    return this.joins.push({ type: e.toString(), table: s, on: `${n} = ${i}` }), this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    let s = `SELECT ${this.columns.length > 0 ? this.columns.join(", ") : "*"} FROM ${this.tableName}`;
    return this.joins.length > 0 && (s += this.joins.map((n) => ` ${n.type} JOIN ${n.table} ON ${n.on}`).join("")), s += this.buildWhere(), this.orderByClauses.length > 0 && (s += ` ORDER BY ${this.orderByClauses.join(", ")}`), s;
  }
}
class am extends gn {
  tableName;
  values = /* @__PURE__ */ new Map();
  batchValues = [];
  into(e) {
    return this.tableName = e, this;
  }
  set(e, s) {
    return this.values.set(e, s), this;
  }
  setValues(e) {
    return e.forEach((s, n) => this.values.set(n, s)), this;
  }
  batch(e) {
    return this.batchValues = e, this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    const e = this.batchValues.length > 0 ? this.batchValues : [this.values], s = e[0];
    if (!s || s.size === 0)
      throw new Error("No data to insert");
    const n = Array.from(s.keys()).join(", "), i = e.map((o) => `(${Array.from(s.keys()).map((a) => {
      const l = o.get(a);
      return this.formatValue(l !== void 0 ? l : null);
    }).join(", ")})`).join(", ");
    return `INSERT INTO ${this.tableName} (${n}) VALUES ${i}`;
  }
}
class lm extends gn {
  tableName;
  sets = /* @__PURE__ */ new Map();
  table(e) {
    return this.tableName = e, this;
  }
  set(e, s) {
    return this.sets.set(e, s), this;
  }
  setValues(e) {
    return e.forEach((s, n) => this.sets.set(n, s)), this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    if (this.sets.size === 0)
      throw new Error("At least one SET clause is required");
    const e = Array.from(this.sets.entries()).map(([s, n]) => `${s} = ${this.formatValue(n)}`).join(", ");
    return `UPDATE ${this.tableName} SET ${e}${this.buildWhere()}`;
  }
}
class cm extends gn {
  tableName;
  from(e) {
    return this.tableName = e, this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    return `DELETE FROM ${this.tableName}${this.buildWhere()}`;
  }
}
class um extends gn {
  tableName;
  columnName;
  appendValue;
  into(e) {
    return this.tableName = e, this;
  }
  column(e) {
    return this.columnName = e, this;
  }
  value(e) {
    return this.appendValue = e, this;
  }
  build() {
    if (!this.tableName || !this.columnName || this.appendValue === void 0)
      throw new Error("Table name, column, and value are required");
    const e = this.formatValue(this.appendValue);
    return `APPEND INTO ${this.tableName} (${this.columnName}) VALUES (${e})${this.buildWhere()}`;
  }
}
class dm {
  static createTable(e, s, n, i) {
    const o = Array.from(s.entries()).map(([a, l]) => {
      let u = `    ${a} ${l}`;
      return i && i.has(a) && (u += ` COMMENT ${this.formatValue(i.get(a))}`), u;
    }).join(`,
`);
    let r = `CREATE TABLE ${e} (
${o}
)`;
    return n && (r += ` COMMENT ${this.formatValue(n)}`), r;
  }
  static alterTableAddColumn(e, s, n, i) {
    let o = `ALTER TABLE ${e} ADD COLUMN ${s} ${n}`;
    return i && (o += ` COMMENT ${this.formatValue(i)}`), o;
  }
  static alterTableDropColumn(e, s) {
    return `ALTER TABLE ${e} DROP COLUMN ${s}`;
  }
  static alterTableRename(e, s) {
    return `ALTER TABLE ${e} RENAME TO ${s}`;
  }
  static alterTableModifyColumnComment(e, s, n, i) {
    return `ALTER TABLE ${e} MODIFY COLUMN ${s} ${n} COMMENT ${this.formatValue(i)}`;
  }
  static alterTableRenameColumn(e, s, n) {
    return `ALTER TABLE ${e} RENAME COLUMN ${s} TO ${n}`;
  }
  static alterTableComment(e, s) {
    return `ALTER TABLE ${e} COMMENT ${this.formatValue(s)}`;
  }
  static dropTable(e) {
    return `DROP TABLE ${e}`;
  }
  static formatValue(e) {
    return `"${e}"`;
  }
}
class rt {
  static select() {
    return new rm();
  }
  static insert() {
    return new am();
  }
  static update() {
    return new lm();
  }
  static delete() {
    return new cm();
  }
  static append() {
    return new um();
  }
  static ddl() {
    return dm;
  }
}
class cl {
  queryData(e, s) {
    const n = rt.select().from(e).where(s || Vs.of()).build();
    return this.executor.execute(n, [se.DQL]);
  }
  insertData(e, s) {
    const n = rt.insert().into(e);
    Array.isArray(s) ? n.batch(s) : n.setValues(s);
    const i = n.build();
    return this.executor.execute(i, [se.DML]);
  }
  deleteData(e, s) {
    const n = rt.delete().from(e).where(s).build();
    return this.executor.execute(n, [se.DML]);
  }
  updateData(e, s, n) {
    const i = rt.update().table(e).setValues(s).where(n).build();
    return this.executor.execute(i, [se.DML]);
  }
  export(e) {
    return this.executor.export(st.INSERT_SQL, e);
  }
}
class fm extends cl {
  get executor() {
    return Pe.instance.tableTemplate;
  }
}
class wo {
  createTable(e, s, n) {
    const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    s.forEach((a) => {
      const l = a.type + (a.primitiveKey ? " PRIMARY KEY" : "");
      i.set(a.name, l), a.comment && o.set(a.name, a.comment);
    });
    const r = rt.ddl().createTable(e, i, n, o);
    return this.executor.execute(r, [se.DDL]);
  }
  dropTable(e) {
    const s = rt.ddl().dropTable(e);
    return this.executor.execute(s, [se.DDL]);
  }
  addColumn(e, s, n) {
    const i = n.type + (n.primitiveKey ? " PRIMARY KEY" : ""), o = rt.ddl().alterTableAddColumn(e, s, i, n.comment);
    return this.executor.execute(o, [se.DDL]);
  }
  dropColumn(e, s) {
    const n = rt.ddl().alterTableDropColumn(e, s);
    return this.executor.execute(n, [se.DDL]);
  }
  alterTableName(e, s) {
    const n = rt.ddl().alterTableRename(e, s);
    return this.executor.execute(n, [se.DDL]);
  }
  alterTableComment(e, s) {
    const n = rt.ddl().alterTableComment(e, s);
    return this.executor.execute(n, [se.DDL]);
  }
  alterColumnComment(e, s, n) {
    if (this.executor.getTableIdxByName(e) === void 0)
      return {
        success: !1,
        message: `Table ${e} not found`,
        data: 0,
        type: se.DDL
      };
    const o = rt.ddl().alterTableModifyColumnComment(e, s, "STRING", n);
    return this.executor.execute(o, [se.DDL]);
  }
  alterColumnName(e, s, n) {
    const i = rt.ddl().alterTableRenameColumn(e, s, n);
    return this.executor.execute(i, [se.DDL]);
  }
  exportData(e) {
    return this.executor.export(st.INSERT_SQL, e);
  }
  exportDDL(e) {
    return this.executor.export(st.DDL, e);
  }
  getTables() {
    return this.executor.getTables();
  }
}
class pm extends wo {
  get executor() {
    return Pe.instance.tableTemplate;
  }
}
class hm extends wo {
  get executor() {
    return xe.instance.tableTemplate;
  }
}
class mm extends cl {
  get executor() {
    return xe.instance.systemSqlExecutor;
  }
}
class vm extends wo {
  get executor() {
    return xe.instance.systemSqlExecutor;
  }
}
class bm {
  execute(e) {
    return xe.instance.systemSqlExecutor.execute(e, [se.DDL, se.DML]);
  }
}
class gm {
  syncTableFromTemplate() {
    xe.instance.systemSqlExecutor = xe.instance.tableTemplate.clone();
  }
  pushTableToTemplate() {
    const e = xe.instance.systemSqlExecutor, s = xe.instance.tableTemplate, n = e.serialize();
    s.deserialize({ structure: n.tableTemplate.structure });
  }
}
class Em {
  execute(e) {
    return Pe.instance.tableTemplate.execute(e, [se.DDL]);
  }
}
class ym {
  execute(e) {
    return xe.instance.tableTemplate.execute(e, [se.DDL]);
  }
}
class _m {
  /**
   * 
   */
  pushTableToTemplate() {
    const e = Pe.instance.tableTemplate, s = xe.instance.tableTemplate, n = e.serialize();
    s.deserialize({ structure: n.tableTemplate.structure });
  }
  /**
   * 
   */
  syncTableFromTemplate() {
    Pe.instance.tableTemplate = xe.instance.tableTemplate.clone();
  }
}
class ke {
  static _chatDataManagementService = new fm();
  static _chatTableManagementService = new pm();
  static _chatSqlExecutorService = new Em();
  static _templateSqlExecutorService = new ym();
  static _templateTableManagementService = new hm();
  static _chatDatabaseSyncService = new _m();
  static _systemDataManagementService = new mm();
  static _systemTableManagementService = new vm();
  static _systemSqlExecutorService = new bm();
  static _systemDatabaseSyncService = new gm();
  static get chatDataManagementService() {
    return ke._chatDataManagementService;
  }
  static get chatTableManagementService() {
    return ke._chatTableManagementService;
  }
  static get chatSqlExecutorService() {
    return ke._chatSqlExecutorService;
  }
  static get templateSqlExecutorService() {
    return ke._templateSqlExecutorService;
  }
  static get templateTableManagementService() {
    return ke._templateTableManagementService;
  }
  static get chatDatabaseSyncService() {
    return ke._chatDatabaseSyncService;
  }
  static get systemDataManagementService() {
    return ke._systemDataManagementService;
  }
  static get systemTableManagementService() {
    return ke._systemTableManagementService;
  }
  static get systemSqlExecutorService() {
    return ke._systemSqlExecutorService;
  }
  static get systemDatabaseSyncService() {
    return ke._systemDatabaseSyncService;
  }
}
function Nm() {
  const t = ie(() => ke.chatDataManagementService), e = ie(() => ke.chatTableManagementService), s = ie(() => ke.chatSqlExecutorService), n = ie(() => ke.chatDatabaseSyncService);
  return {
    dataManagementService: t,
    tableManagementService: e,
    sqlExecutorService: s,
    databaseSyncService: n
  };
}
function Tm() {
  const t = ie(() => ke.templateTableManagementService), e = ie(() => ke.templateSqlExecutorService);
  return {
    tableManagementService: t,
    sqlExecutorService: e
  };
}
function xm() {
  const t = ie(() => ke.systemDataManagementService), e = ie(() => ke.systemTableManagementService), s = ie(() => ke.systemSqlExecutorService), n = ie(() => ke.systemDatabaseSyncService);
  return {
    dataManagementService: t,
    tableManagementService: e,
    sqlExecutorService: s,
    databaseSyncService: n
  };
}
const wm = /* @__PURE__ */ _e({
  __name: "TemplateManagementPanel",
  props: /* @__PURE__ */ oo({
    defaultTabOnTableSelect: { default: "template" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { tableManagementService: n, sqlExecutorService: i } = Tm(), o = ro(t, "visible"), r = /* @__PURE__ */ j(!1), a = /* @__PURE__ */ j("template"), l = /* @__PURE__ */ j(""), u = /* @__PURE__ */ j([]), c = /* @__PURE__ */ j(null), d = [
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], m = () => {
      u.value = n.value.getTables();
    }, h = (_) => {
      l.value = _, a.value = s.defaultTabOnTableSelect;
    }, b = () => {
      r.value = !r.value;
    }, y = async () => {
      a.value = "template", await Pt(), c.value?.openCreateTableModal();
    }, E = () => {
      o.value = !1;
    };
    return lt(o, (_) => {
      _ && m();
    }), e({
      open: () => {
        o.value = !0;
      }
    }), (_, S) => (x(), M("div", null, [
      bt(_.$slots, "default"),
      w(Ge, {
        visible: o.value,
        "onUpdate:visible": S[2] || (S[2] = (N) => o.value = N),
        title: "",
        closable: !0,
        height: "650px",
        onClose: E
      }, {
        titlePrefix: k(() => [
          w(bo, {
            expanded: r.value,
            onToggle: b
          }, null, 8, ["expanded"])
        ]),
        default: k(() => [
          w(mo, {
            "drawer-expanded": r.value,
            "onUpdate:drawerExpanded": S[1] || (S[1] = (N) => r.value = N),
            tables: u.value,
            "selected-table": l.value,
            onSelectTable: h,
            onCreateTable: y
          }, {
            default: k(() => [
              w(vo, {
                "active-tab": a.value,
                "onUpdate:activeTab": S[0] || (S[0] = (N) => a.value = N),
                tabs: d
              }, {
                template: k(() => [
                  w(go, {
                    ref_key: "tableTabRef",
                    ref: c,
                    "table-service": Q(n),
                    tables: u.value,
                    "selected-table": l.value,
                    onRefresh: m,
                    "onUpdate:selectedTable": h
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: k(() => [
                  w(Eo, {
                    "sql-executor-service": Q(i),
                    onRefresh: m
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), Sm = { class: "data-form" }, Cm = { class: "form-content" }, Dm = { class: "form-label" }, Om = {
  key: 0,
  class: "required-mark"
}, $m = ["onUpdate:modelValue", "type"], Am = { class: "form-actions" }, Vm = /* @__PURE__ */ _e({
  __name: "DataForm",
  props: {
    columns: {},
    initialData: {},
    title: { default: "" },
    modalWidth: { default: "50vw" },
    modalHeight: { default: "auto" }
  },
  emits: ["submit", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ j(!1), o = () => {
      i.value = window.innerWidth <= 768;
    };
    ot(() => {
      o(), window.addEventListener("resize", o);
    }), jt(() => {
      window.removeEventListener("resize", o);
    });
    const r = ie(() => i.value ? "100%" : s.modalWidth), a = ie(() => {
      const b = {};
      return s.modalWidth && (b["--form-modal-width"] = i.value ? "100%" : s.modalWidth), s.modalHeight && (b["--form-modal-height"] = s.modalHeight), b;
    }), l = /* @__PURE__ */ Ns({}), u = () => {
      s.columns.forEach((b) => {
        s.initialData && s.initialData[b.name] !== void 0 ? l[b.name] = s.initialData[b.name] : b.defaultValue !== void 0 ? l[b.name] = b.defaultValue : l[b.name] = "";
      });
    }, c = (b) => {
      const y = b.toUpperCase();
      return y.includes("STRING") || y.includes("TEXT");
    }, d = (b) => b.toUpperCase().includes("INT") || b.toUpperCase().includes("REAL") || b.toUpperCase().includes("FLOA") || b.toUpperCase().includes("DOUB") ? "number" : "text", m = () => {
      const b = /* @__PURE__ */ new Map();
      s.columns.forEach((y) => {
        let E = l[y.name], _;
        E === "" || E === void 0 ? y.primitiveKey && y.defaultValue !== void 0 ? _ = y.defaultValue : _ = null : _ = E;
        const S = y.type.toUpperCase();
        S.includes("INT") && _ !== null ? _ = parseInt(String(_)) : (S.includes("REAL") || S.includes("FLOA") || S.includes("DOUB")) && _ !== null && (_ = parseFloat(String(_))), b.set(y.name, _);
      }), n("submit", b);
    }, h = () => {
      n("cancel");
    };
    return lt(() => s.initialData, () => {
      u();
    }, { immediate: !0 }), (b, y) => (x(), M("div", {
      class: "data-form-wrapper",
      style: Ke(a.value)
    }, [
      w(Ge, {
        visible: !0,
        title: t.title,
        width: r.value,
        height: t.modalHeight,
        closable: !1,
        onClose: h
      }, {
        default: k(() => [
          f("div", Sm, [
            f("div", Cm, [
              (x(!0), M(Ae, null, Jt(t.columns, (E) => (x(), M("div", {
                key: E.name,
                class: "form-item"
              }, [
                f("label", Dm, [
                  oe(fe(E.name) + " ", 1),
                  E.primitiveKey ? (x(), M("span", Om, "*")) : ne("", !0)
                ]),
                c(E.type) ? (x(), Ie(Ms, {
                  key: 1,
                  "model-value": String(l[E.name] || ""),
                  "onUpdate:modelValue": (_) => l[E.name] = _,
                  "min-rows": 1,
                  "max-rows": 10
                }, null, 8, ["model-value", "onUpdate:modelValue"])) : it((x(), M("input", {
                  key: 0,
                  "onUpdate:modelValue": (_) => l[E.name] = _,
                  type: d(E.type),
                  class: "form-input"
                }, null, 8, $m)), [
                  [yd, l[E.name]]
                ])
              ]))), 128))
            ]),
            f("div", Am, [
              w(ce, { onClick: h }, {
                default: k(() => [...y[0] || (y[0] = [
                  oe("", -1)
                ])]),
                _: 1
              }),
              w(ce, {
                type: "primary",
                onClick: m
              }, {
                default: k(() => [...y[1] || (y[1] = [
                  oe("", -1)
                ])]),
                _: 1
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["title", "width", "height"])
    ], 4));
  }
}), Rr = /* @__PURE__ */ De(Vm, [["__scopeId", "data-v-dd6bd7a8"]]), Rm = { class: "confirm-container" }, Im = { class: "form-actions" }, Mm = /* @__PURE__ */ _e({
  __name: "DeleteDataConfirm",
  props: {
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = ie(() => {
      const a = {};
      return s.modalWidth && (a["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (a["--confirm-modal-height"] = s.modalHeight), a;
    }), o = () => {
      n("confirm");
    }, r = () => {
      n("cancel");
    };
    return (a, l) => (x(), M("div", {
      class: "delete-data-confirm-wrapper",
      style: Ke(i.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: r
      }, {
        default: k(() => [
          f("div", Rm, [
            l[2] || (l[2] = f("div", { class: "confirm-content" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" }),
              f("p", { class: "confirm-message" }, "")
            ], -1)),
            f("div", Im, [
              w(ce, { onClick: r }, {
                default: k(() => [...l[0] || (l[0] = [
                  oe("", -1)
                ])]),
                _: 1
              }),
              w(ce, {
                type: "danger",
                onClick: o
              }, {
                default: k(() => [...l[1] || (l[1] = [
                  oe("", -1)
                ])]),
                _: 1
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), Lm = /* @__PURE__ */ De(Mm, [["__scopeId", "data-v-b672c047"]]), km = { class: "export-container" }, Pm = { class: "export-header" }, Bm = { class: "export-content" }, Um = { class: "export-code" }, Fm = { class: "form-actions" }, jm = /* @__PURE__ */ _e({
  __name: "ExportDisplay",
  props: {
    sql: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ j(!1);
    let o = null;
    const r = async () => {
      try {
        await navigator.clipboard.writeText(s.sql), i.value = !0, o && clearTimeout(o), o = setTimeout(() => {
          i.value = !1;
        }, 2e3);
      } catch (l) {
        console.error(":", l);
      }
    }, a = () => {
      n("close");
    };
    return (l, u) => (x(), M("div", km, [
      f("div", Pm, [
        u[0] || (u[0] = f("span", { class: "export-title" }, "SQL", -1)),
        f("button", {
          class: "copy-btn",
          onClick: r
        }, [
          f("i", {
            class: Me(i.value ? "fa-solid fa-check" : "fa-solid fa-copy")
          }, null, 2),
          oe(" " + fe(i.value ? "" : ""), 1)
        ])
      ]),
      f("div", Bm, [
        f("pre", Um, fe(t.sql), 1)
      ]),
      f("div", Fm, [
        w(ce, { onClick: a }, {
          default: k(() => [...u[1] || (u[1] = [
            oe("", -1)
          ])]),
          _: 1
        })
      ])
    ]));
  }
}), qm = /* @__PURE__ */ De(jm, [["__scopeId", "data-v-affef56e"]]), Wm = { class: "chat-data-management-tab" }, Hm = {
  key: 1,
  class: "data-detail"
}, Km = { class: "data-toolbar" }, zm = { class: "data-title" }, Gm = { class: "table-name" }, Ym = {
  key: 0,
  class: "table-comment"
}, Jm = { class: "data-actions" }, Qm = { class: "data-list" }, Xm = {
  key: 1,
  class: "table-container"
}, Zm = { class: "data-table" }, ev = {
  key: 0,
  class: "checkbox-header sticky-col",
  style: { left: "0" }
}, tv = { class: "checkbox-wrapper" }, sv = ["checked"], nv = {
  key: 0,
  class: "checkbox-cell sticky-col",
  style: { left: "0" }
}, iv = { class: "checkbox-wrapper" }, ov = ["checked", "onChange"], rv = { class: "row-actions" }, av = { class: "cell-value" }, lv = /* @__PURE__ */ _e({
  __name: "ChatDataManagementTab",
  props: {
    dataService: {},
    tables: {},
    selectedTable: {}
  },
  emits: ["refresh"],
  setup(t, { emit: e }) {
    const s = t, n = ie(() => s.tables.find((K) => K.tableName === s.selectedTable) || {}), i = ie(() => n.value.columnSchemas ? Object.values(n.value.columnSchemas) : []), o = ie(() => u.value === "none" ? "" : u.value === "selecting" ? "" : u.value === "confirming" ? "" : ""), r = /* @__PURE__ */ j([]), a = /* @__PURE__ */ j(/* @__PURE__ */ new Set()), l = /* @__PURE__ */ j(!1), u = /* @__PURE__ */ j("none"), { toast: c, showToast: d } = ll(), m = /* @__PURE__ */ j(!1), h = /* @__PURE__ */ j(!1), b = /* @__PURE__ */ j(!1), y = /* @__PURE__ */ j(!1), E = /* @__PURE__ */ j(null), _ = /* @__PURE__ */ j(""), S = (K) => K === null ? "NULL" : K === void 0 ? "" : String(K).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "\\n").replace(/<br>/gi, "&lt;br&gt;"), N = () => {
      if (n.value.tableName) {
        const K = s.dataService.queryData(n.value.tableName);
        K.success && Array.isArray(K.data) ? r.value = K.data : r.value = [];
      }
    }, R = (K) => {
      if (n.value.tableName) {
        const G = s.dataService.insertData(n.value.tableName, K);
        G.success ? (m.value = !1, N(), d("")) : d(G.message || "", "error");
      }
    }, P = (K, G) => {
      E.value = { index: K, row: G }, h.value = !0;
    }, H = (K) => {
      if (n.value.tableName && E.value) {
        const G = i.value.find((le) => le.primitiveKey), ue = r.value[E.value.index];
        let ve = Vs.of();
        if (G) {
          const le = ue[G.name];
          ve = ve.eq(G.name, le);
        }
        const Y = s.dataService.updateData(n.value.tableName, K, ve);
        Y.success ? (h.value = !1, E.value = null, N(), d("")) : d(Y.message || "", "error");
      }
    }, pe = (K) => {
      E.value = { index: K, row: r.value[K] }, b.value = !0;
    }, he = () => {
      if (n.value.tableName && E.value) {
        const K = i.value.find((Y) => Y.primitiveKey), G = r.value[E.value.index];
        let ue = Vs.of();
        if (K) {
          const Y = G[K.name];
          ue = ue.eq(K.name, Y);
        }
        const ve = s.dataService.deleteData(n.value.tableName, ue);
        ve.success ? (b.value = !1, E.value = null, N(), d("")) : d(ve.message || "", "error");
      }
    }, W = (K) => {
      a.value.has(K) ? a.value.delete(K) : a.value.add(K), a.value.size > 0 ? u.value = "confirming" : u.value = "selecting";
    }, ae = (K) => {
      K.target.checked ? r.value.forEach((ue, ve) => a.value.add(ve)) : a.value.clear(), a.value.size > 0 ? u.value = "confirming" : u.value = "selecting";
    }, me = () => {
      if (u.value === "none")
        u.value = "selecting", l.value = !0, a.value.clear();
      else if (u.value === "selecting")
        u.value = "none", l.value = !1, a.value.clear();
      else if (u.value === "confirming") {
        if (a.value.size === 0) {
          d("", "error");
          return;
        }
        if (n.value.tableName) {
          let K = 0;
          const G = i.value.find((ue) => ue.primitiveKey);
          a.value.forEach((ue) => {
            const ve = r.value[ue];
            let Y = Vs.of();
            if (G) {
              const X = ve[G.name];
              Y = Y.eq(G.name, X);
            }
            s.dataService.deleteData(n.value.tableName, Y).success && K++;
          }), a.value.clear(), N(), d(` ${K} `), u.value = "none", l.value = !1;
        }
      }
    }, q = () => {
      n.value.tableName && (_.value = s.dataService.export(n.value.tableName), y.value = !0);
    };
    return lt(() => s.selectedTable, () => {
      N();
    }), ot(() => {
      N();
    }), (K, G) => (x(), M("div", Wm, [
      t.selectedTable ? (x(), M("div", Hm, [
        f("div", Km, [
          f("div", zm, [
            f("span", Gm, fe(n.value.tableName), 1),
            n.value.comment ? (x(), M("span", Ym, fe(n.value.comment), 1)) : ne("", !0)
          ]),
          f("div", Jm, [
            w(ce, {
              onClick: G[0] || (G[0] = (ue) => m.value = !0)
            }, {
              default: k(() => [...G[6] || (G[6] = [
                f("i", {
                  class: "fa-solid fa-plus",
                  style: { "margin-right": "6px" }
                }, null, -1),
                oe("  ", -1)
              ])]),
              _: 1
            }),
            w(ce, {
              type: "danger",
              onClick: me
            }, {
              default: k(() => [
                G[7] || (G[7] = f("i", {
                  class: "fa-solid fa-trash",
                  style: { "margin-right": "6px" }
                }, null, -1)),
                oe(" " + fe(o.value), 1)
              ]),
              _: 1
            }),
            w(ce, { onClick: q }, {
              default: k(() => [...G[8] || (G[8] = [
                f("i", {
                  class: "fa-solid fa-download",
                  style: { "margin-right": "6px" }
                }, null, -1),
                oe("  ", -1)
              ])]),
              _: 1
            })
          ])
        ]),
        f("div", Qm, [
          r.value.length === 0 ? (x(), Ie(Jn, {
            key: 0,
            icon: "fa-solid fa-database",
            text: ""
          })) : (x(), M("div", Xm, [
            f("table", Zm, [
              f("thead", null, [
                f("tr", null, [
                  l.value ? (x(), M("th", ev, [
                    f("label", tv, [
                      f("input", {
                        type: "checkbox",
                        checked: a.value.size === r.value.length && r.value.length > 0,
                        onChange: ae
                      }, null, 40, sv)
                    ])
                  ])) : ne("", !0),
                  f("th", {
                    class: "actions-header sticky-col",
                    style: Ke({ left: l.value ? "50px" : "0" })
                  }, "  ", 4),
                  (x(!0), M(Ae, null, Jt(i.value, (ue) => (x(), M("th", {
                    key: ue.name,
                    class: Me(["column-header", ue.primitiveKey ? "primary-key" : ""])
                  }, fe(ue.name), 3))), 128))
                ])
              ]),
              f("tbody", null, [
                (x(!0), M(Ae, null, Jt(r.value, (ue, ve) => (x(), M("tr", {
                  key: ve,
                  class: "table-row"
                }, [
                  l.value ? (x(), M("td", nv, [
                    f("label", iv, [
                      f("input", {
                        type: "checkbox",
                        checked: a.value.has(ve),
                        onChange: (Y) => W(ve)
                      }, null, 40, ov)
                    ])
                  ])) : ne("", !0),
                  f("td", {
                    class: "actions-cell sticky-col",
                    style: Ke({ left: l.value ? "50px" : "0" })
                  }, [
                    f("div", rv, [
                      w(ce, {
                        size: "small",
                        onClick: (Y) => P(ve, ue)
                      }, {
                        default: k(() => [...G[9] || (G[9] = [
                          f("i", { class: "fa-solid fa-pen" }, null, -1)
                        ])]),
                        _: 1
                      }, 8, ["onClick"]),
                      w(ce, {
                        type: "danger",
                        size: "small",
                        onClick: (Y) => pe(ve)
                      }, {
                        default: k(() => [...G[10] || (G[10] = [
                          f("i", { class: "fa-solid fa-trash" }, null, -1)
                        ])]),
                        _: 1
                      }, 8, ["onClick"])
                    ])
                  ], 4),
                  (x(!0), M(Ae, null, Jt(i.value, (Y) => (x(), M("td", {
                    key: Y.name,
                    class: Me(["table-cell", Y.primitiveKey ? "primary-key" : ""])
                  }, [
                    f("span", av, fe(S(ue[Y.name])), 1)
                  ], 2))), 128))
                ]))), 128))
              ])
            ])
          ]))
        ])
      ])) : (x(), Ie(Jn, {
        key: 0,
        icon: "fa-solid fa-table",
        text: ""
      })),
      w(al, {
        visible: Q(c).visible,
        message: Q(c).message,
        type: Q(c).type,
        icon: Q(c).icon
      }, null, 8, ["visible", "message", "type", "icon"]),
      m.value ? (x(), Ie(Rr, {
        key: 2,
        title: "",
        columns: i.value,
        "modal-width": "50vw",
        onSubmit: R,
        onCancel: G[1] || (G[1] = (ue) => m.value = !1)
      }, null, 8, ["columns"])) : ne("", !0),
      h.value && E.value ? (x(), Ie(Rr, {
        key: 3,
        title: "",
        columns: i.value,
        "initial-data": E.value.row,
        "modal-width": "50vw",
        onSubmit: H,
        onCancel: G[2] || (G[2] = (ue) => h.value = !1)
      }, null, 8, ["columns", "initial-data"])) : ne("", !0),
      b.value ? (x(), Ie(Lm, {
        key: 4,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: he,
        onCancel: G[3] || (G[3] = (ue) => b.value = !1)
      })) : ne("", !0),
      y.value ? (x(), Ie(Ge, {
        key: 5,
        visible: "",
        title: "",
        onClose: G[5] || (G[5] = (ue) => y.value = !1)
      }, {
        default: k(() => [
          w(qm, {
            sql: _.value,
            onClose: G[4] || (G[4] = (ue) => y.value = !1)
          }, null, 8, ["sql"])
        ]),
        _: 1
      })) : ne("", !0)
    ]));
  }
}), ul = /* @__PURE__ */ De(lv, [["__scopeId", "data-v-1747acc7"]]), cv = /* @__PURE__ */ _e({
  __name: "SystemDataManagementPanel",
  props: /* @__PURE__ */ oo({
    defaultTabOnTableSelect: { default: "data" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { dataManagementService: n, tableManagementService: i, sqlExecutorService: o } = xm(), r = ro(t, "visible"), a = /* @__PURE__ */ j(!1), l = /* @__PURE__ */ j("data"), u = /* @__PURE__ */ j(""), c = /* @__PURE__ */ j([]), d = /* @__PURE__ */ j(null), m = [
      { key: "data", label: "", icon: "fa-solid fa-database" },
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], h = () => {
      c.value = i.value.getTables();
    }, b = (S) => {
      u.value = S, l.value = s.defaultTabOnTableSelect;
    }, y = () => {
      a.value = !a.value;
    }, E = async () => {
      l.value = "template", await Pt(), d.value?.openCreateTableModal();
    }, _ = () => {
      r.value = !1;
    };
    return lt(r, (S) => {
      S && h();
    }), e({
      open: () => {
        r.value = !0;
      }
    }), (S, N) => (x(), M("div", null, [
      bt(S.$slots, "default"),
      w(Ge, {
        visible: r.value,
        "onUpdate:visible": N[2] || (N[2] = (R) => r.value = R),
        title: "",
        closable: !0,
        height: "650px",
        onClose: _
      }, {
        titlePrefix: k(() => [
          w(bo, {
            expanded: a.value,
            onToggle: y
          }, null, 8, ["expanded"])
        ]),
        default: k(() => [
          w(mo, {
            "drawer-expanded": a.value,
            "onUpdate:drawerExpanded": N[1] || (N[1] = (R) => a.value = R),
            tables: c.value,
            "selected-table": u.value,
            "show-sync-buttons": !1,
            onSelectTable: b,
            onCreateTable: E
          }, {
            default: k(() => [
              w(vo, {
                "active-tab": l.value,
                "onUpdate:activeTab": N[0] || (N[0] = (R) => l.value = R),
                tabs: m
              }, {
                data: k(() => [
                  w(ul, {
                    "data-service": Q(n),
                    tables: c.value,
                    "selected-table": u.value,
                    onRefresh: h
                  }, null, 8, ["data-service", "tables", "selected-table"])
                ]),
                template: k(() => [
                  w(go, {
                    ref_key: "tableTabRef",
                    ref: d,
                    "table-service": Q(i),
                    tables: c.value,
                    "selected-table": u.value,
                    onRefresh: h,
                    "onUpdate:selectedTable": b
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: k(() => [
                  w(Eo, {
                    "sql-executor-service": Q(o),
                    onRefresh: h
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), uv = { class: "category_container" }, dv = { style: { display: "flex", "align-items": "center", gap: "10px" } }, fv = { class: "category_container" }, pv = { class: "category_container" }, hv = { style: { display: "flex", "flex-direction": "column", gap: "12px" } }, mv = /* @__PURE__ */ _e({
  __name: "SettingsPanel",
  setup(t) {
    const e = xe.instance, s = ie({
      get: () => e.extensionSwitch,
      set: (y) => e.extensionSwitch = y
    }), n = ie({
      get: () => e.chatStatusBarSwitch,
      set: (y) => e.chatStatusBarSwitch = y
    }), i = /* @__PURE__ */ j(!1), o = /* @__PURE__ */ j(""), r = /* @__PURE__ */ j(), a = /* @__PURE__ */ j(0);
    lt(i, async (y) => {
      if (y) {
        a.value++, await Pt();
        const E = e.chatStatusBarCode;
        o.value = E, await Pt(), r.value && (r.value.value = E);
      }
    });
    const l = () => {
      i.value = !0;
    }, u = () => {
      i.value = !1;
    }, c = () => {
      e.chatStatusBarCode = o.value, i.value = !1;
    }, d = /* @__PURE__ */ j(), m = /* @__PURE__ */ j(), h = () => {
      d.value?.open();
    }, b = () => {
      m.value?.open();
    };
    return (y, E) => (x(), M(Ae, null, [
      f("div", uv, [
        w(wn, null, {
          left: k(() => [...E[4] || (E[4] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-sliders",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: k(() => [
            w(Cr, {
              checked: s.value,
              onChange: E[0] || (E[0] = (_) => s.value = _)
            }, null, 8, ["checked"])
          ]),
          _: 1
        }),
        w(wn, null, {
          left: k(() => [...E[5] || (E[5] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-paper-plane",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: k(() => [
            f("div", dv, [
              w(Cr, {
                checked: n.value,
                onChange: E[1] || (E[1] = (_) => n.value = _)
              }, null, 8, ["checked"]),
              w(ce, { onClick: l }, {
                default: k(() => [...E[6] || (E[6] = [
                  f("i", {
                    class: "fa-solid fa-pen-to-square",
                    style: { "margin-right": "6px" }
                  }, null, -1),
                  oe("  ", -1)
                ])]),
                _: 1
              })
            ])
          ]),
          _: 1
        })
      ]),
      f("div", fv, [
        w(wn, null, {
          left: k(() => [...E[7] || (E[7] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-file-code",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: k(() => [
            w(ce, { onClick: h }, {
              default: k(() => [...E[8] || (E[8] = [
                f("i", {
                  class: "fa-solid fa-gear",
                  style: { "margin-right": "6px" }
                }, null, -1),
                oe("  ", -1)
              ])]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      f("div", pv, [
        w(wn, null, {
          left: k(() => [...E[9] || (E[9] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-database",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: k(() => [
            w(ce, { onClick: b }, {
              default: k(() => [...E[10] || (E[10] = [
                f("i", {
                  class: "fa-solid fa-gear",
                  style: { "margin-right": "6px" }
                }, null, -1),
                oe("  ", -1)
              ])]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      w(wm, {
        ref_key: "templateManagementPanelRef",
        ref: d
      }, {
        default: k(() => [...E[11] || (E[11] = [])]),
        _: 1
      }, 512),
      w(cv, {
        ref_key: "systemDataManagementPanelRef",
        ref: m
      }, {
        default: k(() => [...E[12] || (E[12] = [])]),
        _: 1
      }, 512),
      w(Ge, {
        visible: i.value,
        "onUpdate:visible": E[3] || (E[3] = (_) => i.value = _),
        title: "",
        closable: !0,
        onClose: u
      }, {
        footer: k(() => [
          w(ce, { onClick: u }, {
            default: k(() => [...E[13] || (E[13] = [
              oe("", -1)
            ])]),
            _: 1
          }),
          w(ce, { onClick: c }, {
            default: k(() => [...E[14] || (E[14] = [
              oe("", -1)
            ])]),
            _: 1
          })
        ]),
        default: k(() => [
          f("div", hv, [
            it(f("textarea", {
              ref_key: "textareaRef",
              ref: r,
              "onUpdate:modelValue": E[2] || (E[2] = (_) => o.value = _),
              rows: "10",
              style: { width: "100%", padding: "12px", border: "1px solid var(--SmartThemeBorderColor)", "border-radius": "6px", background: "var(--black30a)", color: "var(--SmartThemeBodyColor)", "font-family": "monospace", resize: "vertical" },
              placeholder: "..."
            }, null, 512), [
              [gt, o.value]
            ])
          ])
        ]),
        _: 1
      }, 8, ["visible"])
    ], 64));
  }
}), vv = /* @__PURE__ */ _e({
  __name: "ExtraMesButtons",
  emits: ["click"],
  setup(t, { emit: e }) {
    const s = e;
    function n() {
      s("click");
    }
    return ot(() => {
      $(document).on("click", ".open_database_table", n);
    }), hn(() => {
      $(document).off("click", ".open_database_table", n);
    }), (i, o) => (x(), Ie(Na, { to: ".extraMesButtons" }, [
      o[0] || (o[0] = f("div", {
        class: "mes_button open_database_table",
        title: ""
      }, [
        f("i", { class: "fa-solid fa-table" })
      ], -1))
    ]));
  }
}), bv = /* @__PURE__ */ _e({
  __name: "ChatManagementPanel",
  props: /* @__PURE__ */ oo({
    defaultTabOnTableSelect: { default: "data" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { dataManagementService: n, tableManagementService: i, sqlExecutorService: o, databaseSyncService: r } = Nm(), a = ro(t, "visible"), l = /* @__PURE__ */ j(!1), u = /* @__PURE__ */ j("data"), c = /* @__PURE__ */ j(""), d = /* @__PURE__ */ j([]), m = /* @__PURE__ */ j(null), h = [
      { key: "data", label: "", icon: "fa-solid fa-database" },
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], b = () => {
      d.value = i.value.getTables();
    }, y = (P) => {
      c.value = P, u.value = s.defaultTabOnTableSelect;
    }, E = () => {
      l.value = !l.value;
    }, _ = async () => {
      u.value = "template", await Pt(), m.value?.openCreateTableModal();
    }, S = () => {
      r.value.syncTableFromTemplate(), b();
    }, N = () => {
      r.value.pushTableToTemplate(), b();
    }, R = () => {
      a.value = !1;
    };
    return lt(a, (P) => {
      P && b();
    }), e({
      open: () => {
        a.value = !0;
      }
    }), (P, H) => (x(), M("div", null, [
      bt(P.$slots, "default"),
      w(Ge, {
        visible: a.value,
        "onUpdate:visible": H[2] || (H[2] = (pe) => a.value = pe),
        title: "",
        closable: !0,
        height: "650px",
        onClose: R
      }, {
        titlePrefix: k(() => [
          w(bo, {
            expanded: l.value,
            onToggle: E
          }, null, 8, ["expanded"])
        ]),
        default: k(() => [
          w(mo, {
            "drawer-expanded": l.value,
            "onUpdate:drawerExpanded": H[1] || (H[1] = (pe) => l.value = pe),
            tables: d.value,
            "selected-table": c.value,
            "show-sync-buttons": !0,
            onSelectTable: y,
            onCreateTable: _,
            onSync: S,
            onPush: N
          }, {
            default: k(() => [
              w(vo, {
                "active-tab": u.value,
                "onUpdate:activeTab": H[0] || (H[0] = (pe) => u.value = pe),
                tabs: h
              }, {
                data: k(() => [
                  w(ul, {
                    "data-service": Q(n),
                    tables: d.value,
                    "selected-table": c.value,
                    onRefresh: b
                  }, null, 8, ["data-service", "tables", "selected-table"])
                ]),
                template: k(() => [
                  w(go, {
                    ref_key: "tableTabRef",
                    ref: m,
                    "table-service": Q(i),
                    tables: d.value,
                    "selected-table": c.value,
                    onRefresh: b,
                    "onUpdate:selectedTable": y
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: k(() => [
                  w(Eo, {
                    "sql-executor-service": Q(o),
                    onRefresh: b
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), gv = { class: "translation_settings" }, Ev = { class: "inline-drawer" }, yv = { class: "inline-drawer-content" }, _v = { style: { padding: "10px" } }, Nv = /* @__PURE__ */ _e({
  __name: "MainView",
  setup(t) {
    const e = /* @__PURE__ */ j(!1), s = () => {
      e.value = !0;
    };
    return (n, i) => (x(), M("div", gv, [
      f("div", Ev, [
        i[1] || (i[1] = f("div", { class: "inline-drawer-toggle inline-drawer-header" }, [
          f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
            f("b", null, "")
          ]),
          f("div", { class: "inline-drawer-icon fa-solid fa-circle-chevron-down down" })
        ], -1)),
        f("div", yv, [
          f("div", _v, [
            w(mv)
          ])
        ])
      ]),
      w(vv, { onClick: s }),
      w(bv, {
        visible: e.value,
        "onUpdate:visible": i[0] || (i[0] = (o) => e.value = o)
      }, null, 8, ["visible"])
    ]));
  }
}), Tv = /* @__PURE__ */ De(Nv, [["__scopeId", "data-v-d18c04a2"]]);
class xv {
  static init() {
    if (xe.instance.extensionSwitch) {
      const e = SillyTavern.getContext(), { registerMacro: s, eventSource: n } = e;
      if (typeof window > "u")
        return;
      window.getTemplateSqlExecutor = () => xe.instance.tableTemplate, window.getChatSqlExecutor = () => Pe.instance.tableTemplate, window.chatDatabaseData = () => JSON.parse(Pe.instance.tableTemplate.export(st.STANDARD_DATA)), n.on("prompt_template_prepare", (i) => {
        i.getTemplateSqlExecutor = () => xe.instance.tableTemplate, i.getChatSqlExecutor = () => Pe.instance.tableTemplate;
      }), this.registerMacros(s);
    }
  }
  static registerMacros(e) {
    const s = ke.chatTableManagementService;
    e("GET_ALL_TABLE_NAMES", () => s.getTables().map((n) => n.tableName)), e("GET_ALL_TABLE_SCHEMAS", () => Pe.instance.tableTemplate.export(st.DDL)), e("GET_ALL_TABLE_DATA", () => Pe.instance.tableTemplate.export(st.MARKDOWN));
  }
}
class wv {
  static init() {
    Zs.init(), xv.init();
    const e = kt.getInstance();
    e.updateChatTemplateDisplay(), xe.instance.onChatStatusBarChange(() => {
      e.updateChatTemplateDisplay();
    });
  }
}
wv.init();
const Ir = document.createElement("div"), Mr = document.querySelector("#extensions_settings");
Mr && (Mr.appendChild(Ir), Cd(Tv).mount(Ir));
//# sourceMappingURL=index.js.map
