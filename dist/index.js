(function(){"use strict";try{if(typeof document<"u"){var a=document.createElement("style");a.appendChild(document.createTextNode('.st-card-unified[data-v-5b66fbc1]{min-height:48px;display:flex;align-items:center;transition:background-color var(--animation-duration, 125ms)}.st-card-unified>div[data-v-5b66fbc1]{width:100%}.st-toggle-switch[data-v-f73e4a93]{position:relative;display:inline-block;width:40px;height:22px;transform:scale(.9)}.st-toggle-switch input[data-v-f73e4a93]{opacity:0;width:0;height:0}.st-toggle-slider[data-v-f73e4a93]{position:absolute;cursor:pointer;inset:0;background-color:var(--SmartThemeEmColor);transition:var(--animation-duration, 125ms);border-radius:22px}.st-toggle-slider[data-v-f73e4a93]:before{position:absolute;content:"";height:16px;width:16px;left:3px;bottom:3px;background-color:var(--SmartThemeBodyColor);transition:var(--animation-duration, 125ms);border-radius:50%;box-shadow:0 2px 4px var(--SmartThemeShadowColor)}input:checked+.st-toggle-slider[data-v-f73e4a93]{background-color:var(--SmartThemeBodyColor)}input:checked+.st-toggle-slider[data-v-f73e4a93]:before{transform:translate(18px);background-color:var(--SmartThemeBlurTintColor)}.button-wrapper[data-v-8b9ccff3]{display:inline-flex;align-items:center;justify-content:center;flex-direction:row}.button-content[data-v-8b9ccff3]{display:flex;align-items:center;gap:6px;flex-direction:row;white-space:nowrap}.popup-modal-overlay[data-v-546209e7]{position:fixed;inset:0;background:#00000080;display:flex;align-items:center;justify-content:center;z-index:9999;padding:20px}.popup-modal[data-v-546209e7]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:8px;box-shadow:0 4px 20px var(--SmartThemeShadowColor);max-width:1200px;width:100%;max-height:90vh;display:flex;flex-direction:column}.popup-modal-header[data-v-546209e7]{display:flex;justify-content:space-between;align-items:center;padding:16px 20px;border-bottom:1px solid var(--SmartThemeBorderColor)}.popup-modal-title[data-v-546209e7]{font-size:18px;font-weight:600;color:var(--SmartThemeBodyColor);display:flex;align-items:center;gap:8px}.popup-modal-close[data-v-546209e7]{width:32px;height:32px;display:flex;align-items:center;justify-content:center;cursor:pointer;border-radius:4px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);transition:all .2s}.popup-modal-close[data-v-546209e7]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.popup-modal-close i[data-v-546209e7]{font-size:18px}.popup-modal-body[data-v-546209e7]{flex:1;overflow:auto;padding:20px}.popup-modal-footer[data-v-546209e7]{padding:16px 20px;border-top:1px solid var(--SmartThemeBorderColor);display:flex;justify-content:flex-end;gap:10px}.modal-enter-active[data-v-546209e7],.modal-leave-active[data-v-546209e7]{transition:opacity .3s ease}.modal-enter-from[data-v-546209e7],.modal-leave-to[data-v-546209e7]{opacity:0}.modal-enter-active .popup-modal[data-v-546209e7],.modal-leave-active .popup-modal[data-v-546209e7]{transition:transform .3s ease,opacity .3s ease}.modal-enter-from .popup-modal[data-v-546209e7],.modal-leave-to .popup-modal[data-v-546209e7]{transform:scale(.9);opacity:0}@media(max-width:768px){.popup-modal-overlay[data-v-546209e7]{padding:10px}.popup-modal[data-v-546209e7]{height:90vh;border-radius:8px 8px 0 0;margin-top:auto}.popup-modal-header[data-v-546209e7]{padding:12px 16px}.popup-modal-title[data-v-546209e7]{font-size:16px}.popup-modal-body[data-v-546209e7]{padding:16px}.popup-modal-footer[data-v-546209e7]{padding:12px 16px}}.table-list-drawer[data-v-85bfbdca]{display:flex;flex-direction:column;height:100%;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);border-right:1px solid var(--SmartThemeBorderColor)}.drawer-header[data-v-85bfbdca]{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor)}.drawer-title[data-v-85bfbdca]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.header-actions[data-v-85bfbdca]{display:flex;align-items:center;gap:6px}.sync-btn[data-v-85bfbdca],.push-btn[data-v-85bfbdca]{display:flex;align-items:center;justify-content:center;width:28px;height:28px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);cursor:pointer;transition:all .2s}.sync-btn[data-v-85bfbdca]:hover,.push-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.sync-btn i[data-v-85bfbdca],.push-btn i[data-v-85bfbdca]{font-size:13px}.create-table-btn[data-v-85bfbdca]{display:flex;align-items:center;justify-content:center;width:28px;height:28px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);cursor:pointer;transition:all .2s}.create-table-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.create-table-btn i[data-v-85bfbdca]{font-size:13px}.drawer-body[data-v-85bfbdca]{flex:1;overflow-y:auto;padding:8px}.empty-state[data-v-85bfbdca]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:200px;gap:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.empty-state i[data-v-85bfbdca]{font-size:32px}.empty-state span[data-v-85bfbdca]{font-size:14px}.empty-create-btn[data-v-85bfbdca]{display:flex;align-items:center;gap:6px;padding:8px 16px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s;margin-top:8px}.empty-create-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.empty-create-btn i[data-v-85bfbdca]{font-size:12px}.table-list[data-v-85bfbdca]{display:flex;flex-direction:column;gap:4px}.table-item[data-v-85bfbdca]{padding:12px;border-radius:6px;cursor:pointer;transition:all .2s;border:1px solid transparent}.table-item[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.table-item.active[data-v-85bfbdca]{background:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent);border-color:var(--SmartThemeBorderColor)}.table-item-main[data-v-85bfbdca]{display:flex;align-items:center;gap:8px;margin-bottom:4px}.table-icon[data-v-85bfbdca]{font-size:14px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.table-name[data-v-85bfbdca]{font-size:14px;font-weight:500;color:var(--SmartThemeBodyColor);flex:1;word-break:break-all}.table-comment[data-v-85bfbdca]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);margin-left:22px;word-break:break-all}@media(max-width:768px){.drawer-header[data-v-85bfbdca],.drawer-body[data-v-85bfbdca]{padding:12px}.empty-state[data-v-85bfbdca]{height:auto;min-height:150px;padding:20px}.table-list[data-v-85bfbdca]{gap:8px}.table-item[data-v-85bfbdca]{padding:14px 12px}.table-name[data-v-85bfbdca]{font-size:15px}.table-comment[data-v-85bfbdca]{font-size:13px;margin-top:4px;margin-left:0}}.table-drawer-layout[data-v-3e0df31e]{display:flex;flex-direction:column;height:100%;min-height:500px}.layout-content[data-v-3e0df31e]{flex:1;display:flex;overflow:hidden;position:relative}.layout-drawer[data-v-3e0df31e]{width:240px;flex-shrink:0;border-right:1px solid var(--SmartThemeBorderColor)}.layout-main[data-v-3e0df31e]{flex:1;overflow:hidden}.drawer-slide-enter-active[data-v-3e0df31e],.drawer-slide-leave-active[data-v-3e0df31e]{transition:all .3s ease}.drawer-slide-enter-from[data-v-3e0df31e],.drawer-slide-leave-to[data-v-3e0df31e]{width:0;opacity:0}@media(max-width:768px){.table-drawer-layout[data-v-3e0df31e]{min-height:400px}.layout-drawer[data-v-3e0df31e]{width:100%}}.tab-container[data-v-9d94b988]{display:flex;flex-direction:column;height:100%}.tab-header[data-v-9d94b988]{display:flex;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);overflow-x:auto;scrollbar-width:none}.tab-header[data-v-9d94b988]::-webkit-scrollbar{display:none}.tab-item[data-v-9d94b988]{padding:12px 24px;cursor:pointer;border-bottom:2px solid transparent;transition:all .2s;display:flex;align-items:center;gap:8px;font-size:14px;color:var(--SmartThemeEmColor)}.tab-item[data-v-9d94b988]:hover{color:var(--SmartThemeBodyColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.tab-item.active[data-v-9d94b988]{color:var(--SmartThemeBodyColor);border-bottom-color:var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.tab-item i[data-v-9d94b988]{font-size:14px}.tab-body[data-v-9d94b988]{flex:1;overflow:hidden}@media(max-width:768px){.tab-header .tab-item[data-v-9d94b988]{width:40vw;flex-shrink:0;justify-content:center;padding:14px 16px;font-size:13px;white-space:nowrap}.tab-item[data-v-9d94b988]{gap:6px}}.drawer-toggle[data-v-04d4da93]{background:none;border:none;cursor:pointer;padding:7.2px;display:flex;align-items:center;justify-content:center;color:var(--SmartThemeBodyColor);transition:all .2s;border-radius:3.6px;transform:scale(.9)}.drawer-toggle[data-v-04d4da93]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.drawer-toggle[data-v-04d4da93]:active{transform:scale(.855)}.drawer-toggle.fab[data-v-04d4da93]{position:fixed;bottom:80px;right:20px;width:56px;height:56px;border-radius:50%;background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);box-shadow:0 4px 12px var(--SmartThemeShadowColor);z-index:1001}.drawer-toggle.fab[data-v-04d4da93]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.drawer-toggle.fab .hamburger-icon[data-v-04d4da93]{width:24px;height:24px}@media(min-width:769px){.drawer-toggle.fab[data-v-04d4da93]{display:none}}.hamburger-icon[data-v-04d4da93]{width:21.6px;height:16.2px;display:flex;flex-direction:column;justify-content:space-between;position:relative}.line[data-v-04d4da93]{width:100%;height:1.8px;background:var(--SmartThemeBodyColor);border-radius:1.8px;transition:all .3s ease}.toast-notification[data-v-76c92735]{position:fixed;top:20px;left:50%;transform:translate(-50%);display:flex;align-items:center;gap:10px;padding:12px 20px;border-radius:6px;font-size:14px;font-weight:500;z-index:10000;box-shadow:0 4px 12px #00000026}.toast-notification.success[data-v-76c92735]{background:#10b981;color:#fff}.toast-notification.error[data-v-76c92735]{background:#ef4444;color:#fff}.toast-notification i[data-v-76c92735]{font-size:16px}.toast-enter-active[data-v-76c92735],.toast-leave-active[data-v-76c92735]{transition:all .3s ease}.toast-enter-from[data-v-76c92735],.toast-leave-to[data-v-76c92735]{opacity:0;transform:translate(-50%) translateY(-20px)}@media(max-width:768px){.toast-notification[data-v-76c92735]{left:16px;right:16px;transform:none;justify-content:center}.toast-enter-from[data-v-76c92735],.toast-leave-to[data-v-76c92735]{transform:translateY(-20px)}}.empty-state[data-v-5ddb0dfd]{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.empty-state span[data-v-5ddb0dfd]{font-size:14px}.empty-state.compact[data-v-5ddb0dfd]{gap:12px;padding:40px 20px}.empty-state.compact span[data-v-5ddb0dfd]{font-size:14px}.auto-resize-wrapper[data-v-fd129974]{position:relative;width:100%;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);transition:all .25s cubic-bezier(.4,0,.2,1)}.auto-resize-wrapper[data-v-fd129974]:hover:not(.disabled){border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.auto-resize-wrapper.focused[data-v-fd129974]{border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.auto-resize-wrapper.disabled[data-v-fd129974]{opacity:.6;cursor:not-allowed}.textarea-mirror[data-v-fd129974]{position:absolute;top:0;left:0;visibility:hidden;pointer-events:none;height:auto;overflow:hidden;z-index:-1}.auto-resize-textarea[data-v-fd129974]{display:block;width:100%;padding:12px 16px;border:none;outline:none;background:transparent;font-family:inherit;font-size:14px;line-height:1.5;color:var(--SmartThemeBodyColor);resize:none;overflow:hidden;box-sizing:border-box;transition:height .15s ease}.auto-resize-textarea[data-v-fd129974]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.auto-resize-textarea[data-v-fd129974]:disabled{cursor:not-allowed}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar{width:8px}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-track{background:transparent}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-thumb{background:color-mix(in srgb,var(--SmartThemeBorderColor) 60%,transparent);border-radius:4px}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-thumb:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 80%,transparent)}.textarea-footer[data-v-fd129974]{display:flex;justify-content:flex-end;padding:2px 14px 8px;margin-top:-4px}.char-count[data-v-fd129974]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);transition:color .2s}.char-count.warning[data-v-fd129974]{color:#ef4444;font-weight:600}@media(max-width:768px){.auto-resize-textarea[data-v-fd129974]{padding:14px 16px;font-size:16px}}.form-wrapper[data-v-08eccbfb]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-08eccbfb]{display:flex;flex-direction:column;gap:24px;max-height:65vh;overflow-y:auto}.form-section[data-v-08eccbfb]{display:flex;flex-direction:column;gap:16px}.form-item[data-v-08eccbfb]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-08eccbfb]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);display:flex;align-items:center;gap:4px;letter-spacing:.3px}.required[data-v-08eccbfb]{color:#ef4444;margin-left:4px}.form-input[data-v-08eccbfb],.form-select[data-v-08eccbfb]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-08eccbfb]:hover,.form-select[data-v-08eccbfb]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-08eccbfb]:focus,.form-select[data-v-08eccbfb]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-08eccbfb]::placeholder,.form-select[data-v-08eccbfb]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input.has-error[data-v-08eccbfb],.form-select.has-error[data-v-08eccbfb]{border-color:#ef4444}.form-input.has-error[data-v-08eccbfb]:focus,.form-select.has-error[data-v-08eccbfb]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-08eccbfb]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-08eccbfb]{font-size:14px}.section-error[data-v-08eccbfb]{padding:10px 12px;background:#ef44441a;border-radius:6px;margin-bottom:8px}.field-hint[data-v-08eccbfb]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.columns-section[data-v-08eccbfb]{border-top:1.5px solid var(--SmartThemeBorderColor);padding-top:20px}.section-header[data-v-08eccbfb]{display:flex;justify-content:space-between;align-items:center}.column-count[data-v-08eccbfb]{font-size:13px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);padding:4px 10px;border-radius:12px}.columns-list[data-v-08eccbfb]{display:flex;flex-direction:column;gap:12px}.column-card[data-v-08eccbfb]{background:var(--SmartThemeBlurTintColor);border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;overflow:hidden}.column-card.has-error[data-v-08eccbfb]{border-color:#ef4444}.column-card-header[data-v-08eccbfb]{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:color-mix(in srgb,var(--SmartThemeBorderColor) 20%,transparent);border-bottom:1.5px solid var(--SmartThemeBorderColor)}.column-number[data-v-08eccbfb]{font-size:12px;font-weight:600;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.remove-btn[data-v-08eccbfb]{background:none;border:none;cursor:pointer;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);padding:6px;border-radius:4px;transition:all .2s}.remove-btn[data-v-08eccbfb]:hover{color:#ef4444;background:#ef44441a}.remove-btn i[data-v-08eccbfb]{font-size:14px}.column-card-body[data-v-08eccbfb]{padding:16px;display:flex;flex-direction:column;gap:12px}.form-row[data-v-08eccbfb]{display:flex;gap:12px}.form-col[data-v-08eccbfb]{display:flex;flex-direction:column;gap:6px}.form-col.form-col-name[data-v-08eccbfb]{flex:2}.form-col.form-col-type[data-v-08eccbfb],.form-col.form-col-default[data-v-08eccbfb],.form-col.form-col-comment[data-v-08eccbfb]{flex:1}.field-label[data-v-08eccbfb]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 70%,transparent)}.field-label .required[data-v-08eccbfb]{font-size:12px;margin-left:4px}.checkbox-label[data-v-08eccbfb]{display:flex;align-items:center;gap:8px;color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;width:fit-content}.checkbox-label input[data-v-08eccbfb]{cursor:pointer;width:16px;height:16px}.add-column-btn[data-v-08eccbfb]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px;border:2px dashed var(--SmartThemeBorderColor);border-radius:8px;background:transparent;color:color-mix(in srgb,var(--SmartThemeBodyColor) 70%,transparent);font-size:14px;cursor:pointer;transition:all .2s}.add-column-btn[data-v-08eccbfb]:hover{border-color:var(--SmartThemeBorderColor);color:var(--SmartThemeBodyColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 10%,transparent)}.add-column-btn i[data-v-08eccbfb]{font-size:14px}.form-actions[data-v-08eccbfb]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-08eccbfb]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-08eccbfb]{--form-modal-width: 100%}.form-container[data-v-08eccbfb]{gap:20px}.form-row[data-v-08eccbfb]{flex-direction:column;gap:12px}.form-col.form-col-name[data-v-08eccbfb],.form-col.form-col-type[data-v-08eccbfb],.form-col.form-col-default[data-v-08eccbfb],.form-col.form-col-comment[data-v-08eccbfb]{flex:1}.column-card-body[data-v-08eccbfb]{padding:12px}.form-actions[data-v-08eccbfb]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-08eccbfb]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-58e374f4]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-58e374f4]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-58e374f4]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-58e374f4]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-58e374f4]{color:#ef4444;margin-left:4px}.form-input[data-v-58e374f4]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-58e374f4]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-58e374f4]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-58e374f4]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-58e374f4]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-input.has-error[data-v-58e374f4]{border-color:#ef4444}.form-input.has-error[data-v-58e374f4]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-58e374f4]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-58e374f4]{font-size:14px}.field-hint[data-v-58e374f4]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.form-actions[data-v-58e374f4]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-58e374f4]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-58e374f4]{--form-modal-width: 100%}.form-container[data-v-58e374f4]{gap:16px}.form-item[data-v-58e374f4]{gap:8px}.form-label[data-v-58e374f4]{font-size:15px}.form-input[data-v-58e374f4]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-58e374f4]::placeholder{font-size:15px}.field-hint[data-v-58e374f4]{font-size:13px}.form-actions[data-v-58e374f4]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-58e374f4]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-03532044]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-03532044]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-03532044]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-03532044]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.form-actions[data-v-03532044]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-03532044]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-03532044]{--form-modal-width: 100%}.form-container[data-v-03532044]{gap:16px}.form-item[data-v-03532044]{gap:8px}.form-label[data-v-03532044]{font-size:15px}.form-actions[data-v-03532044]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-03532044]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.drop-table-confirm-wrapper[data-v-4629727b]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-4629727b]{padding:24px 20px;text-align:center}.confirm-icon-wrapper[data-v-4629727b]{margin-bottom:16px}.warning-icon[data-v-4629727b]{font-size:48px;color:#f59e0b}.confirm-content[data-v-4629727b]{margin-bottom:24px}.confirm-message[data-v-4629727b]{font-size:16px;color:var(--SmartThemeBodyColor);margin-bottom:12px;line-height:1.5}.confirm-message strong[data-v-4629727b]{color:#ef4444;font-weight:600}.confirm-warning[data-v-4629727b]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#ef44441a;border-radius:6px;font-size:13px;color:#ef4444;text-align:left}.confirm-warning i[data-v-4629727b]{font-size:14px;flex-shrink:0}.form-actions[data-v-4629727b]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.drop-table-confirm-wrapper[data-v-4629727b]{--confirm-modal-width: 90vw}.confirm-container[data-v-4629727b]{padding:20px 16px}.warning-icon[data-v-4629727b]{font-size:40px}.confirm-message[data-v-4629727b]{font-size:15px}.form-actions[data-v-4629727b]{flex-direction:column-reverse}.form-actions[data-v-4629727b]>*{width:100%}}.form-wrapper[data-v-019138f2]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-019138f2]{display:flex;flex-direction:column;gap:20px;max-height:70vh;overflow-y:auto}.form-item[data-v-019138f2]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-019138f2]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-019138f2]{color:#ef4444;margin-left:4px}.form-input[data-v-019138f2],.form-select[data-v-019138f2]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-019138f2]:hover,.form-select[data-v-019138f2]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-019138f2]:focus,.form-select[data-v-019138f2]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-019138f2]::placeholder,.form-select[data-v-019138f2]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input.has-error[data-v-019138f2],.form-select.has-error[data-v-019138f2]{border-color:#ef4444}.form-input.has-error[data-v-019138f2]:focus,.form-select.has-error[data-v-019138f2]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-019138f2]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-019138f2]{font-size:14px}.field-hint[data-v-019138f2]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.checkbox-label[data-v-019138f2]{display:flex;align-items:center;gap:8px;color:var(--SmartThemeEmColor);font-size:14px;cursor:pointer;width:fit-content}.checkbox-label input[data-v-019138f2]{cursor:pointer;width:18px;height:18px}.checkbox-label span[data-v-019138f2]{cursor:pointer}.form-actions[data-v-019138f2]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-019138f2]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-019138f2]{--form-modal-width: 100%}.form-container[data-v-019138f2]{gap:16px}.form-item[data-v-019138f2]{gap:8px}.form-label[data-v-019138f2]{font-size:15px}.form-input[data-v-019138f2],.form-select[data-v-019138f2]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-019138f2]::placeholder,.form-select[data-v-019138f2]::placeholder{font-size:15px}.field-hint[data-v-019138f2]{font-size:13px}.form-actions[data-v-019138f2]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-019138f2]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-36708f97]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-36708f97]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-36708f97]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-36708f97]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-36708f97]{color:#ef4444;margin-left:4px}.form-input[data-v-36708f97]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-36708f97]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-36708f97]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-36708f97]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-36708f97]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-input.has-error[data-v-36708f97]{border-color:#ef4444}.form-input.has-error[data-v-36708f97]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-36708f97]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-36708f97]{font-size:14px}.field-hint[data-v-36708f97]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.form-actions[data-v-36708f97]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-36708f97]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-36708f97]{--form-modal-width: 100%}.form-container[data-v-36708f97]{gap:16px}.form-item[data-v-36708f97]{gap:8px}.form-label[data-v-36708f97]{font-size:15px}.form-input[data-v-36708f97]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-36708f97]::placeholder{font-size:15px}.field-hint[data-v-36708f97]{font-size:13px}.form-actions[data-v-36708f97]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-36708f97]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-1f79f493]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-1f79f493]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-1f79f493]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-1f79f493]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.form-input[data-v-1f79f493]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-1f79f493]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-1f79f493]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-1f79f493]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-1f79f493]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-actions[data-v-1f79f493]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-1f79f493]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-1f79f493]{--form-modal-width: 100%}.form-container[data-v-1f79f493]{gap:16px}.form-item[data-v-1f79f493]{gap:8px}.form-label[data-v-1f79f493]{font-size:15px}.form-input[data-v-1f79f493]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-1f79f493]::placeholder{font-size:15px}.form-actions[data-v-1f79f493]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-1f79f493]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.drop-column-confirm-wrapper[data-v-7565defa]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-7565defa]{padding:24px 20px;text-align:center}.confirm-icon-wrapper[data-v-7565defa]{margin-bottom:16px}.warning-icon[data-v-7565defa]{font-size:48px;color:#f59e0b}.confirm-content[data-v-7565defa]{margin-bottom:24px}.confirm-message[data-v-7565defa]{font-size:16px;color:var(--SmartThemeBodyColor);margin-bottom:12px;line-height:1.5}.confirm-message strong[data-v-7565defa]{color:#ef4444;font-weight:600}.confirm-warning[data-v-7565defa]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#ef44441a;border-radius:6px;font-size:13px;color:#ef4444;text-align:left}.confirm-warning i[data-v-7565defa]{font-size:14px;flex-shrink:0}.form-actions[data-v-7565defa]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.drop-column-confirm-wrapper[data-v-7565defa]{--confirm-modal-width: 90vw}.confirm-container[data-v-7565defa]{padding:20px 16px}.warning-icon[data-v-7565defa]{font-size:40px}.confirm-message[data-v-7565defa]{font-size:15px}.form-actions[data-v-7565defa]{flex-direction:column-reverse}.form-actions[data-v-7565defa]>*{width:100%}}.ddl-container[data-v-da039aee]{padding:20px}.ddl-header[data-v-da039aee]{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.ddl-title[data-v-da039aee]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.copy-btn[data-v-da039aee]{display:flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--SmartThemeBorderColor);border-radius:4px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s}.copy-btn[data-v-da039aee]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.copy-btn i[data-v-da039aee]{font-size:12px}.ddl-content[data-v-da039aee]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:6px;padding:16px;margin-bottom:20px;max-height:400px;overflow:auto}.ddl-code[data-v-da039aee]{margin:0;font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;color:var(--SmartThemeBodyColor);white-space:pre-wrap;word-wrap:break-word}.form-actions[data-v-da039aee]{display:flex;gap:12px;justify-content:flex-end}@media(max-width:768px){.ddl-container[data-v-da039aee]{padding:16px}.ddl-content[data-v-da039aee]{padding:12px;max-height:300px}.ddl-code[data-v-da039aee]{font-size:12px}.form-actions[data-v-da039aee]>*{width:100%}}.table-management-tab[data-v-f00e195b]{display:flex;flex-direction:column;height:100%;overflow:hidden}.table-detail[data-v-f00e195b]{flex:1;display:flex;flex-direction:column;overflow:hidden}.table-header[data-v-f00e195b]{padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.table-title-section[data-v-f00e195b]{margin-bottom:12px}.table-name-row[data-v-f00e195b],.table-comment-row[data-v-f00e195b]{display:flex;align-items:center;gap:8px;margin-bottom:8px}.table-name-row[data-v-f00e195b]:last-child,.table-comment-row[data-v-f00e195b]:last-child{margin-bottom:0}.table-label[data-v-f00e195b]{font-size:13px;color:var(--SmartThemeEmColor);min-width:50px;flex-shrink:0}.table-name[data-v-f00e195b]{font-size:15px;font-weight:600;color:var(--SmartThemeBodyColor);flex:1;word-break:break-all}.table-comment[data-v-f00e195b]{font-size:14px;color:var(--SmartThemeEmColor);flex:1;word-break:break-all}.table-comment.placeholder[data-v-f00e195b]{color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent);font-style:italic}.table-actions[data-v-f00e195b]{display:flex;gap:8px}.columns-section[data-v-f00e195b]{flex:1;display:flex;flex-direction:column;overflow:hidden}.section-header[data-v-f00e195b]{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.section-title[data-v-f00e195b]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.columns-list[data-v-f00e195b]{flex:1;overflow-y:auto;padding:12px}.column-item[data-v-f00e195b]{display:flex;justify-content:space-between;align-items:flex-start;padding:12px;border-radius:6px;background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);margin-bottom:8px;transition:all .2s}.column-item[data-v-f00e195b]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent)}.column-main[data-v-f00e195b]{flex:1;min-width:0;margin-right:12px}.column-first-row[data-v-f00e195b]{display:flex;align-items:center;gap:24px;margin-bottom:6px}.column-name-wrapper[data-v-f00e195b]{display:flex;align-items:center;gap:6px;min-width:0}.column-icon[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);flex-shrink:0}.column-name[data-v-f00e195b]{font-size:14px;font-weight:500;color:var(--SmartThemeBodyColor);word-break:break-all;min-width:0}.type-badge[data-v-f00e195b]{display:inline-block;padding:2px 8px;border-radius:4px;font-size:12px;font-weight:500;background:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent);color:var(--SmartThemeEmColor);flex-shrink:0}.primary-key-badge[data-v-f00e195b]{display:inline-flex;align-items:center;justify-content:center;width:24px;height:24px;border-radius:4px;background:#f59e0b26;border:1px solid rgba(245,158,11,.3);flex-shrink:0}.primary-key-badge i[data-v-f00e195b]{font-size:12px;color:#f59e0b}.column-comment[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);word-break:break-all;line-height:1.4;max-height:2.8em;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical}.default-value[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);margin-top:4px}.column-actions[data-v-f00e195b]{display:flex;gap:4px;flex-shrink:0}@media(max-width:768px){.tab-toolbar[data-v-f00e195b]{flex-wrap:wrap;padding:10px 12px}.table-header[data-v-f00e195b]{padding:12px}.table-name-row[data-v-f00e195b],.table-comment-row[data-v-f00e195b]{flex-wrap:wrap}.table-actions[data-v-f00e195b]{width:100%;justify-content:stretch;margin-top:12px}.table-actions>button[data-v-f00e195b]{flex:1}.section-header[data-v-f00e195b]{padding:10px 12px}.columns-list[data-v-f00e195b]{padding:8px}.column-item[data-v-f00e195b]{flex-direction:column;gap:10px;padding:10px}.column-main[data-v-f00e195b]{margin-right:0}.column-first-row[data-v-f00e195b]{flex-wrap:wrap;gap:6px}.column-name-wrapper[data-v-f00e195b]{flex:1;min-width:0}.column-actions[data-v-f00e195b]{gap:2px;width:100%;justify-content:flex-end;border-top:1px solid var(--SmartThemeBorderColor);padding-top:8px;margin-top:4px}}.sql-panel-tab[data-v-34ac73ac]{display:flex;flex-direction:column;height:100%;gap:16px;overflow:hidden}.sql-editor-container[data-v-34ac73ac]{display:flex;flex-direction:column;height:100%;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.sql-toolbar[data-v-34ac73ac]{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-bottom:1px solid var(--SmartThemeBorderColor)}.toolbar-title[data-v-34ac73ac]{font-size:13px;font-weight:500;color:var(--SmartThemeEmColor)}.sql-editor[data-v-34ac73ac]{min-height:200px;max-height:400px;padding:16px;background:var(--SmartThemeBlurTintColor);border:none;outline:none;color:var(--SmartThemeBodyColor);font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;resize:vertical;overflow-y:auto;height:100%}.sql-editor[data-v-34ac73ac]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.sql-footer[data-v-34ac73ac]{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-top:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.result-status[data-v-34ac73ac]{font-size:12px;font-weight:500;color:var(--SmartThemeBodyColor)}.editor-stats[data-v-34ac73ac]{display:flex;gap:16px}.stat-item[data-v-34ac73ac]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.result-message[data-v-34ac73ac]{padding:10px 16px;font-size:12px;border-top:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.result-message.error[data-v-34ac73ac]{background:color-mix(in srgb,#e74c3c 20%,transparent);color:#e74c3c}@media(max-width:768px){.sql-panel-tab[data-v-34ac73ac]{gap:12px}.sql-editor[data-v-34ac73ac]{font-size:12px;min-height:150px;height:100%}.sql-footer[data-v-34ac73ac]{gap:8px}}.data-form-wrapper[data-v-daf1bd0f]{--form-modal-width: 50vw;--form-modal-height: auto}.data-form[data-v-daf1bd0f]{display:flex;flex-direction:column;gap:24px;max-height:65vh}.form-content[data-v-daf1bd0f]{display:flex;flex-direction:column;gap:20px;overflow-y:auto;padding:8px 4px}.form-item[data-v-daf1bd0f]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-daf1bd0f]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required-mark[data-v-daf1bd0f]{color:#ef4444;margin-left:4px;font-size:14px}.form-input[data-v-daf1bd0f]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-daf1bd0f]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-daf1bd0f]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-daf1bd0f]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-daf1bd0f]:disabled{opacity:.6;cursor:not-allowed}.form-hint[data-v-daf1bd0f]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);margin-top:-4px;line-height:1.5;padding-left:2px}.form-actions[data-v-daf1bd0f]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-daf1bd0f]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.data-form-wrapper[data-v-daf1bd0f]{--form-modal-width: 100%}.data-form[data-v-daf1bd0f]{gap:20px;max-height:70vh}.form-content[data-v-daf1bd0f]{gap:16px;padding:4px}.form-item[data-v-daf1bd0f]{gap:8px}.form-label[data-v-daf1bd0f]{font-size:15px}.form-input[data-v-daf1bd0f]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-daf1bd0f]::placeholder{font-size:15px}.form-hint[data-v-daf1bd0f]{font-size:13px}.form-actions[data-v-daf1bd0f]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-daf1bd0f]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.delete-data-confirm-wrapper[data-v-b672c047]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-b672c047]{padding:20px}.confirm-content[data-v-b672c047]{display:flex;flex-direction:column;align-items:center;gap:16px;padding:20px 0}.warning-icon[data-v-b672c047]{font-size:48px;color:#f59e0b}.confirm-message[data-v-b672c047]{font-size:14px;color:var(--SmartThemeBodyColor);text-align:center;line-height:1.6;margin:0}.form-actions[data-v-b672c047]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.delete-data-confirm-wrapper[data-v-b672c047]{--confirm-modal-width: 90vw}.confirm-container[data-v-b672c047]{padding:16px}.form-actions[data-v-b672c047]{flex-direction:column-reverse}.form-actions>button[data-v-b672c047]{width:100%}}.export-container[data-v-affef56e]{padding:20px}.export-header[data-v-affef56e]{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.export-title[data-v-affef56e]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.copy-btn[data-v-affef56e]{display:flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--SmartThemeBorderColor);border-radius:4px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s}.copy-btn[data-v-affef56e]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.copy-btn i[data-v-affef56e]{font-size:12px}.export-content[data-v-affef56e]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:6px;padding:16px;margin-bottom:20px;max-height:400px;overflow:auto}.export-code[data-v-affef56e]{margin:0;font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;color:var(--SmartThemeBodyColor);white-space:pre-wrap;word-wrap:break-word}.form-actions[data-v-affef56e]{display:flex;gap:12px;justify-content:flex-end}@media(max-width:768px){.export-container[data-v-affef56e]{padding:16px}.export-content[data-v-affef56e]{padding:12px;max-height:300px}.export-code[data-v-affef56e]{font-size:12px}.form-actions[data-v-affef56e]>*{width:100%}}.chat-data-management-tab[data-v-0cce85f5]{display:flex;flex-direction:column;height:100%;overflow:hidden}.data-detail[data-v-0cce85f5]{flex:1;display:flex;flex-direction:column;overflow:hidden}.data-toolbar[data-v-0cce85f5]{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.data-title[data-v-0cce85f5]{display:flex;flex-direction:column;gap:4px}.table-name[data-v-0cce85f5]{font-size:15px;font-weight:600;color:var(--SmartThemeBodyColor)}.table-comment[data-v-0cce85f5]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.data-actions[data-v-0cce85f5]{display:flex;gap:8px}.data-list[data-v-0cce85f5]{flex:1;overflow:hidden;display:flex;flex-direction:column}.table-container[data-v-0cce85f5]{flex:1;overflow:auto}.data-table[data-v-0cce85f5]{width:100%;border-collapse:collapse;font-size:13px}thead[data-v-0cce85f5]{position:sticky;top:0;z-index:30;background:var(--SmartThemeBlurTintColor)}thead th[data-v-0cce85f5]{padding:12px 16px;border-bottom:2px solid var(--SmartThemeBorderColor);font-weight:600;color:var(--SmartThemeBodyColor);white-space:nowrap;background:var(--SmartThemeBlurTintColor)}tbody th[data-v-0cce85f5]{text-align:left;padding:12px 16px;font-weight:600;color:var(--SmartThemeBodyColor);white-space:nowrap}.checkbox-header[data-v-0cce85f5]{width:50px;text-align:center;padding:12px 8px}.column-header[data-v-0cce85f5]{min-width:120px}.actions-header[data-v-0cce85f5]{width:100px;text-align:center;padding:12px 8px}.sticky-col[data-v-0cce85f5]{position:sticky;background:var(--SmartThemeBlurTintColor);z-index:20;left:0}thead th.sticky-col[data-v-0cce85f5]{z-index:32;left:0}.primary-key[data-v-0cce85f5]{background:color-mix(in srgb,rgba(218,165,32,.15) 50%,var(--SmartThemeBlurTintColor));border-right:2px solid color-mix(in srgb,rgba(218,165,32,.3) 50%,var(--SmartThemeBorderColor))}thead th.primary-key[data-v-0cce85f5]{background:color-mix(in srgb,rgba(218,165,32,.2) 50%,var(--SmartThemeBlurTintColor))}thead th.actions-header.sticky-col[data-v-0cce85f5]{z-index:31}thead th.checkbox-header.sticky-col[data-v-0cce85f5]{z-index:32}.table-row[data-v-0cce85f5]{border-bottom:1px solid var(--SmartThemeBorderColor);transition:background-color .2s}.table-row[data-v-0cce85f5]:hover{background-color:color-mix(in srgb,var(--SmartThemeBorderColor) 20%,transparent)}.table-row[data-v-0cce85f5]:last-child{border-bottom:none}.table-cell[data-v-0cce85f5]{padding:10px 16px;border-right:1px solid var(--SmartThemeBorderColor);max-width:300px;min-width:120px;background:var(--SmartThemeBlurTintColor);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.table-cell[data-v-0cce85f5]:last-child{border-right:none}.table-cell.primary-key[data-v-0cce85f5]{background:color-mix(in srgb,rgba(59,130,246,.1) 50%,var(--SmartThemeBlurTintColor));border-right:2px solid color-mix(in srgb,rgba(59,130,246,.3) 50%,var(--SmartThemeBorderColor))}.cell-value[data-v-0cce85f5]{color:var(--SmartThemeBodyColor);text-align:center;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;line-height:1.5}.checkbox-cell[data-v-0cce85f5]{width:50px;text-align:center;padding:10px 8px;border-right:1px solid var(--SmartThemeBorderColor)}.actions-cell[data-v-0cce85f5]{width:100px;padding:10px 8px;text-align:center;border-right:1px solid var(--SmartThemeBorderColor)}.actions-cell.sticky-col[data-v-0cce85f5]{box-shadow:3px 0 10px -3px #00000040}.checkbox-cell.sticky-col[data-v-0cce85f5]{box-shadow:2px 0 10px -3px #00000026}.checkbox-wrapper[data-v-0cce85f5]{display:flex;align-items:center;justify-content:center;cursor:pointer}.checkbox-wrapper input[type=checkbox][data-v-0cce85f5]{width:16px;height:16px;cursor:pointer}.row-actions[data-v-0cce85f5]{display:flex;gap:4px;justify-content:center}@media(max-width:768px){.data-toolbar[data-v-0cce85f5]{flex-direction:column;align-items:stretch;gap:12px;padding:12px}.data-title[data-v-0cce85f5]{align-items:flex-start}.data-actions[data-v-0cce85f5]{width:100%}.data-actions>button[data-v-0cce85f5]{flex:1}thead th[data-v-0cce85f5],.table-cell[data-v-0cce85f5]{padding:8px 10px}.column-header[data-v-0cce85f5]{min-width:80px}.table-cell[data-v-0cce85f5]{max-width:150px;min-width:80px}.actions-header[data-v-0cce85f5],.actions-cell[data-v-0cce85f5]{width:70px}}.translation_settings[data-v-d18c04a2],.inline-drawer[data-v-d18c04a2]{width:100%}.inline-drawer-toggle[data-v-d18c04a2]{cursor:pointer}.inline-drawer-icon[data-v-d18c04a2]{transition:transform .2s}.inline-drawer-icon.down[data-v-d18c04a2]{transform:rotate(0)}.inline-drawer-icon.up[data-v-d18c04a2]{transform:rotate(180deg)}')),document.head.appendChild(a)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
var kr = {};
// @__NO_SIDE_EFFECTS__
function Yt(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const s of t.split(",")) e[s] = 1;
  return (s) => s in e;
}
const _e = kr.NODE_ENV !== "production" ? Object.freeze({}) : {}, ws = kr.NODE_ENV !== "production" ? Object.freeze([]) : [], qe = () => {
}, Pr = () => !1, un = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter
(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), Ln = (t) => t.startsWith("onUpdate:"), Me = Object.assign, Qi = (t, e) => {
  const s = t.indexOf(e);
  s > -1 && t.splice(s, 1);
}, Ea = Object.prototype.hasOwnProperty, ye = (t, e) => Ea.call(t, e), z = Array.isArray, hs = (t) => dn(t) === "[object Map]", Is = (t) => dn(t) === "[object Set]", Ao = (t) => dn(t) === "[object Date]", ee = (t) => typeof t == "function", Ve = (t) => typeof t == "string", bt = (t) => typeof t == "symbol", ve = (t) => t !== null && typeof t == "object", Ji = (t) => (ve(t) || ee(t)) && ee(t.then) && ee(t.catch), Br = Object.prototype.toString, dn = (t) => Br.call(t), Xi = (t) => dn(t).slice(8, -1), Fr = (t) => dn(t) === "[object Object]", Zi = (t) => Ve(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Gs = /* @__PURE__ */ Yt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), ya = /* @__PURE__ */ Yt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), ei = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return ((s) => e[s] || (e[s] = t(s)));
}, _a = /-\w/g, ut = ei(
  (t) => t.replace(_a, (e) => e.slice(1).toUpperCase())
), Ta = /\B([A-Z])/g, Gt = ei(
  (t) => t.replace(Ta, "-$1").toLowerCase()
), ti = ei((t) => t.charAt(0).toUpperCase() + t.slice(1)), us = ei(
  (t) => t ? `on${ti(t)}` : ""
), it = (t, e) => !Object.is(t, e), xs = (t, ...e) => {
  for (let s = 0; s < t.length; s++)
    t[s](...e);
}, kn = (t, e, s, n = !1) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    writable: n,
    value: s
  });
}, si = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, Na = (t) => {
  const e = Ve(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let Mo;
const fn = () => Mo || (Mo = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {});
function Ke(t) {
  if (z(t)) {
    const e = {};
    for (let s = 0; s < t.length; s++) {
      const n = t[s], i = Ve(n) ? Ca(n) : Ke(n);
      if (i)
        for (const o in i)
          e[o] = i[o];
    }
    return e;
  } else if (Ve(t) || ve(t))
    return t;
}
const xa = /;(?![^(]*\))/g, Sa = /:([^]+)/, wa = /\/\*[^]*?\*\//g;
function Ca(t) {
  const e = {};
  return t.replace(wa, "").split(xa).forEach((s) => {
    if (s) {
      const n = s.split(Sa);
      n.length > 1 && (e[n[0].trim()] = n[1].trim());
    }
  }), e;
}
function Ie(t) {
  let e = "";
  if (Ve(t))
    e = t;
  else if (z(t))
    for (let s = 0; s < t.length; s++) {
      const n = Ie(t[s]);
      n && (e += n + " ");
    }
  else if (ve(t))
    for (const s in t)
      t[s] && (e += s + " ");
  return e.trim();
}
const Da = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Oa = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", $a = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", Aa = /* @__PURE__ */ Yt(Da), Ma = /* @__PURE__ */ Yt(Oa), Va = /* @__PURE__ */ Yt($a), Ia = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Ra = /* @__PURE__ */ Yt(Ia);
function Ur(t) {
  return !!t || t === "";
}
function La(t, e) {
  if (t.length !== e.length) return !1;
  let s = !0;
  for (let n = 0; s && n < t.length; n++)
    s = Rs(t[n], e[n]);
  return s;
}
function Rs(t, e) {
  if (t === e) return !0;
  let s = Ao(t), n = Ao(e);
  if (s || n)
    return s && n ? t.getTime() === e.getTime() : !1;
  if (s = bt(t), n = bt(e), s || n)
    return t === e;
  if (s = z(t), n = z(e), s || n)
    return s && n ? La(t, e) : !1;
  if (s = ve(t), n = ve(e), s || n) {
    if (!s || !n)
      return !1;
    const i = Object.keys(t).length, o = Object.keys(e).length;
    if (i !== o)
      return !1;
    for (const r in t) {
      const l = t.hasOwnProperty(r), a = e.hasOwnProperty(r);
      if (l && !a || !l && a || !Rs(t[r], e[r]))
        return !1;
    }
  }
  return String(t) === String(e);
}
function eo(t, e) {
  return t.findIndex((s) => Rs(s, e));
}
const jr = (t) => !!(t && t.__v_isRef === !0), de = (t) => Ve(t) ? t : t == null ? "" : z(t) || ve(t) && (t.toString === Br || !ee(t.toString)) ? jr(t) ? de(t.value) : JSON.stringify(t, qr, 2) : String(t), qr = (t, e) => jr(e) ? qr(t, e.value) : hs(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (s, [n, i], o) => (s[bi(n, o) + " =>"] = i, s),
    {}
  )
} : Is(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((s) => bi(s))
} : bt(e) ? bi(e) : ve(e) && !z(e) && !Fr(e) ? String(e) : e, bi = (t, e = "") => {
  var s;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    bt(t) ? `Symbol(${(s = t.description) != null ? s : e})` : t
  );
};
var we = {};
function vt(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
let nt;
class ka {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.__v_skip = !0, this.parent = nt, !e && nt && (this.index = (nt.scopes || (nt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, s;
      if (this.scopes)
        for (e = 0, s = this.scopes.length; e < s; e++)
          this.scopes[e].pause();
      for (e = 0, s = this.effects.length; e < s; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, s;
      if (this.scopes)
        for (e = 0, s = this.scopes.length; e < s; e++)
          this.scopes[e].resume();
      for (e = 0, s = this.effects.length; e < s; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const s = nt;
      try {
        return nt = this, e();
      } finally {
        nt = s;
      }
    } else we.NODE_ENV !== "production" && vt("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = nt, nt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (nt = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let s, n;
      for (s = 0, n = this.effects.length; s < n; s++)
        this.effects[s].stop();
      for (this.effects.length = 0, s = 0, n = this.cleanups.length; s < n; s++)
        this.cleanups[s]();
      if (this.cleanups.length = 0, this.scopes) {
        for (s = 0, n = this.scopes.length; s < n; s++)
          this.scopes[s].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Pa() {
  return nt;
}
let Ne;
const vi = /* @__PURE__ */ new WeakSet();
class Hr {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, nt && nt.active && nt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, vi.has(this) && (vi.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Kr(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Vo(this), zr(this);
    const e = Ne, s = ht;
    Ne = this, ht = !0;
    try {
      return this.fn();
    } finally {
      we.NODE_ENV !== "production" && Ne !== this && vt(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), Gr(this), Ne = e, ht = s, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        no(e);
      this.deps = this.depsTail = void 0, Vo(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? vi.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    $i(this) && this.run();
  }
  get dirty() {
    return $i(this);
  }
}
let Wr = 0, Ys, Qs;
function Kr(t, e = !1) {
  if (t.flags |= 8, e) {
    t.next = Qs, Qs = t;
    return;
  }
  t.next = Ys, Ys = t;
}
function to() {
  Wr++;
}
function so() {
  if (--Wr > 0)
    return;
  if (Qs) {
    let e = Qs;
    for (Qs = void 0; e; ) {
      const s = e.next;
      e.next = void 0, e.flags &= -9, e = s;
    }
  }
  let t;
  for (; Ys; ) {
    let e = Ys;
    for (Ys = void 0; e; ) {
      const s = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (n) {
          t || (t = n);
        }
      e = s;
    }
  }
  if (t) throw t;
}
function zr(t) {
  for (let e = t.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function Gr(t) {
  let e, s = t.depsTail, n = s;
  for (; n; ) {
    const i = n.prevDep;
    n.version === -1 ? (n === s && (s = i), no(n), Ba(n)) : e = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = i;
  }
  t.deps = e, t.depsTail = s;
}
function $i(t) {
  for (let e = t.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (Yr(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!t._dirty;
}
function Yr(t) {
  if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17, t.globalVersion === tn) || (t.globalVersion = tn, !t.isSSR && t.flags & 128 && (!t.deps && !t._dirty || !$i(t))))
    return;
  t.flags |= 2;
  const e = t.dep, s = Ne, n = ht;
  Ne = t, ht = !0;
  try {
    zr(t);
    const i = t.fn(t._value);
    (e.version === 0 || it(i, t._value)) && (t.flags |= 128, t._value = i, e.version++);
  } catch (i) {
    throw e.version++, i;
  } finally {
    Ne = s, ht = n, Gr(t), t.flags &= -3;
  }
}
function no(t, e = !1) {
  const { dep: s, prevSub: n, nextSub: i } = t;
  if (n && (n.nextSub = i, t.prevSub = void 0), i && (i.prevSub = n, t.nextSub = void 0), we.NODE_ENV !== "production" && s.subsHead === t && (s.subsHead = i), s.subs === t && (s.subs = n, !n && s.computed)) {
    s.computed.flags &= -5;
    for (let o = s.computed.deps; o; o = o.nextDep)
      no(o, !0);
  }
  !e && !--s.sc && s.map && s.map.delete(s.key);
}
function Ba(t) {
  const { prevDep: e, nextDep: s } = t;
  e && (e.nextDep = s, t.prevDep = void 0), s && (s.prevDep = e, t.nextDep = void 0);
}
let ht = !0;
const Qr = [];
function gt() {
  Qr.push(ht), ht = !1;
}
function Et() {
  const t = Qr.pop();
  ht = t === void 0 ? !0 : t;
}
function Vo(t) {
  const { cleanup: e } = t;
  if (t.cleanup = void 0, e) {
    const s = Ne;
    Ne = void 0;
    try {
      e();
    } finally {
      Ne = s;
    }
  }
}
let tn = 0;
class Fa {
  constructor(e, s) {
    this.sub = e, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class ni {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0, we.NODE_ENV !== "production" && (this.subsHead = void 0);
  }
  track(e) {
    if (!Ne || !ht || Ne === this.computed)
      return;
    let s = this.activeLink;
    if (s === void 0 || s.sub !== Ne)
      s = this.activeLink = new Fa(Ne, this), Ne.deps ? (s.prevDep = Ne.depsTail, Ne.depsTail.nextDep = s, Ne.depsTail = s) : Ne.deps = Ne.depsTail = s, Jr(s);
    else if (s.version === -1 && (s.version = this.version, s.nextDep)) {
      const n = s.nextDep;
      n.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = n), s.prevDep = Ne.depsTail, s.nextDep = void 0, Ne.depsTail.nextDep = s, Ne.depsTail = s, Ne.deps === s && (Ne.deps = n);
    }
    return we.NODE_ENV !== "production" && Ne.onTrack && Ne.onTrack(
      Me(
        {
          effect: Ne
        },
        e
      )
    ), s;
  }
  trigger(e) {
    this.version++, tn++, this.notify(e);
  }
  notify(e) {
    to();
    try {
      if (we.NODE_ENV !== "production")
        for (let s = this.subsHead; s; s = s.nextSub)
          s.sub.onTrigger && !(s.sub.flags & 8) && s.sub.onTrigger(
            Me(
              {
                effect: s.sub
              },
              e
            )
          );
      for (let s = this.subs; s; s = s.prevSub)
        s.sub.notify() && s.sub.dep.notify();
    } finally {
      so();
    }
  }
}
function Jr(t) {
  if (t.dep.sc++, t.sub.flags & 4) {
    const e = t.dep.computed;
    if (e && !t.dep.subs) {
      e.flags |= 20;
      for (let n = e.deps; n; n = n.nextDep)
        Jr(n);
    }
    const s = t.dep.subs;
    s !== t && (t.prevSub = s, s && (s.nextSub = t)), we.NODE_ENV !== "production" && t.dep.subsHead === void 0 && (t.dep.subsHead = t), t.dep.subs = t;
  }
}
const Ai = /* @__PURE__ */ new WeakMap(), ms = /* @__PURE__ */ Symbol(
  we.NODE_ENV !== "production" ? "Object iterate" : ""
), Mi = /* @__PURE__ */ Symbol(
  we.NODE_ENV !== "production" ? "Map keys iterate" : ""
), sn = /* @__PURE__ */ Symbol(
  we.NODE_ENV !== "production" ? "Array iterate" : ""
);
function je(t, e, s) {
  if (ht && Ne) {
    let n = Ai.get(t);
    n || Ai.set(t, n = /* @__PURE__ */ new Map());
    let i = n.get(s);
    i || (n.set(s, i = new ni()), i.map = n, i.key = s), we.NODE_ENV !== "production" ? i.track({
      target: t,
      type: e,
      key: s
    }) : i.track();
  }
}
function $t(t, e, s, n, i, o) {
  const r = Ai.get(t);
  if (!r) {
    tn++;
    return;
  }
  const l = (a) => {
    a && (we.NODE_ENV !== "production" ? a.trigger({
      target: t,
      type: e,
      key: s,
      newValue: n,
      oldValue: i,
      oldTarget: o
    }) : a.trigger());
  };
  if (to(), e === "clear")
    r.forEach(l);
  else {
    const a = z(t), u = a && Zi(s);
    if (a && s === "length") {
      const c = Number(n);
      r.forEach((d, m) => {
        (m === "length" || m === sn || !bt(m) && m >= c) && l(d);
      });
    } else
      switch ((s !== void 0 || r.has(void 0)) && l(r.get(s)), u && l(r.get(sn)), e) {
        case "add":
          a ? u && l(r.get("length")) : (l(r.get(ms)), hs(t) && l(r.get(Mi)));
          break;
        case "delete":
          a || (l(r.get(ms)), hs(t) && l(r.get(Mi)));
          break;
        case "set":
          hs(t) && l(r.get(ms));
          break;
      }
  }
  so();
}
function _s(t) {
  const e = /* @__PURE__ */ ue(t);
  return e === t ? e : (je(e, "iterate", sn), /* @__PURE__ */ Ze(t) ? e : e.map(_t));
}
function ii(t) {
  return je(t = /* @__PURE__ */ ue(t), "iterate", sn), t;
}
function Zt(t, e) {
  return /* @__PURE__ */ yt(t) ? As(/* @__PURE__ */ is(t) ? _t(e) : e) : _t(e);
}
const Ua = {
  __proto__: null,
  [Symbol.iterator]() {
    return gi(this, Symbol.iterator, (t) => Zt(this, t));
  },
  concat(...t) {
    return _s(this).concat(
      ...t.map((e) => z(e) ? _s(e) : e)
    );
  },
  entries() {
    return gi(this, "entries", (t) => (t[1] = Zt(this, t[1]), t));
  },
  every(t, e) {
    return Bt(this, "every", t, e, void 0, arguments);
  },
  filter(t, e) {
    return Bt(
      this,
      "filter",
      t,
      e,
      (s) => s.map((n) => Zt(this, n)),
      arguments
    );
  },
  find(t, e) {
    return Bt(
      this,
      "find",
      t,
      e,
      (s) => Zt(this, s),
      arguments
    );
  },
  findIndex(t, e) {
    return Bt(this, "findIndex", t, e, void 0, arguments);
  },
  findLast(t, e) {
    return Bt(
      this,
      "findLast",
      t,
      e,
      (s) => Zt(this, s),
      arguments
    );
  },
  findLastIndex(t, e) {
    return Bt(this, "findLastIndex", t, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(t, e) {
    return Bt(this, "forEach", t, e, void 0, arguments);
  },
  includes(...t) {
    return Ei(this, "includes", t);
  },
  indexOf(...t) {
    return Ei(this, "indexOf", t);
  },
  join(t) {
    return _s(this).join(t);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...t) {
    return Ei(this, "lastIndexOf", t);
  },
  map(t, e) {
    return Bt(this, "map", t, e, void 0, arguments);
  },
  pop() {
    return Fs(this, "pop");
  },
  push(...t) {
    return Fs(this, "push", t);
  },
  reduce(t, ...e) {
    return Io(this, "reduce", t, e);
  },
  reduceRight(t, ...e) {
    return Io(this, "reduceRight", t, e);
  },
  shift() {
    return Fs(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(t, e) {
    return Bt(this, "some", t, e, void 0, arguments);
  },
  splice(...t) {
    return Fs(this, "splice", t);
  },
  toReversed() {
    return _s(this).toReversed();
  },
  toSorted(t) {
    return _s(this).toSorted(t);
  },
  toSpliced(...t) {
    return _s(this).toSpliced(...t);
  },
  unshift(...t) {
    return Fs(this, "unshift", t);
  },
  values() {
    return gi(this, "values", (t) => Zt(this, t));
  }
};
function gi(t, e, s) {
  const n = ii(t), i = n[e]();
  return n !== t && !/* @__PURE__ */ Ze(t) && (i._next = i.next, i.next = () => {
    const o = i._next();
    return o.done || (o.value = s(o.value)), o;
  }), i;
}
const ja = Array.prototype;
function Bt(t, e, s, n, i, o) {
  const r = ii(t), l = r !== t && !/* @__PURE__ */ Ze(t), a = r[e];
  if (a !== ja[e]) {
    const d = a.apply(t, o);
    return l ? _t(d) : d;
  }
  let u = s;
  r !== t && (l ? u = function(d, m) {
    return s.call(this, Zt(t, d), m, t);
  } : s.length > 2 && (u = function(d, m) {
    return s.call(this, d, m, t);
  }));
  const c = a.call(r, u, n);
  return l && i ? i(c) : c;
}
function Io(t, e, s, n) {
  const i = ii(t);
  let o = s;
  return i !== t && (/* @__PURE__ */ Ze(t) ? s.length > 3 && (o = function(r, l, a) {
    return s.call(this, r, l, a, t);
  }) : o = function(r, l, a) {
    return s.call(this, r, Zt(t, l), a, t);
  }), i[e](o, ...n);
}
function Ei(t, e, s) {
  const n = /* @__PURE__ */ ue(t);
  je(n, "iterate", sn);
  const i = n[e](...s);
  return (i === -1 || i === !1) && /* @__PURE__ */ Pn(s[0]) ? (s[0] = /* @__PURE__ */ ue(s[0]), n[e](...s)) : i;
}
function Fs(t, e, s = []) {
  gt(), to();
  const n = (/* @__PURE__ */ ue(t))[e].apply(t, s);
  return so(), Et(), n;
}
const qa = /* @__PURE__ */ Yt("__proto__,__v_isRef,__isVue"), Xr = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(bt)
);
function Ha(t) {
  bt(t) || (t = String(t));
  const e = /* @__PURE__ */ ue(this);
  return je(e, "has", t), e.hasOwnProperty(t);
}
class Zr {
  constructor(e = !1, s = !1) {
    this._isReadonly = e, this._isShallow = s;
  }
  get(e, s, n) {
    if (s === "__v_skip") return e.__v_skip;
    const i = this._isReadonly, o = this._isShallow;
    if (s === "__v_isReactive")
      return !i;
    if (s === "__v_isReadonly")
      return i;
    if (s === "__v_isShallow")
      return o;
    if (s === "__v_raw")
      return n === (i ? o ? ol : il : o ? nl : sl).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
    const r = z(e);
    if (!i) {
      let a;
      if (r && (a = Ua[s]))
        return a;
      if (s === "hasOwnProperty")
        return Ha;
    }
    const l = Reflect.get(
      e,
      s,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      /* @__PURE__ */ Fe(e) ? e : n
    );
    if ((bt(s) ? Xr.has(s) : qa(s)) || (i || je(e, "get", s), o))
      return l;
    if (/* @__PURE__ */ Fe(l)) {
      const a = r && Zi(s) ? l : l.value;
      return i && ve(a) ? /* @__PURE__ */ Ii(a) : a;
    }
    return ve(l) ? i ? /* @__PURE__ */ Ii(l) : /* @__PURE__ */ os(l) : l;
  }
}
class el extends Zr {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, s, n, i) {
    let o = e[s];
    const r = z(e) && Zi(s);
    if (!this._isShallow) {
      const u = /* @__PURE__ */ yt(o);
      if (!/* @__PURE__ */ Ze(n) && !/* @__PURE__ */ yt(n) && (o = /* @__PURE__ */ ue(o), n = /* @__PURE__ */ ue(n)), !r && /* @__PURE__ */ Fe(o) && !/* @__PURE__ */ Fe(n))
        return u ? (we.NODE_ENV !== "production" && vt(
          `Set operation on key "${String(s)}" failed: target is readonly.`,
          e[s]
        ), !0) : (o.value = n, !0);
    }
    const l = r ? Number(s) < e.length : ye(e, s), a = Reflect.set(
      e,
      s,
      n,
      /* @__PURE__ */ Fe(e) ? e : i
    );
    return e === /* @__PURE__ */ ue(i) && (l ? it(n, o) && $t(e, "set", s, n, o) : $t(e, "add", s, n)), a;
  }
  deleteProperty(e, s) {
    const n = ye(e, s), i = e[s], o = Reflect.deleteProperty(e, s);
    return o && n && $t(e, "delete", s, void 0, i), o;
  }
  has(e, s) {
    const n = Reflect.has(e, s);
    return (!bt(s) || !Xr.has(s)) && je(e, "has", s), n;
  }
  ownKeys(e) {
    return je(
      e,
      "iterate",
      z(e) ? "length" : ms
    ), Reflect.ownKeys(e);
  }
}
class tl extends Zr {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, s) {
    return we.NODE_ENV !== "production" && vt(
      `Set operation on key "${String(s)}" failed: target is readonly.`,
      e
    ), !0;
  }
  deleteProperty(e, s) {
    return we.NODE_ENV !== "production" && vt(
      `Delete operation on key "${String(s)}" failed: target is readonly.`,
      e
    ), !0;
  }
}
const Wa = /* @__PURE__ */ new el(), Ka = /* @__PURE__ */ new tl(), za = /* @__PURE__ */ new el(!0), Ga = /* @__PURE__ */ new tl(!0), Vi = (t) => t, Tn = (t) => Reflect.getPrototypeOf(t);
function Ya(t, e, s) {
  return function(...n) {
    const i = this.__v_raw, o = /* @__PURE__ */ ue(i), r = hs(o), l = t === "entries" || t === Symbol.iterator && r, a = t === "keys" && r, u = i[t](...n), c = s ? Vi : e ? As : _t;
    return !e && je(
      o,
      "iterate",
      a ? Mi : ms
    ), Me(
      // inheriting all iterator properties
      Object.create(u),
      {
        // iterator protocol
        next() {
          const { value: d, done: m } = u.next();
          return m ? { value: d, done: m } : {
            value: l ? [c(d[0]), c(d[1])] : c(d),
            done: m
          };
        }
      }
    );
  };
}
function Nn(t) {
  return function(...e) {
    if (we.NODE_ENV !== "production") {
      const s = e[0] ? `on key "${e[0]}" ` : "";
      vt(
        `${ti(t)} operation ${s}failed: target is readonly.`,
        /* @__PURE__ */ ue(this)
      );
    }
    return t === "delete" ? !1 : t === "clear" ? void 0 : this;
  };
}
function Qa(t, e) {
  const s = {
    get(i) {
      const o = this.__v_raw, r = /* @__PURE__ */ ue(o), l = /* @__PURE__ */ ue(i);
      t || (it(i, l) && je(r, "get", i), je(r, "get", l));
      const { has: a } = Tn(r), u = e ? Vi : t ? As : _t;
      if (a.call(r, i))
        return u(o.get(i));
      if (a.call(r, l))
        return u(o.get(l));
      o !== r && o.get(i);
    },
    get size() {
      const i = this.__v_raw;
      return !t && je(/* @__PURE__ */ ue(i), "iterate", ms), i.size;
    },
    has(i) {
      const o = this.__v_raw, r = /* @__PURE__ */ ue(o), l = /* @__PURE__ */ ue(i);
      return t || (it(i, l) && je(r, "has", i), je(r, "has", l)), i === l ? o.has(i) : o.has(i) || o.has(l);
    },
    forEach(i, o) {
      const r = this, l = r.__v_raw, a = /* @__PURE__ */ ue(l), u = e ? Vi : t ? As : _t;
      return !t && je(a, "iterate", ms), l.forEach((c, d) => i.call(o, u(c), u(d), r));
    }
  };
  return Me(
    s,
    t ? {
      add: Nn("add"),
      set: Nn("set"),
      delete: Nn("delete"),
      clear: Nn("clear")
    } : {
      add(i) {
        !e && !/* @__PURE__ */ Ze(i) && !/* @__PURE__ */ yt(i) && (i = /* @__PURE__ */ ue(i));
        const o = /* @__PURE__ */ ue(this);
        return Tn(o).has.call(o, i) || (o.add(i), $t(o, "add", i, i)), this;
      },
      set(i, o) {
        !e && !/* @__PURE__ */ Ze(o) && !/* @__PURE__ */ yt(o) && (o = /* @__PURE__ */ ue(o));
        const r = /* @__PURE__ */ ue(this), { has: l, get: a } = Tn(r);
        let u = l.call(r, i);
        u ? we.NODE_ENV !== "production" && Ro(r, l, i) : (i = /* @__PURE__ */ ue(i), u = l.call(r, i));
        const c = a.call(r, i);
        return r.set(i, o), u ? it(o, c) && $t(r, "set", i, o, c) : $t(r, "add", i, o), this;
      },
      delete(i) {
        const o = /* @__PURE__ */ ue(this), { has: r, get: l } = Tn(o);
        let a = r.call(o, i);
        a ? we.NODE_ENV !== "production" && Ro(o, r, i) : (i = /* @__PURE__ */ ue(i), a = r.call(o, i));
        const u = l ? l.call(o, i) : void 0, c = o.delete(i);
        return a && $t(o, "delete", i, void 0, u), c;
      },
      clear() {
        const i = /* @__PURE__ */ ue(this), o = i.size !== 0, r = we.NODE_ENV !== "production" ? hs(i) ? new Map(i) : new Set(i) : void 0, l = i.clear();
        return o && $t(
          i,
          "clear",
          void 0,
          void 0,
          r
        ), l;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((i) => {
    s[i] = Ya(i, t, e);
  }), s;
}
function oi(t, e) {
  const s = Qa(t, e);
  return (n, i, o) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? n : Reflect.get(
    ye(s, i) && i in n ? s : n,
    i,
    o
  );
}
const Ja = {
  get: /* @__PURE__ */ oi(!1, !1)
}, Xa = {
  get: /* @__PURE__ */ oi(!1, !0)
}, Za = {
  get: /* @__PURE__ */ oi(!0, !1)
}, ec = {
  get: /* @__PURE__ */ oi(!0, !0)
};
function Ro(t, e, s) {
  const n = /* @__PURE__ */ ue(s);
  if (n !== s && e.call(t, n)) {
    const i = Xi(t);
    vt(
      `Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const sl = /* @__PURE__ */ new WeakMap(), nl = /* @__PURE__ */ new WeakMap(), il = /* @__PURE__ */ new WeakMap(), ol = /* @__PURE__ */ new WeakMap();
function tc(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function sc(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : tc(Xi(t));
}
// @__NO_SIDE_EFFECTS__
function os(t) {
  return /* @__PURE__ */ yt(t) ? t : ri(
    t,
    !1,
    Wa,
    Ja,
    sl
  );
}
// @__NO_SIDE_EFFECTS__
function nc(t) {
  return ri(
    t,
    !1,
    za,
    Xa,
    nl
  );
}
// @__NO_SIDE_EFFECTS__
function Ii(t) {
  return ri(
    t,
    !0,
    Ka,
    Za,
    il
  );
}
// @__NO_SIDE_EFFECTS__
function Mt(t) {
  return ri(
    t,
    !0,
    Ga,
    ec,
    ol
  );
}
function ri(t, e, s, n, i) {
  if (!ve(t))
    return we.NODE_ENV !== "production" && vt(
      `value cannot be made ${e ? "readonly" : "reactive"}: ${String(
        t
      )}`
    ), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const o = sc(t);
  if (o === 0)
    return t;
  const r = i.get(t);
  if (r)
    return r;
  const l = new Proxy(
    t,
    o === 2 ? n : s
  );
  return i.set(t, l), l;
}
// @__NO_SIDE_EFFECTS__
function is(t) {
  return /* @__PURE__ */ yt(t) ? /* @__PURE__ */ is(t.__v_raw) : !!(t && t.__v_isReactive);
}
// @__NO_SIDE_EFFECTS__
function yt(t) {
  return !!(t && t.__v_isReadonly);
}
// @__NO_SIDE_EFFECTS__
function Ze(t) {
  return !!(t && t.__v_isShallow);
}
// @__NO_SIDE_EFFECTS__
function Pn(t) {
  return t ? !!t.__v_raw : !1;
}
// @__NO_SIDE_EFFECTS__
function ue(t) {
  const e = t && t.__v_raw;
  return e ? /* @__PURE__ */ ue(e) : t;
}
function ic(t) {
  return !ye(t, "__v_skip") && Object.isExtensible(t) && kn(t, "__v_skip", !0), t;
}
const _t = (t) => ve(t) ? /* @__PURE__ */ os(t) : t, As = (t) => ve(t) ? /* @__PURE__ */ Ii(t) : t;
// @__NO_SIDE_EFFECTS__
function Fe(t) {
  return t ? t.__v_isRef === !0 : !1;
}
// @__NO_SIDE_EFFECTS__
function q(t) {
  return oc(t, !1);
}
function oc(t, e) {
  return /* @__PURE__ */ Fe(t) ? t : new rc(t, e);
}
class rc {
  constructor(e, s) {
    this.dep = new ni(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? e : /* @__PURE__ */ ue(e), this._value = s ? e : _t(e), this.__v_isShallow = s;
  }
  get value() {
    return we.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track(), this._value;
  }
  set value(e) {
    const s = this._rawValue, n = this.__v_isShallow || /* @__PURE__ */ Ze(e) || /* @__PURE__ */ yt(e);
    e = n ? e : /* @__PURE__ */ ue(e), it(e, s) && (this._rawValue = e, this._value = n ? e : _t(e), we.NODE_ENV !== "production" ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: e,
      oldValue: s
    }) : this.dep.trigger());
  }
}
function Q(t) {
  return /* @__PURE__ */ Fe(t) ? t.value : t;
}
const lc = {
  get: (t, e, s) => e === "__v_raw" ? t : Q(Reflect.get(t, e, s)),
  set: (t, e, s, n) => {
    const i = t[e];
    return /* @__PURE__ */ Fe(i) && !/* @__PURE__ */ Fe(s) ? (i.value = s, !0) : Reflect.set(t, e, s, n);
  }
};
function rl(t) {
  return /* @__PURE__ */ is(t) ? t : new Proxy(t, lc);
}
class ac {
  constructor(e) {
    this.__v_isRef = !0, this._value = void 0;
    const s = this.dep = new ni(), { get: n, set: i } = e(s.track.bind(s), s.trigger.bind(s));
    this._get = n, this._set = i;
  }
  get value() {
    return this._value = this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function cc(t) {
  return new ac(t);
}
class uc {
  constructor(e, s, n) {
    this.fn = e, this.setter = s, this._value = void 0, this.dep = new ni(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = tn - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !s, this.isSSR = n;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Ne !== this)
      return Kr(this, !0), !0;
  }
  get value() {
    const e = we.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    return Yr(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter ? this.setter(e) : we.NODE_ENV !== "production" && vt("Write operation failed: computed value is readonly");
  }
}
// @__NO_SIDE_EFFECTS__
function dc(t, e, s = !1) {
  let n, i;
  return ee(t) ? n = t : (n = t.get, i = t.set), new uc(n, i, s);
}
const xn = {}, Bn = /* @__PURE__ */ new WeakMap();
let ds;
function fc(t, e = !1, s = ds) {
  if (s) {
    let n = Bn.get(s);
    n || Bn.set(s, n = []), n.push(t);
  } else we.NODE_ENV !== "production" && !e && vt(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function pc(t, e, s = _e) {
  const { immediate: n, deep: i, once: o, scheduler: r, augmentJob: l, call: a } = s, u = (V) => {
    (s.onWarn || vt)(
      "Invalid watch source: ",
      V,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, c = (V) => i ? V : /* @__PURE__ */ Ze(V) || i === !1 || i === 0 ? Ht(V, 1) : Ht(V);
  let d, m, h, E, y = !1, N = !1;
  if (/* @__PURE__ */ Fe(t) ? (m = () => t.value, y = /* @__PURE__ */ Ze(t)) : /* @__PURE__ */ is(t) ? (m = () => c(t), y = !0) : z(t) ? (N = !0, y = t.some((V) => /* @__PURE__ */ is(V) || /* @__PURE__ */ Ze(V)), m = () => t.map((V) => {
    if (/* @__PURE__ */ Fe(V))
      return V.value;
    if (/* @__PURE__ */ is(V))
      return c(V);
    if (ee(V))
      return a ? a(V, 2) : V();
    we.NODE_ENV !== "production" && u(V);
  })) : ee(t) ? e ? m = a ? () => a(t, 2) : t : m = () => {
    if (h) {
      gt();
      try {
        h();
      } finally {
        Et();
      }
    }
    const V = ds;
    ds = d;
    try {
      return a ? a(t, 3, [E]) : t(E);
    } finally {
      ds = V;
    }
  } : (m = qe, we.NODE_ENV !== "production" && u(t)), e && i) {
    const V = m, K = i === !0 ? 1 / 0 : i;
    m = () => Ht(V(), K);
  }
  const b = Pa(), T = () => {
    d.stop(), b && b.active && Qi(b.effects, d);
  };
  if (o && e) {
    const V = e;
    e = (...K) => {
      V(...K), T();
    };
  }
  let _ = N ? new Array(t.length).fill(xn) : xn;
  const O = (V) => {
    if (!(!(d.flags & 1) || !d.dirty && !V))
      if (e) {
        const K = d.run();
        if (i || y || (N ? K.some((he, me) => it(he, _[me])) : it(K, _))) {
          h && h();
          const he = ds;
          ds = d;
          try {
            const me = [
              K,
              // pass undefined as the old value when it's changed for the first time
              _ === xn ? void 0 : N && _[0] === xn ? [] : _,
              E
            ];
            _ = K, a ? a(e, 3, me) : (
              // @ts-expect-error
              e(...me)
            );
          } finally {
            ds = he;
          }
        }
      } else
        d.run();
  };
  return l && l(O), d = new Hr(m), d.scheduler = r ? () => r(O, !1) : O, E = (V) => fc(V, !1, d), h = d.onStop = () => {
    const V = Bn.get(d);
    if (V) {
      if (a)
        a(V, 4);
      else
        for (const K of V) K();
      Bn.delete(d);
    }
  }, we.NODE_ENV !== "production" && (d.onTrack = s.onTrack, d.onTrigger = s.onTrigger), e ? n ? O(!0) : _ = d.run() : r ? r(O.bind(null, !0), !0) : d.run(), T.pause = d.pause.bind(d), T.resume = d.resume.bind(d), T.stop = T, T;
}
function Ht(t, e = 1 / 0, s) {
  if (e <= 0 || !ve(t) || t.__v_skip || (s = s || /* @__PURE__ */ new Map(), (s.get(t) || 0) >= e))
    return t;
  if (s.set(t, e), e--, /* @__PURE__ */ Fe(t))
    Ht(t.value, e, s);
  else if (z(t))
    for (let n = 0; n < t.length; n++)
      Ht(t[n], e, s);
  else if (Is(t) || hs(t))
    t.forEach((n) => {
      Ht(n, e, s);
    });
  else if (Fr(t)) {
    for (const n in t)
      Ht(t[n], e, s);
    for (const n of Object.getOwnPropertySymbols(t))
      Object.prototype.propertyIsEnumerable.call(t, n) && Ht(t[n], e, s);
  }
  return t;
}
var g = {};
const bs = [];
function Dn(t) {
  bs.push(t);
}
function On() {
  bs.pop();
}
let yi = !1;
function R(t, ...e) {
  if (yi) return;
  yi = !0, gt();
  const s = bs.length ? bs[bs.length - 1].component : null, n = s && s.appContext.config.warnHandler, i = hc();
  if (n)
    Ls(
      n,
      s,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        t + e.map((o) => {
          var r, l;
          return (l = (r = o.toString) == null ? void 0 : r.call(o)) != null ? l : JSON.stringify(o);
        }).join(""),
        s && s.proxy,
        i.map(
          ({ vnode: o }) => `at <${En(s, o.type)}>`
        ).join(`
`),
        i
      ]
    );
  else {
    const o = [`[Vue warn]: ${t}`, ...e];
    i.length && o.push(`
`, ...mc(i)), console.warn(...o);
  }
  Et(), yi = !1;
}
function hc() {
  let t = bs[bs.length - 1];
  if (!t)
    return [];
  const e = [];
  for (; t; ) {
    const s = e[0];
    s && s.vnode === t ? s.recurseCount++ : e.push({
      vnode: t,
      recurseCount: 0
    });
    const n = t.component && t.component.parent;
    t = n && n.vnode;
  }
  return e;
}
function mc(t) {
  const e = [];
  return t.forEach((s, n) => {
    e.push(...n === 0 ? [] : [`
`], ...bc(s));
  }), e;
}
function bc({ vnode: t, recurseCount: e }) {
  const s = e > 0 ? `... (${e} recursive calls)` : "", n = t.component ? t.component.parent == null : !1, i = ` at <${En(
    t.component,
    t.type,
    n
  )}`, o = ">" + s;
  return t.props ? [i, ...vc(t.props), o] : [i + o];
}
function vc(t) {
  const e = [], s = Object.keys(t);
  return s.slice(0, 3).forEach((n) => {
    e.push(...ll(n, t[n]));
  }), s.length > 3 && e.push(" ..."), e;
}
function ll(t, e, s) {
  return Ve(e) ? (e = JSON.stringify(e), s ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? s ? e : [`${t}=${e}`] : /* @__PURE__ */ Fe(e) ? (e = ll(t, /* @__PURE__ */ ue(e.value), !0), s ? e : [`${t}=Ref<`, e, ">"]) : ee(e) ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`] : (e = /* @__PURE__ */ ue(e), s ? e : [`${t}=`, e]);
}
function gc(t, e) {
  g.NODE_ENV !== "production" && t !== void 0 && (typeof t != "number" ? R(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && R(`${e} is NaN - the duration expression might be incorrect.`));
}
const io = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function Ls(t, e, s, n) {
  try {
    return n ? t(...n) : t();
  } catch (i) {
    pn(i, e, s);
  }
}
function Tt(t, e, s, n) {
  if (ee(t)) {
    const i = Ls(t, e, s, n);
    return i && Ji(i) && i.catch((o) => {
      pn(o, e, s);
    }), i;
  }
  if (z(t)) {
    const i = [];
    for (let o = 0; o < t.length; o++)
      i.push(Tt(t[o], e, s, n));
    return i;
  } else g.NODE_ENV !== "production" && R(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof t}`
  );
}
function pn(t, e, s, n = !0) {
  const i = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: r } = e && e.appContext.config || _e;
  if (e) {
    let l = e.parent;
    const a = e.proxy, u = g.NODE_ENV !== "production" ? io[s] : `https://vuejs.org/error-reference/#runtime-${s}`;
    for (; l; ) {
      const c = l.ec;
      if (c) {
        for (let d = 0; d < c.length; d++)
          if (c[d](t, a, u) === !1)
            return;
      }
      l = l.parent;
    }
    if (o) {
      gt(), Ls(o, null, 10, [
        t,
        a,
        u
      ]), Et();
      return;
    }
  }
  Ec(t, s, i, n, r);
}
function Ec(t, e, s, n = !0, i = !1) {
  if (g.NODE_ENV !== "production") {
    const o = io[e];
    if (s && Dn(s), R(`Unhandled error${o ? ` during execution of ${o}` : ""}`), s && On(), n)
      throw t;
    console.error(t);
  } else {
    if (i)
      throw t;
    console.error(t);
  }
}
const Je = [];
let Dt = -1;
const Cs = [];
let es = null, Ss = 0;
const al = /* @__PURE__ */ Promise.resolve();
let Fn = null;
const yc = 100;
function It(t) {
  const e = Fn || al;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function _c(t) {
  let e = Dt + 1, s = Je.length;
  for (; e < s; ) {
    const n = e + s >>> 1, i = Je[n], o = nn(i);
    o < t || o === t && i.flags & 2 ? e = n + 1 : s = n;
  }
  return e;
}
function li(t) {
  if (!(t.flags & 1)) {
    const e = nn(t), s = Je[Je.length - 1];
    !s || // fast path when the job id is larger than the tail
    !(t.flags & 2) && e >= nn(s) ? Je.push(t) : Je.splice(_c(e), 0, t), t.flags |= 1, cl();
  }
}
function cl() {
  Fn || (Fn = al.then(fl));
}
function ul(t) {
  z(t) ? Cs.push(...t) : es && t.id === -1 ? es.splice(Ss + 1, 0, t) : t.flags & 1 || (Cs.push(t), t.flags |= 1), cl();
}
function Lo(t, e, s = Dt + 1) {
  for (g.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()); s < Je.length; s++) {
    const n = Je[s];
    if (n && n.flags & 2) {
      if (t && n.id !== t.uid || g.NODE_ENV !== "production" && oo(e, n))
        continue;
      Je.splice(s, 1), s--, n.flags & 4 && (n.flags &= -2), n(), n.flags & 4 || (n.flags &= -2);
    }
  }
}
function dl(t) {
  if (Cs.length) {
    const e = [...new Set(Cs)].sort(
      (s, n) => nn(s) - nn(n)
    );
    if (Cs.length = 0, es) {
      es.push(...e);
      return;
    }
    for (es = e, g.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), Ss = 0; Ss < es.length; Ss++) {
      const s = es[Ss];
      g.NODE_ENV !== "production" && oo(t, s) || (s.flags & 4 && (s.flags &= -2), s.flags & 8 || s(), s.flags &= -2);
    }
    es = null, Ss = 0;
  }
}
const nn = (t) => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id;
function fl(t) {
  g.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map());
  const e = g.NODE_ENV !== "production" ? (s) => oo(t, s) : qe;
  try {
    for (Dt = 0; Dt < Je.length; Dt++) {
      const s = Je[Dt];
      if (s && !(s.flags & 8)) {
        if (g.NODE_ENV !== "production" && e(s))
          continue;
        s.flags & 4 && (s.flags &= -2), Ls(
          s,
          s.i,
          s.i ? 15 : 14
        ), s.flags & 4 || (s.flags &= -2);
      }
    }
  } finally {
    for (; Dt < Je.length; Dt++) {
      const s = Je[Dt];
      s && (s.flags &= -2);
    }
    Dt = -1, Je.length = 0, dl(t), Fn = null, (Je.length || Cs.length) && fl(t);
  }
}
function oo(t, e) {
  const s = t.get(e) || 0;
  if (s > yc) {
    const n = e.i, i = n && na(n.type);
    return pn(
      `Maximum recursive updates exceeded${i ? ` in component <${i}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), !0;
  }
  return t.set(e, s + 1), !1;
}
let pt = !1;
const $n = /* @__PURE__ */ new Map();
g.NODE_ENV !== "production" && (fn().__VUE_HMR_RUNTIME__ = {
  createRecord: _i(pl),
  rerender: _i(xc),
  reload: _i(Sc)
});
const Es = /* @__PURE__ */ new Map();
function Tc(t) {
  const e = t.type.__hmrId;
  let s = Es.get(e);
  s || (pl(e, t.type), s = Es.get(e)), s.instances.add(t);
}
function Nc(t) {
  Es.get(t.type.__hmrId).instances.delete(t);
}
function pl(t, e) {
  return Es.has(t) ? !1 : (Es.set(t, {
    initialDef: Un(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Un(t) {
  return ia(t) ? t.__vccOpts : t;
}
function xc(t, e) {
  const s = Es.get(t);
  s && (s.initialDef.render = e, [...s.instances].forEach((n) => {
    e && (n.render = e, Un(n.type).render = e), n.renderCache = [], pt = !0, n.job.flags & 8 || n.update(), pt = !1;
  }));
}
function Sc(t, e) {
  const s = Es.get(t);
  if (!s) return;
  e = Un(e), ko(s.initialDef, e);
  const n = [...s.instances];
  for (let i = 0; i < n.length; i++) {
    const o = n[i], r = Un(o.type);
    let l = $n.get(r);
    l || (r !== s.initialDef && ko(r, e), $n.set(r, l = /* @__PURE__ */ new Set())), l.add(o), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (l.add(o), o.ceReload(e.styles), l.delete(o)) : o.parent ? li(() => {
      o.job.flags & 8 || (pt = !0, o.parent.update(), pt = !1, l.delete(o));
    }) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), o.root.ce && o !== o.root && o.root.ce._removeChildStyle(r);
  }
  ul(() => {
    $n.clear();
  });
}
function ko(t, e) {
  Me(t, e);
  for (const s in t)
    s !== "__file" && !(s in e) && delete t[s];
}
function _i(t) {
  return (e, s) => {
    try {
      return t(e, s);
    } catch (n) {
      console.error(n), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let At, Ks = [], Ri = !1;
function hn(t, ...e) {
  At ? At.emit(t, ...e) : Ri || Ks.push({ event: t, args: e });
}
function hl(t, e) {
  var s, n;
  At = t, At ? (At.enabled = !0, Ks.forEach(({ event: i, args: o }) => At.emit(i, ...o)), Ks = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((n = (s = window.navigator) == null ? void 0 : s.userAgent) != null && n.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((o) => {
    hl(o, e);
  }), setTimeout(() => {
    At || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Ri = !0, Ks = []);
  }, 3e3)) : (Ri = !0, Ks = []);
}
function wc(t, e) {
  hn("app:init", t, e, {
    Fragment: Ae,
    Text: vn,
    Comment: Be,
    Static: Vn
  });
}
function Cc(t) {
  hn("app:unmount", t);
}
const Dc = /* @__PURE__ */ ro(
  "component:added"
  /* COMPONENT_ADDED */
), ml = /* @__PURE__ */ ro(
  "component:updated"
  /* COMPONENT_UPDATED */
), Oc = /* @__PURE__ */ ro(
  "component:removed"
  /* COMPONENT_REMOVED */
), $c = (t) => {
  At && typeof At.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !At.cleanupBuffer(t) && Oc(t);
};
// @__NO_SIDE_EFFECTS__
function ro(t) {
  return (e) => {
    hn(
      t,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const Ac = /* @__PURE__ */ bl(
  "perf:start"
  /* PERFORMANCE_START */
), Mc = /* @__PURE__ */ bl(
  "perf:end"
  /* PERFORMANCE_END */
);
function bl(t) {
  return (e, s, n) => {
    hn(t, e.appContext.app, e.uid, e, s, n);
  };
}
function Vc(t, e, s) {
  hn(
    "component:emit",
    t.appContext.app,
    t,
    e,
    s
  );
}
let He = null, vl = null;
function jn(t) {
  const e = He;
  return He = t, vl = t && t.type.__scopeId || null, e;
}
function P(t, e = He, s) {
  if (!e || t._n)
    return t;
  const n = (...i) => {
    n._d && Gn(-1);
    const o = jn(e);
    let r;
    try {
      r = t(...i);
    } finally {
      jn(o), n._d && Gn(1);
    }
    return g.NODE_ENV !== "production" && ml(e), r;
  };
  return n._n = !0, n._c = !0, n._d = !0, n;
}
function gl(t) {
  ya(t) && R("Do not use built-in directive ids as custom directive id: " + t);
}
function Xe(t, e) {
  if (He === null)
    return g.NODE_ENV !== "production" && R("withDirectives can only be used inside render functions."), t;
  const s = di(He), n = t.dirs || (t.dirs = []);
  for (let i = 0; i < e.length; i++) {
    let [o, r, l, a = _e] = e[i];
    o && (ee(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Ht(r), n.push({
      dir: o,
      instance: s,
      value: r,
      oldValue: void 0,
      arg: l,
      modifiers: a
    }));
  }
  return t;
}
function rs(t, e, s, n) {
  const i = t.dirs, o = e && e.dirs;
  for (let r = 0; r < i.length; r++) {
    const l = i[r];
    o && (l.oldValue = o[r].value);
    let a = l.dir[n];
    a && (gt(), Tt(a, s, 8, [
      t.el,
      l,
      t,
      e
    ]), Et());
  }
}
function Ic(t, e) {
  if (g.NODE_ENV !== "production" && (!Ue || Ue.isMounted) && R("provide() can only be used inside setup()."), Ue) {
    let s = Ue.provides;
    const n = Ue.parent && Ue.parent.provides;
    n === s && (s = Ue.provides = Object.create(n)), s[t] = e;
  }
}
function An(t, e, s = !1) {
  const n = ui();
  if (n || Os) {
    let i = Os ? Os._context.provides : n ? n.parent == null || n.ce ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0;
    if (i && t in i)
      return i[t];
    if (arguments.length > 1)
      return s && ee(e) ? e.call(n && n.proxy) : e;
    g.NODE_ENV !== "production" && R(`injection "${String(t)}" not found.`);
  } else g.NODE_ENV !== "production" && R("inject() can only be used inside setup() or functional components.");
}
const Rc = /* @__PURE__ */ Symbol.for("v-scx"), Lc = () => {
  {
    const t = An(Rc);
    return t || g.NODE_ENV !== "production" && R(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), t;
  }
};
function kc(t, e) {
  return lo(
    t,
    null,
    g.NODE_ENV !== "production" ? Me({}, e, { flush: "sync" }) : { flush: "sync" }
  );
}
function et(t, e, s) {
  return g.NODE_ENV !== "production" && !ee(e) && R(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), lo(t, e, s);
}
function lo(t, e, s = _e) {
  const { immediate: n, deep: i, flush: o, once: r } = s;
  g.NODE_ENV !== "production" && !e && (n !== void 0 && R(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), i !== void 0 && R(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), r !== void 0 && R(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const l = Me({}, s);
  g.NODE_ENV !== "production" && (l.onWarn = R);
  const a = e && n || !e && o !== "post";
  let u;
  if (ln) {
    if (o === "sync") {
      const h = Lc();
      u = h.__watcherHandles || (h.__watcherHandles = []);
    } else if (!a) {
      const h = () => {
      };
      return h.stop = qe, h.resume = qe, h.pause = qe, h;
    }
  }
  const c = Ue;
  l.call = (h, E, y) => Tt(h, c, E, y);
  let d = !1;
  o === "post" ? l.scheduler = (h) => {
    ze(h, c && c.suspense);
  } : o !== "sync" && (d = !0, l.scheduler = (h, E) => {
    E ? h() : li(h);
  }), l.augmentJob = (h) => {
    e && (h.flags |= 4), d && (h.flags |= 2, c && (h.id = c.uid, h.i = c));
  };
  const m = pc(t, e, l);
  return ln && (u ? u.push(m) : a && m()), m;
}
function Pc(t, e, s) {
  const n = this.proxy, i = Ve(t) ? t.includes(".") ? El(n, t) : () => n[t] : t.bind(n, n);
  let o;
  ee(e) ? o = e : (o = e.handler, s = e);
  const r = gn(this), l = lo(i, o.bind(n), s);
  return r(), l;
}
function El(t, e) {
  const s = e.split(".");
  return () => {
    let n = t;
    for (let i = 0; i < s.length && n; i++)
      n = n[s[i]];
    return n;
  };
}
const yl = /* @__PURE__ */ Symbol("_vte"), _l = (t) => t.__isTeleport, vs = (t) => t && (t.disabled || t.disabled === ""), Po = (t) => t && (t.defer || t.defer === ""), Bo = (t) => typeof SVGElement < "u" && t instanceof SVGElement, Fo = (t) => typeof MathMLElement == "function" && t instanceof MathMLElement, Li = (t, e) => {
  const s = t && t.to;
  if (Ve(s))
    if (e) {
      const n = e(s);
      return g.NODE_ENV !== "production" && !n && !vs(t) && R(
        `Failed to locate Teleport target with selector "${s}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), n;
    } else
      return g.NODE_ENV !== "production" && R(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return g.NODE_ENV !== "production" && !s && !vs(t) && R(`Invalid Teleport target: ${s}`), s;
}, Tl = {
  name: "Teleport",
  __isTeleport: !0,
  process(t, e, s, n, i, o, r, l, a, u) {
    const {
      mc: c,
      pc: d,
      pbc: m,
      o: { insert: h, querySelector: E, createText: y, createComment: N }
    } = u, b = vs(e.props);
    let { shapeFlag: T, children: _, dynamicChildren: O } = e;
    if (g.NODE_ENV !== "production" && pt && (a = !1, O = null), t == null) {
      const V = e.el = g.NODE_ENV !== "production" ? N("teleport start") : y(""), K = e.anchor = g.NODE_ENV !== "production" ? N("teleport end") : y("");
      h(V, s, n), h(K, s, n);
      const he = (H, le) => {
        T & 16 && c(
          _,
          H,
          le,
          i,
          o,
          r,
          l,
          a
        );
      }, me = () => {
        const H = e.target = Li(e.props, E), le = ki(H, e, y, h);
        H ? (r !== "svg" && Bo(H) ? r = "svg" : r !== "mathml" && Fo(H) && (r = "mathml"), i && i.isCE && (i.ce._teleportTargets || (i.ce._teleportTargets = /* @__PURE__ */ new Set())).add(H), b || (he(H, le), Mn(e, !1))) : g.NODE_ENV !== "production" && !b && R(
          "Invalid Teleport target on mount:",
          H,
          `(${typeof H})`
        );
      };
      b && (he(s, K), Mn(e, !0)), Po(e.props) ? (e.el.__isMounted = !1, ze(() => {
        me(), delete e.el.__isMounted;
      }, o)) : me();
    } else {
      if (Po(e.props) && t.el.__isMounted === !1) {
        ze(() => {
          Tl.process(
            t,
            e,
            s,
            n,
            i,
            o,
            r,
            l,
            a,
            u
          );
        }, o);
        return;
      }
      e.el = t.el, e.targetStart = t.targetStart;
      const V = e.anchor = t.anchor, K = e.target = t.target, he = e.targetAnchor = t.targetAnchor, me = vs(t.props), H = me ? s : K, le = me ? V : he;
      if (r === "svg" || Bo(K) ? r = "svg" : (r === "mathml" || Fo(K)) && (r = "mathml"), O ? (m(
        t.dynamicChildren,
        O,
        H,
        i,
        o,
        r,
        l
      ), Xs(t, e, g.NODE_ENV === "production")) : a || d(
        t,
        e,
        H,
        le,
        i,
        o,
        r,
        l,
        !1
      ), b)
        me ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : Sn(
          e,
          s,
          V,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
        const be = e.target = Li(
          e.props,
          E
        );
        be ? Sn(
          e,
          be,
          null,
          u,
          0
        ) : g.NODE_ENV !== "production" && R(
          "Invalid Teleport target on update:",
          K,
          `(${typeof K})`
        );
      } else me && Sn(
        e,
        K,
        he,
        u,
        1
      );
      Mn(e, b);
    }
  },
  remove(t, e, s, { um: n, o: { remove: i } }, o) {
    const {
      shapeFlag: r,
      children: l,
      anchor: a,
      targetStart: u,
      targetAnchor: c,
      target: d,
      props: m
    } = t;
    if (d && (i(u), i(c)), o && i(a), r & 16) {
      const h = o || !vs(m);
      for (let E = 0; E < l.length; E++) {
        const y = l[E];
        n(
          y,
          e,
          s,
          h,
          !!y.dynamicChildren
        );
      }
    }
  },
  move: Sn,
  hydrate: Bc
};
function Sn(t, e, s, { o: { insert: n }, m: i }, o = 2) {
  o === 0 && n(t.targetAnchor, e, s);
  const { el: r, anchor: l, shapeFlag: a, children: u, props: c } = t, d = o === 2;
  if (d && n(r, e, s), (!d || vs(c)) && a & 16)
    for (let m = 0; m < u.length; m++)
      i(
        u[m],
        e,
        s,
        2
      );
  d && n(l, e, s);
}
function Bc(t, e, s, n, i, o, {
  o: { nextSibling: r, parentNode: l, querySelector: a, insert: u, createText: c }
}, d) {
  function m(N, b) {
    let T = b;
    for (; T; ) {
      if (T && T.nodeType === 8) {
        if (T.data === "teleport start anchor")
          e.targetStart = T;
        else if (T.data === "teleport anchor") {
          e.targetAnchor = T, N._lpa = e.targetAnchor && r(e.targetAnchor);
          break;
        }
      }
      T = r(T);
    }
  }
  function h(N, b) {
    b.anchor = d(
      r(N),
      b,
      l(N),
      s,
      n,
      i,
      o
    );
  }
  const E = e.target = Li(
    e.props,
    a
  ), y = vs(e.props);
  if (E) {
    const N = E._lpa || E.firstChild;
    e.shapeFlag & 16 && (y ? (h(t, e), m(E, N), e.targetAnchor || ki(
      E,
      e,
      c,
      u,
      // if target is the same as the main view, insert anchors before current node
      // to avoid hydrating mismatch
      l(t) === E ? t : null
    )) : (e.anchor = r(t), m(E, N), e.targetAnchor || ki(E, e, c, u), d(
      N && r(N),
      e,
      E,
      s,
      n,
      i,
      o
    ))), Mn(e, y);
  } else y && e.shapeFlag & 16 && (h(t, e), e.targetStart = t, e.targetAnchor = r(t));
  return e.anchor && r(e.anchor);
}
const Nl = Tl;
function Mn(t, e) {
  const s = t.ctx;
  if (s && s.ut) {
    let n, i;
    for (e ? (n = t.el, i = t.anchor) : (n = t.targetStart, i = t.targetAnchor); n && n !== i; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", s.uid), n = n.nextSibling;
    s.ut();
  }
}
function ki(t, e, s, n, i = null) {
  const o = e.targetStart = s(""), r = e.targetAnchor = s("");
  return o[yl] = r, t && (n(o, t, i), n(r, t, i)), r;
}
const Ot = /* @__PURE__ */ Symbol("_leaveCb"), Us = /* @__PURE__ */ Symbol("_enterCb");
function Fc() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return ot(() => {
    t.isMounted = !0;
  }), Pt(() => {
    t.isUnmounting = !0;
  }), t;
}
const ct = [Function, Array], xl = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: ct,
  onEnter: ct,
  onAfterEnter: ct,
  onEnterCancelled: ct,
  // leave
  onBeforeLeave: ct,
  onLeave: ct,
  onAfterLeave: ct,
  onLeaveCancelled: ct,
  // appear
  onBeforeAppear: ct,
  onAppear: ct,
  onAfterAppear: ct,
  onAppearCancelled: ct
}, Sl = (t) => {
  const e = t.subTree;
  return e.component ? Sl(e.component) : e;
}, Uc = {
  name: "BaseTransition",
  props: xl,
  setup(t, { slots: e }) {
    const s = ui(), n = Fc();
    return () => {
      const i = e.default && Dl(e.default(), !0);
      if (!i || !i.length)
        return;
      const o = wl(i), r = /* @__PURE__ */ ue(t), { mode: l } = r;
      if (g.NODE_ENV !== "production" && l && l !== "in-out" && l !== "out-in" && l !== "default" && R(`invalid <transition> mode: ${l}`), n.isLeaving)
        return Ti(o);
      const a = Uo(o);
      if (!a)
        return Ti(o);
      let u = Pi(
        a,
        r,
        n,
        s,
        // #11061, ensure enterHooks is fresh after clone
        (d) => u = d
      );
      a.type !== Be && on(a, u);
      let c = s.subTree && Uo(s.subTree);
      if (c && c.type !== Be && !ps(c, a) && Sl(s).type !== Be) {
        let d = Pi(
          c,
          r,
          n,
          s
        );
        if (on(c, d), l === "out-in" && a.type !== Be)
          return n.isLeaving = !0, d.afterLeave = () => {
            n.isLeaving = !1, s.job.flags & 8 || s.update(), delete d.afterLeave, c = void 0;
          }, Ti(o);
        l === "in-out" && a.type !== Be ? d.delayLeave = (m, h, E) => {
          const y = Cl(
            n,
            c
          );
          y[String(c.key)] = c, m[Ot] = () => {
            h(), m[Ot] = void 0, delete u.delayedLeave, c = void 0;
          }, u.delayedLeave = () => {
            E(), delete u.delayedLeave, c = void 0;
          };
        } : c = void 0;
      } else c && (c = void 0);
      return o;
    };
  }
};
function wl(t) {
  let e = t[0];
  if (t.length > 1) {
    let s = !1;
    for (const n of t)
      if (n.type !== Be) {
        if (g.NODE_ENV !== "production" && s) {
          R(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        if (e = n, s = !0, g.NODE_ENV === "production") break;
      }
  }
  return e;
}
const jc = Uc;
function Cl(t, e) {
  const { leavingVNodes: s } = t;
  let n = s.get(e.type);
  return n || (n = /* @__PURE__ */ Object.create(null), s.set(e.type, n)), n;
}
function Pi(t, e, s, n, i) {
  const {
    appear: o,
    mode: r,
    persisted: l = !1,
    onBeforeEnter: a,
    onEnter: u,
    onAfterEnter: c,
    onEnterCancelled: d,
    onBeforeLeave: m,
    onLeave: h,
    onAfterLeave: E,
    onLeaveCancelled: y,
    onBeforeAppear: N,
    onAppear: b,
    onAfterAppear: T,
    onAppearCancelled: _
  } = e, O = String(t.key), V = Cl(s, t), K = (H, le) => {
    H && Tt(
      H,
      n,
      9,
      le
    );
  }, he = (H, le) => {
    const be = le[1];
    K(H, le), z(H) ? H.every((C) => C.length <= 1) && be() : H.length <= 1 && be();
  }, me = {
    mode: r,
    persisted: l,
    beforeEnter(H) {
      let le = a;
      if (!s.isMounted)
        if (o)
          le = N || a;
        else
          return;
      H[Ot] && H[Ot](
        !0
        /* cancelled */
      );
      const be = V[O];
      be && ps(t, be) && be.el[Ot] && be.el[Ot](), K(le, [H]);
    },
    enter(H) {
      let le = u, be = c, C = d;
      if (!s.isMounted)
        if (o)
          le = b || u, be = T || c, C = _ || d;
        else
          return;
      let W = !1;
      H[Us] = (ge) => {
        W || (W = !0, ge ? K(C, [H]) : K(be, [H]), me.delayedLeave && me.delayedLeave(), H[Us] = void 0);
      };
      const re = H[Us].bind(null, !1);
      le ? he(le, [H, re]) : re();
    },
    leave(H, le) {
      const be = String(t.key);
      if (H[Us] && H[Us](
        !0
        /* cancelled */
      ), s.isUnmounting)
        return le();
      K(m, [H]);
      let C = !1;
      H[Ot] = (re) => {
        C || (C = !0, le(), re ? K(y, [H]) : K(E, [H]), H[Ot] = void 0, V[be] === t && delete V[be]);
      };
      const W = H[Ot].bind(null, !1);
      V[be] = t, h ? he(h, [H, W]) : W();
    },
    clone(H) {
      const le = Pi(
        H,
        e,
        s,
        n,
        i
      );
      return i && i(le), le;
    }
  };
  return me;
}
function Ti(t) {
  if (mn(t))
    return t = kt(t), t.children = null, t;
}
function Uo(t) {
  if (!mn(t))
    return _l(t.type) && t.children ? wl(t.children) : t;
  if (t.component)
    return t.component.subTree;
  const { shapeFlag: e, children: s } = t;
  if (s) {
    if (e & 16)
      return s[0];
    if (e & 32 && ee(s.default))
      return s.default();
  }
}
function on(t, e) {
  t.shapeFlag & 6 && t.component ? (t.transition = e, on(t.component.subTree, e)) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function Dl(t, e = !1, s) {
  let n = [], i = 0;
  for (let o = 0; o < t.length; o++) {
    let r = t[o];
    const l = s == null ? r.key : String(s) + String(r.key != null ? r.key : o);
    r.type === Ae ? (r.patchFlag & 128 && i++, n = n.concat(
      Dl(r.children, e, l)
    )) : (e || r.type !== Be) && n.push(l != null ? kt(r, { key: l }) : r);
  }
  if (i > 1)
    for (let o = 0; o < n.length; o++)
      n[o].patchFlag = -2;
  return n;
}
// @__NO_SIDE_EFFECTS__
function Te(t, e) {
  return ee(t) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Me({ name: t.name }, e, { setup: t })
  ) : t;
}
function Ol(t) {
  t.ids = [t.ids[0] + t.ids[2]++ + "-", 0, 0];
}
const jo = /* @__PURE__ */ new WeakSet();
function qo(t, e) {
  let s;
  return !!((s = Object.getOwnPropertyDescriptor(t, e)) && !s.configurable);
}
const qn = /* @__PURE__ */ new WeakMap();
function Js(t, e, s, n, i = !1) {
  if (z(t)) {
    t.forEach(
      (y, N) => Js(
        y,
        e && (z(e) ? e[N] : e),
        s,
        n,
        i
      )
    );
    return;
  }
  if (Ds(n) && !i) {
    n.shapeFlag & 512 && n.type.__asyncResolved && n.component.subTree.component && Js(t, e, s, n.component.subTree);
    return;
  }
  const o = n.shapeFlag & 4 ? di(n.component) : n.el, r = i ? null : o, { i: l, r: a } = t;
  if (g.NODE_ENV !== "production" && !l) {
    R(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const u = e && e.r, c = l.refs === _e ? l.refs = {} : l.refs, d = l.setupState, m = /* @__PURE__ */ ue(d), h = d === _e ? Pr : (y) => g.NODE_ENV !== "production" && (ye(m, y) && !/* @__PURE__ */ Fe(m[y]) && R(
    `Template ref "${y}" used on a non-ref value. It will not work in the production build.`
  ), jo.has(m[y])) || qo(c, y) ? !1 : ye(m, y), E = (y, N) => !(g.NODE_ENV !== "production" && jo.has(y) || N && qo(c, N));
  if (u != null && u !== a) {
    if (Ho(e), Ve(u))
      c[u] = null, h(u) && (d[u] = null);
    else if (/* @__PURE__ */ Fe(u)) {
      const y = e;
      E(u, y.k) && (u.value = null), y.k && (c[y.k] = null);
    }
  }
  if (ee(a))
    Ls(a, l, 12, [r, c]);
  else {
    const y = Ve(a), N = /* @__PURE__ */ Fe(a);
    if (y || N) {
      const b = () => {
        if (t.f) {
          const T = y ? h(a) ? d[a] : c[a] : E(a) || !t.k ? a.value : c[t.k];
          if (i)
            z(T) && Qi(T, o);
          else if (z(T))
            T.includes(o) || T.push(o);
          else if (y)
            c[a] = [o], h(a) && (d[a] = c[a]);
          else {
            const _ = [o];
            E(a, t.k) && (a.value = _), t.k && (c[t.k] = _);
          }
        } else y ? (c[a] = r, h(a) && (d[a] = r)) : N ? (E(a, t.k) && (a.value = r), t.k && (c[t.k] = r)) : g.NODE_ENV !== "production" && R("Invalid template ref type:", a, `(${typeof a})`);
      };
      if (r) {
        const T = () => {
          b(), qn.delete(t);
        };
        T.id = -1, qn.set(t, T), ze(T, s);
      } else
        Ho(t), b();
    } else g.NODE_ENV !== "production" && R("Invalid template ref type:", a, `(${typeof a})`);
  }
}
function Ho(t) {
  const e = qn.get(t);
  e && (e.flags |= 8, qn.delete(t));
}
fn().requestIdleCallback;
fn().cancelIdleCallback;
const Ds = (t) => !!t.type.__asyncLoader, mn = (t) => t.type.__isKeepAlive;
function qc(t, e) {
  $l(t, "a", e);
}
function Hc(t, e) {
  $l(t, "da", e);
}
function $l(t, e, s = Ue) {
  const n = t.__wdc || (t.__wdc = () => {
    let i = s;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return t();
  });
  if (ai(e, n, s), s) {
    let i = s.parent;
    for (; i && i.parent; )
      mn(i.parent.vnode) && Wc(n, e, s, i), i = i.parent;
  }
}
function Wc(t, e, s, n) {
  const i = ai(
    e,
    t,
    n,
    !0
    /* prepend */
  );
  bn(() => {
    Qi(n[e], i);
  }, s);
}
function ai(t, e, s = Ue, n = !1) {
  if (s) {
    const i = s[t] || (s[t] = []), o = e.__weh || (e.__weh = (...r) => {
      gt();
      const l = gn(s), a = Tt(e, s, t, r);
      return l(), Et(), a;
    });
    return n ? i.unshift(o) : i.push(o), o;
  } else if (g.NODE_ENV !== "production") {
    const i = us(io[t].replace(/ hook$/, ""));
    R(
      `${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const Qt = (t) => (e, s = Ue) => {
  (!ln || t === "sp") && ai(t, (...n) => e(...n), s);
}, Kc = Qt("bm"), ot = Qt("m"), zc = Qt(
  "bu"
), Gc = Qt("u"), Pt = Qt(
  "bum"
), bn = Qt("um"), Yc = Qt(
  "sp"
), Qc = Qt("rtg"), Jc = Qt("rtc");
function Xc(t, e = Ue) {
  ai("ec", t, e);
}
const Zc = /* @__PURE__ */ Symbol.for("v-ndc");
function Wt(t, e, s, n) {
  let i;
  const o = s, r = z(t);
  if (r || Ve(t)) {
    const l = r && /* @__PURE__ */ is(t);
    let a = !1, u = !1;
    l && (a = !/* @__PURE__ */ Ze(t), u = /* @__PURE__ */ yt(t), t = ii(t)), i = new Array(t.length);
    for (let c = 0, d = t.length; c < d; c++)
      i[c] = e(
        a ? u ? As(_t(t[c])) : _t(t[c]) : t[c],
        c,
        void 0,
        o
      );
  } else if (typeof t == "number") {
    g.NODE_ENV !== "production" && !Number.isInteger(t) && R(`The v-for range expect an integer value but got ${t}.`), i = new Array(t);
    for (let l = 0; l < t; l++)
      i[l] = e(l + 1, l, void 0, o);
  } else if (ve(t))
    if (t[Symbol.iterator])
      i = Array.from(
        t,
        (l, a) => e(l, a, void 0, o)
      );
    else {
      const l = Object.keys(t);
      i = new Array(l.length);
      for (let a = 0, u = l.length; a < u; a++) {
        const c = l[a];
        i[a] = e(t[c], c, a, o);
      }
    }
  else
    i = [];
  return i;
}
function mt(t, e, s = {}, n, i) {
  if (He.ce || He.parent && Ds(He.parent) && He.parent.ce) {
    const u = Object.keys(s).length > 0;
    return e !== "default" && (s.name = e), S(), Le(
      Ae,
      null,
      [w("slot", s, n)],
      u ? -2 : 64
    );
  }
  let o = t[e];
  g.NODE_ENV !== "production" && o && o.length > 1 && (R(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), o = () => []), o && o._c && (o._d = !1), S();
  const r = o && Al(o(s)), l = s.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  r && r.key, a = Le(
    Ae,
    {
      key: (l && !bt(l) ? l : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!r && n ? "_fb" : "")
    },
    r || [],
    r && t._ === 1 ? 64 : -2
  );
  return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), o && o._c && (o._d = !0), a;
}
function Al(t) {
  return t.some((e) => ys(e) ? !(e.type === Be || e.type === Ae && !Al(e.children)) : !0) ? t : null;
}
const Bi = (t) => t ? ta(t) ? di(t) : Bi(t.parent) : null, gs = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Me(/* @__PURE__ */ Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ Mt(t.props) : t.props,
    $attrs: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ Mt(t.attrs) : t.attrs,
    $slots: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ Mt(t.slots) : t.slots,
    $refs: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ Mt(t.refs) : t.refs,
    $parent: (t) => Bi(t.parent),
    $root: (t) => Bi(t.root),
    $host: (t) => t.ce,
    $emit: (t) => t.emit,
    $options: (t) => Il(t),
    $forceUpdate: (t) => t.f || (t.f = () => {
      li(t.update);
    }),
    $nextTick: (t) => t.n || (t.n = It.bind(t.proxy)),
    $watch: (t) => Pc.bind(t)
  })
), ao = (t) => t === "_" || t === "$", Ni = (t, e) => t !== _e && !t.__isScriptSetup && ye(t, e), Ml = {
  get({ _: t }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: s, setupState: n, data: i, props: o, accessCache: r, type: l, appContext: a } = t;
    if (g.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    if (e[0] !== "$") {
      const m = r[e];
      if (m !== void 0)
        switch (m) {
          case 1:
            return n[e];
          case 2:
            return i[e];
          case 4:
            return s[e];
          case 3:
            return o[e];
        }
      else {
        if (Ni(n, e))
          return r[e] = 1, n[e];
        if (i !== _e && ye(i, e))
          return r[e] = 2, i[e];
        if (ye(o, e))
          return r[e] = 3, o[e];
        if (s !== _e && ye(s, e))
          return r[e] = 4, s[e];
        Fi && (r[e] = 0);
      }
    }
    const u = gs[e];
    let c, d;
    if (u)
      return e === "$attrs" ? (je(t.attrs, "get", ""), g.NODE_ENV !== "production" && Kn()) : g.NODE_ENV !== "production" && e === "$slots" && je(t, "get", e), u(t);
    if (
      // css module (injected by vue-loader)
      (c = l.__cssModules) && (c = c[e])
    )
      return c;
    if (s !== _e && ye(s, e))
      return r[e] = 4, s[e];
    if (
      // global properties
      d = a.config.globalProperties, ye(d, e)
    )
      return d[e];
    g.NODE_ENV !== "production" && He && (!Ve(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (i !== _e && ao(e[0]) && ye(i, e) ? R(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : t === He && R(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: t }, e, s) {
    const { data: n, setupState: i, ctx: o } = t;
    return Ni(i, e) ? (i[e] = s, !0) : g.NODE_ENV !== "production" && i.__isScriptSetup && ye(i, e) ? (R(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : n !== _e && ye(n, e) ? (n[e] = s, !0) : ye(t.props, e) ? (g.NODE_ENV !== "production" && R(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (g.NODE_ENV !== "production" && R(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : (g.NODE_ENV !== "production" && e in t.appContext.config.globalProperties ? Object.defineProperty(o, e, {
      enumerable: !0,
      configurable: !0,
      value: s
    }) : o[e] = s, !0);
  },
  has({
    _: { data: t, setupState: e, accessCache: s, ctx: n, appContext: i, props: o, type: r }
  }, l) {
    let a;
    return !!(s[l] || t !== _e && l[0] !== "$" && ye(t, l) || Ni(e, l) || ye(o, l) || ye(n, l) || ye(gs, l) || ye(i.config.globalProperties, l) || (a = r.__cssModules) && a[l]);
  },
  defineProperty(t, e, s) {
    return s.get != null ? t._.accessCache[e] = 0 : ye(s, "value") && this.set(t, e, s.value, null), Reflect.defineProperty(t, e, s);
  }
};
g.NODE_ENV !== "production" && (Ml.ownKeys = (t) => (R(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(t)));
function eu(t) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => t
  }), Object.keys(gs).forEach((s) => {
    Object.defineProperty(e, s, {
      configurable: !0,
      enumerable: !1,
      get: () => gs[s](t),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: qe
    });
  }), e;
}
function tu(t) {
  const {
    ctx: e,
    propsOptions: [s]
  } = t;
  s && Object.keys(s).forEach((n) => {
    Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[n],
      set: qe
    });
  });
}
function su(t) {
  const { ctx: e, setupState: s } = t;
  Object.keys(/* @__PURE__ */ ue(s)).forEach((n) => {
    if (!s.__isScriptSetup) {
      if (ao(n[0])) {
        R(
          `setup() return property ${JSON.stringify(
            n
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, n, {
        enumerable: !0,
        configurable: !0,
        get: () => s[n],
        set: qe
      });
    }
  });
}
function Hn(t) {
  return z(t) ? t.reduce(
    (e, s) => (e[s] = null, e),
    {}
  ) : t;
}
function co(t, e) {
  return !t || !e ? t || e : z(t) && z(e) ? t.concat(e) : Me({}, Hn(t), Hn(e));
}
function nu() {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, s) => {
    t[s] ? R(`${e} property "${s}" is already defined in ${t[s]}.`) : t[s] = e;
  };
}
let Fi = !0;
function iu(t) {
  const e = Il(t), s = t.proxy, n = t.ctx;
  Fi = !1, e.beforeCreate && Wo(e.beforeCreate, t, "bc");
  const {
    // state
    data: i,
    computed: o,
    methods: r,
    watch: l,
    provide: a,
    inject: u,
    // lifecycle
    created: c,
    beforeMount: d,
    mounted: m,
    beforeUpdate: h,
    updated: E,
    activated: y,
    deactivated: N,
    beforeDestroy: b,
    beforeUnmount: T,
    destroyed: _,
    unmounted: O,
    render: V,
    renderTracked: K,
    renderTriggered: he,
    errorCaptured: me,
    serverPrefetch: H,
    // public API
    expose: le,
    inheritAttrs: be,
    // assets
    components: C,
    directives: W,
    filters: re
  } = e, ge = g.NODE_ENV !== "production" ? nu() : null;
  if (g.NODE_ENV !== "production") {
    const [ce] = t.propsOptions;
    if (ce)
      for (const fe in ce)
        ge("Props", fe);
  }
  if (u && ou(u, n, ge), r)
    for (const ce in r) {
      const fe = r[ce];
      ee(fe) ? (g.NODE_ENV !== "production" ? Object.defineProperty(n, ce, {
        value: fe.bind(s),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : n[ce] = fe.bind(s), g.NODE_ENV !== "production" && ge("Methods", ce)) : g.NODE_ENV !== "production" && R(
        `Method "${ce}" has type "${typeof fe}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (i) {
    g.NODE_ENV !== "production" && !ee(i) && R(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const ce = i.call(s, s);
    if (g.NODE_ENV !== "production" && Ji(ce) && R(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !ve(ce))
      g.NODE_ENV !== "production" && R("data() should return an object.");
    else if (t.data = /* @__PURE__ */ os(ce), g.NODE_ENV !== "production")
      for (const fe in ce)
        ge("Data", fe), ao(fe[0]) || Object.defineProperty(n, fe, {
          configurable: !0,
          enumerable: !0,
          get: () => ce[fe],
          set: qe
        });
  }
  if (Fi = !0, o)
    for (const ce in o) {
      const fe = o[ce], J = ee(fe) ? fe.bind(s, s) : ee(fe.get) ? fe.get.bind(s, s) : qe;
      g.NODE_ENV !== "production" && J === qe && R(`Computed property "${ce}" has no getter.`);
      const L = !ee(fe) && ee(fe.set) ? fe.set.bind(s) : g.NODE_ENV !== "production" ? () => {
        R(
          `Write operation failed: computed property "${ce}" is readonly.`
        );
      } : qe, Oe = te({
        get: J,
        set: L
      });
      Object.defineProperty(n, ce, {
        enumerable: !0,
        configurable: !0,
        get: () => Oe.value,
        set: (We) => Oe.value = We
      }), g.NODE_ENV !== "production" && ge("Computed", ce);
    }
  if (l)
    for (const ce in l)
      Vl(l[ce], n, s, ce);
  if (a) {
    const ce = ee(a) ? a.call(s) : a;
    Reflect.ownKeys(ce).forEach((fe) => {
      Ic(fe, ce[fe]);
    });
  }
  c && Wo(c, t, "c");
  function pe(ce, fe) {
    z(fe) ? fe.forEach((J) => ce(J.bind(s))) : fe && ce(fe.bind(s));
  }
  if (pe(Kc, d), pe(ot, m), pe(zc, h), pe(Gc, E), pe(qc, y), pe(Hc, N), pe(Xc, me), pe(Jc, K), pe(Qc, he), pe(Pt, T), pe(bn, O), pe(Yc, H), z(le))
    if (le.length) {
      const ce = t.exposed || (t.exposed = {});
      le.forEach((fe) => {
        Object.defineProperty(ce, fe, {
          get: () => s[fe],
          set: (J) => s[fe] = J,
          enumerable: !0
        });
      });
    } else t.exposed || (t.exposed = {});
  V && t.render === qe && (t.render = V), be != null && (t.inheritAttrs = be), C && (t.components = C), W && (t.directives = W), H && Ol(t);
}
function ou(t, e, s = qe) {
  z(t) && (t = Ui(t));
  for (const n in t) {
    const i = t[n];
    let o;
    ve(i) ? "default" in i ? o = An(
      i.from || n,
      i.default,
      !0
    ) : o = An(i.from || n) : o = An(i), /* @__PURE__ */ Fe(o) ? Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (r) => o.value = r
    }) : e[n] = o, g.NODE_ENV !== "production" && s("Inject", n);
  }
}
function Wo(t, e, s) {
  Tt(
    z(t) ? t.map((n) => n.bind(e.proxy)) : t.bind(e.proxy),
    e,
    s
  );
}
function Vl(t, e, s, n) {
  let i = n.includes(".") ? El(s, n) : () => s[n];
  if (Ve(t)) {
    const o = e[t];
    ee(o) ? et(i, o) : g.NODE_ENV !== "production" && R(`Invalid watch handler specified by key "${t}"`, o);
  } else if (ee(t))
    et(i, t.bind(s));
  else if (ve(t))
    if (z(t))
      t.forEach((o) => Vl(o, e, s, n));
    else {
      const o = ee(t.handler) ? t.handler.bind(s) : e[t.handler];
      ee(o) ? et(i, o, t) : g.NODE_ENV !== "production" && R(`Invalid watch handler specified by key "${t.handler}"`, o);
    }
  else g.NODE_ENV !== "production" && R(`Invalid watch option: "${n}"`, t);
}
function Il(t) {
  const e = t.type, { mixins: s, extends: n } = e, {
    mixins: i,
    optionsCache: o,
    config: { optionMergeStrategies: r }
  } = t.appContext, l = o.get(e);
  let a;
  return l ? a = l : !i.length && !s && !n ? a = e : (a = {}, i.length && i.forEach(
    (u) => Wn(a, u, r, !0)
  ), Wn(a, e, r)), ve(e) && o.set(e, a), a;
}
function Wn(t, e, s, n = !1) {
  const { mixins: i, extends: o } = e;
  o && Wn(t, o, s, !0), i && i.forEach(
    (r) => Wn(t, r, s, !0)
  );
  for (const r in e)
    if (n && r === "expose")
      g.NODE_ENV !== "production" && R(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const l = ru[r] || s && s[r];
      t[r] = l ? l(t[r], e[r]) : e[r];
    }
  return t;
}
const ru = {
  data: Ko,
  props: zo,
  emits: zo,
  // objects
  methods: zs,
  computed: zs,
  // lifecycle
  beforeCreate: Qe,
  created: Qe,
  beforeMount: Qe,
  mounted: Qe,
  beforeUpdate: Qe,
  updated: Qe,
  beforeDestroy: Qe,
  beforeUnmount: Qe,
  destroyed: Qe,
  unmounted: Qe,
  activated: Qe,
  deactivated: Qe,
  errorCaptured: Qe,
  serverPrefetch: Qe,
  // assets
  components: zs,
  directives: zs,
  // watch
  watch: au,
  // provide / inject
  provide: Ko,
  inject: lu
};
function Ko(t, e) {
  return e ? t ? function() {
    return Me(
      ee(t) ? t.call(this, this) : t,
      ee(e) ? e.call(this, this) : e
    );
  } : e : t;
}
function lu(t, e) {
  return zs(Ui(t), Ui(e));
}
function Ui(t) {
  if (z(t)) {
    const e = {};
    for (let s = 0; s < t.length; s++)
      e[t[s]] = t[s];
    return e;
  }
  return t;
}
function Qe(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function zs(t, e) {
  return t ? Me(/* @__PURE__ */ Object.create(null), t, e) : e;
}
function zo(t, e) {
  return t ? z(t) && z(e) ? [.../* @__PURE__ */ new Set([...t, ...e])] : Me(
    /* @__PURE__ */ Object.create(null),
    Hn(t),
    Hn(e ?? {})
  ) : e;
}
function au(t, e) {
  if (!t) return e;
  if (!e) return t;
  const s = Me(/* @__PURE__ */ Object.create(null), t);
  for (const n in e)
    s[n] = Qe(t[n], e[n]);
  return s;
}
function Rl() {
  return {
    app: null,
    config: {
      isNativeTag: Pr,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let cu = 0;
function uu(t, e) {
  return function(n, i = null) {
    ee(n) || (n = Me({}, n)), i != null && !ve(i) && (g.NODE_ENV !== "production" && R("root props passed to app.mount() must be an object."), i = null);
    const o = Rl(), r = /* @__PURE__ */ new WeakSet(), l = [];
    let a = !1;
    const u = o.app = {
      _uid: cu++,
      _component: n,
      _props: i,
      _container: null,
      _context: o,
      _instance: null,
      version: ir,
      get config() {
        return o.config;
      },
      set config(c) {
        g.NODE_ENV !== "production" && R(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(c, ...d) {
        return r.has(c) ? g.NODE_ENV !== "production" && R("Plugin has already been applied to target app.") : c && ee(c.install) ? (r.add(c), c.install(u, ...d)) : ee(c) ? (r.add(c), c(u, ...d)) : g.NODE_ENV !== "production" && R(
          'A plugin must either be a function or an object with an "install" function.'
        ), u;
      },
      mixin(c) {
        return o.mixins.includes(c) ? g.NODE_ENV !== "production" && R(
          "Mixin has already been applied to target app" + (c.name ? `: ${c.name}` : "")
        ) : o.mixins.push(c), u;
      },
      component(c, d) {
        return g.NODE_ENV !== "production" && Ki(c, o.config), d ? (g.NODE_ENV !== "production" && o.components[c] && R(`Component "${c}" has already been registered in target app.`), o.components[c] = d, u) : o.components[c];
      },
      directive(c, d) {
        return g.NODE_ENV !== "production" && gl(c), d ? (g.NODE_ENV !== "production" && o.directives[c] && R(`Directive "${c}" has already been registered in target app.`), o.directives[c] = d, u) : o.directives[c];
      },
      mount(c, d, m) {
        if (a)
          g.NODE_ENV !== "production" && R(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          g.NODE_ENV !== "production" && c.__vue_app__ && R(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const h = u._ceVNode || w(n, i);
          return h.appContext = o, m === !0 ? m = "svg" : m === !1 && (m = void 0), g.NODE_ENV !== "production" && (o.reload = () => {
            const E = kt(h);
            E.el = null, t(E, c, m);
          }), t(h, c, m), a = !0, u._container = c, c.__vue_app__ = u, g.NODE_ENV !== "production" && (u._instance = h.component, wc(u, ir)), di(h.component);
        }
      },
      onUnmount(c) {
        g.NODE_ENV !== "production" && typeof c != "function" && R(
          `Expected function as first argument to app.onUnmount(), but got ${typeof c}`
        ), l.push(c);
      },
      unmount() {
        a ? (Tt(
          l,
          u._instance,
          16
        ), t(null, u._container), g.NODE_ENV !== "production" && (u._instance = null, Cc(u)), delete u._container.__vue_app__) : g.NODE_ENV !== "production" && R("Cannot unmount an app that is not mounted.");
      },
      provide(c, d) {
        return g.NODE_ENV !== "production" && c in o.provides && (ye(o.provides, c) ? R(
          `App already provides property with key "${String(c)}". It will be overwritten with the new value.`
        ) : R(
          `App already provides property with key "${String(c)}" inherited from its parent element. It will be overwritten with the new value.`
        )), o.provides[c] = d, u;
      },
      runWithContext(c) {
        const d = Os;
        Os = u;
        try {
          return c();
        } finally {
          Os = d;
        }
      }
    };
    return u;
  };
}
let Os = null;
function uo(t, e, s = _e) {
  const n = ui();
  if (g.NODE_ENV !== "production" && !n)
    return R("useModel() called without active instance."), /* @__PURE__ */ q();
  const i = ut(e);
  if (g.NODE_ENV !== "production" && !n.propsOptions[0][i])
    return R(`useModel() called with prop "${e}" which is not declared.`), /* @__PURE__ */ q();
  const o = Gt(e), r = Ll(t, i), l = cc((a, u) => {
    let c, d = _e, m;
    return kc(() => {
      const h = t[i];
      it(c, h) && (c = h, u());
    }), {
      get() {
        return a(), s.get ? s.get(c) : c;
      },
      set(h) {
        const E = s.set ? s.set(h) : h;
        if (!it(E, c) && !(d !== _e && it(h, d)))
          return;
        const y = n.vnode.props;
        y && // check if parent has passed v-model
        (e in y || i in y || o in y) && (`onUpdate:${e}` in y || `onUpdate:${i}` in y || `onUpdate:${o}` in y) || (c = h, u()), n.emit(`update:${e}`, E), it(h, E) && it(h, d) && !it(E, m) && u(), d = h, m = E;
      }
    };
  });
  return l[Symbol.iterator] = () => {
    let a = 0;
    return {
      next() {
        return a < 2 ? { value: a++ ? r || _e : l, done: !1 } : { done: !0 };
      }
    };
  }, l;
}
const Ll = (t, e) => e === "modelValue" || e === "model-value" ? t.modelModifiers : t[`${e}Modifiers`] || t[`${ut(e)}Modifiers`] || t[`${Gt(e)}Modifiers`];
function du(t, e, ...s) {
  if (t.isUnmounted) return;
  const n = t.vnode.props || _e;
  if (g.NODE_ENV !== "production") {
    const {
      emitsOptions: c,
      propsOptions: [d]
    } = t;
    if (c)
      if (!(e in c))
        (!d || !(us(ut(e)) in d)) && R(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${us(ut(e))}" prop.`
        );
      else {
        const m = c[e];
        ee(m) && (m(...s) || R(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let i = s;
  const o = e.startsWith("update:"), r = o && Ll(n, e.slice(7));
  if (r && (r.trim && (i = s.map((c) => Ve(c) ? c.trim() : c)), r.number && (i = s.map(si))), g.NODE_ENV !== "production" && Vc(t, e, i), g.NODE_ENV !== "production") {
    const c = e.toLowerCase();
    c !== e && n[us(c)] && R(
      `Event "${c}" is emitted in component ${En(
        t,
        t.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Gt(
        e
      )}" instead of "${e}".`
    );
  }
  let l, a = n[l = us(e)] || // also try camelCase event handler (#2249)
  n[l = us(ut(e))];
  !a && o && (a = n[l = us(Gt(e))]), a && Tt(
    a,
    t,
    6,
    i
  );
  const u = n[l + "Once"];
  if (u) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[l])
      return;
    t.emitted[l] = !0, Tt(
      u,
      t,
      6,
      i
    );
  }
}
const fu = /* @__PURE__ */ new WeakMap();
function kl(t, e, s = !1) {
  const n = s ? fu : e.emitsCache, i = n.get(t);
  if (i !== void 0)
    return i;
  const o = t.emits;
  let r = {}, l = !1;
  if (!ee(t)) {
    const a = (u) => {
      const c = kl(u, e, !0);
      c && (l = !0, Me(r, c));
    };
    !s && e.mixins.length && e.mixins.forEach(a), t.extends && a(t.extends), t.mixins && t.mixins.forEach(a);
  }
  return !o && !l ? (ve(t) && n.set(t, null), null) : (z(o) ? o.forEach((a) => r[a] = null) : Me(r, o), ve(t) && n.set(t, r), r);
}
function ci(t, e) {
  return !t || !un(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), ye(t, e[0].toLowerCase() + e.slice(1)) || ye(t, Gt(e)) || ye(t, e));
}
let ji = !1;
function Kn() {
  ji = !0;
}
function Go(t) {
  const {
    type: e,
    vnode: s,
    proxy: n,
    withProxy: i,
    propsOptions: [o],
    slots: r,
    attrs: l,
    emit: a,
    render: u,
    renderCache: c,
    props: d,
    data: m,
    setupState: h,
    ctx: E,
    inheritAttrs: y
  } = t, N = jn(t);
  let b, T;
  g.NODE_ENV !== "production" && (ji = !1);
  try {
    if (s.shapeFlag & 4) {
      const V = i || n, K = g.NODE_ENV !== "production" && h.__isScriptSetup ? new Proxy(V, {
        get(he, me, H) {
          return R(
            `Property '${String(
              me
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(he, me, H);
        }
      }) : V;
      b = ft(
        u.call(
          K,
          V,
          c,
          g.NODE_ENV !== "production" ? /* @__PURE__ */ Mt(d) : d,
          h,
          m,
          E
        )
      ), T = l;
    } else {
      const V = e;
      g.NODE_ENV !== "production" && l === d && Kn(), b = ft(
        V.length > 1 ? V(
          g.NODE_ENV !== "production" ? /* @__PURE__ */ Mt(d) : d,
          g.NODE_ENV !== "production" ? {
            get attrs() {
              return Kn(), /* @__PURE__ */ Mt(l);
            },
            slots: r,
            emit: a
          } : { attrs: l, slots: r, emit: a }
        ) : V(
          g.NODE_ENV !== "production" ? /* @__PURE__ */ Mt(d) : d,
          null
        )
      ), T = e.props ? l : pu(l);
    }
  } catch (V) {
    Zs.length = 0, pn(V, t, 1), b = w(Be);
  }
  let _ = b, O;
  if (g.NODE_ENV !== "production" && b.patchFlag > 0 && b.patchFlag & 2048 && ([_, O] = Pl(b)), T && y !== !1) {
    const V = Object.keys(T), { shapeFlag: K } = _;
    if (V.length) {
      if (K & 7)
        o && V.some(Ln) && (T = hu(
          T,
          o
        )), _ = kt(_, T, !1, !0);
      else if (g.NODE_ENV !== "production" && !ji && _.type !== Be) {
        const he = Object.keys(l), me = [], H = [];
        for (let le = 0, be = he.length; le < be; le++) {
          const C = he[le];
          un(C) ? Ln(C) || me.push(C[2].toLowerCase() + C.slice(3)) : H.push(C);
        }
        H.length && R(
          `Extraneous non-props attributes (${H.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
        ), me.length && R(
          `Extraneous non-emits event listeners (${me.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return s.dirs && (g.NODE_ENV !== "production" && !Yo(_) && R(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), _ = kt(_, null, !1, !0), _.dirs = _.dirs ? _.dirs.concat(s.dirs) : s.dirs), s.transition && (g.NODE_ENV !== "production" && !Yo(_) && R(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), on(_, s.transition)), g.NODE_ENV !== "production" && O ? O(_) : b = _, jn(N), b;
}
const Pl = (t) => {
  const e = t.children, s = t.dynamicChildren, n = fo(e, !1);
  if (n) {
    if (g.NODE_ENV !== "production" && n.patchFlag > 0 && n.patchFlag & 2048)
      return Pl(n);
  } else return [t, void 0];
  const i = e.indexOf(n), o = s ? s.indexOf(n) : -1, r = (l) => {
    e[i] = l, s && (o > -1 ? s[o] = l : l.patchFlag > 0 && (t.dynamicChildren = [...s, l]));
  };
  return [ft(n), r];
};
function fo(t, e = !0) {
  let s;
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    if (ys(i)) {
      if (i.type !== Be || i.children === "v-if") {
        if (s)
          return;
        if (s = i, g.NODE_ENV !== "production" && e && s.patchFlag > 0 && s.patchFlag & 2048)
          return fo(s.children);
      }
    } else
      return;
  }
  return s;
}
const pu = (t) => {
  let e;
  for (const s in t)
    (s === "class" || s === "style" || un(s)) && ((e || (e = {}))[s] = t[s]);
  return e;
}, hu = (t, e) => {
  const s = {};
  for (const n in t)
    (!Ln(n) || !(n.slice(9) in e)) && (s[n] = t[n]);
  return s;
}, Yo = (t) => t.shapeFlag & 7 || t.type === Be;
function mu(t, e, s) {
  const { props: n, children: i, component: o } = t, { props: r, children: l, patchFlag: a } = e, u = o.emitsOptions;
  if (g.NODE_ENV !== "production" && (i || l) && pt || e.dirs || e.transition)
    return !0;
  if (s && a >= 0) {
    if (a & 1024)
      return !0;
    if (a & 16)
      return n ? Qo(n, r, u) : !!r;
    if (a & 8) {
      const c = e.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        const m = c[d];
        if (Bl(r, n, m) && !ci(u, m))
          return !0;
      }
    }
  } else
    return (i || l) && (!l || !l.$stable) ? !0 : n === r ? !1 : n ? r ? Qo(n, r, u) : !0 : !!r;
  return !1;
}
function Qo(t, e, s) {
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !0;
  for (let i = 0; i < n.length; i++) {
    const o = n[i];
    if (Bl(e, t, o) && !ci(s, o))
      return !0;
  }
  return !1;
}
function Bl(t, e, s) {
  const n = t[s], i = e[s];
  return s === "style" && ve(n) && ve(i) ? !Rs(n, i) : n !== i;
}
function bu({ vnode: t, parent: e }, s) {
  for (; e; ) {
    const n = e.subTree;
    if (n.suspense && n.suspense.activeBranch === t && (n.el = t.el), n === t)
      (t = e.vnode).el = s, e = e.parent;
    else
      break;
  }
}
const Fl = {}, Ul = () => Object.create(Fl), jl = (t) => Object.getPrototypeOf(t) === Fl;
function vu(t, e, s, n = !1) {
  const i = {}, o = Ul();
  t.propsDefaults = /* @__PURE__ */ Object.create(null), ql(t, e, i, o);
  for (const r in t.propsOptions[0])
    r in i || (i[r] = void 0);
  g.NODE_ENV !== "production" && Wl(e || {}, i, t), s ? t.props = n ? i : /* @__PURE__ */ nc(i) : t.type.props ? t.props = i : t.props = o, t.attrs = o;
}
function gu(t) {
  for (; t; ) {
    if (t.type.__hmrId) return !0;
    t = t.parent;
  }
}
function Eu(t, e, s, n) {
  const {
    props: i,
    attrs: o,
    vnode: { patchFlag: r }
  } = t, l = /* @__PURE__ */ ue(i), [a] = t.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(g.NODE_ENV !== "production" && gu(t)) && (n || r > 0) && !(r & 16)
  ) {
    if (r & 8) {
      const c = t.vnode.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        let m = c[d];
        if (ci(t.emitsOptions, m))
          continue;
        const h = e[m];
        if (a)
          if (ye(o, m))
            h !== o[m] && (o[m] = h, u = !0);
          else {
            const E = ut(m);
            i[E] = qi(
              a,
              l,
              E,
              h,
              t,
              !1
            );
          }
        else
          h !== o[m] && (o[m] = h, u = !0);
      }
    }
  } else {
    ql(t, e, i, o) && (u = !0);
    let c;
    for (const d in l)
      (!e || // for camelCase
      !ye(e, d) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((c = Gt(d)) === d || !ye(e, c))) && (a ? s && // for camelCase
      (s[d] !== void 0 || // for kebab-case
      s[c] !== void 0) && (i[d] = qi(
        a,
        l,
        d,
        void 0,
        t,
        !0
      )) : delete i[d]);
    if (o !== l)
      for (const d in o)
        (!e || !ye(e, d)) && (delete o[d], u = !0);
  }
  u && $t(t.attrs, "set", ""), g.NODE_ENV !== "production" && Wl(e || {}, i, t);
}
function ql(t, e, s, n) {
  const [i, o] = t.propsOptions;
  let r = !1, l;
  if (e)
    for (let a in e) {
      if (Gs(a))
        continue;
      const u = e[a];
      let c;
      i && ye(i, c = ut(a)) ? !o || !o.includes(c) ? s[c] = u : (l || (l = {}))[c] = u : ci(t.emitsOptions, a) || (!(a in n) || u !== n[a]) && (n[a] = u, r = !0);
    }
  if (o) {
    const a = /* @__PURE__ */ ue(s), u = l || _e;
    for (let c = 0; c < o.length; c++) {
      const d = o[c];
      s[d] = qi(
        i,
        a,
        d,
        u[d],
        t,
        !ye(u, d)
      );
    }
  }
  return r;
}
function qi(t, e, s, n, i, o) {
  const r = t[s];
  if (r != null) {
    const l = ye(r, "default");
    if (l && n === void 0) {
      const a = r.default;
      if (r.type !== Function && !r.skipFactory && ee(a)) {
        const { propsDefaults: u } = i;
        if (s in u)
          n = u[s];
        else {
          const c = gn(i);
          n = u[s] = a.call(
            null,
            e
          ), c();
        }
      } else
        n = a;
      i.ce && i.ce._setProp(s, n);
    }
    r[
      0
      /* shouldCast */
    ] && (o && !l ? n = !1 : r[
      1
      /* shouldCastTrue */
    ] && (n === "" || n === Gt(s)) && (n = !0));
  }
  return n;
}
const yu = /* @__PURE__ */ new WeakMap();
function Hl(t, e, s = !1) {
  const n = s ? yu : e.propsCache, i = n.get(t);
  if (i)
    return i;
  const o = t.props, r = {}, l = [];
  let a = !1;
  if (!ee(t)) {
    const c = (d) => {
      a = !0;
      const [m, h] = Hl(d, e, !0);
      Me(r, m), h && l.push(...h);
    };
    !s && e.mixins.length && e.mixins.forEach(c), t.extends && c(t.extends), t.mixins && t.mixins.forEach(c);
  }
  if (!o && !a)
    return ve(t) && n.set(t, ws), ws;
  if (z(o))
    for (let c = 0; c < o.length; c++) {
      g.NODE_ENV !== "production" && !Ve(o[c]) && R("props must be strings when using array syntax.", o[c]);
      const d = ut(o[c]);
      Jo(d) && (r[d] = _e);
    }
  else if (o) {
    g.NODE_ENV !== "production" && !ve(o) && R("invalid props options", o);
    for (const c in o) {
      const d = ut(c);
      if (Jo(d)) {
        const m = o[c], h = r[d] = z(m) || ee(m) ? { type: m } : Me({}, m), E = h.type;
        let y = !1, N = !0;
        if (z(E))
          for (let b = 0; b < E.length; ++b) {
            const T = E[b], _ = ee(T) && T.name;
            if (_ === "Boolean") {
              y = !0;
              break;
            } else _ === "String" && (N = !1);
          }
        else
          y = ee(E) && E.name === "Boolean";
        h[
          0
          /* shouldCast */
        ] = y, h[
          1
          /* shouldCastTrue */
        ] = N, (y || ye(h, "default")) && l.push(d);
      }
    }
  }
  const u = [r, l];
  return ve(t) && n.set(t, u), u;
}
function Jo(t) {
  return t[0] !== "$" && !Gs(t) ? !0 : (g.NODE_ENV !== "production" && R(`Invalid prop name: "${t}" is a reserved property.`), !1);
}
function _u(t) {
  return t === null ? "null" : typeof t == "function" ? t.name || "" : typeof t == "object" && t.constructor && t.constructor.name || "";
}
function Wl(t, e, s) {
  const n = /* @__PURE__ */ ue(e), i = s.propsOptions[0], o = Object.keys(t).map((r) => ut(r));
  for (const r in i) {
    let l = i[r];
    l != null && Tu(
      r,
      n[r],
      l,
      g.NODE_ENV !== "production" ? /* @__PURE__ */ Mt(n) : n,
      !o.includes(r)
    );
  }
}
function Tu(t, e, s, n, i) {
  const { type: o, required: r, validator: l, skipCheck: a } = s;
  if (r && i) {
    R('Missing required prop: "' + t + '"');
    return;
  }
  if (!(e == null && !r)) {
    if (o != null && o !== !0 && !a) {
      let u = !1;
      const c = z(o) ? o : [o], d = [];
      for (let m = 0; m < c.length && !u; m++) {
        const { valid: h, expectedType: E } = xu(e, c[m]);
        d.push(E || ""), u = h;
      }
      if (!u) {
        R(Su(t, e, d));
        return;
      }
    }
    l && !l(e, n) && R('Invalid prop: custom validator check failed for prop "' + t + '".');
  }
}
const Nu = /* @__PURE__ */ Yt(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function xu(t, e) {
  let s;
  const n = _u(e);
  if (n === "null")
    s = t === null;
  else if (Nu(n)) {
    const i = typeof t;
    s = i === n.toLowerCase(), !s && i === "object" && (s = t instanceof e);
  } else n === "Object" ? s = ve(t) : n === "Array" ? s = z(t) : s = t instanceof e;
  return {
    valid: s,
    expectedType: n
  };
}
function Su(t, e, s) {
  if (s.length === 0)
    return `Prop type [] for prop "${t}" won't match anything. Did you mean to use type Array instead?`;
  let n = `Invalid prop: type check failed for prop "${t}". Expected ${s.map(ti).join(" | ")}`;
  const i = s[0], o = Xi(e), r = Xo(e, i), l = Xo(e, o);
  return s.length === 1 && Zo(i) && !wu(i, o) && (n += ` with value ${r}`), n += `, got ${o} `, Zo(o) && (n += `with value ${l}.`), n;
}
function Xo(t, e) {
  return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`;
}
function Zo(t) {
  return ["string", "number", "boolean"].some((s) => t.toLowerCase() === s);
}
function wu(...t) {
  return t.some((e) => e.toLowerCase() === "boolean");
}
const po = (t) => t === "_" || t === "_ctx" || t === "$stable", ho = (t) => z(t) ? t.map(ft) : [ft(t)], Cu = (t, e, s) => {
  if (e._n)
    return e;
  const n = P((...i) => (g.NODE_ENV !== "production" && Ue && !(s === null && He) && !(s && s.root !== Ue.root) && R(
    `Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), ho(e(...i))), s);
  return n._c = !1, n;
}, Kl = (t, e, s) => {
  const n = t._ctx;
  for (const i in t) {
    if (po(i)) continue;
    const o = t[i];
    if (ee(o))
      e[i] = Cu(i, o, n);
    else if (o != null) {
      g.NODE_ENV !== "production" && R(
        `Non-function value encountered for slot "${i}". Prefer function slots for better performance.`
      );
      const r = ho(o);
      e[i] = () => r;
    }
  }
}, zl = (t, e) => {
  g.NODE_ENV !== "production" && !mn(t.vnode) && R(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const s = ho(e);
  t.slots.default = () => s;
}, Hi = (t, e, s) => {
  for (const n in e)
    (s || !po(n)) && (t[n] = e[n]);
}, Du = (t, e, s) => {
  const n = t.slots = Ul();
  if (t.vnode.shapeFlag & 32) {
    const i = e._;
    i ? (Hi(n, e, s), s && kn(n, "_", i, !0)) : Kl(e, n);
  } else e && zl(t, e);
}, Ou = (t, e, s) => {
  const { vnode: n, slots: i } = t;
  let o = !0, r = _e;
  if (n.shapeFlag & 32) {
    const l = e._;
    l ? g.NODE_ENV !== "production" && pt ? (Hi(i, e, s), $t(t, "set", "$slots")) : s && l === 1 ? o = !1 : Hi(i, e, s) : (o = !e.$stable, Kl(e, i)), r = e;
  } else e && (zl(t, e), r = { default: 1 });
  if (o)
    for (const l in i)
      !po(l) && r[l] == null && delete i[l];
};
let js, jt;
function Ts(t, e) {
  t.appContext.config.performance && zn() && jt.mark(`vue-${e}-${t.uid}`), g.NODE_ENV !== "production" && Ac(t, e, zn() ? jt.now() : Date.now());
}
function Ns(t, e) {
  if (t.appContext.config.performance && zn()) {
    const s = `vue-${e}-${t.uid}`, n = s + ":end", i = `<${En(t, t.type)}> ${e}`;
    jt.mark(n), jt.measure(i, s, n), jt.clearMeasures(i), jt.clearMarks(s), jt.clearMarks(n);
  }
  g.NODE_ENV !== "production" && Mc(t, e, zn() ? jt.now() : Date.now());
}
function zn() {
  return js !== void 0 || (typeof window < "u" && window.performance ? (js = !0, jt = window.performance) : js = !1), js;
}
function $u() {
  const t = [];
  if (g.NODE_ENV !== "production" && t.length) {
    const e = t.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${t.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const ze = Ru;
function Au(t) {
  return Mu(t);
}
function Mu(t, e) {
  $u();
  const s = fn();
  s.__VUE__ = !0, g.NODE_ENV !== "production" && hl(s.__VUE_DEVTOOLS_GLOBAL_HOOK__, s);
  const {
    insert: n,
    remove: i,
    patchProp: o,
    createElement: r,
    createText: l,
    createComment: a,
    setText: u,
    setElementText: c,
    parentNode: d,
    nextSibling: m,
    setScopeId: h = qe,
    insertStaticContent: E
  } = t, y = (p, v, x, I = null, D = null, A = null, U = void 0, F = null, B = g.NODE_ENV !== "production" && pt ? !1 : !!v.dynamicChildren) => {
    if (p === v)
      return;
    p && !ps(p, v) && (I = _n(p), dt(p, D, A, !0), p = null), v.patchFlag === -2 && (B = !1, v.dynamicChildren = null);
    const { type: M, ref: X, shapeFlag: j } = v;
    switch (M) {
      case vn:
        N(p, v, x, I);
        break;
      case Be:
        b(p, v, x, I);
        break;
      case Vn:
        p == null ? T(v, x, I, U) : g.NODE_ENV !== "production" && _(p, v, x, U);
        break;
      case Ae:
        W(
          p,
          v,
          x,
          I,
          D,
          A,
          U,
          F,
          B
        );
        break;
      default:
        j & 1 ? K(
          p,
          v,
          x,
          I,
          D,
          A,
          U,
          F,
          B
        ) : j & 6 ? re(
          p,
          v,
          x,
          I,
          D,
          A,
          U,
          F,
          B
        ) : j & 64 || j & 128 ? M.process(
          p,
          v,
          x,
          I,
          D,
          A,
          U,
          F,
          B,
          Ps
        ) : g.NODE_ENV !== "production" && R("Invalid VNode type:", M, `(${typeof M})`);
    }
    X != null && D ? Js(X, p && p.ref, A, v || p, !v) : X == null && p && p.ref != null && Js(p.ref, null, A, p, !0);
  }, N = (p, v, x, I) => {
    if (p == null)
      n(
        v.el = l(v.children),
        x,
        I
      );
    else {
      const D = v.el = p.el;
      v.children !== p.children && u(D, v.children);
    }
  }, b = (p, v, x, I) => {
    p == null ? n(
      v.el = a(v.children || ""),
      x,
      I
    ) : v.el = p.el;
  }, T = (p, v, x, I) => {
    [p.el, p.anchor] = E(
      p.children,
      v,
      x,
      I,
      p.el,
      p.anchor
    );
  }, _ = (p, v, x, I) => {
    if (v.children !== p.children) {
      const D = m(p.anchor);
      V(p), [v.el, v.anchor] = E(
        v.children,
        x,
        D,
        I
      );
    } else
      v.el = p.el, v.anchor = p.anchor;
  }, O = ({ el: p, anchor: v }, x, I) => {
    let D;
    for (; p && p !== v; )
      D = m(p), n(p, x, I), p = D;
    n(v, x, I);
  }, V = ({ el: p, anchor: v }) => {
    let x;
    for (; p && p !== v; )
      x = m(p), i(p), p = x;
    i(v);
  }, K = (p, v, x, I, D, A, U, F, B) => {
    if (v.type === "svg" ? U = "svg" : v.type === "math" && (U = "mathml"), p == null)
      he(
        v,
        x,
        I,
        D,
        A,
        U,
        F,
        B
      );
    else {
      const M = p.el && p.el._isVueCE ? p.el : null;
      try {
        M && M._beginPatch(), le(
          p,
          v,
          D,
          A,
          U,
          F,
          B
        );
      } finally {
        M && M._endPatch();
      }
    }
  }, he = (p, v, x, I, D, A, U, F) => {
    let B, M;
    const { props: X, shapeFlag: j, transition: G, dirs: ie } = p;
    if (B = p.el = r(
      p.type,
      A,
      X && X.is,
      X
    ), j & 8 ? c(B, p.children) : j & 16 && H(
      p.children,
      B,
      null,
      I,
      D,
      xi(p, A),
      U,
      F
    ), ie && rs(p, null, I, "created"), me(B, p, p.scopeId, U, I), X) {
      for (const Ce in X)
        Ce !== "value" && !Gs(Ce) && o(B, Ce, null, X[Ce], A, I);
      "value" in X && o(B, "value", null, X.value, A), (M = X.onVnodeBeforeMount) && Ct(M, I, p);
    }
    g.NODE_ENV !== "production" && (kn(B, "__vnode", p, !0), kn(B, "__vueParentComponent", I, !0)), ie && rs(p, null, I, "beforeMount");
    const Ee = Vu(D, G);
    Ee && G.beforeEnter(B), n(B, v, x), ((M = X && X.onVnodeMounted) || Ee || ie) && ze(() => {
      M && Ct(M, I, p), Ee && G.enter(B), ie && rs(p, null, I, "mounted");
    }, D);
  }, me = (p, v, x, I, D) => {
    if (x && h(p, x), I)
      for (let A = 0; A < I.length; A++)
        h(p, I[A]);
    if (D) {
      let A = D.subTree;
      if (g.NODE_ENV !== "production" && A.patchFlag > 0 && A.patchFlag & 2048 && (A = fo(A.children) || A), v === A || Ql(A.type) && (A.ssContent === v || A.ssFallback === v)) {
        const U = D.vnode;
        me(
          p,
          U,
          U.scopeId,
          U.slotScopeIds,
          D.parent
        );
      }
    }
  }, H = (p, v, x, I, D, A, U, F, B = 0) => {
    for (let M = B; M < p.length; M++) {
      const X = p[M] = F ? qt(p[M]) : ft(p[M]);
      y(
        null,
        X,
        v,
        x,
        I,
        D,
        A,
        U,
        F
      );
    }
  }, le = (p, v, x, I, D, A, U) => {
    const F = v.el = p.el;
    g.NODE_ENV !== "production" && (F.__vnode = v);
    let { patchFlag: B, dynamicChildren: M, dirs: X } = v;
    B |= p.patchFlag & 16;
    const j = p.props || _e, G = v.props || _e;
    let ie;
    if (x && ls(x, !1), (ie = G.onVnodeBeforeUpdate) && Ct(ie, x, v, p), X && rs(v, p, x, "beforeUpdate"), x && ls(x, !0), g.NODE_ENV !== "production" && pt && (B = 0, U = !1, M = null), (j.innerHTML && G.innerHTML == null || j.textContent && G.textContent == null) && c(F, ""), M ? (be(
      p.dynamicChildren,
      M,
      F,
      x,
      I,
      xi(v, D),
      A
    ), g.NODE_ENV !== "production" && Xs(p, v)) : U || J(
      p,
      v,
      F,
      null,
      x,
      I,
      xi(v, D),
      A,
      !1
    ), B > 0) {
      if (B & 16)
        C(F, j, G, x, D);
      else if (B & 2 && j.class !== G.class && o(F, "class", null, G.class, D), B & 4 && o(F, "style", j.style, G.style, D), B & 8) {
        const Ee = v.dynamicProps;
        for (let Ce = 0; Ce < Ee.length; Ce++) {
          const xe = Ee[Ce], tt = j[xe], st = G[xe];
          (st !== tt || xe === "value") && o(F, xe, tt, st, D, x);
        }
      }
      B & 1 && p.children !== v.children && c(F, v.children);
    } else !U && M == null && C(F, j, G, x, D);
    ((ie = G.onVnodeUpdated) || X) && ze(() => {
      ie && Ct(ie, x, v, p), X && rs(v, p, x, "updated");
    }, I);
  }, be = (p, v, x, I, D, A, U) => {
    for (let F = 0; F < v.length; F++) {
      const B = p[F], M = v[F], X = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        B.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (B.type === Ae || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ps(B, M) || // - In the case of a component, it could contain anything.
        B.shapeFlag & 198) ? d(B.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          x
        )
      );
      y(
        B,
        M,
        X,
        null,
        I,
        D,
        A,
        U,
        !0
      );
    }
  }, C = (p, v, x, I, D) => {
    if (v !== x) {
      if (v !== _e)
        for (const A in v)
          !Gs(A) && !(A in x) && o(
            p,
            A,
            v[A],
            null,
            D,
            I
          );
      for (const A in x) {
        if (Gs(A)) continue;
        const U = x[A], F = v[A];
        U !== F && A !== "value" && o(p, A, F, U, D, I);
      }
      "value" in x && o(p, "value", v.value, x.value, D);
    }
  }, W = (p, v, x, I, D, A, U, F, B) => {
    const M = v.el = p ? p.el : l(""), X = v.anchor = p ? p.anchor : l("");
    let { patchFlag: j, dynamicChildren: G, slotScopeIds: ie } = v;
    g.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (pt || j & 2048) && (j = 0, B = !1, G = null), ie && (F = F ? F.concat(ie) : ie), p == null ? (n(M, x, I), n(X, x, I), H(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      v.children || [],
      x,
      X,
      D,
      A,
      U,
      F,
      B
    )) : j > 0 && j & 64 && G && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    p.dynamicChildren && p.dynamicChildren.length === G.length ? (be(
      p.dynamicChildren,
      G,
      x,
      D,
      A,
      U,
      F
    ), g.NODE_ENV !== "production" ? Xs(p, v) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (v.key != null || D && v === D.subTree) && Xs(
        p,
        v,
        !0
        /* shallow */
      )
    )) : J(
      p,
      v,
      x,
      X,
      D,
      A,
      U,
      F,
      B
    );
  }, re = (p, v, x, I, D, A, U, F, B) => {
    v.slotScopeIds = F, p == null ? v.shapeFlag & 512 ? D.ctx.activate(
      v,
      x,
      I,
      U,
      B
    ) : ge(
      v,
      x,
      I,
      D,
      A,
      U,
      B
    ) : pe(p, v, B);
  }, ge = (p, v, x, I, D, A, U) => {
    const F = p.component = ju(
      p,
      I,
      D
    );
    if (g.NODE_ENV !== "production" && F.type.__hmrId && Tc(F), g.NODE_ENV !== "production" && (Dn(p), Ts(F, "mount")), mn(p) && (F.ctx.renderer = Ps), g.NODE_ENV !== "production" && Ts(F, "init"), Hu(F, !1, U), g.NODE_ENV !== "production" && Ns(F, "init"), g.NODE_ENV !== "production" && pt && (p.el = null), F.asyncDep) {
      if (D && D.registerDep(F, ce, U), !p.el) {
        const B = F.subTree = w(Be);
        b(null, B, v, x), p.placeholder = B.el;
      }
    } else
      ce(
        F,
        p,
        v,
        x,
        D,
        A,
        U
      );
    g.NODE_ENV !== "production" && (On(), Ns(F, "mount"));
  }, pe = (p, v, x) => {
    const I = v.component = p.component;
    if (mu(p, v, x))
      if (I.asyncDep && !I.asyncResolved) {
        g.NODE_ENV !== "production" && Dn(v), fe(I, v, x), g.NODE_ENV !== "production" && On();
        return;
      } else
        I.next = v, I.update();
    else
      v.el = p.el, I.vnode = v;
  }, ce = (p, v, x, I, D, A, U) => {
    const F = () => {
      if (p.isMounted) {
        let { next: j, bu: G, u: ie, parent: Ee, vnode: Ce } = p;
        {
          const St = Gl(p);
          if (St) {
            j && (j.el = Ce.el, fe(p, j, U)), St.asyncDep.then(() => {
              ze(() => {
                p.isUnmounted || M();
              }, D);
            });
            return;
          }
        }
        let xe = j, tt;
        g.NODE_ENV !== "production" && Dn(j || p.vnode), ls(p, !1), j ? (j.el = Ce.el, fe(p, j, U)) : j = Ce, G && xs(G), (tt = j.props && j.props.onVnodeBeforeUpdate) && Ct(tt, Ee, j, Ce), ls(p, !0), g.NODE_ENV !== "production" && Ts(p, "render");
        const st = Go(p);
        g.NODE_ENV !== "production" && Ns(p, "render");
        const xt = p.subTree;
        p.subTree = st, g.NODE_ENV !== "production" && Ts(p, "patch"), y(
          xt,
          st,
          // parent may have changed if it's in a teleport
          d(xt.el),
          // anchor may have changed if it's in a fragment
          _n(xt),
          p,
          D,
          A
        ), g.NODE_ENV !== "production" && Ns(p, "patch"), j.el = st.el, xe === null && bu(p, st.el), ie && ze(ie, D), (tt = j.props && j.props.onVnodeUpdated) && ze(
          () => Ct(tt, Ee, j, Ce),
          D
        ), g.NODE_ENV !== "production" && ml(p), g.NODE_ENV !== "production" && On();
      } else {
        let j;
        const { el: G, props: ie } = v, { bm: Ee, m: Ce, parent: xe, root: tt, type: st } = p, xt = Ds(v);
        ls(p, !1), Ee && xs(Ee), !xt && (j = ie && ie.onVnodeBeforeMount) && Ct(j, xe, v), ls(p, !0);
        {
          tt.ce && tt.ce._hasShadowRoot() && tt.ce._injectChildStyle(st), g.NODE_ENV !== "production" && Ts(p, "render");
          const St = p.subTree = Go(p);
          g.NODE_ENV !== "production" && Ns(p, "render"), g.NODE_ENV !== "production" && Ts(p, "patch"), y(
            null,
            St,
            x,
            I,
            p,
            D,
            A
          ), g.NODE_ENV !== "production" && Ns(p, "patch"), v.el = St.el;
        }
        if (Ce && ze(Ce, D), !xt && (j = ie && ie.onVnodeMounted)) {
          const St = v;
          ze(
            () => Ct(j, xe, St),
            D
          );
        }
        (v.shapeFlag & 256 || xe && Ds(xe.vnode) && xe.vnode.shapeFlag & 256) && p.a && ze(p.a, D), p.isMounted = !0, g.NODE_ENV !== "production" && Dc(p), v = x = I = null;
      }
    };
    p.scope.on();
    const B = p.effect = new Hr(F);
    p.scope.off();
    const M = p.update = B.run.bind(B), X = p.job = B.runIfDirty.bind(B);
    X.i = p, X.id = p.uid, B.scheduler = () => li(X), ls(p, !0), g.NODE_ENV !== "production" && (B.onTrack = p.rtc ? (j) => xs(p.rtc, j) : void 0, B.onTrigger = p.rtg ? (j) => xs(p.rtg, j) : void 0), M();
  }, fe = (p, v, x) => {
    v.component = p;
    const I = p.vnode.props;
    p.vnode = v, p.next = null, Eu(p, v.props, I, x), Ou(p, v.children, x), gt(), Lo(p), Et();
  }, J = (p, v, x, I, D, A, U, F, B = !1) => {
    const M = p && p.children, X = p ? p.shapeFlag : 0, j = v.children, { patchFlag: G, shapeFlag: ie } = v;
    if (G > 0) {
      if (G & 128) {
        Oe(
          M,
          j,
          x,
          I,
          D,
          A,
          U,
          F,
          B
        );
        return;
      } else if (G & 256) {
        L(
          M,
          j,
          x,
          I,
          D,
          A,
          U,
          F,
          B
        );
        return;
      }
    }
    ie & 8 ? (X & 16 && ks(M, D, A), j !== M && c(x, j)) : X & 16 ? ie & 16 ? Oe(
      M,
      j,
      x,
      I,
      D,
      A,
      U,
      F,
      B
    ) : ks(M, D, A, !0) : (X & 8 && c(x, ""), ie & 16 && H(
      j,
      x,
      I,
      D,
      A,
      U,
      F,
      B
    ));
  }, L = (p, v, x, I, D, A, U, F, B) => {
    p = p || ws, v = v || ws;
    const M = p.length, X = v.length, j = Math.min(M, X);
    let G;
    for (G = 0; G < j; G++) {
      const ie = v[G] = B ? qt(v[G]) : ft(v[G]);
      y(
        p[G],
        ie,
        x,
        null,
        D,
        A,
        U,
        F,
        B
      );
    }
    M > X ? ks(
      p,
      D,
      A,
      !0,
      !1,
      j
    ) : H(
      v,
      x,
      I,
      D,
      A,
      U,
      F,
      B,
      j
    );
  }, Oe = (p, v, x, I, D, A, U, F, B) => {
    let M = 0;
    const X = v.length;
    let j = p.length - 1, G = X - 1;
    for (; M <= j && M <= G; ) {
      const ie = p[M], Ee = v[M] = B ? qt(v[M]) : ft(v[M]);
      if (ps(ie, Ee))
        y(
          ie,
          Ee,
          x,
          null,
          D,
          A,
          U,
          F,
          B
        );
      else
        break;
      M++;
    }
    for (; M <= j && M <= G; ) {
      const ie = p[j], Ee = v[G] = B ? qt(v[G]) : ft(v[G]);
      if (ps(ie, Ee))
        y(
          ie,
          Ee,
          x,
          null,
          D,
          A,
          U,
          F,
          B
        );
      else
        break;
      j--, G--;
    }
    if (M > j) {
      if (M <= G) {
        const ie = G + 1, Ee = ie < X ? v[ie].el : I;
        for (; M <= G; )
          y(
            null,
            v[M] = B ? qt(v[M]) : ft(v[M]),
            x,
            Ee,
            D,
            A,
            U,
            F,
            B
          ), M++;
      }
    } else if (M > G)
      for (; M <= j; )
        dt(p[M], D, A, !0), M++;
    else {
      const ie = M, Ee = M, Ce = /* @__PURE__ */ new Map();
      for (M = Ee; M <= G; M++) {
        const Ye = v[M] = B ? qt(v[M]) : ft(v[M]);
        Ye.key != null && (g.NODE_ENV !== "production" && Ce.has(Ye.key) && R(
          "Duplicate keys found during update:",
          JSON.stringify(Ye.key),
          "Make sure keys are unique."
        ), Ce.set(Ye.key, M));
      }
      let xe, tt = 0;
      const st = G - Ee + 1;
      let xt = !1, St = 0;
      const Bs = new Array(st);
      for (M = 0; M < st; M++) Bs[M] = 0;
      for (M = ie; M <= j; M++) {
        const Ye = p[M];
        if (tt >= st) {
          dt(Ye, D, A, !0);
          continue;
        }
        let wt;
        if (Ye.key != null)
          wt = Ce.get(Ye.key);
        else
          for (xe = Ee; xe <= G; xe++)
            if (Bs[xe - Ee] === 0 && ps(Ye, v[xe])) {
              wt = xe;
              break;
            }
        wt === void 0 ? dt(Ye, D, A, !0) : (Bs[wt - Ee] = M + 1, wt >= St ? St = wt : xt = !0, y(
          Ye,
          v[wt],
          x,
          null,
          D,
          A,
          U,
          F,
          B
        ), tt++);
      }
      const Do = xt ? Iu(Bs) : ws;
      for (xe = Do.length - 1, M = st - 1; M >= 0; M--) {
        const Ye = Ee + M, wt = v[Ye], Oo = v[Ye + 1], $o = Ye + 1 < X ? (
          // #13559, #14173 fallback to el placeholder for unresolved async component
          Oo.el || Yl(Oo)
        ) : I;
        Bs[M] === 0 ? y(
          null,
          wt,
          x,
          $o,
          D,
          A,
          U,
          F,
          B
        ) : xt && (xe < 0 || M !== Do[xe] ? We(wt, x, $o, 2) : xe--);
      }
    }
  }, We = (p, v, x, I, D = null) => {
    const { el: A, type: U, transition: F, children: B, shapeFlag: M } = p;
    if (M & 6) {
      We(p.component.subTree, v, x, I);
      return;
    }
    if (M & 128) {
      p.suspense.move(v, x, I);
      return;
    }
    if (M & 64) {
      U.move(p, v, x, Ps);
      return;
    }
    if (U === Ae) {
      n(A, v, x);
      for (let j = 0; j < B.length; j++)
        We(B[j], v, x, I);
      n(p.anchor, v, x);
      return;
    }
    if (U === Vn) {
      O(p, v, x);
      return;
    }
    if (I !== 2 && M & 1 && F)
      if (I === 0)
        F.beforeEnter(A), n(A, v, x), ze(() => F.enter(A), D);
      else {
        const { leave: j, delayLeave: G, afterLeave: ie } = F, Ee = () => {
          p.ctx.isUnmounted ? i(A) : n(A, v, x);
        }, Ce = () => {
          A._isLeaving && A[Ot](
            !0
            /* cancelled */
          ), j(A, () => {
            Ee(), ie && ie();
          });
        };
        G ? G(A, Ee, Ce) : Ce();
      }
    else
      n(A, v, x);
  }, dt = (p, v, x, I = !1, D = !1) => {
    const {
      type: A,
      props: U,
      ref: F,
      children: B,
      dynamicChildren: M,
      shapeFlag: X,
      patchFlag: j,
      dirs: G,
      cacheIndex: ie
    } = p;
    if (j === -2 && (D = !1), F != null && (gt(), Js(F, null, x, p, !0), Et()), ie != null && (v.renderCache[ie] = void 0), X & 256) {
      v.ctx.deactivate(p);
      return;
    }
    const Ee = X & 1 && G, Ce = !Ds(p);
    let xe;
    if (Ce && (xe = U && U.onVnodeBeforeUnmount) && Ct(xe, v, p), X & 6)
      ga(p.component, x, I);
    else {
      if (X & 128) {
        p.suspense.unmount(x, I);
        return;
      }
      Ee && rs(p, null, v, "beforeUnmount"), X & 64 ? p.type.remove(
        p,
        v,
        x,
        Ps,
        I
      ) : M && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !M.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (A !== Ae || j > 0 && j & 64) ? ks(
        M,
        v,
        x,
        !1,
        !0
      ) : (A === Ae && j & 384 || !D && X & 16) && ks(B, v, x), I && hi(p);
    }
    (Ce && (xe = U && U.onVnodeUnmounted) || Ee) && ze(() => {
      xe && Ct(xe, v, p), Ee && rs(p, null, v, "unmounted");
    }, x);
  }, hi = (p) => {
    const { type: v, el: x, anchor: I, transition: D } = p;
    if (v === Ae) {
      g.NODE_ENV !== "production" && p.patchFlag > 0 && p.patchFlag & 2048 && D && !D.persisted ? p.children.forEach((U) => {
        U.type === Be ? i(U.el) : hi(U);
      }) : va(x, I);
      return;
    }
    if (v === Vn) {
      V(p);
      return;
    }
    const A = () => {
      i(x), D && !D.persisted && D.afterLeave && D.afterLeave();
    };
    if (p.shapeFlag & 1 && D && !D.persisted) {
      const { leave: U, delayLeave: F } = D, B = () => U(x, A);
      F ? F(p.el, A, B) : B();
    } else
      A();
  }, va = (p, v) => {
    let x;
    for (; p !== v; )
      x = m(p), i(p), p = x;
    i(v);
  }, ga = (p, v, x) => {
    g.NODE_ENV !== "production" && p.type.__hmrId && Nc(p);
    const { bum: I, scope: D, job: A, subTree: U, um: F, m: B, a: M } = p;
    er(B), er(M), I && xs(I), D.stop(), A && (A.flags |= 8, dt(U, p, v, x)), F && ze(F, v), ze(() => {
      p.isUnmounted = !0;
    }, v), g.NODE_ENV !== "production" && $c(p);
  }, ks = (p, v, x, I = !1, D = !1, A = 0) => {
    for (let U = A; U < p.length; U++)
      dt(p[U], v, x, I, D);
  }, _n = (p) => {
    if (p.shapeFlag & 6)
      return _n(p.component.subTree);
    if (p.shapeFlag & 128)
      return p.suspense.next();
    const v = m(p.anchor || p.el), x = v && v[yl];
    return x ? m(x) : v;
  };
  let mi = !1;
  const Co = (p, v, x) => {
    let I;
    p == null ? v._vnode && (dt(v._vnode, null, null, !0), I = v._vnode.component) : y(
      v._vnode || null,
      p,
      v,
      null,
      null,
      null,
      x
    ), v._vnode = p, mi || (mi = !0, Lo(I), dl(), mi = !1);
  }, Ps = {
    p: y,
    um: dt,
    m: We,
    r: hi,
    mt: ge,
    mc: H,
    pc: J,
    pbc: be,
    n: _n,
    o: t
  };
  return {
    render: Co,
    hydrate: void 0,
    createApp: uu(Co)
  };
}
function xi({ type: t, props: e }, s) {
  return s === "svg" && t === "foreignObject" || s === "mathml" && t === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : s;
}
function ls({ effect: t, job: e }, s) {
  s ? (t.flags |= 32, e.flags |= 4) : (t.flags &= -33, e.flags &= -5);
}
function Vu(t, e) {
  return (!t || t && !t.pendingBranch) && e && !e.persisted;
}
function Xs(t, e, s = !1) {
  const n = t.children, i = e.children;
  if (z(n) && z(i))
    for (let o = 0; o < n.length; o++) {
      const r = n[o];
      let l = i[o];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = i[o] = qt(i[o]), l.el = r.el), !s && l.patchFlag !== -2 && Xs(r, l)), l.type === vn && (l.patchFlag === -1 && (l = i[o] = qt(l)), l.el = r.el), l.type === Be && !l.el && (l.el = r.el), g.NODE_ENV !== "production" && l.el && (l.el.__vnode = l);
    }
}
function Iu(t) {
  const e = t.slice(), s = [0];
  let n, i, o, r, l;
  const a = t.length;
  for (n = 0; n < a; n++) {
    const u = t[n];
    if (u !== 0) {
      if (i = s[s.length - 1], t[i] < u) {
        e[n] = i, s.push(n);
        continue;
      }
      for (o = 0, r = s.length - 1; o < r; )
        l = o + r >> 1, t[s[l]] < u ? o = l + 1 : r = l;
      u < t[s[o]] && (o > 0 && (e[n] = s[o - 1]), s[o] = n);
    }
  }
  for (o = s.length, r = s[o - 1]; o-- > 0; )
    s[o] = r, r = e[r];
  return s;
}
function Gl(t) {
  const e = t.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : Gl(e);
}
function er(t) {
  if (t)
    for (let e = 0; e < t.length; e++)
      t[e].flags |= 8;
}
function Yl(t) {
  if (t.placeholder)
    return t.placeholder;
  const e = t.component;
  return e ? Yl(e.subTree) : null;
}
const Ql = (t) => t.__isSuspense;
function Ru(t, e) {
  e && e.pendingBranch ? z(t) ? e.effects.push(...t) : e.effects.push(t) : ul(t);
}
const Ae = /* @__PURE__ */ Symbol.for("v-fgt"), vn = /* @__PURE__ */ Symbol.for("v-txt"), Be = /* @__PURE__ */ Symbol.for("v-cmt"), Vn = /* @__PURE__ */ Symbol.for("v-stc"), Zs = [];
let at = null;
function S(t = !1) {
  Zs.push(at = t ? null : []);
}
function Lu() {
  Zs.pop(), at = Zs[Zs.length - 1] || null;
}
let rn = 1;
function Gn(t, e = !1) {
  rn += t, t < 0 && at && e && (at.hasOnce = !0);
}
function Jl(t) {
  return t.dynamicChildren = rn > 0 ? at || ws : null, Lu(), rn > 0 && at && at.push(t), t;
}
function k(t, e, s, n, i, o) {
  return Jl(
    f(
      t,
      e,
      s,
      n,
      i,
      o,
      !0
    )
  );
}
function Le(t, e, s, n, i) {
  return Jl(
    w(
      t,
      e,
      s,
      n,
      i,
      !0
    )
  );
}
function ys(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function ps(t, e) {
  if (g.NODE_ENV !== "production" && e.shapeFlag & 6 && t.component) {
    const s = $n.get(e.type);
    if (s && s.has(t.component))
      return t.shapeFlag &= -257, e.shapeFlag &= -513, !1;
  }
  return t.type === e.type && t.key === e.key;
}
const ku = (...t) => Zl(
  ...t
), Xl = ({ key: t }) => t ?? null, In = ({
  ref: t,
  ref_key: e,
  ref_for: s
}) => (typeof t == "number" && (t = "" + t), t != null ? Ve(t) || /* @__PURE__ */ Fe(t) || ee(t) ? { i: He, r: t, k: e, f: !!s } : t : null);
function f(t, e = null, s = null, n = 0, i = null, o = t === Ae ? 0 : 1, r = !1, l = !1) {
  const a = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && Xl(e),
    ref: e && In(e),
    scopeId: vl,
    slotScopeIds: null,
    children: s,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: n,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: He
  };
  return l ? (mo(a, s), o & 128 && t.normalize(a)) : s && (a.shapeFlag |= Ve(s) ? 8 : 16), g.NODE_ENV !== "production" && a.key !== a.key && R("VNode created with invalid key (NaN). VNode type:", a.type), rn > 0 && // avoid a block node from tracking itself
  !r && // has current parent block
  at && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (a.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  a.patchFlag !== 32 && at.push(a), a;
}
const w = g.NODE_ENV !== "production" ? ku : Zl;
function Zl(t, e = null, s = null, n = 0, i = null, o = !1) {
  if ((!t || t === Zc) && (g.NODE_ENV !== "production" && !t && R(`Invalid vnode type when creating vnode: ${t}.`), t = Be), ys(t)) {
    const l = kt(
      t,
      e,
      !0
      /* mergeRef: true */
    );
    return s && mo(l, s), rn > 0 && !o && at && (l.shapeFlag & 6 ? at[at.indexOf(t)] = l : at.push(l)), l.patchFlag = -2, l;
  }
  if (ia(t) && (t = t.__vccOpts), e) {
    e = Pu(e);
    let { class: l, style: a } = e;
    l && !Ve(l) && (e.class = Ie(l)), ve(a) && (/* @__PURE__ */ Pn(a) && !z(a) && (a = Me({}, a)), e.style = Ke(a));
  }
  const r = Ve(t) ? 1 : Ql(t) ? 128 : _l(t) ? 64 : ve(t) ? 4 : ee(t) ? 2 : 0;
  return g.NODE_ENV !== "production" && r & 4 && /* @__PURE__ */ Pn(t) && (t = /* @__PURE__ */ ue(t), R(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    t
  )), f(
    t,
    e,
    s,
    n,
    i,
    r,
    o,
    !0
  );
}
function Pu(t) {
  return t ? /* @__PURE__ */ Pn(t) || jl(t) ? Me({}, t) : t : null;
}
function kt(t, e, s = !1, n = !1) {
  const { props: i, ref: o, patchFlag: r, children: l, transition: a } = t, u = e ? Bu(i || {}, e) : i, c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: u,
    key: u && Xl(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      s && o ? z(o) ? o.concat(In(e)) : [o, In(e)] : In(e)
    ) : o,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: g.NODE_ENV !== "production" && r === -1 && z(l) ? l.map(ea) : l,
    target: t.target,
    targetStart: t.targetStart,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && t.type !== Ae ? r === -1 ? 16 : r | 16 : r,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: a,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && kt(t.ssContent),
    ssFallback: t.ssFallback && kt(t.ssFallback),
    placeholder: t.placeholder,
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
  return a && n && on(
    c,
    a.clone(c)
  ), c;
}
function ea(t) {
  const e = kt(t);
  return z(t.children) && (e.children = t.children.map(ea)), e;
}
function se(t = " ", e = 0) {
  return w(vn, null, t, e);
}
function ne(t = "", e = !1) {
  return e ? (S(), Le(Be, null, t)) : w(Be, null, t);
}
function ft(t) {
  return t == null || typeof t == "boolean" ? w(Be) : z(t) ? w(
    Ae,
    null,
    // #3666, avoid reference pollution when reusing vnode
    t.slice()
  ) : ys(t) ? qt(t) : w(vn, null, String(t));
}
function qt(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : kt(t);
}
function mo(t, e) {
  let s = 0;
  const { shapeFlag: n } = t;
  if (e == null)
    e = null;
  else if (z(e))
    s = 16;
  else if (typeof e == "object")
    if (n & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), mo(t, i()), i._c && (i._d = !0));
      return;
    } else {
      s = 32;
      const i = e._;
      !i && !jl(e) ? e._ctx = He : i === 3 && He && (He.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else ee(e) ? (e = { default: e, _ctx: He }, s = 32) : (e = String(e), n & 64 ? (s = 16, e = [se(e)]) : s = 8);
  t.children = e, t.shapeFlag |= s;
}
function Bu(...t) {
  const e = {};
  for (let s = 0; s < t.length; s++) {
    const n = t[s];
    for (const i in n)
      if (i === "class")
        e.class !== n.class && (e.class = Ie([e.class, n.class]));
      else if (i === "style")
        e.style = Ke([e.style, n.style]);
      else if (un(i)) {
        const o = e[i], r = n[i];
        r && o !== r && !(z(o) && o.includes(r)) && (e[i] = o ? [].concat(o, r) : r);
      } else i !== "" && (e[i] = n[i]);
  }
  return e;
}
function Ct(t, e, s, n = null) {
  Tt(t, e, 7, [
    s,
    n
  ]);
}
const Fu = Rl();
let Uu = 0;
function ju(t, e, s) {
  const n = t.type, i = (e ? e.appContext : t.appContext) || Fu, o = {
    uid: Uu++,
    vnode: t,
    type: n,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new ka(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Hl(n, i),
    emitsOptions: kl(n, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: _e,
    // inheritAttrs
    inheritAttrs: n.inheritAttrs,
    // state
    ctx: _e,
    data: _e,
    props: _e,
    attrs: _e,
    slots: _e,
    refs: _e,
    setupState: _e,
    setupContext: null,
    // suspense related
    suspense: s,
    suspenseId: s ? s.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return g.NODE_ENV !== "production" ? o.ctx = eu(o) : o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = du.bind(null, o), t.ce && t.ce(o), o;
}
let Ue = null;
const ui = () => Ue || He;
let Yn, Wi;
{
  const t = fn(), e = (s, n) => {
    let i;
    return (i = t[s]) || (i = t[s] = []), i.push(n), (o) => {
      i.length > 1 ? i.forEach((r) => r(o)) : i[0](o);
    };
  };
  Yn = e(
    "__VUE_INSTANCE_SETTERS__",
    (s) => Ue = s
  ), Wi = e(
    "__VUE_SSR_SETTERS__",
    (s) => ln = s
  );
}
const gn = (t) => {
  const e = Ue;
  return Yn(t), t.scope.on(), () => {
    t.scope.off(), Yn(e);
  };
}, tr = () => {
  Ue && Ue.scope.off(), Yn(null);
}, qu = /* @__PURE__ */ Yt("slot,component");
function Ki(t, { isNativeTag: e }) {
  (qu(t) || e(t)) && R(
    "Do not use built-in or reserved HTML elements as component id: " + t
  );
}
function ta(t) {
  return t.vnode.shapeFlag & 4;
}
let ln = !1;
function Hu(t, e = !1, s = !1) {
  e && Wi(e);
  const { props: n, children: i } = t.vnode, o = ta(t);
  vu(t, n, o, e), Du(t, i, s || e);
  const r = o ? Wu(t, e) : void 0;
  return e && Wi(!1), r;
}
function Wu(t, e) {
  const s = t.type;
  if (g.NODE_ENV !== "production") {
    if (s.name && Ki(s.name, t.appContext.config), s.components) {
      const i = Object.keys(s.components);
      for (let o = 0; o < i.length; o++)
        Ki(i[o], t.appContext.config);
    }
    if (s.directives) {
      const i = Object.keys(s.directives);
      for (let o = 0; o < i.length; o++)
        gl(i[o]);
    }
    s.compilerOptions && Ku() && R(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = new Proxy(t.ctx, Ml), g.NODE_ENV !== "production" && tu(t);
  const { setup: n } = s;
  if (n) {
    gt();
    const i = t.setupContext = n.length > 1 ? Gu(t) : null, o = gn(t), r = Ls(
      n,
      t,
      0,
      [
        g.NODE_ENV !== "production" ? /* @__PURE__ */ Mt(t.props) : t.props,
        i
      ]
    ), l = Ji(r);
    if (Et(), o(), (l || t.sp) && !Ds(t) && Ol(t), l) {
      if (r.then(tr, tr), e)
        return r.then((a) => {
          sr(t, a, e);
        }).catch((a) => {
          pn(a, t, 0);
        });
      if (t.asyncDep = r, g.NODE_ENV !== "production" && !t.suspense) {
        const a = En(t, s);
        R(
          `Component <${a}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      sr(t, r, e);
  } else
    sa(t, e);
}
function sr(t, e, s) {
  ee(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : ve(e) ? (g.NODE_ENV !== "production" && ys(e) && R(
    "setup() should not return VNodes directly - return a render function instead."
  ), g.NODE_ENV !== "production" && (t.devtoolsRawSetupState = e), t.setupState = rl(e), g.NODE_ENV !== "production" && su(t)) : g.NODE_ENV !== "production" && e !== void 0 && R(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), sa(t, s);
}
const Ku = () => !0;
function sa(t, e, s) {
  const n = t.type;
  t.render || (t.render = n.render || qe);
  {
    const i = gn(t);
    gt();
    try {
      iu(t);
    } finally {
      Et(), i();
    }
  }
  g.NODE_ENV !== "production" && !n.render && t.render === qe && !e && (n.template ? R(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : R("Component is missing template or render function: ", n));
}
const nr = g.NODE_ENV !== "production" ? {
  get(t, e) {
    return Kn(), je(t, "get", ""), t[e];
  },
  set() {
    return R("setupContext.attrs is readonly."), !1;
  },
  deleteProperty() {
    return R("setupContext.attrs is readonly."), !1;
  }
} : {
  get(t, e) {
    return je(t, "get", ""), t[e];
  }
};
function zu(t) {
  return new Proxy(t.slots, {
    get(e, s) {
      return je(t, "get", "$slots"), e[s];
    }
  });
}
function Gu(t) {
  const e = (s) => {
    if (g.NODE_ENV !== "production" && (t.exposed && R("expose() should be called only once per setup()."), s != null)) {
      let n = typeof s;
      n === "object" && (z(s) ? n = "array" : /* @__PURE__ */ Fe(s) && (n = "ref")), n !== "object" && R(
        `expose() should be passed a plain object, received ${n}.`
      );
    }
    t.exposed = s || {};
  };
  if (g.NODE_ENV !== "production") {
    let s, n;
    return Object.freeze({
      get attrs() {
        return s || (s = new Proxy(t.attrs, nr));
      },
      get slots() {
        return n || (n = zu(t));
      },
      get emit() {
        return (i, ...o) => t.emit(i, ...o);
      },
      expose: e
    });
  } else
    return {
      attrs: new Proxy(t.attrs, nr),
      slots: t.slots,
      emit: t.emit,
      expose: e
    };
}
function di(t) {
  return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(rl(ic(t.exposed)), {
    get(e, s) {
      if (s in e)
        return e[s];
      if (s in gs)
        return gs[s](t);
    },
    has(e, s) {
      return s in e || s in gs;
    }
  })) : t.proxy;
}
const Yu = /(?:^|[-_])\w/g, Qu = (t) => t.replace(Yu, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function na(t, e = !0) {
  return ee(t) ? t.displayName || t.name : t.name || e && t.__name;
}
function En(t, e, s = !1) {
  let n = na(e);
  if (!n && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (n = i[1]);
  }
  if (!n && t) {
    const i = (o) => {
      for (const r in o)
        if (o[r] === e)
          return r;
    };
    n = i(t.components) || t.parent && i(
      t.parent.type.components
    ) || i(t.appContext.components);
  }
  return n ? Qu(n) : s ? "App" : "Anonymous";
}
function ia(t) {
  return ee(t) && "__vccOpts" in t;
}
const te = (t, e) => {
  const s = /* @__PURE__ */ dc(t, e, ln);
  if (g.NODE_ENV !== "production") {
    const n = ui();
    n && n.appContext.config.warnRecursiveComputed && (s._warnRecursive = !0);
  }
  return s;
};
function Ju(t, e, s) {
  try {
    Gn(-1);
    const n = arguments.length;
    return n === 2 ? ve(e) && !z(e) ? ys(e) ? w(t, null, [e]) : w(t, e) : w(t, null, e) : (n > 3 ? s = Array.prototype.slice.call(arguments, 2) : n === 3 && ys(s) && (s = [s]), w(t, e, s));
  } finally {
    Gn(1);
  }
}
function Xu() {
  if (g.NODE_ENV === "production" || typeof window > "u")
    return;
  const t = { style: "color:#3ba776" }, e = { style: "color:#1677ff" }, s = { style: "color:#f5222d" }, n = { style: "color:#eb2f96" }, i = {
    __vue_custom_formatter: !0,
    header(d) {
      if (!ve(d))
        return null;
      if (d.__isVue)
        return ["div", t, "VueInstance"];
      if (/* @__PURE__ */ Fe(d)) {
        gt();
        const m = d.value;
        return Et(), [
          "div",
          {},
          ["span", t, c(d)],
          "<",
          l(m),
          ">"
        ];
      } else {
        if (/* @__PURE__ */ is(d))
          return [
            "div",
            {},
            ["span", t, /* @__PURE__ */ Ze(d) ? "ShallowReactive" : "Reactive"],
            "<",
            l(d),
            `>${/* @__PURE__ */ yt(d) ? " (readonly)" : ""}`
          ];
        if (/* @__PURE__ */ yt(d))
          return [
            "div",
            {},
            ["span", t, /* @__PURE__ */ Ze(d) ? "ShallowReadonly" : "Readonly"],
            "<",
            l(d),
            ">"
          ];
      }
      return null;
    },
    hasBody(d) {
      return d && d.__isVue;
    },
    body(d) {
      if (d && d.__isVue)
        return [
          "div",
          {},
          ...o(d.$)
        ];
    }
  };
  function o(d) {
    const m = [];
    d.type.props && d.props && m.push(r("props", /* @__PURE__ */ ue(d.props))), d.setupState !== _e && m.push(r("setup", d.setupState)), d.data !== _e && m.push(r("data", /* @__PURE__ */ ue(d.data)));
    const h = a(d, "computed");
    h && m.push(r("computed", h));
    const E = a(d, "inject");
    return E && m.push(r("injected", E)), m.push([
      "div",
      {},
      [
        "span",
        {
          style: n.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: d }]
    ]), m;
  }
  function r(d, m) {
    return m = Me({}, m), Object.keys(m).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        d
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(m).map((h) => [
          "div",
          {},
          ["span", n, h + ": "],
          l(m[h], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function l(d, m = !0) {
    return typeof d == "number" ? ["span", e, d] : typeof d == "string" ? ["span", s, JSON.stringify(d)] : typeof d == "boolean" ? ["span", n, d] : ve(d) ? ["object", { object: m ? /* @__PURE__ */ ue(d) : d }] : ["span", s, String(d)];
  }
  function a(d, m) {
    const h = d.type;
    if (ee(h))
      return;
    const E = {};
    for (const y in d.ctx)
      u(h, y, m) && (E[y] = d.ctx[y]);
    return E;
  }
  function u(d, m, h) {
    const E = d[h];
    if (z(E) && E.includes(m) || ve(E) && m in E || d.extends && u(d.extends, m, h) || d.mixins && d.mixins.some((y) => u(y, m, h)))
      return !0;
  }
  function c(d) {
    return /* @__PURE__ */ Ze(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];
}
const ir = "3.5.28", Rt = g.NODE_ENV !== "production" ? R : qe;
var Nt = {};
let zi;
const or = typeof window < "u" && window.trustedTypes;
if (or)
  try {
    zi = /* @__PURE__ */ or.createPolicy("vue", {
      createHTML: (t) => t
    });
  } catch (t) {
    Nt.NODE_ENV !== "production" && Rt(`Error creating trusted types policy: ${t}`);
  }
const oa = zi ? (t) => zi.createHTML(t) : (t) => t, Zu = "http://www.w3.org/2000/svg", ed = "http://www.w3.org/1998/Math/MathML", Ut = typeof document < "u" ? document : null, rr = Ut && /* @__PURE__ */ Ut.createElement("template"), td = {
  insert: (t, e, s) => {
    e.insertBefore(t, s || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, s, n) => {
    const i = e === "svg" ? Ut.createElementNS(Zu, t) : e === "mathml" ? Ut.createElementNS(ed, t) : s ? Ut.createElement(t, { is: s }) : Ut.createElement(t);
    return t === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple), i;
  },
  createText: (t) => Ut.createTextNode(t),
  createComment: (t) => Ut.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Ut.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(t, e, s, n, i, o) {
    const r = s ? s.previousSibling : e.lastChild;
    if (i && (i === o || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), s), !(i === o || !(i = i.nextSibling)); )
        ;
    else {
      rr.innerHTML = oa(
        n === "svg" ? `<svg>${t}</svg>` : n === "mathml" ? `<math>${t}</math>` : t
      );
      const l = rr.content;
      if (n === "svg" || n === "mathml") {
        const a = l.firstChild;
        for (; a.firstChild; )
          l.appendChild(a.firstChild);
        l.removeChild(a);
      }
      e.insertBefore(l, s);
    }
    return [
      // first
      r ? r.nextSibling : e.firstChild,
      // last
      s ? s.previousSibling : e.lastChild
    ];
  }
}, Jt = "transition", qs = "animation", an = /* @__PURE__ */ Symbol("_vtc"), ra = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, sd = /* @__PURE__ */ Me(
  {},
  xl,
  ra
), nd = (t) => (t.displayName = "Transition", t.props = sd, t), bo = /* @__PURE__ */ nd(
  (t, { slots: e }) => Ju(jc, id(t), e)
), as = (t, e = []) => {
  z(t) ? t.forEach((s) => s(...e)) : t && t(...e);
}, lr = (t) => t ? z(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function id(t) {
  const e = {};
  for (const C in t)
    C in ra || (e[C] = t[C]);
  if (t.css === !1)
    return e;
  const {
    name: s = "v",
    type: n,
    duration: i,
    enterFromClass: o = `${s}-enter-from`,
    enterActiveClass: r = `${s}-enter-active`,
    enterToClass: l = `${s}-enter-to`,
    appearFromClass: a = o,
    appearActiveClass: u = r,
    appearToClass: c = l,
    leaveFromClass: d = `${s}-leave-from`,
    leaveActiveClass: m = `${s}-leave-active`,
    leaveToClass: h = `${s}-leave-to`
  } = t, E = od(i), y = E && E[0], N = E && E[1], {
    onBeforeEnter: b,
    onEnter: T,
    onEnterCancelled: _,
    onLeave: O,
    onLeaveCancelled: V,
    onBeforeAppear: K = b,
    onAppear: he = T,
    onAppearCancelled: me = _
  } = e, H = (C, W, re, ge) => {
    C._enterCancelled = ge, cs(C, W ? c : l), cs(C, W ? u : r), re && re();
  }, le = (C, W) => {
    C._isLeaving = !1, cs(C, d), cs(C, h), cs(C, m), W && W();
  }, be = (C) => (W, re) => {
    const ge = C ? he : T, pe = () => H(W, C, re);
    as(ge, [W, pe]), ar(() => {
      cs(W, C ? a : o), Ft(W, C ? c : l), lr(ge) || cr(W, n, y, pe);
    });
  };
  return Me(e, {
    onBeforeEnter(C) {
      as(b, [C]), Ft(C, o), Ft(C, r);
    },
    onBeforeAppear(C) {
      as(K, [C]), Ft(C, a), Ft(C, u);
    },
    onEnter: be(!1),
    onAppear: be(!0),
    onLeave(C, W) {
      C._isLeaving = !0;
      const re = () => le(C, W);
      Ft(C, d), C._enterCancelled ? (Ft(C, m), fr(C)) : (fr(C), Ft(C, m)), ar(() => {
        C._isLeaving && (cs(C, d), Ft(C, h), lr(O) || cr(C, n, N, re));
      }), as(O, [C, re]);
    },
    onEnterCancelled(C) {
      H(C, !1, void 0, !0), as(_, [C]);
    },
    onAppearCancelled(C) {
      H(C, !0, void 0, !0), as(me, [C]);
    },
    onLeaveCancelled(C) {
      le(C), as(V, [C]);
    }
  });
}
function od(t) {
  if (t == null)
    return null;
  if (ve(t))
    return [Si(t.enter), Si(t.leave)];
  {
    const e = Si(t);
    return [e, e];
  }
}
function Si(t) {
  const e = Na(t);
  return Nt.NODE_ENV !== "production" && gc(e, "<transition> explicit duration"), e;
}
function Ft(t, e) {
  e.split(/\s+/).forEach((s) => s && t.classList.add(s)), (t[an] || (t[an] = /* @__PURE__ */ new Set())).add(e);
}
function cs(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.remove(n));
  const s = t[an];
  s && (s.delete(e), s.size || (t[an] = void 0));
}
function ar(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let rd = 0;
function cr(t, e, s, n) {
  const i = t._endId = ++rd, o = () => {
    i === t._endId && n();
  };
  if (s != null)
    return setTimeout(o, s);
  const { type: r, timeout: l, propCount: a } = ld(t, e);
  if (!r)
    return n();
  const u = r + "end";
  let c = 0;
  const d = () => {
    t.removeEventListener(u, m), o();
  }, m = (h) => {
    h.target === t && ++c >= a && d();
  };
  setTimeout(() => {
    c < a && d();
  }, l + 1), t.addEventListener(u, m);
}
function ld(t, e) {
  const s = window.getComputedStyle(t), n = (E) => (s[E] || "").split(", "), i = n(`${Jt}Delay`), o = n(`${Jt}Duration`), r = ur(i, o), l = n(`${qs}Delay`), a = n(`${qs}Duration`), u = ur(l, a);
  let c = null, d = 0, m = 0;
  e === Jt ? r > 0 && (c = Jt, d = r, m = o.length) : e === qs ? u > 0 && (c = qs, d = u, m = a.length) : (d = Math.max(r, u), c = d > 0 ? r > u ? Jt : qs : null, m = c ? c === Jt ? o.length : a.length : 0);
  const h = c === Jt && /\b(?:transform|all)(?:,|$)/.test(
    n(`${Jt}Property`).toString()
  );
  return {
    type: c,
    timeout: d,
    propCount: m,
    hasTransform: h
  };
}
function ur(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((s, n) => dr(s) + dr(t[n])));
}
function dr(t) {
  return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function fr(t) {
  return (t ? t.ownerDocument : document).body.offsetHeight;
}
function ad(t, e, s) {
  const n = t[an];
  n && (e = (e ? [e, ...n] : [...n]).join(" ")), e == null ? t.removeAttribute("class") : s ? t.setAttribute("class", e) : t.className = e;
}
const Qn = /* @__PURE__ */ Symbol("_vod"), la = /* @__PURE__ */ Symbol("_vsh"), pr = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(t, { value: e }, { transition: s }) {
    t[Qn] = t.style.display === "none" ? "" : t.style.display, s && e ? s.beforeEnter(t) : Hs(t, e);
  },
  mounted(t, { value: e }, { transition: s }) {
    s && e && s.enter(t);
  },
  updated(t, { value: e, oldValue: s }, { transition: n }) {
    !e != !s && (n ? e ? (n.beforeEnter(t), Hs(t, !0), n.enter(t)) : n.leave(t, () => {
      Hs(t, !1);
    }) : Hs(t, e));
  },
  beforeUnmount(t, { value: e }) {
    Hs(t, e);
  }
};
function Hs(t, e) {
  t.style.display = e ? t[Qn] : "none", t[la] = !e;
}
const cd = /* @__PURE__ */ Symbol(Nt.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""), ud = /(?:^|;)\s*display\s*:/;
function dd(t, e, s) {
  const n = t.style, i = Ve(s);
  let o = !1;
  if (s && !i) {
    if (e)
      if (Ve(e))
        for (const r of e.split(";")) {
          const l = r.slice(0, r.indexOf(":")).trim();
          s[l] == null && Rn(n, l, "");
        }
      else
        for (const r in e)
          s[r] == null && Rn(n, r, "");
    for (const r in s)
      r === "display" && (o = !0), Rn(n, r, s[r]);
  } else if (i) {
    if (e !== s) {
      const r = n[cd];
      r && (s += ";" + r), n.cssText = s, o = ud.test(s);
    }
  } else e && t.removeAttribute("style");
  Qn in t && (t[Qn] = o ? n.display : "", t[la] && (n.display = "none"));
}
const fd = /[^\\];\s*$/, hr = /\s*!important$/;
function Rn(t, e, s) {
  if (z(s))
    s.forEach((n) => Rn(t, e, n));
  else if (s == null && (s = ""), Nt.NODE_ENV !== "production" && fd.test(s) && Rt(
    `Unexpected semicolon at the end of '${e}' style value: '${s}'`
  ), e.startsWith("--"))
    t.setProperty(e, s);
  else {
    const n = pd(t, e);
    hr.test(s) ? t.setProperty(
      Gt(n),
      s.replace(hr, ""),
      "important"
    ) : t[n] = s;
  }
}
const mr = ["Webkit", "Moz", "ms"], wi = {};
function pd(t, e) {
  const s = wi[e];
  if (s)
    return s;
  let n = ut(e);
  if (n !== "filter" && n in t)
    return wi[e] = n;
  n = ti(n);
  for (let i = 0; i < mr.length; i++) {
    const o = mr[i] + n;
    if (o in t)
      return wi[e] = o;
  }
  return e;
}
const br = "http://www.w3.org/1999/xlink";
function vr(t, e, s, n, i, o = Ra(e)) {
  n && e.startsWith("xlink:") ? s == null ? t.removeAttributeNS(br, e.slice(6, e.length)) : t.setAttributeNS(br, e, s) : s == null || o && !Ur(s) ? t.removeAttribute(e) : t.setAttribute(
    e,
    o ? "" : bt(s) ? String(s) : s
  );
}
function gr(t, e, s, n, i) {
  if (e === "innerHTML" || e === "textContent") {
    s != null && (t[e] = e === "innerHTML" ? oa(s) : s);
    return;
  }
  const o = t.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const l = o === "OPTION" ? t.getAttribute("value") || "" : t.value, a = s == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      t.type === "checkbox" ? "on" : ""
    ) : String(s);
    (l !== a || !("_value" in t)) && (t.value = a), s == null && t.removeAttribute(e), t._value = s;
    return;
  }
  let r = !1;
  if (s === "" || s == null) {
    const l = typeof t[e];
    l === "boolean" ? s = Ur(s) : s == null && l === "string" ? (s = "", r = !0) : l === "number" && (s = 0, r = !0);
  }
  try {
    t[e] = s;
  } catch (l) {
    Nt.NODE_ENV !== "production" && !r && Rt(
      `Failed setting prop "${e}" on <${o.toLowerCase()}>: value ${s} is invalid.`,
      l
    );
  }
  r && t.removeAttribute(i || e);
}
function ts(t, e, s, n) {
  t.addEventListener(e, s, n);
}
function hd(t, e, s, n) {
  t.removeEventListener(e, s, n);
}
const Er = /* @__PURE__ */ Symbol("_vei");
function md(t, e, s, n, i = null) {
  const o = t[Er] || (t[Er] = {}), r = o[e];
  if (n && r)
    r.value = Nt.NODE_ENV !== "production" ? _r(n, e) : n;
  else {
    const [l, a] = bd(e);
    if (n) {
      const u = o[e] = Ed(
        Nt.NODE_ENV !== "production" ? _r(n, e) : n,
        i
      );
      ts(t, l, u, a);
    } else r && (hd(t, l, r, a), o[e] = void 0);
  }
}
const yr = /(?:Once|Passive|Capture)$/;
function bd(t) {
  let e;
  if (yr.test(t)) {
    e = {};
    let n;
    for (; n = t.match(yr); )
      t = t.slice(0, t.length - n[0].length), e[n[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : Gt(t.slice(2)), e];
}
let Ci = 0;
const vd = /* @__PURE__ */ Promise.resolve(), gd = () => Ci || (vd.then(() => Ci = 0), Ci = Date.now());
function Ed(t, e) {
  const s = (n) => {
    if (!n._vts)
      n._vts = Date.now();
    else if (n._vts <= s.attached)
      return;
    Tt(
      yd(n, s.value),
      e,
      5,
      [n]
    );
  };
  return s.value = t, s.attached = gd(), s;
}
function _r(t, e) {
  return ee(t) || z(t) ? t : (Rt(
    `Wrong type passed as event handler to ${e} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof t}.`
  ), qe);
}
function yd(t, e) {
  if (z(e)) {
    const s = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      s.call(t), t._stopped = !0;
    }, e.map(
      (n) => (i) => !i._stopped && n && n(i)
    );
  } else
    return e;
}
const Tr = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // lowercase letter
t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, _d = (t, e, s, n, i, o) => {
  const r = i === "svg";
  e === "class" ? ad(t, n, r) : e === "style" ? dd(t, s, n) : un(e) ? Ln(e) || md(t, e, s, n, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : Td(t, e, n, r)) ? (gr(t, e, n), !t.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && vr(t, e, n, r, o, e !== "value")) : /* #11081 force set props for possible async custom element */ t._isVueCE && (/[A-Z]/.test(e) || !Ve(n)) ? gr(t, ut(e), n, o, e) : (e === "true-value" ? t._trueValue = n : e === "false-value" && (t._falseValue = n), vr(t, e, n, r));
};
function Td(t, e, s, n) {
  if (n)
    return !!(e === "innerHTML" || e === "textContent" || e in t && Tr(e) && ee(s));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && t.tagName === "IFRAME" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = t.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return Tr(e) && Ve(s) ? !1 : e in t;
}
const Ms = (t) => {
  const e = t.props["onUpdate:modelValue"] || !1;
  return z(e) ? (s) => xs(e, s) : e;
};
function Nd(t) {
  t.target.composing = !0;
}
function Nr(t) {
  const e = t.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const Kt = /* @__PURE__ */ Symbol("_assign");
function xr(t, e, s) {
  return e && (t = t.trim()), s && (t = si(t)), t;
}
const zt = {
  created(t, { modifiers: { lazy: e, trim: s, number: n } }, i) {
    t[Kt] = Ms(i);
    const o = n || i.props && i.props.type === "number";
    ts(t, e ? "change" : "input", (r) => {
      r.target.composing || t[Kt](xr(t.value, s, o));
    }), (s || o) && ts(t, "change", () => {
      t.value = xr(t.value, s, o);
    }), e || (ts(t, "compositionstart", Nd), ts(t, "compositionend", Nr), ts(t, "change", Nr));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(t, { value: e }) {
    t.value = e ?? "";
  },
  beforeUpdate(t, { value: e, oldValue: s, modifiers: { lazy: n, trim: i, number: o } }, r) {
    if (t[Kt] = Ms(r), t.composing) return;
    const l = (o || t.type === "number") && !/^0\d/.test(t.value) ? si(t.value) : t.value, a = e ?? "";
    l !== a && (document.activeElement === t && t.type !== "range" && (n && e === s || i && t.value.trim() === a) || (t.value = a));
  }
}, aa = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(t, e, s) {
    t[Kt] = Ms(s), ts(t, "change", () => {
      const n = t._modelValue, i = cn(t), o = t.checked, r = t[Kt];
      if (z(n)) {
        const l = eo(n, i), a = l !== -1;
        if (o && !a)
          r(n.concat(i));
        else if (!o && a) {
          const u = [...n];
          u.splice(l, 1), r(u);
        }
      } else if (Is(n)) {
        const l = new Set(n);
        o ? l.add(i) : l.delete(i), r(l);
      } else
        r(ua(t, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Sr,
  beforeUpdate(t, e, s) {
    t[Kt] = Ms(s), Sr(t, e, s);
  }
};
function Sr(t, { value: e, oldValue: s }, n) {
  t._modelValue = e;
  let i;
  if (z(e))
    i = eo(e, n.props.value) > -1;
  else if (Is(e))
    i = e.has(n.props.value);
  else {
    if (e === s) return;
    i = Rs(e, ua(t, !0));
  }
  t.checked !== i && (t.checked = i);
}
const ca = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(t, { value: e, modifiers: { number: s } }, n) {
    const i = Is(e);
    ts(t, "change", () => {
      const o = Array.prototype.filter.call(t.options, (r) => r.selected).map(
        (r) => s ? si(cn(r)) : cn(r)
      );
      t[Kt](
        t.multiple ? i ? new Set(o) : o : o[0]
      ), t._assigning = !0, It(() => {
        t._assigning = !1;
      });
    }), t[Kt] = Ms(n);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(t, { value: e }) {
    wr(t, e);
  },
  beforeUpdate(t, e, s) {
    t[Kt] = Ms(s);
  },
  updated(t, { value: e }) {
    t._assigning || wr(t, e);
  }
};
function wr(t, e) {
  const s = t.multiple, n = z(e);
  if (s && !n && !Is(e)) {
    Nt.NODE_ENV !== "production" && Rt(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let i = 0, o = t.options.length; i < o; i++) {
    const r = t.options[i], l = cn(r);
    if (s)
      if (n) {
        const a = typeof l;
        a === "string" || a === "number" ? r.selected = e.some((u) => String(u) === String(l)) : r.selected = eo(e, l) > -1;
      } else
        r.selected = e.has(l);
    else if (Rs(cn(r), e)) {
      t.selectedIndex !== i && (t.selectedIndex = i);
      return;
    }
  }
  !s && t.selectedIndex !== -1 && (t.selectedIndex = -1);
}
function cn(t) {
  return "_value" in t ? t._value : t.value;
}
function ua(t, e) {
  const s = e ? "_trueValue" : "_falseValue";
  return s in t ? t[s] : e;
}
const xd = ["ctrl", "shift", "alt", "meta"], Sd = {
  stop: (t) => t.stopPropagation(),
  prevent: (t) => t.preventDefault(),
  self: (t) => t.target !== t.currentTarget,
  ctrl: (t) => !t.ctrlKey,
  shift: (t) => !t.shiftKey,
  alt: (t) => !t.altKey,
  meta: (t) => !t.metaKey,
  left: (t) => "button" in t && t.button !== 0,
  middle: (t) => "button" in t && t.button !== 1,
  right: (t) => "button" in t && t.button !== 2,
  exact: (t, e) => xd.some((s) => t[`${s}Key`] && !e.includes(s))
}, wd = (t, e) => {
  if (!t) return t;
  const s = t._withMods || (t._withMods = {}), n = e.join(".");
  return s[n] || (s[n] = ((i, ...o) => {
    for (let r = 0; r < e.length; r++) {
      const l = Sd[e[r]];
      if (l && l(i, e)) return;
    }
    return t(i, ...o);
  }));
}, Cd = /* @__PURE__ */ Me({ patchProp: _d }, td);
let Cr;
function Dd() {
  return Cr || (Cr = Au(Cd));
}
const Od = ((...t) => {
  const e = Dd().createApp(...t);
  Nt.NODE_ENV !== "production" && (Ad(e), Md(e));
  const { mount: s } = e;
  return e.mount = (n) => {
    const i = Vd(n);
    if (!i) return;
    const o = e._component;
    !ee(o) && !o.render && !o.template && (o.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
    const r = s(i, !1, $d(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), r;
  }, e;
});
function $d(t) {
  if (t instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && t instanceof MathMLElement)
    return "mathml";
}
function Ad(t) {
  Object.defineProperty(t.config, "isNativeTag", {
    value: (e) => Aa(e) || Ma(e) || Va(e),
    writable: !1
  });
}
function Md(t) {
  {
    const e = t.config.isCustomElement;
    Object.defineProperty(t.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        Rt(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const s = t.config.compilerOptions, n = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(t.config, "compilerOptions", {
      get() {
        return Rt(n), s;
      },
      set() {
        Rt(n);
      }
    });
  }
}
function Vd(t) {
  if (Ve(t)) {
    const e = document.querySelector(t);
    return Nt.NODE_ENV !== "production" && !e && Rt(
      `Failed to mount app: mount target selector "${t}" returned null.`
    ), e;
  }
  return Nt.NODE_ENV !== "production" && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && Rt(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), t;
}
var Id = {};
function Rd() {
  Xu();
}
Id.NODE_ENV !== "production" && Rd();
const De = (t, e) => {
  const s = t.__vccOpts || t;
  for (const [n, i] of e)
    s[n] = i;
  return s;
}, Ld = {}, kd = { class: "card st-card-unified" }, Pd = { style: { display: "flex", "align-items": "center", "justify-content": "space-between" } };
function Bd(t, e) {
  return S(), k("div", kd, [
    f("div", Pd, [
      mt(t.$slots, "left", {}, void 0, !0),
      mt(t.$slots, "right", {}, void 0, !0)
    ])
  ]);
}
const Ws = /* @__PURE__ */ De(Ld, [["render", Bd], ["__scopeId", "data-v-5b66fbc1"]]), Fd = { class: "st-toggle-switch" }, Ud = ["checked"], jd = /* @__PURE__ */ Te({
  __name: "ToggleSwitch",
  props: {
    checked: { type: Boolean }
  },
  emits: ["change"],
  setup(t) {
    return (e, s) => (S(), k("label", Fd, [
      f("input", {
        type: "checkbox",
        checked: t.checked,
        onChange: s[0] || (s[0] = (n) => e.$emit("change", n.target.checked))
      }, null, 40, Ud),
      s[1] || (s[1] = f("span", { class: "st-toggle-slider" }, null, -1))
    ]));
  }
}), Di = /* @__PURE__ */ De(jd, [["__scopeId", "data-v-f73e4a93"]]), qd = { class: "button-content" }, Hd = /* @__PURE__ */ Te({
  __name: "Button",
  emits: ["click"],
  setup(t) {
    return (e, s) => (S(), k("button", {
      class: "menu_button button-wrapper",
      onClick: s[0] || (s[0] = (n) => e.$emit("click"))
    }, [
      f("span", qd, [
        mt(e.$slots, "default", {}, void 0, !0)
      ])
    ]));
  }
}), ae = /* @__PURE__ */ De(Hd, [["__scopeId", "data-v-8b9ccff3"]]), Wd = {
  key: 0,
  class: "popup-modal-header"
}, Kd = { class: "popup-modal-title" }, zd = { class: "popup-modal-body" }, Gd = {
  key: 1,
  class: "popup-modal-footer"
}, Yd = /* @__PURE__ */ Te({
  __name: "PopupModal",
  props: {
    visible: { type: Boolean },
    title: {},
    closable: { type: Boolean, default: !0 },
    maskClosable: { type: Boolean, default: !0 },
    height: {},
    width: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = te(() => {
      const l = {};
      return s.height && (l.height = s.height, l["max-height"] = s.height), s.width && (l.width = s.width, l["max-width"] = s.width), l;
    }), i = e, o = () => {
      i("close");
    }, r = () => {
      s.maskClosable && o();
    };
    return (l, a) => (S(), Le(Nl, { to: "body" }, [
      w(bo, { name: "modal" }, {
        default: P(() => [
          t.visible ? (S(), k("div", {
            key: 0,
            class: "popup-modal-overlay",
            onClick: wd(r, ["self"])
          }, [
            f("div", {
              class: "popup-modal",
              style: Ke(n.value)
            }, [
              t.title || t.closable || l.$slots.titlePrefix ? (S(), k("div", Wd, [
                f("div", Kd, [
                  mt(l.$slots, "titlePrefix", {}, void 0, !0),
                  f("span", null, de(t.title), 1)
                ]),
                t.closable ? (S(), k("div", {
                  key: 0,
                  class: "popup-modal-close",
                  onClick: o
                }, [...a[0] || (a[0] = [
                  f("i", { class: "fa-solid fa-xmark" }, null, -1)
                ])])) : ne("", !0)
              ])) : ne("", !0),
              f("div", zd, [
                mt(l.$slots, "default", {}, void 0, !0)
              ]),
              l.$slots.footer ? (S(), k("div", Gd, [
                mt(l.$slots, "footer", {}, void 0, !0)
              ])) : ne("", !0)
            ], 4)
          ])) : ne("", !0)
        ]),
        _: 3
      })
    ]));
  }
}), Ge = /* @__PURE__ */ De(Yd, [["__scopeId", "data-v-546209e7"]]), Qd = { class: "drawer-header" }, Jd = { class: "header-actions" }, Xd = { class: "drawer-body" }, Zd = {
  key: 0,
  class: "empty-state"
}, ef = {
  key: 1,
  class: "table-list"
}, tf = ["onClick"], sf = { class: "table-item-main" }, nf = { class: "table-name" }, of = {
  key: 0,
  class: "table-comment"
}, rf = /* @__PURE__ */ Te({
  __name: "TableListDrawer",
  props: {
    tables: {},
    selectedTable: {},
    isDrawer: { type: Boolean, default: !0 },
    showSyncButtons: { type: Boolean, default: !1 }
  },
  emits: ["select", "create", "closeDrawer", "sync", "push"],
  setup(t, { emit: e }) {
    const s = e, n = /* @__PURE__ */ q(window.innerWidth), i = () => {
      n.value = window.innerWidth;
    };
    ot(() => {
      window.addEventListener("resize", i);
    }), bn(() => {
      window.removeEventListener("resize", i);
    });
    const o = () => n.value <= 768, r = (c) => {
      s("select", c), o() && s("closeDrawer");
    }, l = () => {
      s("create");
    }, a = () => {
      s("sync");
    }, u = () => {
      s("push");
    };
    return (c, d) => (S(), k("div", {
      class: Ie(["table-list-drawer", { "is-drawer": t.isDrawer }])
    }, [
      f("div", Qd, [
        d[3] || (d[3] = f("span", { class: "drawer-title" }, "", -1)),
        f("div", Jd, [
          t.showSyncButtons ? (S(), k("button", {
            key: 0,
            class: "sync-btn",
            title: "",
            onClick: a
          }, [...d[0] || (d[0] = [
            f("i", { class: "fa-solid fa-rotate" }, null, -1)
          ])])) : ne("", !0),
          t.showSyncButtons ? (S(), k("button", {
            key: 1,
            class: "push-btn",
            title: "",
            onClick: u
          }, [...d[1] || (d[1] = [
            f("i", { class: "fa-solid fa-share-from-square" }, null, -1)
          ])])) : ne("", !0),
          f("button", {
            class: "create-table-btn",
            title: "",
            onClick: l
          }, [...d[2] || (d[2] = [
            f("i", { class: "fa-solid fa-plus" }, null, -1)
          ])])
        ])
      ]),
      f("div", Xd, [
        t.tables.length === 0 ? (S(), k("div", Zd, [
          d[5] || (d[5] = f("i", { class: "fa-solid fa-table" }, null, -1)),
          d[6] || (d[6] = f("span", null, "", -1)),
          f("button", {
            class: "empty-create-btn",
            onClick: l
          }, [...d[4] || (d[4] = [
            f("i", { class: "fa-solid fa-plus" }, null, -1),
            se("  ", -1)
          ])])
        ])) : (S(), k("div", ef, [
          (S(!0), k(Ae, null, Wt(t.tables, (m) => (S(), k("div", {
            key: m.tableName,
            class: Ie(["table-item", { active: t.selectedTable === m.tableName }]),
            onClick: (h) => r(m.tableName)
          }, [
            f("div", sf, [
              d[7] || (d[7] = f("i", { class: "fa-solid fa-table table-icon" }, null, -1)),
              f("span", nf, de(m.tableName), 1)
            ]),
            m.comment ? (S(), k("div", of, de(m.comment), 1)) : ne("", !0)
          ], 10, tf))), 128))
        ]))
      ])
    ], 2));
  }
}), lf = /* @__PURE__ */ De(rf, [["__scopeId", "data-v-85bfbdca"]]), af = { class: "table-drawer-layout" }, cf = { class: "layout-content" }, uf = {
  key: 0,
  class: "layout-drawer"
}, df = { class: "layout-main" }, ff = /* @__PURE__ */ Te({
  __name: "TableDrawerLayout",
  props: {
    drawerExpanded: { type: Boolean },
    tables: {},
    selectedTable: {},
    showSyncButtons: { type: Boolean, default: !1 }
  },
  emits: ["update:drawerExpanded", "selectTable", "createTable", "sync", "push"],
  setup(t, { emit: e }) {
    const s = e, n = (a) => {
      s("selectTable", a);
    }, i = () => {
      s("createTable");
    }, o = () => {
      s("update:drawerExpanded", !1);
    }, r = () => {
      s("sync");
    }, l = () => {
      s("push");
    };
    return (a, u) => (S(), k("div", af, [
      f("div", cf, [
        w(bo, { name: "drawer-slide" }, {
          default: P(() => [
            t.drawerExpanded ? (S(), k("div", uf, [
              w(lf, {
                tables: t.tables,
                "selected-table": t.selectedTable,
                "show-sync-buttons": t.showSyncButtons,
                onSelect: n,
                onCreate: i,
                onCloseDrawer: o,
                onSync: r,
                onPush: l
              }, null, 8, ["tables", "selected-table", "show-sync-buttons"])
            ])) : ne("", !0)
          ]),
          _: 1
        }),
        f("div", df, [
          mt(a.$slots, "default", {}, void 0, !0)
        ])
      ])
    ]));
  }
}), vo = /* @__PURE__ */ De(ff, [["__scopeId", "data-v-3e0df31e"]]), pf = { class: "tab-container" }, hf = { class: "tab-header" }, mf = ["onClick"], bf = { class: "tab-body" }, vf = /* @__PURE__ */ Te({
  __name: "TabContainer",
  props: {
    tabs: {},
    activeTab: {}
  },
  emits: ["update:activeTab"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(window.innerWidth), o = () => {
      i.value = window.innerWidth;
    };
    ot(() => {
      window.addEventListener("resize", o);
    }), bn(() => {
      window.removeEventListener("resize", o);
    });
    const r = te(() => {
      const a = i.value <= 768;
      return s.tabs.filter((u) => !(u.mobileOnly && !a || u.desktopOnly && a));
    }), l = (a) => {
      n("update:activeTab", a);
    };
    return (a, u) => (S(), k("div", pf, [
      f("div", hf, [
        (S(!0), k(Ae, null, Wt(r.value, (c) => (S(), k("div", {
          key: c.key,
          class: Ie(["tab-item", { active: t.activeTab === c.key }]),
          onClick: (d) => l(c.key)
        }, [
          c.icon ? (S(), k("i", {
            key: 0,
            class: Ie(c.icon)
          }, null, 2)) : ne("", !0),
          f("span", null, de(c.label), 1)
        ], 10, mf))), 128))
      ]),
      f("div", bf, [
        (S(!0), k(Ae, null, Wt(t.tabs, (c) => (S(), k(Ae, {
          key: c.key
        }, [
          t.activeTab === c.key ? mt(a.$slots, c.key, { key: 0 }, void 0, !0) : ne("", !0)
        ], 64))), 128))
      ])
    ]));
  }
}), go = /* @__PURE__ */ De(vf, [["__scopeId", "data-v-9d94b988"]]), gf = /* @__PURE__ */ Te({
  __name: "DrawerToggle",
  props: {
    expanded: { type: Boolean },
    fab: { type: Boolean, default: !1 }
  },
  emits: ["toggle"],
  setup(t, { emit: e }) {
    const s = e, n = () => {
      s("toggle");
    };
    return (i, o) => (S(), k("button", {
      class: Ie(["drawer-toggle", { fab: t.fab }]),
      onClick: n
    }, [...o[0] || (o[0] = [
      f("div", { class: "hamburger-icon" }, [
        f("span", { class: "line" }),
        f("span", { class: "line" }),
        f("span", { class: "line" })
      ], -1)
    ])], 2));
  }
}), Eo = /* @__PURE__ */ De(gf, [["__scopeId", "data-v-04d4da93"]]), Ef = /* @__PURE__ */ Te({
  __name: "ToastNotification",
  props: {
    visible: { type: Boolean },
    message: {},
    type: {},
    icon: {}
  },
  setup(t) {
    return (e, s) => (S(), Le(bo, { name: "toast" }, {
      default: P(() => [
        t.visible ? (S(), k("div", {
          key: 0,
          class: Ie(["toast-notification", t.type])
        }, [
          f("i", {
            class: Ie(t.icon)
          }, null, 2),
          f("span", null, de(t.message), 1)
        ], 2)) : ne("", !0)
      ]),
      _: 1
    }));
  }
}), da = /* @__PURE__ */ De(Ef, [["__scopeId", "data-v-76c92735"]]), yf = /* @__PURE__ */ Te({
  __name: "EmptyState",
  props: {
    icon: {},
    text: {},
    iconSize: { default: 48 },
    variant: { default: "default" }
  },
  setup(t) {
    return (e, s) => (S(), k("div", {
      class: Ie([t.variant, "empty-state"])
    }, [
      f("i", {
        class: Ie(t.icon),
        style: Ke({ fontSize: `${t.iconSize}px` })
      }, null, 6),
      f("span", null, de(t.text), 1)
    ], 2));
  }
}), Jn = /* @__PURE__ */ De(yf, [["__scopeId", "data-v-5ddb0dfd"]]);
function fa() {
  const t = /* @__PURE__ */ os({
    visible: !1,
    message: "",
    type: "success",
    icon: "fa-solid fa-check-circle"
  });
  let e = null;
  return {
    toast: t,
    showToast: (n, i = "success") => {
      e && clearTimeout(e), t.message = n, t.type = i, t.icon = i === "success" ? "fa-solid fa-check-circle" : "fa-solid fa-circle-xmark", t.visible = !0, e = setTimeout(() => {
        t.visible = !1;
      }, 3e3);
    }
  };
}
function _f() {
  return {
    showCreateTableModal: /* @__PURE__ */ q(!1),
    showEditTableNameModal: /* @__PURE__ */ q(!1),
    showEditTableCommentModal: /* @__PURE__ */ q(!1),
    showDropTableModal: /* @__PURE__ */ q(!1),
    showAddColumnModal: /* @__PURE__ */ q(!1),
    showEditColumnNameModal: /* @__PURE__ */ q(!1),
    showEditColumnCommentModal: /* @__PURE__ */ q(!1),
    showDropColumnModal: /* @__PURE__ */ q(!1),
    showDDLModal: /* @__PURE__ */ q(!1),
    editingColumn: /* @__PURE__ */ q(null),
    exportedDDL: /* @__PURE__ */ q("")
  };
}
const Tf = ["value", "placeholder", "disabled", "readonly", "maxlength"], Nf = {
  key: 0,
  class: "textarea-footer"
}, xf = /* @__PURE__ */ Te({
  __name: "AutoResizeTextarea",
  props: {
    modelValue: { default: "" },
    placeholder: { default: "..." },
    minRows: { default: 1 },
    maxRows: { default: 15 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    maxlength: { default: void 0 },
    showCount: { type: Boolean, default: !1 },
    submitOnEnter: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "focus", "blur", "submit"],
  setup(t, { expose: e, emit: s }) {
    const n = t, i = s, o = /* @__PURE__ */ q(null), r = /* @__PURE__ */ q(null), l = /* @__PURE__ */ q(!1), a = /* @__PURE__ */ q(24), u = te(() => (n.modelValue || "").length);
    function c() {
      const T = o.value, _ = r.value;
      if (!T || !_) return;
      const O = window.getComputedStyle(T), V = parseFloat(O.lineHeight) || 24;
      a.value = V;
      const K = parseFloat(O.paddingTop) || 0, he = parseFloat(O.paddingBottom) || 0, me = parseFloat(O.borderTopWidth) || 0, H = parseFloat(O.borderBottomWidth) || 0;
      _.style.width = `${T.clientWidth}px`, _.style.fontSize = O.fontSize, _.style.fontFamily = O.fontFamily, _.style.fontWeight = O.fontWeight, _.style.letterSpacing = O.letterSpacing, _.style.wordSpacing = O.wordSpacing, _.style.lineHeight = O.lineHeight, _.style.paddingTop = O.paddingTop, _.style.paddingBottom = O.paddingBottom, _.style.paddingLeft = O.paddingLeft, _.style.paddingRight = O.paddingRight, _.style.wordBreak = O.wordBreak, _.style.whiteSpace = "pre-wrap", _.style.overflowWrap = "break-word", _.style.boxSizing = "border-box";
      const le = n.modelValue || "";
      _.textContent = le + `
`;
      const be = _.scrollHeight, C = V * n.minRows + K + he, W = V * n.maxRows + K + he, re = Math.min(Math.max(be, C), W);
      T.style.height = `${re + me + H}px`, T.style.overflowY = be > W ? "auto" : "hidden";
    }
    function d(T) {
      const _ = T.target;
      i("update:modelValue", _.value), c(), It(c);
    }
    function m(T) {
      l.value = !0, i("focus", T);
    }
    function h(T) {
      l.value = !1, i("blur", T);
    }
    function E(T) {
      n.submitOnEnter && T.key === "Enter" && !T.shiftKey && (T.preventDefault(), i("submit", n.modelValue || ""));
    }
    function y() {
      o.value?.focus();
    }
    function N() {
      o.value?.blur();
    }
    e({ focus: y, blur: N, adjustHeight: c }), et(() => n.modelValue, () => {
      It(c);
    }), et([() => n.minRows, () => n.maxRows], () => {
      It(c);
    });
    let b = null;
    return ot(() => {
      c(), window.ResizeObserver && o.value && (b = new ResizeObserver(() => c()), b.observe(o.value.parentElement));
    }), Pt(() => {
      b?.disconnect();
    }), (T, _) => (S(), k("div", {
      class: Ie(["auto-resize-wrapper", { focused: l.value, disabled: t.disabled }])
    }, [
      f("div", {
        ref_key: "mirrorRef",
        ref: r,
        class: "textarea-mirror",
        "aria-hidden": "true"
      }, null, 512),
      f("textarea", {
        ref_key: "textareaRef",
        ref: o,
        class: "auto-resize-textarea",
        value: t.modelValue,
        placeholder: t.placeholder,
        disabled: t.disabled,
        readonly: t.readonly,
        maxlength: t.maxlength,
        rows: 1,
        onInput: d,
        onFocus: m,
        onBlur: h,
        onKeydown: E
      }, null, 40, Tf),
      t.showCount && t.maxlength ? (S(), k("div", Nf, [
        f("span", {
          class: Ie(["char-count", { warning: u.value > t.maxlength * 0.9 }])
        }, de(u.value) + " / " + de(t.maxlength), 3)
      ])) : ne("", !0)
    ], 2));
  }
}), Vs = /* @__PURE__ */ De(xf, [["__scopeId", "data-v-fd129974"]]);
var Lt = /* @__PURE__ */ ((t) => (t.NUMBER = "NUMBER", t.STRING = "STRING", t))(Lt || {});
function fi() {
  const t = /* @__PURE__ */ q([]), e = te(() => t.value.length > 0), s = (h) => t.value.find((E) => E.field === h)?.message, n = () => {
    t.value = [];
  }, i = (h, E) => {
    t.value.push({ field: h, message: E });
  }, o = (h, E) => {
    const y = h.trim();
    return y ? y.length > 64 ? (i("tableName", "64"), !1) : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(y) ? E?.checkTableNameExists && E.checkTableNameExists(y) ? E.excludeName && y === E.excludeName ? !0 : (i("tableName", ` "${y}" `), !1) : !0 : (i("tableName", ""), !1) : (i("tableName", ""), !1);
  }, r = (h, E) => {
    const y = h.trim();
    return y ? y.length > 64 ? (i("columnName", "64"), !1) : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(y) ? E?.checkColumnNameExists && E.checkColumnNameExists(y) ? E.excludeName && y === E.excludeName ? !0 : (i("columnName", ` "${y}" `), !1) : !0 : (i("columnName", ""), !1) : (i("columnName", ""), !1);
  }, l = (h) => {
    const E = h.map((b) => b.name.trim()).filter((b) => b), y = [], N = /* @__PURE__ */ new Set();
    for (const b of E)
      N.has(b) && (y.includes(b) || y.push(b)), N.add(b);
    return y.length > 0 ? (i("columns", `: ${y.join(", ")}`), !1) : !0;
  };
  return {
    errors: t,
    hasErrors: e,
    getFieldError: s,
    clearErrors: n,
    addError: i,
    validateTableName: o,
    validateColumnName: r,
    validateDuplicateColumnNames: l,
    validateCreateTableForm: (h, E, y) => {
      n();
      const N = y.map((b) => b.tableName);
      return o(h, {
        checkTableNameExists: (b) => N.includes(b)
      }), E.length === 0 && i("columns", ""), E.forEach((b, T) => {
        const _ = b.name.trim();
        _ ? /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(_) || i(`column_${T}`, ` "${_}" `) : i(`column_${T}`, ` ${T + 1} `);
      }), l(E), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateAddColumnForm: (h, E) => {
      n();
      const y = E.map((N) => N.name);
      return r(h, {
        checkColumnNameExists: (N) => y.includes(N)
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateEditTableNameForm: (h, E, y) => {
      n();
      const N = y.map((b) => b.tableName);
      return o(h, {
        checkTableNameExists: (b) => N.includes(b),
        excludeName: E
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateEditColumnNameForm: (h, E, y) => {
      n();
      const N = y.map((b) => b.name);
      return r(h, {
        checkColumnNameExists: (b) => N.includes(b),
        excludeName: E
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateComment: (h, E = 500) => h && h.length > E ? (i("comment", ` ${E} `), !1) : !0
  };
}
const Sf = { class: "form-container" }, wf = { class: "form-section" }, Cf = { class: "form-item" }, Df = {
  key: 0,
  class: "field-error"
}, Of = { class: "form-item" }, $f = { class: "form-section columns-section" }, Af = { class: "section-header" }, Mf = { class: "column-count" }, Vf = {
  key: 0,
  class: "field-error section-error"
}, If = { class: "columns-list" }, Rf = { class: "column-card-header" }, Lf = { class: "column-number" }, kf = ["onClick"], Pf = { class: "column-card-body" }, Bf = { class: "form-row" }, Ff = { class: "form-col form-col-name" }, Uf = ["onUpdate:modelValue"], jf = { class: "form-col form-col-type" }, qf = ["onUpdate:modelValue"], Hf = ["value"], Wf = ["value"], Kf = {
  key: 0,
  class: "field-error"
}, zf = { class: "form-row" }, Gf = { class: "form-col form-col-default" }, Yf = ["onUpdate:modelValue"], Qf = { class: "form-col form-col-comment" }, Jf = { class: "checkbox-label" }, Xf = ["onUpdate:modelValue"], Zf = { class: "form-actions" }, ep = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, tp = "auto", sp = /* @__PURE__ */ Te({
  __name: "CreateTableForm",
  props: {
    existingTables: { default: () => [] }
  },
  emits: ["create", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateCreateTableForm: o, clearErrors: r } = fi(), l = /* @__PURE__ */ q(!1), a = /* @__PURE__ */ q(!1), u = () => {
      a.value = window.innerWidth <= 768;
    };
    ot(() => {
      u(), window.addEventListener("resize", u);
    }), Pt(() => {
      window.removeEventListener("resize", u);
    });
    const c = te(() => a.value ? "100%" : "50vw"), d = te(() => {
      const T = {};
      return T["--form-modal-width"] = a.value ? "100%" : "50vw", T;
    });
    let m = 0;
    const h = /* @__PURE__ */ os({
      tableName: "",
      comment: "",
      columns: []
    }), E = () => {
      h.columns.push({
        id: ++m,
        name: "",
        type: Lt.STRING,
        primitiveKey: !1,
        comment: ""
      });
    }, y = (T) => {
      h.columns.splice(T, 1);
    }, N = () => {
      if (r(), l.value = !0, !o(
        h.tableName,
        h.columns,
        s.existingTables
      ).valid) {
        l.value = !1;
        return;
      }
      const _ = h.columns.map((O) => ({
        name: O.name.trim(),
        type: O.type,
        primitiveKey: O.primitiveKey,
        defaultValue: O.defaultValue || void 0,
        comment: O.comment || void 0
      }));
      n("create", {
        tableName: h.tableName.trim(),
        columns: _,
        comment: h.comment.trim() || void 0
      }), l.value = !1;
    }, b = () => {
      r(), n("cancel");
    };
    return h.columns.length === 0 && E(), (T, _) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(d.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: c.value,
        height: tp,
        closable: !1,
        onClose: b
      }, {
        default: P(() => [
          f("div", Sf, [
            f("div", wf, [
              f("div", Cf, [
                _[3] || (_[3] = f("label", { class: "form-label" }, [
                  se("  "),
                  f("span", { class: "required" }, "*")
                ], -1)),
                Xe(f("input", {
                  "onUpdate:modelValue": _[0] || (_[0] = (O) => h.tableName = O),
                  class: Ie(["form-input", { "has-error": Q(i)("tableName") }]),
                  type: "text",
                  placeholder: "user_info"
                }, null, 2), [
                  [zt, h.tableName]
                ]),
                Q(i)("tableName") ? (S(), k("div", Df, [
                  _[2] || (_[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                  se(" " + de(Q(i)("tableName")), 1)
                ])) : ne("", !0),
                _[4] || (_[4] = f("div", { class: "field-hint" }, "", -1))
              ]),
              f("div", Of, [
                _[5] || (_[5] = f("label", { class: "form-label" }, "", -1)),
                w(Vs, {
                  modelValue: h.comment,
                  "onUpdate:modelValue": _[1] || (_[1] = (O) => h.comment = O),
                  placeholder: "",
                  "min-rows": 2,
                  "max-rows": 6
                }, null, 8, ["modelValue"]),
                _[6] || (_[6] = f("div", { class: "field-hint" }, "", -1))
              ])
            ]),
            f("div", $f, [
              f("div", Af, [
                _[7] || (_[7] = f("label", { class: "form-label" }, [
                  se("  "),
                  f("span", { class: "required" }, "*")
                ], -1)),
                f("span", Mf, de(h.columns.length) + " ", 1)
              ]),
              Q(i)("columns") ? (S(), k("div", Vf, [
                _[8] || (_[8] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                se(" " + de(Q(i)("columns")), 1)
              ])) : ne("", !0),
              f("div", If, [
                (S(!0), k(Ae, null, Wt(h.columns, (O, V) => (S(), k("div", {
                  key: O.id,
                  class: Ie(["column-card", { "has-error": Q(i)(`column_${V}`) }])
                }, [
                  f("div", Rf, [
                    f("span", Lf, "#" + de(V + 1), 1),
                    f("button", {
                      class: "remove-btn",
                      onClick: (K) => y(V),
                      title: ""
                    }, [..._[9] || (_[9] = [
                      f("i", { class: "fa-solid fa-trash" }, null, -1)
                    ])], 8, kf)
                  ]),
                  f("div", Pf, [
                    f("div", Bf, [
                      f("div", Ff, [
                        _[10] || (_[10] = f("label", { class: "field-label" }, [
                          se(" "),
                          f("span", { class: "required" }, "*")
                        ], -1)),
                        Xe(f("input", {
                          "onUpdate:modelValue": (K) => O.name = K,
                          class: "form-input",
                          type: "text",
                          placeholder: ""
                        }, null, 8, Uf), [
                          [zt, O.name]
                        ])
                      ]),
                      f("div", jf, [
                        _[11] || (_[11] = f("label", { class: "field-label" }, "", -1)),
                        Xe(f("select", {
                          "onUpdate:modelValue": (K) => O.type = K,
                          class: "form-select"
                        }, [
                          f("option", {
                            value: Q(Lt).STRING
                          }, "STRING", 8, Hf),
                          f("option", {
                            value: Q(Lt).NUMBER
                          }, "NUMBER", 8, Wf)
                        ], 8, qf), [
                          [ca, O.type]
                        ])
                      ])
                    ]),
                    Q(i)(`column_${V}`) ? (S(), k("div", Kf, [
                      _[12] || (_[12] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                      se(" " + de(Q(i)(`column_${V}`)), 1)
                    ])) : ne("", !0),
                    f("div", zf, [
                      f("div", Gf, [
                        _[13] || (_[13] = f("label", { class: "field-label" }, "", -1)),
                        Xe(f("input", {
                          "onUpdate:modelValue": (K) => O.defaultValue = K,
                          class: "form-input",
                          type: "text",
                          placeholder: ""
                        }, null, 8, Yf), [
                          [zt, O.defaultValue]
                        ])
                      ]),
                      f("div", Qf, [
                        _[14] || (_[14] = f("label", { class: "field-label" }, "", -1)),
                        w(Vs, {
                          modelValue: O.comment,
                          "onUpdate:modelValue": (K) => O.comment = K,
                          placeholder: "",
                          "min-rows": 1,
                          "max-rows": 4
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ])
                    ]),
                    f("label", Jf, [
                      Xe(f("input", {
                        "onUpdate:modelValue": (K) => O.primitiveKey = K,
                        type: "checkbox"
                      }, null, 8, Xf), [
                        [aa, O.primitiveKey]
                      ]),
                      _[15] || (_[15] = f("span", null, "", -1))
                    ])
                  ])
                ], 2))), 128)),
                f("button", {
                  class: "add-column-btn",
                  onClick: E
                }, [..._[16] || (_[16] = [
                  f("i", { class: "fa-solid fa-plus" }, null, -1),
                  f("span", null, "", -1)
                ])])
              ])
            ]),
            f("div", Zf, [
              w(ae, { onClick: b }, {
                default: P(() => [..._[17] || (_[17] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: l.value,
                onClick: N
              }, {
                default: P(() => [
                  l.value ? (S(), k("i", ep)) : ne("", !0),
                  _[18] || (_[18] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), np = /* @__PURE__ */ De(sp, [["__scopeId", "data-v-08eccbfb"]]), ip = { class: "form-container" }, op = { class: "form-item" }, rp = ["value"], lp = { class: "form-item" }, ap = {
  key: 0,
  class: "field-error"
}, cp = { class: "form-actions" }, up = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, dp = "auto", fp = /* @__PURE__ */ Te({
  __name: "EditTableNameForm",
  props: {
    tableName: {},
    existingTables: { default: () => [] }
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateEditTableNameForm: o, clearErrors: r } = fi(), l = /* @__PURE__ */ q(!1), a = /* @__PURE__ */ q(s.tableName), u = /* @__PURE__ */ q(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    ot(() => {
      c(), window.addEventListener("resize", c);
    }), Pt(() => {
      window.removeEventListener("resize", c);
    });
    const d = te(() => u.value ? "100%" : "50vw"), m = te(() => {
      const N = {};
      return N["--form-modal-width"] = u.value ? "100%" : "50vw", N;
    }), h = te(() => a.value.trim() !== s.tableName);
    et(() => s.tableName, (N) => {
      a.value = N, r();
    });
    const E = () => {
      if (r(), l.value = !0, !o(
        a.value,
        s.tableName,
        s.existingTables
      ).valid) {
        l.value = !1;
        return;
      }
      n("save", a.value.trim()), l.value = !1;
    }, y = () => {
      a.value = s.tableName, r(), n("cancel");
    };
    return (N, b) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: dp,
        closable: !1,
        onClose: y
      }, {
        default: P(() => [
          f("div", ip, [
            f("div", op, [
              b[1] || (b[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.tableName,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, rp)
            ]),
            f("div", lp, [
              b[3] || (b[3] = f("label", { class: "form-label" }, [
                se("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              Xe(f("input", {
                "onUpdate:modelValue": b[0] || (b[0] = (T) => a.value = T),
                class: Ie(["form-input", { "has-error": Q(i)("tableName") }]),
                type: "text",
                placeholder: ""
              }, null, 2), [
                [zt, a.value]
              ]),
              Q(i)("tableName") ? (S(), k("div", ap, [
                b[2] || (b[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                se(" " + de(Q(i)("tableName")), 1)
              ])) : ne("", !0),
              b[4] || (b[4] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", cp, [
              w(ae, { onClick: y }, {
                default: P(() => [...b[5] || (b[5] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: l.value || !h.value,
                onClick: E
              }, {
                default: P(() => [
                  l.value ? (S(), k("i", up)) : ne("", !0),
                  b[6] || (b[6] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), pp = /* @__PURE__ */ De(fp, [["__scopeId", "data-v-58e374f4"]]), hp = { class: "form-container" }, mp = { class: "form-item" }, bp = { class: "form-actions" }, vp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, gp = "auto", Ep = /* @__PURE__ */ Te({
  __name: "EditTableCommentForm",
  props: {
    comment: {}
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(s.comment || ""), o = /* @__PURE__ */ q(!1), r = /* @__PURE__ */ q(!1), l = () => {
      r.value = window.innerWidth <= 768;
    };
    ot(() => {
      l(), window.addEventListener("resize", l);
    }), Pt(() => {
      window.removeEventListener("resize", l);
    });
    const a = te(() => r.value ? "100%" : "50vw"), u = te(() => {
      const m = {};
      return m["--form-modal-width"] = r.value ? "100%" : "50vw", m;
    }), c = () => {
      o.value = !0, n("save", i.value), o.value = !1;
    }, d = () => {
      i.value = s.comment || "", n("cancel");
    };
    return (m, h) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(u.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: a.value,
        height: gp,
        closable: !1,
        onClose: d
      }, {
        default: P(() => [
          f("div", hp, [
            f("div", mp, [
              h[1] || (h[1] = f("label", { class: "form-label" }, "", -1)),
              w(Vs, {
                modelValue: i.value,
                "onUpdate:modelValue": h[0] || (h[0] = (E) => i.value = E),
                placeholder: "",
                maxlength: 500,
                "show-count": !0,
                "min-rows": 3,
                "max-rows": 10
              }, null, 8, ["modelValue"])
            ]),
            f("div", bp, [
              w(ae, { onClick: d }, {
                default: P(() => [...h[2] || (h[2] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: o.value,
                onClick: c
              }, {
                default: P(() => [
                  o.value ? (S(), k("i", vp)) : ne("", !0),
                  h[3] || (h[3] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), yp = /* @__PURE__ */ De(Ep, [["__scopeId", "data-v-03532044"]]), _p = { class: "confirm-container" }, Tp = { class: "confirm-content" }, Np = { class: "confirm-message" }, xp = { class: "form-actions" }, Sp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, wp = /* @__PURE__ */ Te({
  __name: "DropTableConfirm",
  props: {
    tableName: {},
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1), o = te(() => {
      const a = {};
      return s.modalWidth && (a["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (a["--confirm-modal-height"] = s.modalHeight), a;
    }), r = () => {
      i.value = !0, n("confirm");
    }, l = () => {
      n("cancel");
    };
    return (a, u) => (S(), k("div", {
      class: "drop-table-confirm-wrapper",
      style: Ke(o.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: l
      }, {
        default: P(() => [
          f("div", _p, [
            u[5] || (u[5] = f("div", { class: "confirm-icon-wrapper" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" })
            ], -1)),
            f("div", Tp, [
              f("div", Np, [
                u[0] || (u[0] = se("  ", -1)),
                f("strong", null, de(t.tableName), 1),
                u[1] || (u[1] = se("  ", -1))
              ]),
              u[2] || (u[2] = f("div", { class: "confirm-warning" }, [
                f("i", { class: "fa-solid fa-circle-info" }),
                f("span", null, "")
              ], -1))
            ]),
            f("div", xp, [
              w(ae, { onClick: l }, {
                default: P(() => [...u[3] || (u[3] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "danger",
                disabled: i.value,
                onClick: r
              }, {
                default: P(() => [
                  i.value ? (S(), k("i", Sp)) : ne("", !0),
                  u[4] || (u[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), Cp = /* @__PURE__ */ De(wp, [["__scopeId", "data-v-4629727b"]]), Dp = { class: "form-container" }, Op = { class: "form-item" }, $p = {
  key: 0,
  class: "field-error"
}, Ap = { class: "form-item" }, Mp = ["value"], Vp = ["value"], Ip = { class: "form-item" }, Rp = { class: "checkbox-label" }, Lp = { class: "form-item" }, kp = { class: "form-item" }, Pp = { class: "form-actions" }, Bp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Fp = "auto", Up = /* @__PURE__ */ Te({
  __name: "AddColumnForm",
  props: {
    existingColumns: { default: () => [] }
  },
  emits: ["create", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateAddColumnForm: o, clearErrors: r } = fi(), l = /* @__PURE__ */ q(!1), a = /* @__PURE__ */ os({
      name: "",
      type: Lt.STRING,
      primitiveKey: !1
    }), u = /* @__PURE__ */ q(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    ot(() => {
      c(), window.addEventListener("resize", c);
    }), Pt(() => {
      window.removeEventListener("resize", c);
    });
    const d = te(() => u.value ? "100%" : "50vw"), m = te(() => {
      const y = {};
      return y["--form-modal-width"] = u.value ? "100%" : "50vw", y;
    }), h = () => {
      if (r(), l.value = !0, !o(a.name, s.existingColumns).valid) {
        l.value = !1;
        return;
      }
      const N = {
        name: a.name.trim(),
        type: a.type,
        primitiveKey: a.primitiveKey,
        defaultValue: a.defaultValue || void 0,
        comment: a.comment || void 0
      };
      n("create", N), l.value = !1;
    }, E = () => {
      r(), n("cancel");
    };
    return (y, N) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: Fp,
        closable: !1,
        onClose: E
      }, {
        default: P(() => [
          f("div", Dp, [
            f("div", Op, [
              N[6] || (N[6] = f("label", { class: "form-label" }, [
                se("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              Xe(f("input", {
                "onUpdate:modelValue": N[0] || (N[0] = (b) => a.name = b),
                class: Ie(["form-input", { "has-error": Q(i)("columnName") }]),
                type: "text",
                placeholder: "username"
              }, null, 2), [
                [zt, a.name]
              ]),
              Q(i)("columnName") ? (S(), k("div", $p, [
                N[5] || (N[5] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                se(" " + de(Q(i)("columnName")), 1)
              ])) : ne("", !0),
              N[7] || (N[7] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Ap, [
              N[8] || (N[8] = f("label", { class: "form-label" }, "", -1)),
              Xe(f("select", {
                "onUpdate:modelValue": N[1] || (N[1] = (b) => a.type = b),
                class: "form-select"
              }, [
                f("option", {
                  value: Q(Lt).STRING
                }, "STRING", 8, Mp),
                f("option", {
                  value: Q(Lt).NUMBER
                }, "NUMBER", 8, Vp)
              ], 512), [
                [ca, a.type]
              ])
            ]),
            f("div", Ip, [
              f("label", Rp, [
                Xe(f("input", {
                  "onUpdate:modelValue": N[2] || (N[2] = (b) => a.primitiveKey = b),
                  type: "checkbox"
                }, null, 512), [
                  [aa, a.primitiveKey]
                ]),
                N[9] || (N[9] = f("span", null, "", -1))
              ])
            ]),
            f("div", Lp, [
              N[10] || (N[10] = f("label", { class: "form-label" }, "", -1)),
              Xe(f("input", {
                "onUpdate:modelValue": N[3] || (N[3] = (b) => a.defaultValue = b),
                class: "form-input",
                type: "text",
                placeholder: ""
              }, null, 512), [
                [zt, a.defaultValue]
              ]),
              N[11] || (N[11] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", kp, [
              N[12] || (N[12] = f("label", { class: "form-label" }, "", -1)),
              w(Vs, {
                modelValue: a.comment,
                "onUpdate:modelValue": N[4] || (N[4] = (b) => a.comment = b),
                placeholder: "",
                "min-rows": 1,
                "max-rows": 4
              }, null, 8, ["modelValue"])
            ]),
            f("div", Pp, [
              w(ae, { onClick: E }, {
                default: P(() => [...N[13] || (N[13] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: l.value,
                onClick: h
              }, {
                default: P(() => [
                  l.value ? (S(), k("i", Bp)) : ne("", !0),
                  N[14] || (N[14] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), jp = /* @__PURE__ */ De(Up, [["__scopeId", "data-v-019138f2"]]), qp = { class: "form-container" }, Hp = { class: "form-item" }, Wp = ["value"], Kp = { class: "form-item" }, zp = {
  key: 0,
  class: "field-error"
}, Gp = { class: "form-actions" }, Yp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Qp = "auto", Jp = /* @__PURE__ */ Te({
  __name: "EditColumnNameForm",
  props: {
    column: {},
    existingColumns: { default: () => [] }
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateEditColumnNameForm: o, clearErrors: r } = fi(), l = /* @__PURE__ */ q(!1), a = /* @__PURE__ */ q(s.column.name), u = /* @__PURE__ */ q(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    ot(() => {
      c(), window.addEventListener("resize", c);
    }), Pt(() => {
      window.removeEventListener("resize", c);
    });
    const d = te(() => u.value ? "100%" : "50vw"), m = te(() => {
      const N = {};
      return N["--form-modal-width"] = u.value ? "100%" : "50vw", N;
    }), h = te(() => a.value.trim() !== s.column.name);
    et(() => s.column, (N) => {
      a.value = N.name, r();
    }, { deep: !0 });
    const E = () => {
      if (r(), l.value = !0, !o(
        a.value,
        s.column.name,
        s.existingColumns
      ).valid) {
        l.value = !1;
        return;
      }
      n("save", a.value.trim()), l.value = !1;
    }, y = () => {
      a.value = s.column.name, r(), n("cancel");
    };
    return (N, b) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: Qp,
        closable: !1,
        onClose: y
      }, {
        default: P(() => [
          f("div", qp, [
            f("div", Hp, [
              b[1] || (b[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.column.name,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, Wp)
            ]),
            f("div", Kp, [
              b[3] || (b[3] = f("label", { class: "form-label" }, [
                se("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              Xe(f("input", {
                "onUpdate:modelValue": b[0] || (b[0] = (T) => a.value = T),
                class: Ie(["form-input", { "has-error": Q(i)("columnName") }]),
                type: "text",
                placeholder: ""
              }, null, 2), [
                [zt, a.value]
              ]),
              Q(i)("columnName") ? (S(), k("div", zp, [
                b[2] || (b[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                se(" " + de(Q(i)("columnName")), 1)
              ])) : ne("", !0),
              b[4] || (b[4] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Gp, [
              w(ae, { onClick: y }, {
                default: P(() => [...b[5] || (b[5] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: l.value || !h.value,
                onClick: E
              }, {
                default: P(() => [
                  l.value ? (S(), k("i", Yp)) : ne("", !0),
                  b[6] || (b[6] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Xp = /* @__PURE__ */ De(Jp, [["__scopeId", "data-v-36708f97"]]), Zp = { class: "form-container" }, eh = { class: "form-item" }, th = ["value"], sh = { class: "form-item" }, nh = { class: "form-actions" }, ih = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, oh = "auto", rh = /* @__PURE__ */ Te({
  __name: "EditColumnCommentForm",
  props: {
    column: {}
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(s.column.comment || ""), o = /* @__PURE__ */ q(!1), r = /* @__PURE__ */ q(!1), l = () => {
      r.value = window.innerWidth <= 768;
    };
    ot(() => {
      l(), window.addEventListener("resize", l);
    }), Pt(() => {
      window.removeEventListener("resize", l);
    });
    const a = te(() => r.value ? "100%" : "50vw"), u = te(() => {
      const m = {};
      return m["--form-modal-width"] = r.value ? "100%" : "50vw", m;
    }), c = () => {
      o.value = !0, n("save", i.value), o.value = !1;
    }, d = () => {
      i.value = s.column.comment || "", n("cancel");
    };
    return (m, h) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(u.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: a.value,
        height: oh,
        closable: !1,
        onClose: d
      }, {
        default: P(() => [
          f("div", Zp, [
            f("div", eh, [
              h[1] || (h[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.column.name,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, th)
            ]),
            f("div", sh, [
              h[2] || (h[2] = f("label", { class: "form-label" }, "", -1)),
              w(Vs, {
                modelValue: i.value,
                "onUpdate:modelValue": h[0] || (h[0] = (E) => i.value = E),
                placeholder: "",
                maxlength: 500,
                "show-count": !0,
                "min-rows": 3,
                "max-rows": 10
              }, null, 8, ["modelValue"])
            ]),
            f("div", nh, [
              w(ae, { onClick: d }, {
                default: P(() => [...h[3] || (h[3] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: o.value,
                onClick: c
              }, {
                default: P(() => [
                  o.value ? (S(), k("i", ih)) : ne("", !0),
                  h[4] || (h[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), lh = /* @__PURE__ */ De(rh, [["__scopeId", "data-v-1f79f493"]]), ah = { class: "confirm-container" }, ch = { class: "confirm-content" }, uh = { class: "confirm-message" }, dh = { class: "form-actions" }, fh = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, ph = /* @__PURE__ */ Te({
  __name: "DropColumnConfirm",
  props: {
    column: {},
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1), o = te(() => {
      const a = {};
      return s.modalWidth && (a["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (a["--confirm-modal-height"] = s.modalHeight), a;
    }), r = () => {
      i.value = !0, n("confirm");
    }, l = () => {
      n("cancel");
    };
    return (a, u) => (S(), k("div", {
      class: "drop-column-confirm-wrapper",
      style: Ke(o.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: l
      }, {
        default: P(() => [
          f("div", ah, [
            u[5] || (u[5] = f("div", { class: "confirm-icon-wrapper" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" })
            ], -1)),
            f("div", ch, [
              f("div", uh, [
                u[0] || (u[0] = se("  ", -1)),
                f("strong", null, de(t.column.name), 1),
                u[1] || (u[1] = se("  ", -1))
              ]),
              u[2] || (u[2] = f("div", { class: "confirm-warning" }, [
                f("i", { class: "fa-solid fa-circle-info" }),
                f("span", null, "")
              ], -1))
            ]),
            f("div", dh, [
              w(ae, { onClick: l }, {
                default: P(() => [...u[3] || (u[3] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "danger",
                disabled: i.value,
                onClick: r
              }, {
                default: P(() => [
                  i.value ? (S(), k("i", fh)) : ne("", !0),
                  u[4] || (u[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), hh = /* @__PURE__ */ De(ph, [["__scopeId", "data-v-7565defa"]]), mh = { class: "ddl-container" }, bh = { class: "ddl-header" }, vh = { class: "ddl-content" }, gh = { class: "ddl-code" }, Eh = { class: "form-actions" }, yh = /* @__PURE__ */ Te({
  __name: "DDLDisplay",
  props: {
    ddl: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1);
    let o = null;
    const r = async () => {
      try {
        await navigator.clipboard.writeText(s.ddl), i.value = !0, o && clearTimeout(o), o = setTimeout(() => {
          i.value = !1;
        }, 2e3);
      } catch (a) {
        console.error(":", a);
      }
    }, l = () => {
      n("close");
    };
    return (a, u) => (S(), k("div", mh, [
      f("div", bh, [
        u[0] || (u[0] = f("span", { class: "ddl-title" }, "DDL ", -1)),
        f("button", {
          class: "copy-btn",
          onClick: r
        }, [
          f("i", {
            class: Ie(i.value ? "fa-solid fa-check" : "fa-solid fa-copy")
          }, null, 2),
          se(" " + de(i.value ? "" : ""), 1)
        ])
      ]),
      f("div", vh, [
        f("pre", gh, de(t.ddl), 1)
      ]),
      f("div", Eh, [
        w(ae, { onClick: l }, {
          default: P(() => [...u[1] || (u[1] = [
            se("", -1)
          ])]),
          _: 1
        })
      ])
    ]));
  }
}), _h = /* @__PURE__ */ De(yh, [["__scopeId", "data-v-da039aee"]]), Th = { class: "table-management-tab" }, Nh = {
  key: 1,
  class: "table-detail"
}, xh = { class: "table-header" }, Sh = { class: "table-title-section" }, wh = { class: "table-name-row" }, Ch = { class: "table-name" }, Dh = {
  key: 0,
  class: "table-comment-row"
}, Oh = { class: "table-comment" }, $h = {
  key: 1,
  class: "table-comment-row"
}, Ah = { class: "table-actions" }, Mh = { class: "columns-section" }, Vh = { class: "section-header" }, Ih = { class: "columns-list" }, Rh = { key: 1 }, Lh = { class: "column-main" }, kh = { class: "column-first-row" }, Ph = { class: "column-name-wrapper" }, Bh = { class: "column-name" }, Fh = { class: "type-badge" }, Uh = {
  key: 0,
  class: "primary-key-badge",
  title: ""
}, jh = {
  key: 0,
  class: "column-comment"
}, qh = {
  key: 1,
  class: "default-value"
}, Hh = { class: "column-actions" }, Wh = /* @__PURE__ */ Te({
  __name: "TableManagementTab",
  props: {
    tableService: {},
    tables: {},
    selectedTable: {}
  },
  emits: ["refresh", "update:selectedTable"],
  setup(t, { expose: e, emit: s }) {
    const n = t, i = s, o = te(() => n.tables.find((J) => J.tableName === n.selectedTable) || {}), r = te(() => o.value.columnSchemas ? Object.entries(o.value.columnSchemas).map(([J, L]) => [parseInt(J), L]) : []), l = te(() => o.value.columnSchemas ? Object.values(o.value.columnSchemas) : []), a = te(() => !o.value.columnSchemas || !O.value ? [] : Object.values(o.value.columnSchemas).filter((J) => J.name !== O.value?.column.name)), { toast: u, showToast: c } = fa(), {
      showCreateTableModal: d,
      showEditTableNameModal: m,
      showEditTableCommentModal: h,
      showDropTableModal: E,
      showAddColumnModal: y,
      showEditColumnNameModal: N,
      showEditColumnCommentModal: b,
      showDropColumnModal: T,
      showDDLModal: _,
      editingColumn: O,
      exportedDDL: V
    } = _f(), K = (J) => J === null ? "NULL" : J === void 0 ? "" : String(J), he = (J) => {
      const L = n.tableService.createTable(J.tableName, J.columns, J.comment);
      L.success ? (d.value = !1, i("refresh"), c(` "${J.tableName}" `)) : c(L.message || "", "error");
    }, me = (J) => {
      if (o.value.tableName) {
        const L = n.tableService.alterTableName(o.value.tableName, J);
        L.success ? (m.value = !1, i("update:selectedTable", J), i("refresh"), c("")) : c(L.message || "", "error");
      }
    }, H = (J) => {
      if (o.value.tableName) {
        const L = n.tableService.alterTableComment(o.value.tableName, J);
        L.success ? (h.value = !1, i("refresh"), c("")) : c(L.message || "", "error");
      }
    }, le = () => {
      if (o.value.tableName) {
        const J = n.tableService.dropTable(o.value.tableName);
        J.success ? (E.value = !1, i("update:selectedTable", ""), i("refresh"), c("")) : c(J.message || "", "error");
      }
    }, be = (J) => {
      if (o.value.tableName) {
        const L = n.tableService.addColumn(o.value.tableName, J.name, J);
        L.success ? (y.value = !1, i("refresh"), c(` "${J.name}" `)) : c(L.message || "", "error");
      }
    }, C = (J, L) => {
      O.value = { fieldId: J, column: L }, N.value = !0;
    }, W = (J) => {
      if (o.value.tableName && O.value) {
        const L = n.tableService.alterColumnName(
          o.value.tableName,
          O.value.column.name,
          J
        );
        L.success ? (N.value = !1, O.value = null, i("refresh"), c("")) : c(L.message || "", "error");
      }
    }, re = (J, L) => {
      O.value = { fieldId: J, column: L }, b.value = !0;
    }, ge = (J) => {
      if (o.value.tableName && O.value) {
        const L = n.tableService.alterColumnComment(
          o.value.tableName,
          O.value.column.name,
          J
        );
        L.success ? (b.value = !1, O.value = null, i("refresh"), c("")) : c(L.message || "", "error");
      }
    }, pe = (J, L) => {
      O.value = { fieldId: J, column: L }, T.value = !0;
    }, ce = () => {
      if (o.value.tableName && O.value) {
        const J = n.tableService.dropColumn(
          o.value.tableName,
          O.value.column.name
        );
        J.success ? (T.value = !1, O.value = null, i("refresh"), c("")) : c(J.message || "", "error");
      }
    }, fe = () => {
      o.value.tableName && (V.value = n.tableService.exportDDL(o.value.tableName), _.value = !0);
    };
    return e({
      openCreateTableModal: () => {
        d.value = !0;
      }
    }), (J, L) => (S(), k("div", Th, [
      t.selectedTable ? (S(), k("div", Nh, [
        f("div", xh, [
          f("div", Sh, [
            f("div", wh, [
              L[16] || (L[16] = f("span", { class: "table-label" }, "", -1)),
              f("span", Ch, de(o.value.tableName), 1),
              w(ae, {
                size: "small",
                onClick: L[0] || (L[0] = (Oe) => m.value = !0)
              }, {
                default: P(() => [...L[15] || (L[15] = [
                  f("i", { class: "fa-solid fa-pen" }, null, -1)
                ])]),
                _: 1
              })
            ]),
            o.value.comment ? (S(), k("div", Dh, [
              L[18] || (L[18] = f("span", { class: "table-label" }, "", -1)),
              f("span", Oh, de(o.value.comment), 1),
              w(ae, {
                size: "small",
                onClick: L[1] || (L[1] = (Oe) => h.value = !0)
              }, {
                default: P(() => [...L[17] || (L[17] = [
                  f("i", { class: "fa-solid fa-pen" }, null, -1)
                ])]),
                _: 1
              })
            ])) : (S(), k("div", $h, [
              L[20] || (L[20] = f("span", { class: "table-label" }, "", -1)),
              L[21] || (L[21] = f("span", { class: "table-comment placeholder" }, "", -1)),
              w(ae, {
                size: "small",
                onClick: L[2] || (L[2] = (Oe) => h.value = !0)
              }, {
                default: P(() => [...L[19] || (L[19] = [
                  f("i", { class: "fa-solid fa-plus" }, null, -1)
                ])]),
                _: 1
              })
            ]))
          ]),
          f("div", Ah, [
            w(ae, { onClick: fe }, {
              default: P(() => [...L[22] || (L[22] = [
                f("i", {
                  class: "fa-solid fa-download",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se(" DDL ", -1)
              ])]),
              _: 1
            }),
            w(ae, {
              type: "danger",
              onClick: L[3] || (L[3] = (Oe) => E.value = !0)
            }, {
              default: P(() => [...L[23] || (L[23] = [
                f("i", {
                  class: "fa-solid fa-trash",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            })
          ])
        ]),
        f("div", Mh, [
          f("div", Vh, [
            L[25] || (L[25] = f("span", { class: "section-title" }, "", -1)),
            w(ae, {
              size: "small",
              onClick: L[4] || (L[4] = (Oe) => y.value = !0)
            }, {
              default: P(() => [...L[24] || (L[24] = [
                f("i", {
                  class: "fa-solid fa-plus",
                  style: { "margin-right": "4px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            })
          ]),
          f("div", Ih, [
            r.value.length === 0 ? (S(), Le(Jn, {
              key: 0,
              icon: "fa-solid fa-columns",
              text: "",
              variant: "compact"
            })) : (S(), k("div", Rh, [
              (S(!0), k(Ae, null, Wt(r.value, ([Oe, We]) => (S(), k("div", {
                key: Oe,
                class: "column-item"
              }, [
                f("div", Lh, [
                  f("div", kh, [
                    f("div", Ph, [
                      L[26] || (L[26] = f("i", { class: "fa-solid fa-hashtag column-icon" }, null, -1)),
                      f("span", Bh, de(We.name), 1)
                    ]),
                    f("span", Fh, de(We.type), 1),
                    We.primitiveKey ? (S(), k("span", Uh, [...L[27] || (L[27] = [
                      f("i", { class: "fa-solid fa-key" }, null, -1)
                    ])])) : ne("", !0)
                  ]),
                  We.comment ? (S(), k("div", jh, de(We.comment), 1)) : ne("", !0),
                  We.defaultValue !== void 0 ? (S(), k("div", qh, " : " + de(K(We.defaultValue)), 1)) : ne("", !0)
                ]),
                f("div", Hh, [
                  w(ae, {
                    size: "small",
                    title: "",
                    onClick: (dt) => C(Oe, We)
                  }, {
                    default: P(() => [...L[28] || (L[28] = [
                      f("i", { class: "fa-solid fa-pen" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"]),
                  w(ae, {
                    size: "small",
                    title: "",
                    onClick: (dt) => re(Oe, We)
                  }, {
                    default: P(() => [...L[29] || (L[29] = [
                      f("i", { class: "fa-solid fa-comment" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"]),
                  w(ae, {
                    type: "danger",
                    size: "small",
                    title: "",
                    onClick: (dt) => pe(Oe, We)
                  }, {
                    default: P(() => [...L[30] || (L[30] = [
                      f("i", { class: "fa-solid fa-trash" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"])
                ])
              ]))), 128))
            ]))
          ])
        ])
      ])) : (S(), Le(Jn, {
        key: 0,
        icon: "fa-solid fa-table",
        text: ""
      })),
      w(da, {
        visible: Q(u).visible,
        message: Q(u).message,
        type: Q(u).type,
        icon: Q(u).icon
      }, null, 8, ["visible", "message", "type", "icon"]),
      Q(d) ? (S(), Le(np, {
        key: 2,
        "existing-tables": t.tables,
        onCreate: he,
        onCancel: L[5] || (L[5] = (Oe) => d.value = !1)
      }, null, 8, ["existing-tables"])) : ne("", !0),
      Q(m) ? (S(), Le(pp, {
        key: 3,
        "table-name": o.value.tableName,
        "existing-tables": t.tables,
        onSave: me,
        onCancel: L[6] || (L[6] = (Oe) => m.value = !1)
      }, null, 8, ["table-name", "existing-tables"])) : ne("", !0),
      Q(h) ? (S(), Le(yp, {
        key: 4,
        comment: o.value.comment,
        onSave: H,
        onCancel: L[7] || (L[7] = (Oe) => h.value = !1)
      }, null, 8, ["comment"])) : ne("", !0),
      Q(E) ? (S(), Le(Cp, {
        key: 5,
        "table-name": o.value.tableName,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: le,
        onCancel: L[8] || (L[8] = (Oe) => E.value = !1)
      }, null, 8, ["table-name"])) : ne("", !0),
      Q(y) ? (S(), Le(jp, {
        key: 6,
        "existing-columns": l.value,
        onCreate: be,
        onCancel: L[9] || (L[9] = (Oe) => y.value = !1)
      }, null, 8, ["existing-columns"])) : ne("", !0),
      Q(N) && Q(O) ? (S(), Le(Xp, {
        key: 7,
        column: Q(O).column,
        "existing-columns": a.value,
        onSave: W,
        onCancel: L[10] || (L[10] = (Oe) => N.value = !1)
      }, null, 8, ["column", "existing-columns"])) : ne("", !0),
      Q(b) && Q(O) ? (S(), Le(lh, {
        key: 8,
        column: Q(O).column,
        onSave: ge,
        onCancel: L[11] || (L[11] = (Oe) => b.value = !1)
      }, null, 8, ["column"])) : ne("", !0),
      Q(T) && Q(O) ? (S(), Le(hh, {
        key: 9,
        column: Q(O).column,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: ce,
        onCancel: L[12] || (L[12] = (Oe) => T.value = !1)
      }, null, 8, ["column"])) : ne("", !0),
      Q(_) ? (S(), Le(Ge, {
        key: 10,
        visible: "",
        title: "DDL",
        onClose: L[14] || (L[14] = (Oe) => _.value = !1)
      }, {
        default: P(() => [
          w(_h, {
            ddl: Q(V),
            onClose: L[13] || (L[13] = (Oe) => _.value = !1)
          }, null, 8, ["ddl"])
        ]),
        _: 1
      })) : ne("", !0)
    ]));
  }
}), yo = /* @__PURE__ */ De(Wh, [["__scopeId", "data-v-f00e195b"]]), Kh = { class: "sql-panel-tab" }, zh = { class: "sql-editor-container" }, Gh = { class: "sql-toolbar" }, Yh = { class: "sql-footer" }, Qh = { class: "editor-stats" }, Jh = { class: "stat-item" }, Xh = { class: "stat-item" }, Zh = {
  key: 0,
  class: "result-status"
}, em = { key: 0 }, tm = { key: 1 }, sm = /* @__PURE__ */ Te({
  __name: "SqlPanelTab",
  props: {
    sqlExecutorService: {}
  },
  emits: ["refresh"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(""), o = /* @__PURE__ */ q({ success: !1, message: "", data: 0, type: "DQL" }), r = te(() => i.value.split(`
`).length), l = te(() => i.value.length), a = te(() => u.value && Array.isArray(o.value.data) ? o.value.data : []), u = te(() => Array.isArray(o.value.data)), c = te(() => o.value.success || o.value.message !== ""), d = () => {
      if (!i.value.trim()) {
        o.value = { success: !1, message: "SQL", data: 0, type: "DQL" };
        return;
      }
      try {
        o.value = s.sqlExecutorService.execute(i.value), o.value.success && n("refresh");
      } catch (m) {
        o.value = {
          success: !1,
          message: m instanceof Error ? m.message : "",
          data: 0,
          type: "DQL"
        };
      }
    };
    return (m, h) => (S(), k("div", Kh, [
      f("div", zh, [
        f("div", Gh, [
          h[2] || (h[2] = f("span", { class: "toolbar-title" }, "SQL", -1)),
          w(ae, { onClick: d }, {
            default: P(() => [...h[1] || (h[1] = [
              f("i", {
                class: "fa-solid fa-play",
                style: { "margin-right": "6px" }
              }, null, -1),
              se("  ", -1)
            ])]),
            _: 1
          })
        ]),
        Xe(f("textarea", {
          "onUpdate:modelValue": h[0] || (h[0] = (E) => i.value = E),
          class: "sql-editor",
          placeholder: "SQL...",
          spellcheck: "false"
        }, null, 512), [
          [zt, i.value]
        ]),
        f("div", Yh, [
          f("div", Qh, [
            f("span", Jh, ": " + de(r.value), 1),
            f("span", Xh, ": " + de(l.value), 1)
          ]),
          c.value ? (S(), k("div", Zh, [
            u.value ? (S(), k("span", em, ": " + de(a.value.length) + " ", 1)) : (S(), k("span", tm, ": " + de(o.value.data) + " ", 1))
          ])) : ne("", !0)
        ]),
        o.value.message ? (S(), k("div", {
          key: 0,
          class: Ie(["result-message", { error: !o.value.success }])
        }, de(o.value.message), 3)) : ne("", !0)
      ])
    ]));
  }
}), _o = /* @__PURE__ */ De(sm, [["__scopeId", "data-v-34ac73ac"]]);
var Z = /* @__PURE__ */ ((t) => (t.DDL = "DDL", t.DML = "DML", t.DQL = "DQL", t.ROW = "ROW", t))(Z || {}), lt = /* @__PURE__ */ ((t) => (t.INSERT_SQL = "INSERT_SQL", t.TABLE_SCHEMA = "TABLE_SCHEMA", t.DDL = "DDL", t.MARKDOWN = "MARKDOWN", t.STANDARD_DATA = "STANDARD_DATA", t))(lt || {}), Gi = /* @__PURE__ */ ((t) => (t.INNER = "INNER", t.LEFT = "LEFT", t))(Gi || {}), pi = /* @__PURE__ */ ((t) => (t.SYNTAX_ERROR = "SYNTAX_ERROR", t.VALIDATION_ERROR = "VALIDATION_ERROR", t.EXECUTION_ERROR = "EXECUTION_ERROR", t.TABLE_NOT_FOUND = "TABLE_NOT_FOUND", t.COLUMN_NOT_FOUND = "COLUMN_NOT_FOUND", t.TYPE_MISMATCH = "TYPE_MISMATCH", t))(pi || {});
class To extends Error {
  /**  */
  code;
  /** SQL */
  position;
  /** SQL */
  sql;
  constructor(e, s, n, i) {
    super(s), this.name = "SqlError", this.code = e, this.position = n, this.sql = i;
  }
}
class wn extends To {
  constructor(e, s, n) {
    super(pi.SYNTAX_ERROR, e, s, n), this.name = "SqlSyntaxError";
  }
}
class Re extends To {
  constructor(e, s) {
    super(pi.VALIDATION_ERROR, e, void 0, s), this.name = "SqlValidationError";
  }
}
class ns extends To {
  constructor(e, s) {
    super(pi.EXECUTION_ERROR, e, void 0, s), this.name = "SqlExecutionError";
  }
}
var Y = /* @__PURE__ */ ((t) => (t.KEYWORD = "KEYWORD", t.IDENTIFIER = "IDENTIFIER", t.STRING = "STRING", t.NUMBER = "NUMBER", t.OPERATOR = "OPERATOR", t.COMMA = "COMMA", t.SEMICOLON = "SEMICOLON", t.LPAREN = "LPAREN", t.RPAREN = "RPAREN", t.DOT = "DOT", t.EOF = "EOF", t))(Y || {}), $e = /* @__PURE__ */ ((t) => (t.CREATE_TABLE = "CREATE_TABLE", t.ALTER_TABLE = "ALTER_TABLE", t.DROP_TABLE = "DROP_TABLE", t.INSERT = "INSERT", t.UPDATE = "UPDATE", t.DELETE = "DELETE", t.APPEND = "APPEND", t.SELECT = "SELECT", t.ROW = "ROW", t))($e || {}), Xt = /* @__PURE__ */ ((t) => (t.ADD_COLUMN = "ADD_COLUMN", t.DROP_COLUMN = "DROP_COLUMN", t.RENAME = "RENAME", t.RENAME_COLUMN = "RENAME_COLUMN", t.MODIFY_COLUMN_COMMENT = "MODIFY_COLUMN_COMMENT", t.MODIFY_COLUMN_PRIMITIVE_KEY = "MODIFY_COLUMN_PRIMITIVE_KEY", t.ALTER_TABLE_COMMENT = "ALTER_TABLE_COMMENT", t))(Xt || {});
const nm = /* @__PURE__ */ new Set([
  "SELECT",
  "FROM",
  "WHERE",
  "INSERT",
  "INTO",
  "VALUES",
  "UPDATE",
  "SET",
  "DELETE",
  "CREATE",
  "TABLE",
  "ALTER",
  "DROP",
  "ADD",
  "COLUMN",
  "RENAME",
  "TO",
  "APPEND",
  "AND",
  "OR",
  "NOT",
  "NULL",
  "IS",
  "BETWEEN",
  "IN",
  "ORDER",
  "BY",
  "ASC",
  "DESC",
  "INNER",
  "LEFT",
  "JOIN",
  "ON",
  "DISTINCT",
  "STRING",
  "NUMBER",
  "PRIMARY",
  "KEY",
  "DEFAULT",
  "COMMENT",
  "MODIFY"
]), Dr = ["=", "!=", "<>", ">", "<", ">=", "<="];
class Xn {
  input;
  pos = 0;
  length;
  tokenCount = 0;
  static MAX_TOKENS = 1e4;
  constructor(e) {
    this.input = e, this.length = e.length;
  }
  /**
   * 
   */
  peek(e = 0) {
    const s = this.pos + e;
    return this.input[s] ?? "";
  }
  /**
   * 
   */
  advance() {
    return this.pos >= this.length ? "" : this.input[this.pos++] ?? "";
  }
  /**
   * 
   */
  skipWhitespace() {
    for (; this.pos < this.length && /\s/.test(this.peek()); )
      this.pos++;
  }
  /**
   * 
   */
  skipComment() {
    for (; this.peek() === "-" && this.peek(1) === "-"; ) {
      for (this.pos += 2; this.pos < this.length && this.peek() !== `
`; )
        this.pos++;
      this.pos < this.length && this.peek() === `
` && this.pos++, this.skipWhitespace();
    }
  }
  /**
   * 
   */
  readIdentifier() {
    let e = "";
    for (; this.pos < this.length && /[\w]/.test(this.peek()); )
      e += this.advance();
    return e;
  }
  /**
   * 
   */
  readString(e) {
    let s = "";
    for (this.advance(); this.pos < this.length; ) {
      const n = this.peek();
      if (n === e)
        if (this.advance(), this.peek() === e)
          s += e, this.advance();
        else
          break;
      else n === "\\" ? (this.advance(), s += this.advance()) : s += this.advance();
    }
    return s;
  }
  /**
   * 
   */
  readNumber() {
    let e = "";
    for (; this.pos < this.length && /[\d.]/.test(this.peek()); )
      e += this.advance();
    return e;
  }
  /**
   * 
   */
  readOperator() {
    const e = this.peek() + this.peek(1);
    return Dr.includes(e) ? (this.advance(), this.advance(), e) : this.advance();
  }
  /**
   * Token
   */
  nextToken() {
    if (this.tokenCount >= Xn.MAX_TOKENS)
      throw new Error(`Parser exceeded maximum token limit (${Xn.MAX_TOKENS}). Possible infinite loop detected.`);
    if (this.tokenCount++, this.skipWhitespace(), this.skipComment(), this.pos >= this.length)
      return { type: Y.EOF, value: "", position: this.pos };
    const e = this.pos, s = this.peek();
    if (s === "(")
      return this.advance(), { type: Y.LPAREN, value: "(", position: e };
    if (s === ")")
      return this.advance(), { type: Y.RPAREN, value: ")", position: e };
    if (s === ",")
      return this.advance(), { type: Y.COMMA, value: ",", position: e };
    if (s === ";")
      return this.advance(), { type: Y.SEMICOLON, value: ";", position: e };
    if (s === ".")
      return this.advance(), { type: Y.DOT, value: ".", position: e };
    if (s === "'") {
      const n = this.readString(s);
      return { type: Y.STRING, value: n, position: e };
    }
    if (s === '"') {
      const n = this.readString(s);
      return { type: Y.STRING, value: n, position: e };
    }
    if (s === "*")
      return this.advance(), { type: Y.KEYWORD, value: "*", position: e };
    if (/[\d]/.test(s)) {
      const n = this.readNumber();
      return { type: Y.NUMBER, value: n, position: e };
    }
    if (/[a-zA-Z_]/.test(s)) {
      const n = this.readIdentifier(), i = n.toUpperCase();
      return nm.has(i) ? { type: Y.KEYWORD, value: i, position: e } : { type: Y.IDENTIFIER, value: n, position: e };
    }
    if (Dr.some((n) => n.startsWith(s))) {
      const n = this.readOperator();
      return { type: Y.OPERATOR, value: n, position: e };
    }
    throw this.advance(), new Error(`Unexpected character: ${s} at position ${e}`);
  }
  /**
   * Token
   */
  tokenize() {
    const e = [];
    let s;
    do
      s = this.nextToken(), e.push(s);
    while (s.type !== Y.EOF);
    return e;
  }
}
class ss {
  lexer;
  current;
  peekToken;
  errors = [];
  errorCount = 0;
  startTime;
  static MAX_ERRORS = 100;
  static TIMEOUT_MS = 5e3;
  constructor(e) {
    this.lexer = e, this.current = this.lexer.nextToken(), this.peekToken = this.lexer.nextToken(), this.startTime = performance.now();
  }
  /**
   * Token
   */
  nextToken() {
    this.current = this.peekToken, this.peekToken = this.lexer.nextToken();
  }
  /**
   * Token
   */
  isCurrentType(e) {
    return this.current.type === e;
  }
  /**
   * Token
   */
  isCurrentValue(e) {
    return (this.current.type === Y.KEYWORD || this.current.type === Y.OPERATOR) && this.current.value === e;
  }
  /**
   * Token
   */
  expectType(e) {
    if (!this.isCurrentType(e))
      throw this.errors.push(`Expected ${e}, got ${this.current.type} at position ${this.current.position}`), new Error(`Parse error at position ${this.current.position}`);
    const s = this.current;
    return this.nextToken(), s;
  }
  /**
   * Token
   */
  expectValue(e) {
    if (!this.isCurrentValue(e))
      throw this.errors.push(`Expected ${e}, got ${this.current.value} at position ${this.current.position}`), new Error(`Parse error at position ${this.current.position}`);
    const s = this.current;
    return this.nextToken(), s;
  }
  /**
   * Token
   */
  matchValue(e) {
    return this.current.value === e && (this.current.type === Y.KEYWORD || this.current.type === Y.OPERATOR || this.current.type === Y.COMMA || this.current.type === Y.SEMICOLON) ? (this.nextToken(), !0) : !1;
  }
  /**
   * 
   */
  parseIdentifier() {
    if (this.isCurrentType(Y.IDENTIFIER) || this.isCurrentType(Y.KEYWORD)) {
      const e = this.current.value;
      return this.nextToken(), e;
    }
    throw new Error(`Expected identifier at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseFieldType() {
    if (this.isCurrentValue("STRING"))
      return this.nextToken(), Lt.STRING;
    if (this.isCurrentValue("NUMBER"))
      return this.nextToken(), Lt.NUMBER;
    throw new Error(`Expected field type at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseColumnDef() {
    const e = this.parseIdentifier(), s = this.parseFieldType(), n = { name: e, type: s };
    if (this.matchValue("PRIMARY") && (this.expectValue("KEY"), n.primitiveKey = !0), this.matchValue("DEFAULT"))
      if (this.isCurrentType(Y.STRING))
        n.defaultValue = this.current.value, this.nextToken();
      else if (this.isCurrentType(Y.NUMBER))
        n.defaultValue = Number(this.current.value), this.nextToken();
      else if (this.matchValue("NULL"))
        n.defaultValue = null;
      else
        throw new Error(`Expected default value at position ${this.current.position}`);
    if (this.matchValue("COMMENT"))
      if (this.isCurrentType(Y.STRING))
        n.comment = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    return n;
  }
  /**
   * 
   */
  parseExpression() {
    return this.parseLogicalOr();
  }
  /**
   * OR
   */
  parseLogicalOr() {
    let e = this.parseLogicalAnd();
    for (; this.matchValue("OR"); ) {
      const s = this.parseLogicalAnd();
      e = { type: "binary", operator: "OR", left: e, right: s };
    }
    return e;
  }
  /**
   * AND
   */
  parseLogicalAnd() {
    let e = this.parseNot();
    for (; this.matchValue("AND"); ) {
      const s = this.parseNot();
      e = { type: "binary", operator: "AND", left: e, right: s };
    }
    return e;
  }
  /**
   * NOT
   */
  parseNot() {
    if (this.matchValue("NOT")) {
      const e = this.parseNot();
      return e.type === "binary" ? { ...e, operator: `NOT ${e.operator}` } : e;
    }
    return this.parseComparison();
  }
  /**
   * 
   */
  parseComparison() {
    let e = this.parseIs();
    const s = ["=", "!=", "<>", ">", "<", ">=", "<="];
    for (; s.includes(this.current.value); ) {
      const n = this.current.value;
      this.nextToken();
      const i = this.parseIs();
      e = { type: "binary", operator: n, left: e, right: i };
    }
    if (this.matchValue("IN")) {
      this.expectType(Y.LPAREN);
      const n = [];
      for (n.push(this.parseExpression()); this.matchValue(","); )
        n.push(this.parseExpression());
      return this.expectType(Y.RPAREN), { type: "in", value: e, values: n };
    }
    if (this.matchValue("BETWEEN")) {
      const n = this.parseAdditive();
      this.expectValue("AND");
      const i = this.parseAdditive();
      return { type: "between", value: e, min: n, max: i };
    }
    return e;
  }
  /**
   * IS
   */
  parseIs() {
    const e = this.parseAdditive();
    if (this.matchValue("IS"))
      if (this.matchValue("NOT")) {
        const s = this.parseAdditive();
        return s.type === "null" ? { type: "null", value: e, not: !0 } : { type: "binary", operator: "IS NOT", left: e, right: s };
      } else {
        const s = this.parseAdditive();
        return s.type === "null" ? { type: "null", value: e } : { type: "binary", operator: "IS", left: e, right: s };
      }
    return e;
  }
  /**
   * 
   */
  parseAdditive() {
    let e = this.parseMultiplicative();
    for (; this.current.value === "+" || this.current.value === "-"; ) {
      const s = this.current.value;
      this.nextToken();
      const n = this.parseMultiplicative();
      e = { type: "binary", operator: s, left: e, right: n };
    }
    return e;
  }
  /**
   * 
   */
  parseMultiplicative() {
    let e = this.parsePrimary();
    for (; this.current.value === "*" || this.current.value === "/"; ) {
      const s = this.current.value;
      this.nextToken();
      const n = this.parsePrimary();
      e = { type: "binary", operator: s, left: e, right: n };
    }
    return e;
  }
  /**
   * 
   */
  parsePrimary() {
    if (this.isCurrentType(Y.NUMBER)) {
      const e = Number(this.current.value);
      return this.nextToken(), { type: "value", value: e };
    }
    if (this.isCurrentType(Y.STRING)) {
      const e = this.current.value;
      return this.nextToken(), { type: "value", value: e };
    }
    if (this.matchValue("NULL"))
      return { type: "null", value: { type: "value", value: null } };
    if (this.isCurrentType(Y.IDENTIFIER) || this.isCurrentType(Y.KEYWORD))
      return this.parseColumnExpression();
    if (this.isCurrentType(Y.LPAREN)) {
      this.nextToken();
      const e = this.parseExpression();
      return this.expectType(Y.RPAREN), e;
    }
    throw new Error(`Unexpected token at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseColumnExpression() {
    const e = this.parseIdentifier();
    if (this.matchValue(".")) {
      const s = e, n = this.parseIdentifier();
      return { type: "column", tableName: s, name: n };
    }
    return { type: "column", name: e };
  }
  /**
   * CREATE TABLE
   */
  parseCreateTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    this.expectType(Y.LPAREN);
    const s = [];
    for (s.push(this.parseColumnDef()); this.matchValue(","); )
      s.push(this.parseColumnDef());
    this.expectType(Y.RPAREN);
    const n = {
      type: $e.CREATE_TABLE,
      tableName: e,
      columns: s,
      position: this.current.position
    };
    if (this.matchValue("COMMENT"))
      if (this.isCurrentType(Y.STRING))
        n.comment = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    return n;
  }
  /**
   * ALTER TABLE
   */
  parseAlterTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    let s, n, i, o, r, l;
    if (this.matchValue("ADD"))
      this.expectValue("COLUMN"), s = Xt.ADD_COLUMN, i = this.parseColumnDef();
    else if (this.matchValue("DROP"))
      this.expectValue("COLUMN"), s = Xt.DROP_COLUMN, n = this.parseIdentifier();
    else if (this.matchValue("RENAME"))
      this.matchValue("COLUMN") ? (s = Xt.RENAME_COLUMN, n = this.parseIdentifier(), this.expectValue("TO"), r = this.parseIdentifier()) : (this.expectValue("TO"), s = Xt.RENAME, o = this.parseIdentifier());
    else if (this.matchValue("MODIFY")) {
      this.expectValue("COLUMN"), n = this.parseIdentifier();
      const a = this.parseFieldType();
      let u = !1;
      if (this.matchValue("PRIMARY") && (this.expectValue("KEY"), u = !0), this.matchValue("COMMENT"))
        if (this.isCurrentType(Y.STRING))
          l = this.current.value, this.nextToken();
        else
          throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
      if (u)
        s = Xt.MODIFY_COLUMN_PRIMITIVE_KEY, i = { name: n, type: a, primitiveKey: u, comment: l };
      else if (l !== void 0)
        s = Xt.MODIFY_COLUMN_COMMENT;
      else
        throw new Error(`Expected PRIMARY KEY or COMMENT after MODIFY COLUMN at position ${this.current.position}`);
    } else if (this.matchValue("COMMENT"))
      if (s = Xt.ALTER_TABLE_COMMENT, this.isCurrentType(Y.STRING))
        l = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    else
      throw new Error(`Expected ADD, DROP, RENAME, MODIFY COLUMN or COMMENT after ALTER TABLE at position ${this.current.position}`);
    return {
      type: $e.ALTER_TABLE,
      tableName: e,
      opType: s,
      columnName: n,
      columnDef: i,
      newTableName: o,
      newColumnName: r,
      comment: l,
      position: this.current.position
    };
  }
  /**
   * DROP TABLE
   */
  parseDropTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    return {
      type: $e.DROP_TABLE,
      tableName: e,
      position: this.current.position
    };
  }
  /**
   * INSERT
   */
  parseInsert() {
    this.expectValue("INTO");
    const e = this.parseIdentifier();
    let s;
    if (this.isCurrentType(Y.LPAREN)) {
      for (this.nextToken(), s = [], s.push(this.parseIdentifier()); this.matchValue(","); )
        s.push(this.parseIdentifier());
      this.expectType(Y.RPAREN);
    }
    this.expectValue("VALUES"), this.expectType(Y.LPAREN);
    const n = [], i = [];
    for (i.push(this.parseExpression()); this.matchValue(","); )
      i.push(this.parseExpression());
    for (n.push(i), this.expectType(Y.RPAREN); this.matchValue(","); ) {
      this.expectType(Y.LPAREN);
      const o = [];
      for (o.push(this.parseExpression()); this.matchValue(","); )
        o.push(this.parseExpression());
      n.push(o), this.expectType(Y.RPAREN);
    }
    return {
      type: $e.INSERT,
      tableName: e,
      columns: s,
      values: n,
      position: this.current.position
    };
  }
  /**
   * UPDATE
   */
  parseUpdate() {
    const e = this.parseIdentifier();
    this.expectValue("SET");
    const s = [], n = this.parseIdentifier();
    this.expectValue("=");
    const i = this.parseExpression();
    for (s.push({ column: n, value: i }); this.matchValue(","); ) {
      const r = this.parseIdentifier();
      this.expectValue("=");
      const l = this.parseExpression();
      s.push({ column: r, value: l });
    }
    let o;
    return this.matchValue("WHERE") && (o = this.parseExpression()), {
      type: $e.UPDATE,
      tableName: e,
      sets: s,
      where: o,
      position: this.current.position
    };
  }
  /**
   * DELETE
   */
  parseDelete() {
    this.expectValue("FROM");
    const e = this.parseIdentifier();
    let s;
    return this.matchValue("WHERE") && (s = this.parseExpression()), {
      type: $e.DELETE,
      tableName: e,
      where: s,
      position: this.current.position
    };
  }
  /**
   * APPEND
   */
  parseAppend() {
    this.expectValue("INTO");
    const e = this.parseIdentifier();
    this.expectType(Y.LPAREN);
    const s = [];
    for (s.push(this.parseIdentifier()); this.matchValue(","); )
      s.push(this.parseIdentifier());
    this.expectType(Y.RPAREN), this.expectValue("VALUES"), this.expectType(Y.LPAREN);
    const n = [];
    for (n.push(this.parseExpression()); this.matchValue(","); )
      n.push(this.parseExpression());
    this.expectType(Y.RPAREN);
    let i;
    return this.matchValue("WHERE") && (i = this.parseExpression()), {
      type: $e.APPEND,
      tableName: e,
      columns: s,
      values: n,
      where: i,
      position: this.current.position
    };
  }
  /**
   * SELECT
   */
  parseSelectList() {
    const e = [];
    if (this.matchValue("*"))
      e.push({ type: "star" });
    else
      for (e.push(this.parseSelectItem()); this.matchValue(","); )
        e.push(this.parseSelectItem());
    return e;
  }
  /**
   * SELECT
   */
  parseSelectItem() {
    return this.parseColumnExpression();
  }
  /**
   * JOIN
   */
  parseJoin() {
    if (this.matchValue("INNER")) {
      this.expectValue("JOIN");
      const e = this.parseIdentifier();
      this.expectValue("ON");
      const s = this.parseColumnExpression(), n = this.parseColumnExpression();
      return {
        type: Gi.INNER,
        tableName: e,
        on: { left: s, right: n }
      };
    }
    if (this.matchValue("LEFT")) {
      this.expectValue("JOIN");
      const e = this.parseIdentifier();
      this.expectValue("ON");
      const s = this.parseColumnExpression(), n = this.parseColumnExpression();
      return {
        type: Gi.LEFT,
        tableName: e,
        on: { left: s, right: n }
      };
    }
  }
  /**
   * ORDER BY
   */
  parseOrderBy() {
    if (!this.matchValue("ORDER")) return;
    this.expectValue("BY");
    const e = [];
    if (e.push({
      column: this.parseIdentifier(),
      ascending: !this.matchValue("DESC")
    }), this.matchValue("ASC")) {
      const s = e[e.length - 1];
      s && (s.ascending = !0);
    }
    for (; this.matchValue(","); )
      if (e.push({
        column: this.parseIdentifier(),
        ascending: !this.matchValue("DESC")
      }), this.matchValue("ASC")) {
        const s = e[e.length - 1];
        s && (s.ascending = !0);
      }
    return e;
  }
  /**
   * SELECT
   */
  parseSelect() {
    let e = !1;
    this.matchValue("DISTINCT") && (e = !0);
    const s = this.parseSelectList();
    this.expectValue("FROM");
    const n = this.parseIdentifier(), i = [];
    for (; ; ) {
      const l = this.parseJoin();
      if (!l) break;
      i.push(l);
    }
    let o;
    this.matchValue("WHERE") && (o = this.parseExpression());
    let r;
    return this.isCurrentValue("ORDER") && (r = this.parseOrderBy()), {
      type: $e.SELECT,
      distinct: e,
      columns: s,
      from: n,
      joins: i,
      where: o,
      orderBy: r,
      position: this.current.position
    };
  }
  /**
   * 
   */
  parseStatement() {
    return this.isCurrentValue("CREATE") ? (this.nextToken(), this.parseCreateTable()) : this.isCurrentValue("ALTER") ? (this.nextToken(), this.parseAlterTable()) : this.isCurrentValue("DROP") ? (this.nextToken(), this.parseDropTable()) : this.isCurrentValue("INSERT") ? (this.nextToken(), this.parseInsert()) : this.isCurrentValue("UPDATE") ? (this.nextToken(), this.parseUpdate()) : this.isCurrentValue("DELETE") ? (this.nextToken(), this.parseDelete()) : this.isCurrentValue("APPEND") ? (this.nextToken(), this.parseAppend()) : this.isCurrentValue("SELECT") ? (this.nextToken(), this.parseSelect()) : null;
  }
  /**
   * 
   */
  parse() {
    const e = [], s = [];
    for (; !this.isCurrentType(Y.EOF); ) {
      if (performance.now() - this.startTime > ss.TIMEOUT_MS)
        throw new Error(`Parser timeout after ${ss.TIMEOUT_MS}ms. Possible infinite loop detected.`);
      if (this.errorCount >= ss.MAX_ERRORS)
        throw new Error(`Parser exceeded maximum error limit (${ss.MAX_ERRORS}). Too many syntax errors.`);
      try {
        const n = this.parseStatement();
        n && e.push(n), this.matchValue(";") || this.isCurrentType(Y.EOF) || (s.push(`Expected ';' at position ${this.current.position}`), this.errorCount++);
      } catch (n) {
        for (s.push(n.message), this.errorCount++; !this.isCurrentType(Y.EOF) && !this.isCurrentType(Y.SEMICOLON); )
          this.nextToken();
        this.isCurrentType(Y.SEMICOLON) && this.nextToken();
      }
    }
    return { statements: e, errors: s };
  }
  /**
   * SQL
   */
  static parse(e) {
    const s = new Xn(e);
    return new ss(s).parse();
  }
}
class pa {
  evaluateExpression(e, s, n, i) {
    if (e.type === "value")
      return e.value;
    if (e.type === "column") {
      if (i === null)
        throw new Error("Cannot evaluate column expression without row context");
      const o = e.name, r = s.fieldName2id[o];
      if (r === void 0)
        throw new Error(`Column '${o}' does not exist`);
      return i[r];
    }
    if (e.type === "binary") {
      const o = this.evaluateExpression(e.left, s, n, i), r = this.evaluateExpression(e.right, s, n, i);
      switch (e.operator) {
        case "+":
          return Number(o) + Number(r);
        case "-":
          return Number(o) - Number(r);
        case "*":
          return Number(o) * Number(r);
        case "/":
          return Number(o) / Number(r);
        case "=":
          return o === r;
        case "!=":
        case "<>":
          return o !== r;
        case ">":
          return Number(o) > Number(r);
        case "<":
          return Number(o) < Number(r);
        case ">=":
          return Number(o) >= Number(r);
        case "<=":
          return Number(o) <= Number(r);
        case "AND":
          return !!o && !!r;
        case "OR":
          return !!o || !!r;
        case "IS":
          return o === r;
        case "IS NOT":
          return o !== r;
        default:
          throw new Error(`Unknown operator: ${e.operator}`);
      }
    }
    if (e.type === "null") {
      if (e.value && e.value.type === "value" && e.value.value === null)
        return null;
      const o = this.evaluateExpression(e.value, s, n, i);
      return e.not ? o !== null : o === null;
    }
    if (e.type === "in") {
      const o = this.evaluateExpression(e.value, s, n, i);
      return e.values.map((l) => this.evaluateExpression(l, s, n, i)).some((l) => l === o);
    }
    if (e.type === "between") {
      const o = this.evaluateExpression(e.value, s, n, i), r = this.evaluateExpression(e.min, s, n, i), l = this.evaluateExpression(e.max, s, n, i);
      return o >= r && o <= l;
    }
    throw new Error(`Unknown expression type: ${e.type}`);
  }
  evaluateWhere(e, s, n, i) {
    return !!this.evaluateExpression(e, s, n, i);
  }
}
class No {
  static exportTable(e, s) {
    if (s.length === 0)
      return `**${e.tableName}**

*()*`;
    const n = Object.keys(e.id2fieldName).map((l) => parseInt(l)), i = n.map((l) => e.id2fieldName[l]), o = i.map(() => "---"), r = [];
    for (const l of s) {
      const a = [];
      for (const u of n) {
        const c = l[u];
        a.push(No.formatValue(c));
      }
      r.push(a.join(" | "));
    }
    return `**${e.tableName}**

| ${i.join(" | ")} |
| ${o.join(" | ")} |
${r.map((l) => `| ${l} |`).join(`
`)}`;
  }
  static formatValue(e) {
    return e === null ? "*NULL*" : typeof e == "string" ? e.replace(/\n/g, "<br>") : String(e);
  }
}
class im {
  export(e, s, n, i, o) {
    if (i) {
      if (!o)
        throw new ns("getTableIdxByName function is required when exporting a specific table");
      const l = o(i);
      if (l === void 0)
        throw new ns(`Table '${i}' does not exist`);
      const a = s[l];
      if (!a)
        throw new ns(`Schema for table '${i}' not found`);
      const u = e.getTableData(l);
      return this.exportTable(a, u, n, l);
    }
    if (n === lt.STANDARD_DATA) {
      const l = {};
      for (const [a, u] of Object.entries(s)) {
        const c = parseInt(a), d = e.getTableData(c), m = this.exportAsStandardData(u, d), h = JSON.parse(m);
        Object.assign(l, h);
      }
      return JSON.stringify(l, null, 2);
    }
    const r = [];
    for (const [l, a] of Object.entries(s)) {
      const u = parseInt(l), c = e.getTableData(u);
      r.push(this.exportTable(a, c, n, u));
    }
    return r.join(`

`);
  }
  exportTable(e, s, n, i) {
    switch (n) {
      case lt.INSERT_SQL:
        return this.exportAsInsertSql(e, s);
      case lt.TABLE_SCHEMA:
        return JSON.stringify(e, null, 2);
      case lt.DDL:
        return this.exportAsDDL(e);
      case lt.MARKDOWN:
        return this.exportAsMarkdown(e, s);
      case lt.STANDARD_DATA:
        return this.exportAsStandardData(e, s);
      default:
        throw new ns(`Unknown export format: ${n}`);
    }
  }
  exportAsInsertSql(e, s) {
    const n = [];
    for (const i of s) {
      const o = [];
      for (const [l] of Object.entries(e.id2fieldName)) {
        const a = parseInt(l), u = i[a];
        if (u === null)
          o.push("NULL");
        else if (typeof u == "string") {
          const c = u.replace(/\\/g, "\\\\").replace(/'/g, "''").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
          o.push(`'${c}'`);
        } else
          o.push(String(u));
      }
      const r = Object.values(e.id2fieldName).join(", ");
      n.push(`INSERT INTO ${e.tableName} (${r}) VALUES (${o.join(", ")});`);
    }
    return n.join(`
`);
  }
  exportAsMarkdown(e, s) {
    return No.exportTable(e, s);
  }
  exportAsStandardData(e, s) {
    const n = {}, i = [];
    for (const o of s) {
      const r = {};
      for (const [l, a] of Object.entries(e.id2fieldName)) {
        const u = parseInt(l);
        r[a] = o[u] ?? null;
      }
      i.push(r);
    }
    return n[e.tableName] = i, JSON.stringify(n, null, 2);
  }
  exportAsDDL(e) {
    const s = {}, n = {};
    for (const [r] of Object.entries(e.id2fieldName)) {
      const l = parseInt(r), a = e.columnSchemas[l];
      if (a) {
        const u = a.type + (a.primitiveKey ? " PRIMARY KEY" : "");
        s[a.name] = u, a.comment && (n[a.name] = a.comment);
      }
    }
    const i = new Map(Object.entries(s)), o = new Map(Object.entries(n));
    return rt.ddl().createTable(e.tableName, i, e.comment, o);
  }
}
class xo {
  structure;
  dataStorage;
  ddlExecutor;
  dmlExecutor;
  dqlExecutor;
  dataExporter;
  constructor(e, s) {
    this.dataStorage = e || fs.newStorage(), this.structure = s || this.createEmptyStructure(), this.ddlExecutor = new Or(
      this.structure,
      this.dataStorage,
      this.getTableIdxByName.bind(this)
    ), this.dmlExecutor = new $r(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dqlExecutor = new Ar(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dataExporter = new im();
  }
  createEmptyStructure() {
    return {
      tableSchemas: {},
      tableName2Idx: {},
      tableIdxCounter: 0
    };
  }
  getTables() {
    return Object.values(this.structure.tableSchemas).map((s) => ({
      ...s,
      id2fieldName: { ...s.id2fieldName },
      fieldName2id: { ...s.fieldName2id },
      columnSchemas: { ...s.columnSchemas }
    }));
  }
  execute(e, s) {
    try {
      const n = ss.parse(e);
      if (n.errors.length > 0)
        throw new wn(
          n.errors.join("; "),
          0,
          e
        );
      const i = n.statements;
      if (i.length === 0)
        throw new wn("No valid SQL statement found", 0, e);
      let o;
      for (let r = 0; r < i.length; r++) {
        const l = i[r];
        if (!l) continue;
        const a = this.getStatementType(l);
        if (!s.includes(a))
          throw new Re(
            `Expected SQL type ${s.join(" or ")}, got ${a}`,
            e
          );
        o = this.executeStatement(l);
      }
      if (!o)
        throw new wn("No valid statement executed", 0, e);
      return o;
    } catch (n) {
      throw n instanceof wn || n instanceof Re || n instanceof ns ? n : new ns(n.message, e);
    }
  }
  getStatementType(e) {
    const s = e.type;
    switch (s) {
      case $e.CREATE_TABLE:
      case $e.ALTER_TABLE:
      case $e.DROP_TABLE:
        return Z.DDL;
      case $e.INSERT:
      case $e.UPDATE:
      case $e.DELETE:
      case $e.APPEND:
        return Z.DML;
      case $e.SELECT:
        return Z.DQL;
      default:
        throw new ns(`Unknown statement type: ${s}`);
    }
  }
  executeStatement(e) {
    switch (e.type) {
      case $e.CREATE_TABLE:
        return this.ddlExecutor.executeCreateTable(e);
      case $e.ALTER_TABLE:
        return this.ddlExecutor.executeAlterTable(e);
      case $e.DROP_TABLE:
        return this.ddlExecutor.executeDropTable(e);
      case $e.INSERT:
        return this.dmlExecutor.executeInsert(e);
      case $e.UPDATE:
        return this.dmlExecutor.executeUpdate(e);
      case $e.DELETE:
        return this.dmlExecutor.executeDelete(e);
      case $e.APPEND:
        return this.dmlExecutor.executeAppend(e);
      case $e.SELECT:
        return this.dqlExecutor.executeSelect(e);
      default:
        throw new ns("Unsupported statement type");
    }
  }
  getTableIdxByName(e) {
    return this.structure.tableName2Idx[e];
  }
  getTableNameByIdx(e) {
    return this.structure.tableSchemas[e]?.tableName;
  }
  validateTableExists(e) {
    const s = this.getTableIdxByName(e);
    if (s === void 0)
      throw new Re(
        `Table '${e}' does not exist`,
        `Table '${e}' does not exist`
      );
    return s;
  }
  getDataStorage() {
    return this.dataStorage;
  }
  setDataStorage(e) {
    this.dataStorage = e;
  }
  export(e, s) {
    return this.dataExporter.export(
      this.dataStorage,
      this.structure.tableSchemas,
      e,
      s,
      this.getTableIdxByName.bind(this)
    );
  }
  clone() {
    const e = JSON.parse(JSON.stringify(this.structure));
    return new xo(void 0, e);
  }
  serialize() {
    return {
      structure: this.structure,
      dataStorage: this.dataStorage.serialize()
    };
  }
  deserialize(e) {
    const s = e;
    s.structure ? this.structure = s.structure : this.structure = this.createEmptyStructure(), s.dataStorage ? this.dataStorage.deserialize(s.dataStorage) : this.dataStorage.clear(), this.rebuildExecutors();
  }
  rebuildExecutors() {
    this.ddlExecutor = new Or(
      this.structure,
      this.dataStorage,
      this.getTableIdxByName.bind(this)
    ), this.dmlExecutor = new $r(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dqlExecutor = new Ar(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    );
  }
}
class So {
  data = {};
  constructor(e) {
    e && Object.keys(e).forEach((s) => {
      const n = parseInt(s), i = e[n];
      i && (this.data[n] = i.map((o) => ({ ...o })));
    });
  }
  /**
   * 
   */
  clone() {
    const e = {};
    return Object.keys(this.data).forEach((s) => {
      const n = parseInt(s), i = this.data[n];
      i && (e[n] = i.map((o) => ({ ...o })));
    }), new So(e);
  }
  /**
   * 
   */
  getTableData(e) {
    return this.data[e] || [];
  }
  /**
   * 
   */
  setTableData(e, s) {
    this.data[e] = s.map((n) => ({ ...n }));
  }
  /**
   * 
   */
  clear() {
    this.data = {};
  }
  /**
   * 
   */
  serialize() {
    return this.data;
  }
  /**
   * 
   */
  deserialize(e) {
    this.data = {};
    const s = e;
    Object.keys(s).forEach((n) => {
      const i = parseInt(n), o = s[n];
      Array.isArray(o) ? this.data[i] = o.map((r) => ({ ...r })) : this.data[i] = [];
    });
  }
}
class Or {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.getTableIdxByName = n;
  }
  executeCreateTable(e) {
    const s = e.tableName;
    this.validateTableNotExists(s);
    const n = this.allocateTableIdx(), i = e.columns, o = {}, r = {}, l = {};
    let a = 0;
    for (const c of i) {
      const d = a++;
      o[d] = c.name, r[c.name] = d;
      const m = {
        name: c.name,
        type: c.type,
        primitiveKey: c.primitiveKey || !1,
        defaultValue: c.defaultValue,
        comment: c.comment || ""
      };
      l[d] = m;
    }
    const u = {
      tableName: s,
      id2fieldName: o,
      fieldName2id: r,
      columnSchemas: l,
      counter: a,
      comment: e.comment || ""
    };
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [n]: u }, this.structure.tableName2Idx = { ...this.structure.tableName2Idx, [s]: n }, {
      success: !0,
      message: `Table '${s}' created successfully`,
      data: 0,
      type: Z.DDL
    };
  }
  executeAlterTable(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.structure.tableSchemas[n];
    switch (e.opType) {
      case "ADD_COLUMN":
        return this.addColumn(i, s, e.columnDef);
      case "DROP_COLUMN":
        return this.removeColumn(i, s, e.columnName);
      case "RENAME":
        return this.renameTable(i, n, s, e.newTableName);
      case "RENAME_COLUMN":
        return this.renameColumn(i, s, e.columnName, e.newColumnName);
      case "MODIFY_COLUMN_COMMENT":
        return this.modifyColumnComment(i, s, e.columnName, e.comment);
      case "MODIFY_COLUMN_PRIMITIVE_KEY":
        return this.modifyColumnPrimitiveKey(i, s, e.columnName, e.columnDef);
      case "ALTER_TABLE_COMMENT":
        return this.modifyTableComment(i, s, e.comment);
    }
    throw new Error("Invalid ALTER TABLE statement");
  }
  executeDropTable(e) {
    const s = e.tableName, n = this.validateTableExists(s), { [n]: i, ...o } = this.structure.tableSchemas, { [s]: r, ...l } = this.structure.tableName2Idx;
    return this.structure.tableSchemas = o, this.structure.tableName2Idx = l, this.dataStorage.setTableData(n, []), Object.keys(this.structure.tableSchemas).length === 0 && (this.structure.tableIdxCounter = 0), {
      success: !0,
      message: `Table '${s}' dropped`,
      data: 0,
      type: Z.DDL
    };
  }
  addColumn(e, s, n) {
    if (e.fieldName2id[n.name] !== void 0)
      throw new Re(
        `Column '${n.name}' already exists in table '${s}'`,
        `ALTER TABLE ${s} ADD COLUMN ${n.name}`
      );
    const i = e.counter, o = {
      name: n.name,
      type: n.type,
      primitiveKey: n.primitiveKey || !1,
      defaultValue: n.defaultValue,
      comment: n.comment || ""
    };
    e.id2fieldName = { ...e.id2fieldName, [i]: o.name }, e.fieldName2id = { ...e.fieldName2id, [o.name]: i }, e.columnSchemas = { ...e.columnSchemas, [i]: o }, e.counter = i + 1;
    const r = { ...e }, l = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [l]: r }, {
      success: !0,
      message: `Column '${n.name}' added to table '${s}'`,
      data: 0,
      type: Z.DDL
    };
  }
  removeColumn(e, s, n) {
    const i = e.fieldName2id[n];
    if (i === void 0)
      throw new Re(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} DROP COLUMN ${n}`
      );
    const { [i]: o, ...r } = e.id2fieldName, { [n]: l, ...a } = e.fieldName2id, { [i]: u, ...c } = e.columnSchemas;
    e.id2fieldName = r, e.fieldName2id = a, e.columnSchemas = c;
    const d = { ...e }, m = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [m]: d }, {
      success: !0,
      message: `Column '${n}' dropped from table '${s}'`,
      data: 0,
      type: Z.DDL
    };
  }
  renameTable(e, s, n, i) {
    if (!i)
      throw new Re("New table name is required", `ALTER TABLE ${n} RENAME TO`);
    if (this.getTableIdxByName(i) !== void 0)
      throw new Re(
        `Table '${i}' already exists`,
        `ALTER TABLE ${n} RENAME TO ${i}`
      );
    const o = { ...e, tableName: i }, { [n]: r, ...l } = this.structure.tableName2Idx;
    return this.structure.tableName2Idx = { ...l, [i]: s }, this.structure.tableSchemas = { ...this.structure.tableSchemas, [s]: o }, {
      success: !0,
      message: `Table renamed from '${n}' to '${i}'`,
      data: 0,
      type: Z.DDL
    };
  }
  renameColumn(e, s, n, i) {
    if (!n || !i)
      throw new Re("Column names are required", `ALTER TABLE ${s} RENAME COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Re(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} RENAME COLUMN ${n} TO ${i}`
      );
    if (e.fieldName2id[i] !== void 0)
      throw new Re(
        `Column '${i}' already exists in table '${s}'`,
        `ALTER TABLE ${s} RENAME COLUMN ${n} TO ${i}`
      );
    const { [n]: r, ...l } = e.fieldName2id, a = { ...e.id2fieldName, [o]: i }, u = e.columnSchemas[o], c = {
      name: i,
      type: u.type,
      primitiveKey: u.primitiveKey,
      defaultValue: u.defaultValue,
      comment: u.comment
    }, { [o]: d, ...m } = e.columnSchemas, h = { ...m, [o]: c };
    e.fieldName2id = { ...l, [i]: o }, e.id2fieldName = a, e.columnSchemas = h;
    const E = { ...e }, y = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [y]: E }, {
      success: !0,
      message: `Column '${n}' renamed to '${i}' in table '${s}'`,
      data: 0,
      type: Z.DDL
    };
  }
  modifyColumnComment(e, s, n, i) {
    if (!n)
      throw new Re("Column name is required", `ALTER TABLE ${s} MODIFY COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Re(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} MODIFY COLUMN ${n}`
      );
    const r = e.columnSchemas[o], l = {
      name: r.name,
      type: r.type,
      primitiveKey: r.primitiveKey,
      defaultValue: r.defaultValue,
      comment: i
    }, { [o]: a, ...u } = e.columnSchemas;
    e.columnSchemas = { ...u, [o]: l };
    const c = { ...e }, d = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [d]: c }, {
      success: !0,
      message: `Column '${n}' comment updated in table '${s}'`,
      data: 0,
      type: Z.DDL
    };
  }
  modifyTableComment(e, s, n) {
    const i = { ...e, comment: n }, o = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [o]: i }, {
      success: !0,
      message: `Table '${s}' comment updated`,
      data: 0,
      type: Z.DDL
    };
  }
  modifyColumnPrimitiveKey(e, s, n, i) {
    if (!n)
      throw new Re("Column name is required", `ALTER TABLE ${s} MODIFY COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Re(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} MODIFY COLUMN ${n}`
      );
    const r = e.columnSchemas[o], l = {
      name: r.name,
      type: r.type,
      primitiveKey: i.primitiveKey,
      defaultValue: r.defaultValue,
      comment: i.comment !== void 0 ? i.comment : r.comment
    }, { [o]: a, ...u } = e.columnSchemas;
    e.columnSchemas = { ...u, [o]: l };
    const c = { ...e }, d = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [d]: c }, {
      success: !0,
      message: `Column '${n}' primary key updated in table '${s}'`,
      data: 0,
      type: Z.DDL
    };
  }
  allocateTableIdx() {
    return this.structure.tableIdxCounter++;
  }
  validateTableExists(e) {
    const s = this.getTableIdxByName(e);
    if (s === void 0)
      throw new Re(
        `Table '${e}' does not exist`,
        `Table '${e}' does not exist`
      );
    return s;
  }
  validateTableNotExists(e) {
    if (this.getTableIdxByName(e) !== void 0)
      throw new Re(
        `Table '${e}' already exists`,
        `Table '${e}' already exists`
      );
  }
}
class $r {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.validateTableExists = n, this.expressionEvaluator = new pa();
  }
  expressionEvaluator;
  get tableSchemas() {
    return this.structure.tableSchemas;
  }
  executeInsert(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = 0;
    const r = Object.entries(i.columnSchemas).filter(([l, a]) => a.primitiveKey).map(([l, a]) => parseInt(l)).sort((l, a) => l - a);
    for (const l of e.values) {
      const a = {}, u = {}, c = e.columns;
      if (c && c.length > 0)
        for (let d = 0; d < c.length; d++) {
          const m = c[d];
          if (i.fieldName2id[m] === void 0)
            throw new Re(
              `Column '${m}' does not exist in table '${s}'`,
              `INSERT INTO ${s}`
            );
          u[m] = d;
        }
      else {
        const d = Object.entries(i.columnSchemas).filter(([m]) => !isNaN(parseInt(m))).sort((m, h) => parseInt(m[0]) - parseInt(h[0]));
        for (let m = 0; m < d.length; m++) {
          const h = d[m];
          if (!h) continue;
          const [E, y] = h;
          u[y.name] = m;
        }
      }
      for (const [d, m] of Object.entries(i.columnSchemas)) {
        const h = parseInt(d), E = m.name, y = u[E];
        if (y !== void 0) {
          const N = l[y], b = this.expressionEvaluator.evaluateExpression(N, i, n, null);
          b === null && m.defaultValue !== void 0 ? a[h] = m.defaultValue : a[h] = b;
        } else m.defaultValue !== void 0 ? a[h] = m.defaultValue : a[h] = null;
      }
      if (r.length > 0) {
        const d = this.dataStorage.getTableData(n), m = d.find((h) => r.every((E) => JSON.stringify(h[E]) === JSON.stringify(a[E])));
        if (m) {
          for (const [h] of Object.entries(u)) {
            const E = i.fieldName2id[h];
            if (E !== void 0) {
              const y = a[E];
              m[E] = y !== void 0 ? y : null;
            }
          }
          this.dataStorage.setTableData(n, d);
        } else
          d.push(a), this.dataStorage.setTableData(n, d);
      } else {
        const d = this.dataStorage.getTableData(n);
        d.push(a), this.dataStorage.setTableData(n, d);
      }
      o++;
    }
    return {
      success: !0,
      message: `Inserted ${o} row(s) into '${s}'`,
      data: o,
      type: Z.DML
    };
  }
  executeUpdate(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = 0;
    const r = this.dataStorage.getTableData(n);
    for (const l of r)
      if (e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, l)) {
        for (const u of e.sets) {
          const c = i.fieldName2id[u.column];
          if (c === void 0)
            throw new Re(
              `Column '${u.column}' does not exist in table '${s}'`,
              `UPDATE ${s}`
            );
          const d = this.expressionEvaluator.evaluateExpression(u.value, i, n, l);
          l[c] = d;
        }
        o++;
      }
    return this.dataStorage.setTableData(n, r), {
      success: !0,
      message: `Updated ${o} row(s) in '${s}'`,
      data: o,
      type: Z.DML
    };
  }
  executeDelete(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n], o = this.dataStorage.getTableData(n), r = [];
    for (const a of o)
      e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, a) || r.push(a);
    const l = o.length - r.length;
    return this.dataStorage.setTableData(n, r), {
      success: !0,
      message: `Deleted ${l} row(s) from '${s}'`,
      data: l,
      type: Z.DML
    };
  }
  executeAppend(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n], o = e.columns, r = e.values;
    if (o.length !== r.length)
      throw new Re(
        `Number of columns (${o.length}) does not match number of values (${r.length})`,
        `APPEND INTO ${s}`
      );
    const l = [];
    for (let c = 0; c < o.length; c++) {
      const d = o[c], m = i.fieldName2id[d];
      if (m === void 0)
        throw new Re(
          `Column '${d}' does not exist in table '${s}'`,
          `APPEND INTO ${s}`
        );
      const h = i.columnSchemas[m];
      if (!h)
        throw new Re(
          `Column '${d}' does not exist in table '${s}'`,
          `APPEND INTO ${s}`
        );
      if (h.primitiveKey)
        throw new Re(
          `Cannot APPEND to primary key column '${d}'`,
          `APPEND INTO ${s}`
        );
      if (h.type !== Lt.STRING)
        throw new Re(
          `Column '${d}' must be STRING type for APPEND operation`,
          `APPEND INTO ${s}`
        );
      l.push({
        fieldIdx: m,
        colSchema: h,
        valueExpr: r[c]
      });
    }
    let a = 0;
    const u = this.dataStorage.getTableData(n);
    for (const c of u)
      if (e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, c)) {
        for (const m of l) {
          let h = c[m.fieldIdx];
          h == null && (h = "");
          const E = this.expressionEvaluator.evaluateExpression(m.valueExpr, i, n, c);
          c[m.fieldIdx] = h + E;
        }
        a++;
      }
    return this.dataStorage.setTableData(n, u), {
      success: !0,
      message: `Appended to ${a} row(s) in '${s}'`,
      data: a,
      type: Z.DML
    };
  }
}
class Ar {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.validateTableExists = n, this.expressionEvaluator = new pa();
  }
  expressionEvaluator;
  get tableSchemas() {
    return this.structure.tableSchemas;
  }
  executeSelect(e) {
    const s = e.from, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = this.dataStorage.getTableData(n);
    e.where && (o = o.filter(
      (l) => this.expressionEvaluator.evaluateWhere(e.where, i, n, l)
    ));
    const r = [];
    for (const l of o) {
      const a = {};
      for (const u of e.columns)
        if (u.type === "star")
          for (const [c, d] of Object.entries(i.id2fieldName)) {
            const m = parseInt(c);
            a[d] = l[m];
          }
        else if (u.type === "column") {
          const c = (u.tableName, u.name), d = i.fieldName2id[c];
          d !== void 0 && (a[c] = l[d]);
        }
      r.push(a);
    }
    if (e.orderBy) {
      const l = e.orderBy[0];
      if (l) {
        const a = l.column;
        i.fieldName2id[a] !== void 0 && r.sort((c, d) => {
          const m = c[a], h = d[a];
          return m === null && h === null ? 0 : m === null ? l.ascending ? -1 : 1 : h === null ? l.ascending ? 1 : -1 : m < h ? l.ascending ? -1 : 1 : m > h ? l.ascending ? 1 : -1 : 0;
        });
      }
    }
    return {
      success: !0,
      message: `Selected ${r.length} row(s)`,
      data: r,
      type: Z.DQL
    };
  }
}
class fs {
  static newExecutor() {
    return new xo();
  }
  static newStorage() {
    return new So();
  }
}
class oe {
  static COMMITTED_START_TAG = "<committed>";
  static COMMITTED_END_TAG = "</committed>";
  static COMMIT_START_TAG = "<commit>";
  static COMMIT_END_TAG = "</commit>";
  static ERROR_START_TAG = "<error>";
  static ERROR_END_TAG = "</error>";
  static getCommitted() {
    const s = SillyTavern.getContext()?.chat || [], n = /* @__PURE__ */ new Map();
    for (let i = 0; i < s.length; i++) {
      const o = s[i];
      if (o?.mes) {
        const r = this.extractTagContent(o.mes, oe.COMMITTED_START_TAG, oe.COMMITTED_END_TAG);
        r && n.set(i, r);
      }
    }
    return n;
  }
  static processMessage(e, s, n, i) {
    const o = SillyTavern.getContext(), l = (o?.chat || [])[e];
    if (!l)
      return;
    const a = l.mes || "", u = this.extractTagContent(a, s, n), c = i(u);
    if (u === null)
      l.mes = a + c;
    else {
      const d = a.lastIndexOf(n), m = a.lastIndexOf(s, d), h = a.substring(0, m), E = a.substring(d + n.length);
      l.mes = h + c + E;
    }
    o?.saveChat();
  }
  static processCommit(e, s) {
    return oe.processMessage(e, oe.COMMIT_START_TAG, oe.COMMIT_END_TAG, s);
  }
  static processCommitted(e, s) {
    return oe.processMessage(e, oe.COMMITTED_START_TAG, oe.COMMITTED_END_TAG, s);
  }
  static processLastCommitted(e) {
    const s = SillyTavern.getContext();
    (s?.chat || []).length == 0 && s?.chat.push({
      id: 0,
      name: "",
      role: "assistant",
      mes: "",
      date: Date.now()
    }), this.processCommitted(s?.chat.length - 1, e);
  }
  static processError(e, s) {
    return oe.processMessage(e, oe.ERROR_START_TAG, oe.ERROR_END_TAG, s);
  }
  static processLastError(e) {
    const s = SillyTavern.getContext();
    return (s?.chat || []).length == 0 && s?.chat.push({
      id: 0,
      name: "",
      role: "assistant",
      mes: "",
      date: Date.now()
    }), oe.processMessage(s?.chat.length - 1, oe.ERROR_START_TAG, oe.ERROR_END_TAG, e);
  }
  static extractCommit(e) {
    return this.extractTagContent(e, oe.COMMIT_START_TAG, oe.COMMIT_END_TAG);
  }
  static extractCommitted(e) {
    return this.extractTagContent(e, oe.COMMITTED_START_TAG, oe.COMMITTED_END_TAG);
  }
  static replaceCommitWithCommitted(e, s) {
    const n = SillyTavern.getContext(), o = (n?.chat || [])[e];
    if (!o)
      return;
    let r = o.mes || "";
    const l = r.lastIndexOf(oe.COMMIT_END_TAG);
    if (l !== -1) {
      const u = r.lastIndexOf(oe.COMMIT_START_TAG, l);
      if (u !== -1) {
        const c = r.substring(0, u), d = r.substring(l + oe.COMMIT_END_TAG.length), m = /\s$/.test(c), h = /^\s/.test(d);
        m && h ? r = c.replace(/\s$/, "") + d : r = c + d;
      }
    }
    const a = r.lastIndexOf(oe.COMMITTED_END_TAG);
    if (a !== -1) {
      const u = r.lastIndexOf(oe.COMMITTED_START_TAG, a);
      if (u !== -1) {
        const c = r.substring(0, u), d = r.substring(a + oe.COMMITTED_END_TAG.length);
        r = c + oe.COMMITTED_START_TAG + s + oe.COMMITTED_END_TAG + d;
      }
    } else
      r = r + oe.COMMITTED_START_TAG + s + oe.COMMITTED_END_TAG;
    o.mes = r, n?.saveChat();
  }
  static replaceCommitWithError(e, s) {
    const n = SillyTavern.getContext(), o = (n?.chat || [])[e];
    if (!o)
      return;
    let r = o.mes || "";
    const l = r.lastIndexOf(oe.COMMIT_END_TAG);
    if (l !== -1) {
      const u = r.lastIndexOf(oe.COMMIT_START_TAG, l);
      if (u !== -1) {
        const c = r.substring(0, u), d = r.substring(l + oe.COMMIT_END_TAG.length), m = /\s$/.test(c), h = /^\s/.test(d);
        m && h ? r = c.replace(/\s$/, "") + d : r = c + d;
      }
    }
    const a = r.lastIndexOf(oe.ERROR_END_TAG);
    if (a !== -1) {
      const u = r.lastIndexOf(oe.ERROR_START_TAG, a);
      if (u !== -1) {
        const c = r.substring(0, u), d = r.substring(a + oe.ERROR_END_TAG.length);
        r = c + oe.ERROR_START_TAG + s + oe.ERROR_END_TAG + d;
      }
    } else
      r = r + oe.ERROR_START_TAG + s + oe.ERROR_END_TAG;
    o.mes = r, n?.saveChat();
  }
  static extractTagContent(e, s, n) {
    const i = e.lastIndexOf(n);
    if (i === -1) return null;
    const o = e.lastIndexOf(s, i);
    return o === -1 ? null : e.substring(o + s.length, i).trim() || null;
  }
}
class Mr {
  static validateSql(e) {
    const s = [], n = ss.parse(e);
    for (const o of n.errors)
      s.push(o);
    const i = e.split(";").map((o) => o.trim()).filter((o) => o.length > 0);
    for (const o of i) {
      const r = this.checkBasicSyntax(o);
      s.push(...r);
    }
    return s;
  }
  static checkBasicSyntax(e) {
    const s = [];
    (e.match(/'/g) || []).length % 2 !== 0 && s.push(`SQL : ${e}`);
    const i = [];
    let o = !1, r = 0;
    for (; r < e.length; ) {
      const l = e[r], a = e[r + 1];
      if (l === "'" && (!o || o && (a !== "'" || e[r - 1] === "'")) && (o = !o), !o) {
        if (l === "(")
          i.push("(");
        else if (l === ")") {
          if (i.length === 0)
            return s.push(`SQL : ${e}`), s;
          i.pop();
        }
      }
      r++;
    }
    return i.length > 0 && s.push(`SQL : ${e}`), s;
  }
  static compressDml(e, s) {
    let n = e;
    const i = Object.entries(s);
    i.sort((o, r) => {
      const [, l] = o, [, a] = r;
      return a.tableName.length - l.tableName.length;
    });
    for (const [o, r] of i) {
      const l = parseInt(o), a = r.tableName, u = `@t${l}`, c = Object.entries(r.columnSchemas);
      c.sort((d, m) => {
        const [, h] = d, [, E] = m;
        return E.name.length - h.name.length;
      });
      for (const [d, m] of c) {
        const h = parseInt(d), E = m.name, y = `@t${l}c${h}`;
        n = n.replace(new RegExp(`\\b${E.replace(/@/g, "\\@")}\\b`, "g"), y);
      }
      n = n.replace(new RegExp(`\\b${a.replace(/@/g, "\\@")}\\b`, "g"), u);
    }
    return n;
  }
  static decompressDml(e, s) {
    let n = e;
    const i = Object.entries(s);
    i.sort((o, r) => {
      const [l] = o, [a] = r;
      return a.length - l.length;
    });
    for (const [o, r] of i) {
      const l = parseInt(o), a = r.tableName, u = `@t${l}`, c = Object.entries(r.columnSchemas);
      c.sort((d, m) => {
        const [h] = d, [E] = m;
        return E.length - h.length;
      });
      for (const [d, m] of c) {
        const h = parseInt(d), E = m.name, y = `@t${l}c${h}`;
        n = n.replace(new RegExp(y.replace(/@/g, "\\@"), "g"), E);
      }
      n = n.replace(new RegExp(u.replace(/@/g, "\\@"), "g"), a);
    }
    return n;
  }
}
class ha {
  static show(e, s = "info", n) {
    try {
      const i = window.toastr;
      i && typeof i[s] == "function" ? i[s](e, n) : console.warn(`[ToastUtil] toastr not available, message: ${e}`);
    } catch (i) {
      console.warn("[ToastUtil] Failed to show toast:", i);
    }
  }
  static success(e, s) {
    this.show(e, "success", s);
  }
  static error(e, s) {
    this.show(e, "error", s);
  }
  static warning(e, s) {
    this.show(e, "warning", s);
  }
  static info(e, s) {
    this.show(e, "info", s);
  }
}
class Vr {
  tableTemplate;
  constructor(e) {
    this.tableTemplate = e.clone();
  }
  getTables() {
    return this.tableTemplate.getTables();
  }
  clone() {
    return this.tableTemplate.clone();
  }
  compressDml(e) {
    const s = this.getTableSchemas();
    return Mr.compressDml(e, s);
  }
  decompressDml(e) {
    const s = this.getTableSchemas();
    return Mr.decompressDml(e, s);
  }
  getTableSchemas() {
    const e = this.getTables(), s = {};
    for (const n of e) {
      const i = this.getTableIdxByName(n.tableName);
      i !== void 0 && (s[i] = n);
    }
    return s;
  }
  execute(e, s) {
    const n = e.split(";").map((l) => l.trim()).filter((l) => l.length > 0);
    if (n.length === 0)
      return { success: !0, message: "SQL", data: 0, type: Z.DML };
    let i = 0, o = [], r = [];
    for (const l of n) {
      const a = this.detectSqlType(l);
      if (!s.includes(a))
        throw new Error(`SQL ${s.join("  ")} ${a}`);
      if (a === Z.DML)
        r.length > 0 && (this.tableTemplate.execute(r.join(`;
`), [Z.DDL]), r = []), o.push(l);
      else if (a === Z.DDL)
        o.length > 0 && (i += this.executeDml(o.join(`;
`)), o = []), r.push(l);
      else if (a === Z.DQL)
        return r.length > 0 && (this.tableTemplate.execute(r.join(`;
`), [Z.DDL]), r = []), o.length > 0 && (i += this.executeDml(o.join(`;
`)), o = []), this.storage.execute(l, [Z.DQL]);
    }
    return r.length > 0 && this.tableTemplate.execute(r.join(`;
`), [Z.DDL]), o.length > 0 && (i += this.executeDml(o.join(`;
`))), { success: !0, message: "", data: i, type: Z.DML };
  }
  detectSqlType(e) {
    const s = e.trim().toUpperCase();
    if (/^CREATE\s+TABLE|^ALTER\s+TABLE|^DROP\s+TABLE/i.test(s))
      return Z.DDL;
    if (/^SELECT/i.test(s))
      return Z.DQL;
    if (/^INSERT|^UPDATE|^DELETE|^APPEND/i.test(s))
      return Z.DML;
    throw new Error(`SQL: ${e}`);
  }
  executeDml(e) {
    const s = this.compressDml(e);
    return oe.processLastCommitted((n) => {
      const i = n || "";
      return `<committed>${i ? `${i};
${s}` : s}</committed>`;
    }), e.split(";").map((n) => n.trim()).filter((n) => n.length > 0).length;
  }
  export(e, s) {
    return this.storage.export(e, s);
  }
  get storage() {
    const e = Date.now(), s = oe.getCommitted(), n = this.tableTemplate.clone();
    for (const [i, o] of s.entries())
      try {
        n.execute(this.decompressDml(o), [Z.DML]);
      } catch (r) {
        const l = r instanceof Error ? r.message : "";
        return ha.error(` ${i}  SQL : ${l}`), n;
      }
    return console.log(` ${Date.now() - e} ms`), n;
  }
  getDataStorage() {
    return this.storage.getDataStorage();
  }
  getTableIdxByName(e) {
    return this.tableTemplate.getTableIdxByName(e);
  }
  getTableNameByIdx(e) {
    return this.tableTemplate.getTableNameByIdx(e);
  }
  setDataStorage(e) {
  }
  serialize() {
    return this.tableTemplate.serialize();
  }
  deserialize(e) {
    this.tableTemplate.deserialize(e);
  }
}
function Yi(t, e) {
  return new Proxy(t, {
    get(s, n) {
      const i = s[n];
      return typeof i == "function" && n === "execute" ? function(...o) {
        const r = i.apply(s, o);
        return e(), r;
      } : i;
    }
  });
}
class Se {
  static MODULE_NAME = "ST_BETTER_DATABASE";
  static _instance = new Se();
  _tableTemplateCache = null;
  _tableTemplateProxy = null;
  _chatStatusBarSwitch = !1;
  _chatStatusBarCode = "";
  _extensionSwitch = !1;
  _debugMode = !1;
  _systemSqlExecutorCache = null;
  _systemSqlExecutorProxy = null;
  _chatStatusBarChangeListeners = /* @__PURE__ */ new Set();
  constructor() {
    const { extensionSettings: e } = SillyTavern.getContext();
    e[Se.MODULE_NAME] || (e[Se.MODULE_NAME] = {
      tableTemplate: null,
      chatStatusBarSwitch: !1,
      chatStatusBarCode: "",
      extensionSwitch: !1,
      debugMode: !1,
      systemSqlExecutor: null
    }), this._loadFromSettings();
  }
  _loadFromSettings() {
    const { extensionSettings: e } = SillyTavern.getContext(), s = e[Se.MODULE_NAME];
    if (s) {
      if (s.tableTemplate)
        try {
          this._tableTemplateCache = fs.newExecutor(), this._tableTemplateCache.deserialize(s.tableTemplate);
        } catch {
          this._tableTemplateCache = null;
        }
      if (this._chatStatusBarSwitch = s.chatStatusBarSwitch ?? !1, this._chatStatusBarCode = s.chatStatusBarCode ?? "", this._extensionSwitch = s.extensionSwitch ?? !1, this._debugMode = s.debugMode ?? !1, s.systemSqlExecutor)
        try {
          this._systemSqlExecutorCache = fs.newExecutor(), this._systemSqlExecutorCache.deserialize(s.systemSqlExecutor);
        } catch {
          this._systemSqlExecutorCache = null;
        }
    }
  }
  _saveToSettings() {
    const { extensionSettings: e } = SillyTavern.getContext();
    let s = e[Se.MODULE_NAME];
    s || (s = {
      tableTemplate: null,
      chatStatusBarSwitch: !1,
      chatStatusBarCode: "",
      extensionSwitch: !1,
      debugMode: !1,
      systemSqlExecutor: null
    }, e[Se.MODULE_NAME] = s), s.tableTemplate = this._tableTemplateCache?.serialize(), s.chatStatusBarSwitch = this._chatStatusBarSwitch, s.chatStatusBarCode = this._chatStatusBarCode, s.extensionSwitch = this._extensionSwitch, s.debugMode = this._debugMode, s.systemSqlExecutor = this._systemSqlExecutorCache?.serialize(), SillyTavern.getContext().saveSettingsDebounced();
  }
  get tableTemplate() {
    return this._tableTemplateCache || (this._tableTemplateCache = fs.newExecutor()), this._tableTemplateProxy || (this._tableTemplateProxy = Yi(this._tableTemplateCache, () => this._saveToSettings())), this._tableTemplateProxy;
  }
  set tableTemplate(e) {
    if (typeof e == "object" && "serialize" in e) {
      const s = e.serialize();
      this._tableTemplateCache = fs.newExecutor(), this._tableTemplateCache.deserialize(s);
    } else
      this._tableTemplateCache = e;
    this._tableTemplateProxy = null, this._saveToSettings();
  }
  get chatStatusBarSwitch() {
    return this._chatStatusBarSwitch;
  }
  set chatStatusBarSwitch(e) {
    this._chatStatusBarSwitch !== e && (this._chatStatusBarSwitch = e, this._saveToSettings(), this._notifyChatStatusBarChange());
  }
  onChatStatusBarChange(e) {
    return this._chatStatusBarChangeListeners.add(e), () => this._chatStatusBarChangeListeners.delete(e);
  }
  _notifyChatStatusBarChange() {
    this._chatStatusBarChangeListeners.forEach((e) => e());
  }
  get chatStatusBarCode() {
    return this._chatStatusBarCode;
  }
  set chatStatusBarCode(e) {
    this._chatStatusBarCode = e, this._saveToSettings(), this._notifyChatStatusBarChange();
  }
  get extensionSwitch() {
    return this._extensionSwitch;
  }
  set extensionSwitch(e) {
    this._extensionSwitch = e, this._saveToSettings();
  }
  get debugMode() {
    return this._debugMode;
  }
  set debugMode(e) {
    this._debugMode = e, this._saveToSettings();
  }
  get systemSqlExecutor() {
    return this._systemSqlExecutorCache || (this._systemSqlExecutorCache = fs.newExecutor()), this._systemSqlExecutorProxy || (this._systemSqlExecutorProxy = Yi(this._systemSqlExecutorCache, () => this._saveToSettings())), this._systemSqlExecutorProxy;
  }
  set systemSqlExecutor(e) {
    if (typeof e == "object" && "serialize" in e) {
      const s = e.serialize();
      this._systemSqlExecutorCache = fs.newExecutor(), this._systemSqlExecutorCache.deserialize(s);
    } else
      this._systemSqlExecutorCache = e;
    this._systemSqlExecutorProxy = null, this._saveToSettings();
  }
  static get instance() {
    return Se._instance;
  }
}
class Pe {
  static MODULE_NAME = "ST_BETTER_DATABASE";
  /**
   *  null 
   *
   * 
   * -  readonly _instance = new ChatMetaManager()
   * -  SillyTavern.getContext() 
   * -  chatMetadata 
   */
  static _instance = null;
  /**
   * 
   *  object  SimpleSqlExecutor.serialize() 
   * 
   */
  _serializedTemplateCache = null;
  /**
   * SqlExecutor 
   *  tableTemplate  _serializedTemplateCache 
   * 
   */
  _tableTemplateCache = null;
  /**
   * 
   *  execute  _saveToMetadata()
   */
  _tableTemplateProxy = null;
  constructor() {
    const { chatMetadata: e } = SillyTavern.getContext();
    e[Pe.MODULE_NAME] || (e[Pe.MODULE_NAME] = {
      tableTemplate: null
    }), this._loadFromMetadata();
  }
  /**
   *  chatMetadata 
   *
   *  SillyTavern.getContext().chatMetadata
   * chatMetadata 
   */
  _loadFromMetadata() {
    const { chatMetadata: e } = SillyTavern.getContext(), s = e[Pe.MODULE_NAME];
    if (!s || !s.tableTemplate) {
      const n = Se.instance.tableTemplate, i = new Vr(n);
      this._serializedTemplateCache = i.serialize();
    } else
      this._serializedTemplateCache = s.tableTemplate;
    this._tableTemplateCache = null, this._tableTemplateProxy = null;
  }
  /**
   *  chatMetadata
   *
   *  SillyTavern.getContext().chatMetadata
   * chatMetadata 
   */
  _saveToMetadata() {
    const { chatMetadata: e } = SillyTavern.getContext(), s = e[Pe.MODULE_NAME] || {};
    s.tableTemplate = this._serializedTemplateCache, e[Pe.MODULE_NAME] = s, SillyTavern.getContext().saveMetadata();
  }
  get tableTemplate() {
    if (!this._tableTemplateCache && this._serializedTemplateCache) {
      const e = Se.instance.tableTemplate;
      this._tableTemplateCache = new Vr(e), this._tableTemplateCache.deserialize(this._serializedTemplateCache);
    }
    return !this._tableTemplateProxy && this._tableTemplateCache && (this._tableTemplateProxy = Yi(this._tableTemplateCache, () => {
      this._saveToMetadata();
    })), this._tableTemplateProxy || Se.instance.tableTemplate;
  }
  set tableTemplate(e) {
    typeof e == "object" && "serialize" in e ? this._serializedTemplateCache = e.serialize() : this._serializedTemplateCache = e, this._tableTemplateCache = null, this._tableTemplateProxy = null, this._saveToMetadata();
  }
  /**
   * 
   *
   * 
   *  SillyTavern.getContext() 
   */
  static get instance() {
    return Pe._instance || (Pe._instance = new Pe()), Pe._instance;
  }
  /**
   * 
   *
   *  chatMetadata 
   *
   * chatMetadata 
   * 
   */
  reload() {
    this._tableTemplateCache = null, this._tableTemplateProxy = null, this._loadFromMetadata();
  }
}
const Cn = "chatTemplateContainer", om = "chat";
class Vt {
  static _instance = null;
  constructor() {
  }
  static getInstance() {
    return Vt._instance || (Vt._instance = new Vt()), Vt._instance;
  }
  updateChatTemplateDisplay() {
    const e = Se.instance;
    if (!e.chatStatusBarSwitch) {
      this.removeTemplateContainer();
      return;
    }
    const s = e.chatStatusBarCode.trim();
    if (!s) {
      this.removeTemplateContainer();
      return;
    }
    this.renderTemplateToChat(s);
  }
  removeTemplateContainer() {
    const e = document.getElementById(Cn);
    e && e.remove();
  }
  renderTemplateToChat(e) {
    const s = this.escapeIframeContent(e), n = document.getElementById(om);
    if (!n) return;
    const i = document.getElementById(Cn);
    i && i.remove(), n.insertAdjacentHTML("beforeend", `<div class="wide100p" id="${Cn}">${s}</div>`);
    const o = document.getElementById(Cn);
    o && this.attachTouchEventHandlers(o);
  }
  attachTouchEventHandlers(e) {
    const s = (n) => n.stopPropagation();
    e.addEventListener("touchstart", s, { passive: !1 }), e.addEventListener("touchmove", s, { passive: !1 }), e.addEventListener("touchend", s, { passive: !1 });
  }
  escapeIframeContent(e) {
    return e.replace(/<iframe\b([^>]*)>([\s\S]*?)<\/iframe>/gi, (s, n, i) => {
      if (/\bsrcdoc=/i.test(n))
        return s;
      const o = i.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      return `<iframe${n} srcdoc="${o}"></iframe>`;
    });
  }
}
class en {
  static instance;
  constructor() {
  }
  static init() {
    if (Se.instance.extensionSwitch && !en.instance) {
      const e = new en();
      e.registerEventListeners(), en.instance = e;
    }
  }
  registerEventListeners() {
    const e = SillyTavern.getContext(), { eventSource: s, event_types: n } = e;
    s.on(n.MESSAGE_RECEIVED, (i) => this.onMessageReceived(i)), s.on(n.MESSAGE_EDITED, (i) => this.onMessageEdited(i)), s.on(n.MESSAGE_DELETED, (i) => this.onMessageDeleted()), s.on(n.CHAT_CHANGED, () => this.onChatChanged());
  }
  onMessageReceived(e) {
    this.processMessage(e), Vt.getInstance().updateChatTemplateDisplay();
  }
  onMessageEdited(e) {
    this.processMessage(e), Vt.getInstance().updateChatTemplateDisplay();
  }
  onMessageDeleted() {
    Vt.getInstance().updateChatTemplateDisplay();
  }
  onChatChanged() {
    Pe.instance.reload(), Vt.getInstance().updateChatTemplateDisplay();
  }
  processMessage(e) {
    const i = (SillyTavern.getContext().chat || [])[e];
    if (!i || !i.mes)
      return;
    const o = oe.extractCommit(i.mes);
    if (o)
      try {
        const r = Pe.instance.tableTemplate, l = r.compressDml(o), a = oe.extractCommitted(i.mes);
        let u = "";
        a && (u = a);
        const c = r.clone();
        u && c.execute(r.decompressDml(u), [Z.DML]), c.execute(o, [Z.DML]);
        const d = u ? `${u};
${l}` : l;
        oe.replaceCommitWithCommitted(e, d);
      } catch (r) {
        const l = r instanceof Error ? r.message : "";
        console.error("[ChatMessageHandler] Failed to execute DML:", r), ha.error(` ${e}  DML : ${l}`), oe.replaceCommitWithError(e, o);
        return;
      }
  }
}
class $s {
  root;
  currentCondition;
  static of() {
    return new $s();
  }
  eq(e, s) {
    const n = `${e} = ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  ne(e, s) {
    const n = `${e} != ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  gt(e, s) {
    const n = `${e} > ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  lt(e, s) {
    const n = `${e} < ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  ge(e, s) {
    const n = `${e} >= ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  le(e, s) {
    const n = `${e} <= ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  between(e, s, n) {
    const i = `${e} BETWEEN ${this.formatValue(s)} AND ${this.formatValue(n)}`;
    return this.addCondition({ type: "condition", sql: i });
  }
  notBetween(e, s, n) {
    const i = `${e} NOT BETWEEN ${this.formatValue(s)} AND ${this.formatValue(n)}`;
    return this.addCondition({ type: "condition", sql: i });
  }
  in(e, s) {
    const n = s.map((o) => this.formatValue(o)).join(", "), i = `${e} IN (${n})`;
    return this.addCondition({ type: "condition", sql: i });
  }
  notIn(e, s) {
    const n = s.map((o) => this.formatValue(o)).join(", "), i = `${e} NOT IN (${n})`;
    return this.addCondition({ type: "condition", sql: i });
  }
  isNull(e) {
    const s = `${e} IS NULL`;
    return this.addCondition({ type: "condition", sql: s });
  }
  isNotNull(e) {
    const s = `${e} IS NOT NULL`;
    return this.addCondition({ type: "condition", sql: s });
  }
  and(e) {
    return this.combine("and", e);
  }
  or(e) {
    return this.combine("or", e);
  }
  addCondition(e) {
    return this.currentCondition ? this.currentCondition = { type: "and", left: this.currentCondition, right: e } : this.currentCondition = e, this.root = this.currentCondition, this;
  }
  combine(e, s) {
    const n = s.root || s.currentCondition;
    return n ? (this.currentCondition ? this.currentCondition = { type: e, left: this.currentCondition, right: n } : this.currentCondition = n, this.root = this.currentCondition, this) : this;
  }
  formatValue(e) {
    return e === null ? "NULL" : typeof e == "string" ? `"${e}"` : String(e);
  }
  build() {
    const e = this.root || this.currentCondition;
    return e ? this.buildNode(e) : "";
  }
  buildNode(e) {
    if (e.type === "condition")
      return e.sql;
    const s = this.buildNode(e.left), n = this.buildNode(e.right), i = e.type.toUpperCase();
    return `(${s} ${i} ${n})`;
  }
}
class yn {
  whereCondition;
  orderByClauses = [];
  joins = [];
  where(e) {
    return this.whereCondition = e, this;
  }
  orderBy(e, s = !0) {
    return this.orderByClauses.push(`${e} ${s ? "ASC" : "DESC"}`), this;
  }
  formatValue(e) {
    return e === null ? "NULL" : typeof e == "string" ? `"${e}"` : String(e);
  }
  buildWhere() {
    if (!this.whereCondition) return "";
    const e = this.whereCondition.build();
    return e ? ` WHERE ${e}` : "";
  }
}
class rm extends yn {
  tableName;
  columns = [];
  from(e) {
    return this.tableName = e, this;
  }
  select(...e) {
    return this.columns = e, this;
  }
  join(e, s, n, i) {
    return this.joins.push({ type: e.toString(), table: s, on: `${n} = ${i}` }), this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    let s = `SELECT ${this.columns.length > 0 ? this.columns.join(", ") : "*"} FROM ${this.tableName}`;
    return this.joins.length > 0 && (s += this.joins.map((n) => ` ${n.type} JOIN ${n.table} ON ${n.on}`).join("")), s += this.buildWhere(), this.orderByClauses.length > 0 && (s += ` ORDER BY ${this.orderByClauses.join(", ")}`), s;
  }
}
class lm extends yn {
  tableName;
  values = /* @__PURE__ */ new Map();
  batchValues = [];
  into(e) {
    return this.tableName = e, this;
  }
  set(e, s) {
    return this.values.set(e, s), this;
  }
  setValues(e) {
    return e.forEach((s, n) => this.values.set(n, s)), this;
  }
  batch(e) {
    return this.batchValues = e, this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    const e = this.batchValues.length > 0 ? this.batchValues : [this.values], s = e[0];
    if (!s || s.size === 0)
      throw new Error("No data to insert");
    const n = Array.from(s.keys()).join(", "), i = e.map((o) => `(${Array.from(s.keys()).map((l) => {
      const a = o.get(l);
      return this.formatValue(a !== void 0 ? a : null);
    }).join(", ")})`).join(", ");
    return `INSERT INTO ${this.tableName} (${n}) VALUES ${i}`;
  }
}
class am extends yn {
  tableName;
  sets = /* @__PURE__ */ new Map();
  table(e) {
    return this.tableName = e, this;
  }
  set(e, s) {
    return this.sets.set(e, s), this;
  }
  setValues(e) {
    return e.forEach((s, n) => this.sets.set(n, s)), this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    if (this.sets.size === 0)
      throw new Error("At least one SET clause is required");
    const e = Array.from(this.sets.entries()).map(([s, n]) => `${s} = ${this.formatValue(n)}`).join(", ");
    return `UPDATE ${this.tableName} SET ${e}${this.buildWhere()}`;
  }
}
class cm extends yn {
  tableName;
  from(e) {
    return this.tableName = e, this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    return `DELETE FROM ${this.tableName}${this.buildWhere()}`;
  }
}
class um extends yn {
  tableName;
  columnName;
  appendValue;
  into(e) {
    return this.tableName = e, this;
  }
  column(e) {
    return this.columnName = e, this;
  }
  value(e) {
    return this.appendValue = e, this;
  }
  build() {
    if (!this.tableName || !this.columnName || this.appendValue === void 0)
      throw new Error("Table name, column, and value are required");
    const e = this.formatValue(this.appendValue);
    return `APPEND INTO ${this.tableName} (${this.columnName}) VALUES (${e})${this.buildWhere()}`;
  }
}
class dm {
  static createTable(e, s, n, i) {
    const o = Array.from(s.entries()).map(([l, a]) => {
      let u = `    ${l} ${a}`;
      return i && i.has(l) && (u += ` COMMENT ${this.formatValue(i.get(l))}`), u;
    }).join(`,
`);
    let r = `CREATE TABLE ${e} (
${o}
)`;
    return n && (r += ` COMMENT ${this.formatValue(n)}`), r;
  }
  static alterTableAddColumn(e, s, n, i) {
    let o = `ALTER TABLE ${e} ADD COLUMN ${s} ${n}`;
    return i && (o += ` COMMENT ${this.formatValue(i)}`), o;
  }
  static alterTableDropColumn(e, s) {
    return `ALTER TABLE ${e} DROP COLUMN ${s}`;
  }
  static alterTableRename(e, s) {
    return `ALTER TABLE ${e} RENAME TO ${s}`;
  }
  static alterTableModifyColumnComment(e, s, n, i) {
    return `ALTER TABLE ${e} MODIFY COLUMN ${s} ${n} COMMENT ${this.formatValue(i)}`;
  }
  static alterTableRenameColumn(e, s, n) {
    return `ALTER TABLE ${e} RENAME COLUMN ${s} TO ${n}`;
  }
  static alterTableComment(e, s) {
    return `ALTER TABLE ${e} COMMENT ${this.formatValue(s)}`;
  }
  static dropTable(e) {
    return `DROP TABLE ${e}`;
  }
  static formatValue(e) {
    return `"${e}"`;
  }
}
class rt {
  static select() {
    return new rm();
  }
  static insert() {
    return new lm();
  }
  static update() {
    return new am();
  }
  static delete() {
    return new cm();
  }
  static append() {
    return new um();
  }
  static ddl() {
    return dm;
  }
}
class ma {
  queryData(e, s) {
    const n = rt.select().from(e).where(s || $s.of()).build();
    return this.executor.execute(n, [Z.DQL]);
  }
  insertData(e, s) {
    const n = rt.insert().into(e);
    Array.isArray(s) ? n.batch(s) : n.setValues(s);
    const i = n.build();
    return this.executor.execute(i, [Z.DML]);
  }
  deleteData(e, s) {
    const n = rt.delete().from(e).where(s).build();
    return this.executor.execute(n, [Z.DML]);
  }
  updateData(e, s, n) {
    const i = rt.update().table(e).setValues(s).where(n).build();
    return this.executor.execute(i, [Z.DML]);
  }
  export(e) {
    return this.executor.export(lt.INSERT_SQL, e);
  }
}
class fm extends ma {
  get executor() {
    return Pe.instance.tableTemplate;
  }
}
class wo {
  createTable(e, s, n) {
    const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    s.forEach((l) => {
      const a = l.type + (l.primitiveKey ? " PRIMARY KEY" : "");
      i.set(l.name, a), l.comment && o.set(l.name, l.comment);
    });
    const r = rt.ddl().createTable(e, i, n, o);
    return this.executor.execute(r, [Z.DDL]);
  }
  dropTable(e) {
    const s = rt.ddl().dropTable(e);
    return this.executor.execute(s, [Z.DDL]);
  }
  addColumn(e, s, n) {
    const i = n.type + (n.primitiveKey ? " PRIMARY KEY" : ""), o = rt.ddl().alterTableAddColumn(e, s, i, n.comment);
    return this.executor.execute(o, [Z.DDL]);
  }
  dropColumn(e, s) {
    const n = rt.ddl().alterTableDropColumn(e, s);
    return this.executor.execute(n, [Z.DDL]);
  }
  alterTableName(e, s) {
    const n = rt.ddl().alterTableRename(e, s);
    return this.executor.execute(n, [Z.DDL]);
  }
  alterTableComment(e, s) {
    const n = rt.ddl().alterTableComment(e, s);
    return this.executor.execute(n, [Z.DDL]);
  }
  alterColumnComment(e, s, n) {
    if (this.executor.getTableIdxByName(e) === void 0)
      return {
        success: !1,
        message: `Table ${e} not found`,
        data: 0,
        type: Z.DDL
      };
    const o = rt.ddl().alterTableModifyColumnComment(e, s, "STRING", n);
    return this.executor.execute(o, [Z.DDL]);
  }
  alterColumnName(e, s, n) {
    const i = rt.ddl().alterTableRenameColumn(e, s, n);
    return this.executor.execute(i, [Z.DDL]);
  }
  exportData(e) {
    return this.executor.export(lt.INSERT_SQL, e);
  }
  exportDDL(e) {
    return this.executor.export(lt.DDL, e);
  }
  getTables() {
    return this.executor.getTables();
  }
}
class pm extends wo {
  get executor() {
    return Pe.instance.tableTemplate;
  }
}
class hm extends wo {
  get executor() {
    return Se.instance.tableTemplate;
  }
}
class mm extends ma {
  get executor() {
    return Se.instance.systemSqlExecutor;
  }
}
class bm extends wo {
  get executor() {
    return Se.instance.systemSqlExecutor;
  }
}
class vm {
  execute(e) {
    return Se.instance.systemSqlExecutor.execute(e, [Z.DDL, Z.DML]);
  }
}
class gm {
  syncTableFromTemplate() {
    Se.instance.systemSqlExecutor = Se.instance.tableTemplate.clone();
  }
  pushTableToTemplate() {
    const e = Se.instance.systemSqlExecutor, s = Se.instance.tableTemplate, n = e.serialize();
    s.deserialize({ structure: n.tableTemplate.structure });
  }
}
class Em {
  execute(e) {
    return Pe.instance.tableTemplate.execute(e, [Z.DDL]);
  }
}
class ym {
  execute(e) {
    return Se.instance.tableTemplate.execute(e, [Z.DDL]);
  }
}
class _m {
  /**
   * 
   */
  pushTableToTemplate() {
    const e = Pe.instance.tableTemplate, s = Se.instance.tableTemplate, n = e.serialize();
    s.deserialize({ structure: n.tableTemplate.structure });
  }
  /**
   * 
   */
  syncTableFromTemplate() {
    Pe.instance.tableTemplate = Se.instance.tableTemplate.clone();
  }
}
class ke {
  static _chatDataManagementService = new fm();
  static _chatTableManagementService = new pm();
  static _chatSqlExecutorService = new Em();
  static _templateSqlExecutorService = new ym();
  static _templateTableManagementService = new hm();
  static _chatDatabaseSyncService = new _m();
  static _systemDataManagementService = new mm();
  static _systemTableManagementService = new bm();
  static _systemSqlExecutorService = new vm();
  static _systemDatabaseSyncService = new gm();
  static get chatDataManagementService() {
    return ke._chatDataManagementService;
  }
  static get chatTableManagementService() {
    return ke._chatTableManagementService;
  }
  static get chatSqlExecutorService() {
    return ke._chatSqlExecutorService;
  }
  static get templateSqlExecutorService() {
    return ke._templateSqlExecutorService;
  }
  static get templateTableManagementService() {
    return ke._templateTableManagementService;
  }
  static get chatDatabaseSyncService() {
    return ke._chatDatabaseSyncService;
  }
  static get systemDataManagementService() {
    return ke._systemDataManagementService;
  }
  static get systemTableManagementService() {
    return ke._systemTableManagementService;
  }
  static get systemSqlExecutorService() {
    return ke._systemSqlExecutorService;
  }
  static get systemDatabaseSyncService() {
    return ke._systemDatabaseSyncService;
  }
}
function Tm() {
  const t = te(() => ke.chatDataManagementService), e = te(() => ke.chatTableManagementService), s = te(() => ke.chatSqlExecutorService), n = te(() => ke.chatDatabaseSyncService);
  return {
    dataManagementService: t,
    tableManagementService: e,
    sqlExecutorService: s,
    databaseSyncService: n
  };
}
function Nm() {
  const t = te(() => ke.templateTableManagementService), e = te(() => ke.templateSqlExecutorService);
  return {
    tableManagementService: t,
    sqlExecutorService: e
  };
}
function xm() {
  const t = te(() => ke.systemDataManagementService), e = te(() => ke.systemTableManagementService), s = te(() => ke.systemSqlExecutorService), n = te(() => ke.systemDatabaseSyncService);
  return {
    dataManagementService: t,
    tableManagementService: e,
    sqlExecutorService: s,
    databaseSyncService: n
  };
}
const Sm = /* @__PURE__ */ Te({
  __name: "TemplateManagementPanel",
  props: /* @__PURE__ */ co({
    defaultTabOnTableSelect: { default: "template" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { tableManagementService: n, sqlExecutorService: i } = Nm(), o = uo(t, "visible"), r = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q("template"), a = /* @__PURE__ */ q(""), u = /* @__PURE__ */ q([]), c = /* @__PURE__ */ q(null), d = [
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], m = () => {
      u.value = n.value.getTables();
    }, h = (b) => {
      a.value = b, l.value = s.defaultTabOnTableSelect;
    }, E = () => {
      r.value = !r.value;
    }, y = async () => {
      l.value = "template", await It(), c.value?.openCreateTableModal();
    }, N = () => {
      o.value = !1;
    };
    return et(o, (b) => {
      b && m();
    }), e({
      open: () => {
        o.value = !0;
      }
    }), (b, T) => (S(), k("div", null, [
      mt(b.$slots, "default"),
      w(Ge, {
        visible: o.value,
        "onUpdate:visible": T[2] || (T[2] = (_) => o.value = _),
        title: "",
        closable: !0,
        height: "650px",
        onClose: N
      }, {
        titlePrefix: P(() => [
          w(Eo, {
            expanded: r.value,
            onToggle: E
          }, null, 8, ["expanded"])
        ]),
        default: P(() => [
          w(vo, {
            "drawer-expanded": r.value,
            "onUpdate:drawerExpanded": T[1] || (T[1] = (_) => r.value = _),
            tables: u.value,
            "selected-table": a.value,
            onSelectTable: h,
            onCreateTable: y
          }, {
            default: P(() => [
              w(go, {
                "active-tab": l.value,
                "onUpdate:activeTab": T[0] || (T[0] = (_) => l.value = _),
                tabs: d
              }, {
                template: P(() => [
                  w(yo, {
                    ref_key: "tableTabRef",
                    ref: c,
                    "table-service": Q(n),
                    tables: u.value,
                    "selected-table": a.value,
                    onRefresh: m,
                    "onUpdate:selectedTable": h
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: P(() => [
                  w(_o, {
                    "sql-executor-service": Q(i),
                    onRefresh: m
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), wm = { class: "data-form" }, Cm = { class: "form-content" }, Dm = { class: "form-label" }, Om = {
  key: 0,
  class: "required-mark"
}, $m = ["value", "onInput", "type"], Am = { class: "form-actions" }, Mm = /* @__PURE__ */ Te({
  __name: "DataForm",
  props: {
    visible: { type: Boolean, default: !0 },
    columns: {},
    initialData: {},
    title: { default: "" },
    modalWidth: { default: "50vw" },
    modalHeight: { default: "auto" }
  },
  emits: ["submit", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1), o = () => {
      i.value = window.innerWidth <= 768;
    };
    ot(() => {
      o(), window.addEventListener("resize", o);
    }), Pt(() => {
      window.removeEventListener("resize", o);
    });
    const r = te(() => i.value ? "100%" : s.modalWidth), l = te(() => {
      const b = {};
      return s.modalWidth && (b["--form-modal-width"] = i.value ? "100%" : s.modalWidth), s.modalHeight && (b["--form-modal-height"] = s.modalHeight), b;
    }), a = /* @__PURE__ */ os({}), u = /* @__PURE__ */ os({}), c = /* @__PURE__ */ new Set(), d = () => {
      c.clear(), s.columns.forEach((b) => {
        let T;
        s.initialData && s.initialData[b.name] !== void 0 ? T = s.initialData[b.name] : b.defaultValue !== void 0 ? T = b.defaultValue : T = "", a[b.name] = T, u[b.name] = T;
      });
    }, m = (b) => {
      const T = b.toUpperCase();
      return T.includes("STRING") || T.includes("TEXT");
    }, h = (b) => b.toUpperCase().includes("INT") || b.toUpperCase().includes("REAL") || b.toUpperCase().includes("FLOA") || b.toUpperCase().includes("DOUB") ? "number" : "text", E = (b, T) => {
      let _;
      if (typeof T == "string")
        _ = T;
      else {
        const V = T.target;
        _ = V.type === "number" ? parseFloat(V.value) : V.value;
      }
      a[b] = _;
      const O = u[b];
      String(_) !== String(O) ? c.add(b) : c.delete(b);
    }, y = () => {
      const b = /* @__PURE__ */ new Map(), T = s.initialData !== void 0;
      s.columns.forEach((_) => {
        if (T && !c.has(_.name))
          return;
        let O = a[_.name], V;
        O === "" || O === void 0 ? _.primitiveKey && _.defaultValue !== void 0 ? V = _.defaultValue : V = null : V = O;
        const K = _.type.toUpperCase();
        K.includes("INT") && V !== null ? V = parseInt(String(V)) : (K.includes("REAL") || K.includes("FLOA") || K.includes("DOUB")) && V !== null && (V = parseFloat(String(V))), b.set(_.name, V);
      }), n("submit", b);
    }, N = () => {
      n("cancel");
    };
    return et(() => s.visible, (b) => {
      b && d();
    }), et(() => s.initialData, () => {
      s.visible && d();
    }, { immediate: !0 }), (b, T) => (S(), k("div", {
      class: "data-form-wrapper",
      style: Ke(l.value)
    }, [
      w(Ge, {
        visible: t.visible,
        title: t.title,
        width: r.value,
        height: t.modalHeight,
        closable: !1,
        onClose: N
      }, {
        default: P(() => [
          f("div", wm, [
            f("div", Cm, [
              (S(!0), k(Ae, null, Wt(t.columns, (_) => (S(), k("div", {
                key: _.name,
                class: "form-item"
              }, [
                f("label", Dm, [
                  se(de(_.name) + " ", 1),
                  _.primitiveKey ? (S(), k("span", Om, "*")) : ne("", !0)
                ]),
                m(_.type) ? (S(), Le(Vs, {
                  key: 1,
                  "model-value": String(a[_.name] || ""),
                  "onUpdate:modelValue": (O) => E(_.name, O),
                  "min-rows": 1,
                  "max-rows": 10
                }, null, 8, ["model-value", "onUpdate:modelValue"])) : (S(), k("input", {
                  key: 0,
                  value: a[_.name],
                  onInput: (O) => E(_.name, O),
                  type: h(_.type),
                  class: "form-input"
                }, null, 40, $m))
              ]))), 128))
            ]),
            f("div", Am, [
              w(ae, { onClick: N }, {
                default: P(() => [...T[0] || (T[0] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                onClick: y
              }, {
                default: P(() => [...T[1] || (T[1] = [
                  se("", -1)
                ])]),
                _: 1
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["visible", "title", "width", "height"])
    ], 4));
  }
}), Ir = /* @__PURE__ */ De(Mm, [["__scopeId", "data-v-daf1bd0f"]]), Vm = { class: "confirm-container" }, Im = { class: "form-actions" }, Rm = /* @__PURE__ */ Te({
  __name: "DeleteDataConfirm",
  props: {
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = te(() => {
      const l = {};
      return s.modalWidth && (l["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (l["--confirm-modal-height"] = s.modalHeight), l;
    }), o = () => {
      n("confirm");
    }, r = () => {
      n("cancel");
    };
    return (l, a) => (S(), k("div", {
      class: "delete-data-confirm-wrapper",
      style: Ke(i.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: r
      }, {
        default: P(() => [
          f("div", Vm, [
            a[2] || (a[2] = f("div", { class: "confirm-content" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" }),
              f("p", { class: "confirm-message" }, "")
            ], -1)),
            f("div", Im, [
              w(ae, { onClick: r }, {
                default: P(() => [...a[0] || (a[0] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "danger",
                onClick: o
              }, {
                default: P(() => [...a[1] || (a[1] = [
                  se("", -1)
                ])]),
                _: 1
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), Lm = /* @__PURE__ */ De(Rm, [["__scopeId", "data-v-b672c047"]]), km = { class: "export-container" }, Pm = { class: "export-header" }, Bm = { class: "export-content" }, Fm = { class: "export-code" }, Um = { class: "form-actions" }, jm = /* @__PURE__ */ Te({
  __name: "ExportDisplay",
  props: {
    sql: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1);
    let o = null;
    const r = async () => {
      try {
        await navigator.clipboard.writeText(s.sql), i.value = !0, o && clearTimeout(o), o = setTimeout(() => {
          i.value = !1;
        }, 2e3);
      } catch (a) {
        console.error(":", a);
      }
    }, l = () => {
      n("close");
    };
    return (a, u) => (S(), k("div", km, [
      f("div", Pm, [
        u[0] || (u[0] = f("span", { class: "export-title" }, "SQL", -1)),
        f("button", {
          class: "copy-btn",
          onClick: r
        }, [
          f("i", {
            class: Ie(i.value ? "fa-solid fa-check" : "fa-solid fa-copy")
          }, null, 2),
          se(" " + de(i.value ? "" : ""), 1)
        ])
      ]),
      f("div", Bm, [
        f("pre", Fm, de(t.sql), 1)
      ]),
      f("div", Um, [
        w(ae, { onClick: l }, {
          default: P(() => [...u[1] || (u[1] = [
            se("", -1)
          ])]),
          _: 1
        })
      ])
    ]));
  }
}), qm = /* @__PURE__ */ De(jm, [["__scopeId", "data-v-affef56e"]]), Hm = { class: "chat-data-management-tab" }, Wm = {
  key: 1,
  class: "data-detail"
}, Km = { class: "data-toolbar" }, zm = { class: "data-title" }, Gm = { class: "table-name" }, Ym = {
  key: 0,
  class: "table-comment"
}, Qm = { class: "data-actions" }, Jm = { class: "data-list" }, Xm = {
  key: 1,
  class: "table-container"
}, Zm = { class: "data-table" }, eb = {
  key: 0,
  class: "checkbox-header sticky-col",
  style: { left: "0" }
}, tb = { class: "checkbox-wrapper" }, sb = ["checked"], nb = {
  key: 0,
  class: "checkbox-cell sticky-col",
  style: { left: "0" }
}, ib = { class: "checkbox-wrapper" }, ob = ["checked", "onChange"], rb = { class: "row-actions" }, lb = { class: "cell-value" }, ab = /* @__PURE__ */ Te({
  __name: "ChatDataManagementTab",
  props: {
    dataService: {},
    tables: {},
    selectedTable: {}
  },
  setup(t) {
    const e = t, s = te(() => e.tables.find((C) => C.tableName === e.selectedTable) || {}), n = te(() => s.value.columnSchemas ? Object.values(s.value.columnSchemas) : []), i = te(() => a.value === "none" ? "" : a.value === "selecting" ? "" : a.value === "confirming" ? "" : ""), o = /* @__PURE__ */ q([]), r = /* @__PURE__ */ q(/* @__PURE__ */ new Set()), l = /* @__PURE__ */ q(!1), a = /* @__PURE__ */ q("none"), { toast: u, showToast: c } = fa(), d = /* @__PURE__ */ q(!1), m = /* @__PURE__ */ q(!1), h = /* @__PURE__ */ q(!1), E = /* @__PURE__ */ q(!1), y = /* @__PURE__ */ q(null), N = /* @__PURE__ */ q(""), b = (C) => C === null ? "NULL" : C === void 0 ? "" : String(C).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "\\n").replace(/<br>/gi, "&lt;br&gt;"), T = () => {
      if (s.value.tableName) {
        const C = e.dataService.queryData(s.value.tableName);
        C.success && Array.isArray(C.data) ? o.value = C.data : o.value = [];
      }
    }, _ = (C) => {
      if (s.value.tableName) {
        const W = e.dataService.insertData(s.value.tableName, C);
        W.success ? (d.value = !1, T(), c("")) : c(W.message || "", "error");
      }
    }, O = (C, W) => {
      y.value = { index: C, row: W }, m.value = !0;
    }, V = (C) => {
      if (s.value.tableName && y.value) {
        const W = n.value.find((ce) => ce.primitiveKey), re = o.value[y.value.index];
        let ge = $s.of();
        if (W) {
          const ce = re[W.name];
          ge = ge.eq(W.name, ce);
        }
        const pe = e.dataService.updateData(s.value.tableName, C, ge);
        pe.success ? (m.value = !1, y.value = null, T(), c("")) : c(pe.message || "", "error");
      }
    }, K = (C) => {
      y.value = { index: C, row: o.value[C] }, h.value = !0;
    }, he = () => {
      if (s.value.tableName && y.value) {
        const C = n.value.find((pe) => pe.primitiveKey), W = o.value[y.value.index];
        let re = $s.of();
        if (C) {
          const pe = W[C.name];
          re = re.eq(C.name, pe);
        }
        const ge = e.dataService.deleteData(s.value.tableName, re);
        ge.success ? (h.value = !1, y.value = null, T(), c("")) : c(ge.message || "", "error");
      }
    }, me = (C) => {
      r.value.has(C) ? r.value.delete(C) : r.value.add(C), r.value.size > 0 ? a.value = "confirming" : a.value = "selecting";
    }, H = (C) => {
      C.target.checked ? o.value.forEach((re, ge) => r.value.add(ge)) : r.value.clear(), r.value.size > 0 ? a.value = "confirming" : a.value = "selecting";
    }, le = () => {
      if (a.value === "none")
        a.value = "selecting", l.value = !0, r.value.clear();
      else if (a.value === "selecting")
        a.value = "none", l.value = !1, r.value.clear();
      else if (a.value === "confirming") {
        if (r.value.size === 0) {
          c("", "error");
          return;
        }
        if (s.value.tableName) {
          let C = 0;
          const W = n.value.find((re) => re.primitiveKey);
          r.value.forEach((re) => {
            const ge = o.value[re];
            let pe = $s.of();
            if (W) {
              const fe = ge[W.name];
              pe = pe.eq(W.name, fe);
            }
            e.dataService.deleteData(s.value.tableName, pe).success && C++;
          }), r.value.clear(), T(), c(` ${C} `), a.value = "none", l.value = !1;
        }
      }
    }, be = () => {
      s.value.tableName && (N.value = e.dataService.export(s.value.tableName), E.value = !0);
    };
    return et(() => e.selectedTable, () => {
      T();
    }), ot(() => {
      T();
    }), (C, W) => (S(), k("div", Hm, [
      t.selectedTable ? (S(), k("div", Wm, [
        f("div", Km, [
          f("div", zm, [
            f("span", Gm, de(s.value.tableName), 1),
            s.value.comment ? (S(), k("span", Ym, de(s.value.comment), 1)) : ne("", !0)
          ]),
          f("div", Qm, [
            w(ae, {
              onClick: W[0] || (W[0] = (re) => d.value = !0)
            }, {
              default: P(() => [...W[6] || (W[6] = [
                f("i", {
                  class: "fa-solid fa-plus",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            }),
            w(ae, {
              type: "danger",
              onClick: le
            }, {
              default: P(() => [
                W[7] || (W[7] = f("i", {
                  class: "fa-solid fa-trash",
                  style: { "margin-right": "6px" }
                }, null, -1)),
                se(" " + de(i.value), 1)
              ]),
              _: 1
            }),
            w(ae, { onClick: be }, {
              default: P(() => [...W[8] || (W[8] = [
                f("i", {
                  class: "fa-solid fa-download",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            })
          ])
        ]),
        f("div", Jm, [
          o.value.length === 0 ? (S(), Le(Jn, {
            key: 0,
            icon: "fa-solid fa-database",
            text: ""
          })) : (S(), k("div", Xm, [
            f("table", Zm, [
              f("thead", null, [
                f("tr", null, [
                  l.value ? (S(), k("th", eb, [
                    f("label", tb, [
                      f("input", {
                        type: "checkbox",
                        checked: r.value.size === o.value.length && o.value.length > 0,
                        onChange: H
                      }, null, 40, sb)
                    ])
                  ])) : ne("", !0),
                  f("th", {
                    class: "actions-header sticky-col",
                    style: Ke({ left: l.value ? "50px" : "0" })
                  }, "  ", 4),
                  (S(!0), k(Ae, null, Wt(n.value, (re) => (S(), k("th", {
                    key: re.name,
                    class: Ie(["column-header", re.primitiveKey ? "primary-key" : ""])
                  }, de(re.name), 3))), 128))
                ])
              ]),
              f("tbody", null, [
                (S(!0), k(Ae, null, Wt(o.value, (re, ge) => (S(), k("tr", {
                  key: ge,
                  class: "table-row"
                }, [
                  l.value ? (S(), k("td", nb, [
                    f("label", ib, [
                      f("input", {
                        type: "checkbox",
                        checked: r.value.has(ge),
                        onChange: (pe) => me(ge)
                      }, null, 40, ob)
                    ])
                  ])) : ne("", !0),
                  f("td", {
                    class: "actions-cell sticky-col",
                    style: Ke({ left: l.value ? "50px" : "0" })
                  }, [
                    f("div", rb, [
                      w(ae, {
                        size: "small",
                        onClick: (pe) => O(ge, re)
                      }, {
                        default: P(() => [...W[9] || (W[9] = [
                          f("i", { class: "fa-solid fa-pen" }, null, -1)
                        ])]),
                        _: 1
                      }, 8, ["onClick"]),
                      w(ae, {
                        type: "danger",
                        size: "small",
                        onClick: (pe) => K(ge)
                      }, {
                        default: P(() => [...W[10] || (W[10] = [
                          f("i", { class: "fa-solid fa-trash" }, null, -1)
                        ])]),
                        _: 1
                      }, 8, ["onClick"])
                    ])
                  ], 4),
                  (S(!0), k(Ae, null, Wt(n.value, (pe) => (S(), k("td", {
                    key: pe.name,
                    class: Ie(["table-cell", pe.primitiveKey ? "primary-key" : ""])
                  }, [
                    f("span", lb, de(b(re[pe.name])), 1)
                  ], 2))), 128))
                ]))), 128))
              ])
            ])
          ]))
        ])
      ])) : (S(), Le(Jn, {
        key: 0,
        icon: "fa-solid fa-table",
        text: ""
      })),
      w(da, {
        visible: Q(u).visible,
        message: Q(u).message,
        type: Q(u).type,
        icon: Q(u).icon
      }, null, 8, ["visible", "message", "type", "icon"]),
      Xe(w(Ir, {
        visible: d.value,
        title: "",
        columns: n.value,
        "modal-width": "50vw",
        onSubmit: _,
        onCancel: W[1] || (W[1] = (re) => d.value = !1)
      }, null, 8, ["visible", "columns"]), [
        [pr, d.value]
      ]),
      Xe(w(Ir, {
        visible: m.value,
        title: "",
        columns: n.value,
        "initial-data": y.value?.row,
        "modal-width": "50vw",
        onSubmit: V,
        onCancel: W[2] || (W[2] = (re) => m.value = !1)
      }, null, 8, ["visible", "columns", "initial-data"]), [
        [pr, m.value]
      ]),
      h.value ? (S(), Le(Lm, {
        key: 2,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: he,
        onCancel: W[3] || (W[3] = (re) => h.value = !1)
      })) : ne("", !0),
      E.value ? (S(), Le(Ge, {
        key: 3,
        visible: "",
        title: "",
        onClose: W[5] || (W[5] = (re) => E.value = !1)
      }, {
        default: P(() => [
          w(qm, {
            sql: N.value,
            onClose: W[4] || (W[4] = (re) => E.value = !1)
          }, null, 8, ["sql"])
        ]),
        _: 1
      })) : ne("", !0)
    ]));
  }
}), ba = /* @__PURE__ */ De(ab, [["__scopeId", "data-v-0cce85f5"]]), cb = /* @__PURE__ */ Te({
  __name: "SystemDataManagementPanel",
  props: /* @__PURE__ */ co({
    defaultTabOnTableSelect: { default: "data" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { dataManagementService: n, tableManagementService: i, sqlExecutorService: o } = xm(), r = uo(t, "visible"), l = /* @__PURE__ */ q(!1), a = /* @__PURE__ */ q("data"), u = /* @__PURE__ */ q(""), c = /* @__PURE__ */ q([]), d = /* @__PURE__ */ q(null), m = [
      { key: "data", label: "", icon: "fa-solid fa-database" },
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], h = () => {
      c.value = i.value.getTables();
    }, E = (T) => {
      u.value = T, a.value = s.defaultTabOnTableSelect;
    }, y = () => {
      l.value = !l.value;
    }, N = async () => {
      a.value = "template", await It(), d.value?.openCreateTableModal();
    }, b = () => {
      r.value = !1;
    };
    return et(r, (T) => {
      T && h();
    }), e({
      open: () => {
        r.value = !0;
      }
    }), (T, _) => (S(), k("div", null, [
      mt(T.$slots, "default"),
      w(Ge, {
        visible: r.value,
        "onUpdate:visible": _[2] || (_[2] = (O) => r.value = O),
        title: "",
        closable: !0,
        height: "650px",
        onClose: b
      }, {
        titlePrefix: P(() => [
          w(Eo, {
            expanded: l.value,
            onToggle: y
          }, null, 8, ["expanded"])
        ]),
        default: P(() => [
          w(vo, {
            "drawer-expanded": l.value,
            "onUpdate:drawerExpanded": _[1] || (_[1] = (O) => l.value = O),
            tables: c.value,
            "selected-table": u.value,
            "show-sync-buttons": !1,
            onSelectTable: E,
            onCreateTable: N
          }, {
            default: P(() => [
              w(go, {
                "active-tab": a.value,
                "onUpdate:activeTab": _[0] || (_[0] = (O) => a.value = O),
                tabs: m
              }, {
                data: P(() => [
                  w(ba, {
                    "data-service": Q(n),
                    tables: c.value,
                    "selected-table": u.value,
                    onRefresh: h
                  }, null, 8, ["data-service", "tables", "selected-table"])
                ]),
                template: P(() => [
                  w(yo, {
                    ref_key: "tableTabRef",
                    ref: d,
                    "table-service": Q(i),
                    tables: c.value,
                    "selected-table": u.value,
                    onRefresh: h,
                    "onUpdate:selectedTable": E
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: P(() => [
                  w(_o, {
                    "sql-executor-service": Q(o),
                    onRefresh: h
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
});
class Zn {
  static _instance = new Zn();
  debugEnabled = !1;
  constructor() {
  }
  static get instance() {
    return Zn._instance;
  }
  setDebugMode(e) {
    this.debugEnabled = e;
  }
  debug(e, s, ...n) {
    this.debugEnabled && console.log(`[${e}] ${s}`, ...n);
  }
  info(e, s, ...n) {
    console.log(`[${e}] ${s}`, ...n);
  }
  warn(e, s, ...n) {
    console.warn(`[${e}] ${s}`, ...n);
  }
  error(e, s, ...n) {
    console.error(`[${e}] ${s}`, ...n);
  }
}
const Oi = Zn.instance, ub = { class: "category_container" }, db = { style: { display: "flex", "align-items": "center", gap: "10px" } }, fb = { class: "category_container" }, pb = { class: "category_container" }, hb = { style: { display: "flex", "flex-direction": "column", gap: "12px" } }, mb = /* @__PURE__ */ Te({
  __name: "SettingsPanel",
  setup(t) {
    const e = Se.instance;
    Oi.setDebugMode(e.debugMode);
    const s = te({
      get: () => e.extensionSwitch,
      set: (N) => e.extensionSwitch = N
    }), n = te({
      get: () => e.chatStatusBarSwitch,
      set: (N) => e.chatStatusBarSwitch = N
    }), i = te({
      get: () => e.debugMode,
      set: (N) => e.debugMode = N
    }), o = /* @__PURE__ */ q(!1), r = /* @__PURE__ */ q(""), l = /* @__PURE__ */ q(), a = /* @__PURE__ */ q(0);
    et(o, async (N) => {
      if (N) {
        a.value++, await It();
        const b = e.chatStatusBarCode;
        r.value = b, await It(), l.value && (l.value.value = b);
      }
    }), et(i, (N) => {
      Oi.setDebugMode(N), Oi.info("SettingsPanel", "Debug mode changed to: " + N);
    }, { immediate: !0 });
    const u = () => {
      o.value = !0;
    }, c = () => {
      o.value = !1;
    }, d = () => {
      e.chatStatusBarCode = r.value, o.value = !1;
    }, m = /* @__PURE__ */ q(), h = /* @__PURE__ */ q(), E = () => {
      m.value?.open();
    }, y = () => {
      h.value?.open();
    };
    return (N, b) => (S(), k(Ae, null, [
      f("div", ub, [
        w(Ws, null, {
          left: P(() => [...b[5] || (b[5] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-sliders",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: P(() => [
            w(Di, {
              checked: s.value,
              onChange: b[0] || (b[0] = (T) => s.value = T)
            }, null, 8, ["checked"])
          ]),
          _: 1
        }),
        w(Ws, null, {
          left: P(() => [...b[6] || (b[6] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-bug",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: P(() => [
            w(Di, {
              checked: i.value,
              onChange: b[1] || (b[1] = (T) => i.value = T)
            }, null, 8, ["checked"])
          ]),
          _: 1
        }),
        w(Ws, null, {
          left: P(() => [...b[7] || (b[7] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-paper-plane",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: P(() => [
            f("div", db, [
              w(Di, {
                checked: n.value,
                onChange: b[2] || (b[2] = (T) => n.value = T)
              }, null, 8, ["checked"]),
              w(ae, { onClick: u }, {
                default: P(() => [...b[8] || (b[8] = [
                  f("i", {
                    class: "fa-solid fa-pen-to-square",
                    style: { "margin-right": "6px" }
                  }, null, -1),
                  se("  ", -1)
                ])]),
                _: 1
              })
            ])
          ]),
          _: 1
        })
      ]),
      f("div", fb, [
        w(Ws, null, {
          left: P(() => [...b[9] || (b[9] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-file-code",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: P(() => [
            w(ae, { onClick: E }, {
              default: P(() => [...b[10] || (b[10] = [
                f("i", {
                  class: "fa-solid fa-gear",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      f("div", pb, [
        w(Ws, null, {
          left: P(() => [...b[11] || (b[11] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-database",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: P(() => [
            w(ae, { onClick: y }, {
              default: P(() => [...b[12] || (b[12] = [
                f("i", {
                  class: "fa-solid fa-gear",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      w(Sm, {
        ref_key: "templateManagementPanelRef",
        ref: m
      }, {
        default: P(() => [...b[13] || (b[13] = [])]),
        _: 1
      }, 512),
      w(cb, {
        ref_key: "systemDataManagementPanelRef",
        ref: h
      }, {
        default: P(() => [...b[14] || (b[14] = [])]),
        _: 1
      }, 512),
      w(Ge, {
        visible: o.value,
        "onUpdate:visible": b[4] || (b[4] = (T) => o.value = T),
        title: "",
        closable: !0,
        onClose: c
      }, {
        footer: P(() => [
          w(ae, { onClick: c }, {
            default: P(() => [...b[15] || (b[15] = [
              se("", -1)
            ])]),
            _: 1
          }),
          w(ae, { onClick: d }, {
            default: P(() => [...b[16] || (b[16] = [
              se("", -1)
            ])]),
            _: 1
          })
        ]),
        default: P(() => [
          f("div", hb, [
            Xe(f("textarea", {
              ref_key: "textareaRef",
              ref: l,
              "onUpdate:modelValue": b[3] || (b[3] = (T) => r.value = T),
              rows: "10",
              style: { width: "100%", padding: "12px", border: "1px solid var(--SmartThemeBorderColor)", "border-radius": "6px", background: "var(--black30a)", color: "var(--SmartThemeBodyColor)", "font-family": "monospace", resize: "vertical" },
              placeholder: "..."
            }, null, 512), [
              [zt, r.value]
            ])
          ])
        ]),
        _: 1
      }, 8, ["visible"])
    ], 64));
  }
}), bb = /* @__PURE__ */ Te({
  __name: "ExtraMesButtons",
  emits: ["click"],
  setup(t, { emit: e }) {
    const s = e;
    function n() {
      s("click");
    }
    return ot(() => {
      $(document).on("click", ".open_database_table", n);
    }), bn(() => {
      $(document).off("click", ".open_database_table", n);
    }), (i, o) => (S(), Le(Nl, { to: ".extraMesButtons" }, [
      o[0] || (o[0] = f("div", {
        class: "mes_button open_database_table",
        title: ""
      }, [
        f("i", { class: "fa-solid fa-table" })
      ], -1))
    ]));
  }
}), vb = /* @__PURE__ */ Te({
  __name: "ChatManagementPanel",
  props: /* @__PURE__ */ co({
    defaultTabOnTableSelect: { default: "data" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { dataManagementService: n, tableManagementService: i, sqlExecutorService: o, databaseSyncService: r } = Tm(), l = uo(t, "visible"), a = /* @__PURE__ */ q(!1), u = /* @__PURE__ */ q("data"), c = /* @__PURE__ */ q(""), d = /* @__PURE__ */ q([]), m = /* @__PURE__ */ q(null), h = [
      { key: "data", label: "", icon: "fa-solid fa-database" },
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], E = () => {
      d.value = i.value.getTables();
    }, y = (V) => {
      c.value = V, u.value = s.defaultTabOnTableSelect;
    }, N = () => {
      a.value = !a.value;
    }, b = async () => {
      u.value = "template", await It(), m.value?.openCreateTableModal();
    }, T = () => {
      r.value.syncTableFromTemplate(), E();
    }, _ = () => {
      r.value.pushTableToTemplate(), E();
    }, O = () => {
      l.value = !1;
    };
    return et(l, (V) => {
      V && E();
    }), e({
      open: () => {
        l.value = !0;
      }
    }), (V, K) => (S(), k("div", null, [
      mt(V.$slots, "default"),
      w(Ge, {
        visible: l.value,
        "onUpdate:visible": K[2] || (K[2] = (he) => l.value = he),
        title: "",
        closable: !0,
        height: "650px",
        onClose: O
      }, {
        titlePrefix: P(() => [
          w(Eo, {
            expanded: a.value,
            onToggle: N
          }, null, 8, ["expanded"])
        ]),
        default: P(() => [
          w(vo, {
            "drawer-expanded": a.value,
            "onUpdate:drawerExpanded": K[1] || (K[1] = (he) => a.value = he),
            tables: d.value,
            "selected-table": c.value,
            "show-sync-buttons": !0,
            onSelectTable: y,
            onCreateTable: b,
            onSync: T,
            onPush: _
          }, {
            default: P(() => [
              w(go, {
                "active-tab": u.value,
                "onUpdate:activeTab": K[0] || (K[0] = (he) => u.value = he),
                tabs: h
              }, {
                data: P(() => [
                  w(ba, {
                    "data-service": Q(n),
                    tables: d.value,
                    "selected-table": c.value,
                    onRefresh: E
                  }, null, 8, ["data-service", "tables", "selected-table"])
                ]),
                template: P(() => [
                  w(yo, {
                    ref_key: "tableTabRef",
                    ref: m,
                    "table-service": Q(i),
                    tables: d.value,
                    "selected-table": c.value,
                    onRefresh: E,
                    "onUpdate:selectedTable": y
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: P(() => [
                  w(_o, {
                    "sql-executor-service": Q(o),
                    onRefresh: E
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), gb = { class: "translation_settings" }, Eb = { class: "inline-drawer" }, yb = { class: "inline-drawer-content" }, _b = { style: { padding: "10px" } }, Tb = /* @__PURE__ */ Te({
  __name: "MainView",
  setup(t) {
    const e = /* @__PURE__ */ q(!1), s = () => {
      e.value = !0;
    };
    return (n, i) => (S(), k("div", gb, [
      f("div", Eb, [
        i[1] || (i[1] = f("div", { class: "inline-drawer-toggle inline-drawer-header" }, [
          f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
            f("b", null, "")
          ]),
          f("div", { class: "inline-drawer-icon fa-solid fa-circle-chevron-down down" })
        ], -1)),
        f("div", yb, [
          f("div", _b, [
            w(mb)
          ])
        ])
      ]),
      w(bb, { onClick: s }),
      w(vb, {
        visible: e.value,
        "onUpdate:visible": i[0] || (i[0] = (o) => e.value = o)
      }, null, 8, ["visible"])
    ]));
  }
}), Nb = /* @__PURE__ */ De(Tb, [["__scopeId", "data-v-d18c04a2"]]);
class xb {
  static init() {
    if (Se.instance.extensionSwitch) {
      const e = SillyTavern.getContext(), { registerMacro: s, eventSource: n } = e;
      if (typeof window > "u")
        return;
      window.getTemplateSqlExecutor = () => Se.instance.tableTemplate, window.getChatSqlExecutor = () => Pe.instance.tableTemplate, window.chatDatabaseData = () => JSON.parse(Pe.instance.tableTemplate.export(lt.STANDARD_DATA)), n.on("prompt_template_prepare", (i) => {
        i.getTemplateSqlExecutor = () => Se.instance.tableTemplate, i.getChatSqlExecutor = () => Pe.instance.tableTemplate;
      }), this.registerMacros(s);
    }
  }
  static registerMacros(e) {
    const s = ke.chatTableManagementService;
    e("GET_ALL_TABLE_NAMES", () => s.getTables().map((n) => n.tableName)), e("GET_ALL_TABLE_SCHEMAS", () => Pe.instance.tableTemplate.export(lt.DDL)), e("GET_ALL_TABLE_DATA", () => Pe.instance.tableTemplate.export(lt.MARKDOWN));
  }
}
class Sb {
  static init() {
    en.init(), xb.init();
    const e = Vt.getInstance();
    e.updateChatTemplateDisplay(), Se.instance.onChatStatusBarChange(() => {
      e.updateChatTemplateDisplay();
    });
  }
}
Sb.init();
const Rr = document.createElement("div"), Lr = document.querySelector("#extensions_settings");
Lr && (Lr.appendChild(Rr), Od(Nb).mount(Rr));
//# sourceMappingURL=index.js.map
