(function(){"use strict";try{if(typeof document<"u"){var a=document.createElement("style");a.appendChild(document.createTextNode('.st-card-unified[data-v-5b66fbc1]{min-height:48px;display:flex;align-items:center;transition:background-color var(--animation-duration, 125ms)}.st-card-unified>div[data-v-5b66fbc1]{width:100%}.st-toggle-switch[data-v-f73e4a93]{position:relative;display:inline-block;width:40px;height:22px;transform:scale(.9)}.st-toggle-switch input[data-v-f73e4a93]{opacity:0;width:0;height:0}.st-toggle-slider[data-v-f73e4a93]{position:absolute;cursor:pointer;inset:0;background-color:var(--SmartThemeEmColor);transition:var(--animation-duration, 125ms);border-radius:22px}.st-toggle-slider[data-v-f73e4a93]:before{position:absolute;content:"";height:16px;width:16px;left:3px;bottom:3px;background-color:var(--SmartThemeBodyColor);transition:var(--animation-duration, 125ms);border-radius:50%;box-shadow:0 2px 4px var(--SmartThemeShadowColor)}input:checked+.st-toggle-slider[data-v-f73e4a93]{background-color:var(--SmartThemeBodyColor)}input:checked+.st-toggle-slider[data-v-f73e4a93]:before{transform:translate(18px);background-color:var(--SmartThemeBlurTintColor)}.button-wrapper[data-v-8b9ccff3]{display:inline-flex;align-items:center;justify-content:center;flex-direction:row}.button-content[data-v-8b9ccff3]{display:flex;align-items:center;gap:6px;flex-direction:row;white-space:nowrap}.popup-modal-overlay[data-v-546209e7]{position:fixed;inset:0;background:#00000080;display:flex;align-items:center;justify-content:center;z-index:9999;padding:20px}.popup-modal[data-v-546209e7]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:8px;box-shadow:0 4px 20px var(--SmartThemeShadowColor);max-width:1200px;width:100%;max-height:90vh;display:flex;flex-direction:column}.popup-modal-header[data-v-546209e7]{display:flex;justify-content:space-between;align-items:center;padding:16px 20px;border-bottom:1px solid var(--SmartThemeBorderColor)}.popup-modal-title[data-v-546209e7]{font-size:18px;font-weight:600;color:var(--SmartThemeBodyColor);display:flex;align-items:center;gap:8px}.popup-modal-close[data-v-546209e7]{width:32px;height:32px;display:flex;align-items:center;justify-content:center;cursor:pointer;border-radius:4px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);transition:all .2s}.popup-modal-close[data-v-546209e7]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.popup-modal-close i[data-v-546209e7]{font-size:18px}.popup-modal-body[data-v-546209e7]{flex:1;overflow:auto;padding:20px}.popup-modal-footer[data-v-546209e7]{padding:16px 20px;border-top:1px solid var(--SmartThemeBorderColor);display:flex;justify-content:flex-end;gap:10px}.modal-enter-active[data-v-546209e7],.modal-leave-active[data-v-546209e7]{transition:opacity .3s ease}.modal-enter-from[data-v-546209e7],.modal-leave-to[data-v-546209e7]{opacity:0}.modal-enter-active .popup-modal[data-v-546209e7],.modal-leave-active .popup-modal[data-v-546209e7]{transition:transform .3s ease,opacity .3s ease}.modal-enter-from .popup-modal[data-v-546209e7],.modal-leave-to .popup-modal[data-v-546209e7]{transform:scale(.9);opacity:0}@media(max-width:768px){.popup-modal-overlay[data-v-546209e7]{padding:10px}.popup-modal[data-v-546209e7]{height:90vh;border-radius:8px 8px 0 0;margin-top:auto}.popup-modal-header[data-v-546209e7]{padding:12px 16px}.popup-modal-title[data-v-546209e7]{font-size:16px}.popup-modal-body[data-v-546209e7]{padding:16px}.popup-modal-footer[data-v-546209e7]{padding:12px 16px}}.table-list-drawer[data-v-85bfbdca]{display:flex;flex-direction:column;height:100%;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);border-right:1px solid var(--SmartThemeBorderColor)}.drawer-header[data-v-85bfbdca]{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor)}.drawer-title[data-v-85bfbdca]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.header-actions[data-v-85bfbdca]{display:flex;align-items:center;gap:6px}.sync-btn[data-v-85bfbdca],.push-btn[data-v-85bfbdca]{display:flex;align-items:center;justify-content:center;width:28px;height:28px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);cursor:pointer;transition:all .2s}.sync-btn[data-v-85bfbdca]:hover,.push-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.sync-btn i[data-v-85bfbdca],.push-btn i[data-v-85bfbdca]{font-size:13px}.create-table-btn[data-v-85bfbdca]{display:flex;align-items:center;justify-content:center;width:28px;height:28px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);cursor:pointer;transition:all .2s}.create-table-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.create-table-btn i[data-v-85bfbdca]{font-size:13px}.drawer-body[data-v-85bfbdca]{flex:1;overflow-y:auto;padding:8px}.empty-state[data-v-85bfbdca]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:200px;gap:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.empty-state i[data-v-85bfbdca]{font-size:32px}.empty-state span[data-v-85bfbdca]{font-size:14px}.empty-create-btn[data-v-85bfbdca]{display:flex;align-items:center;gap:6px;padding:8px 16px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s;margin-top:8px}.empty-create-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.empty-create-btn i[data-v-85bfbdca]{font-size:12px}.table-list[data-v-85bfbdca]{display:flex;flex-direction:column;gap:4px}.table-item[data-v-85bfbdca]{padding:12px;border-radius:6px;cursor:pointer;transition:all .2s;border:1px solid transparent}.table-item[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.table-item.active[data-v-85bfbdca]{background:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent);border-color:var(--SmartThemeBorderColor)}.table-item-main[data-v-85bfbdca]{display:flex;align-items:center;gap:8px;margin-bottom:4px}.table-icon[data-v-85bfbdca]{font-size:14px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.table-name[data-v-85bfbdca]{font-size:14px;font-weight:500;color:var(--SmartThemeBodyColor);flex:1;word-break:break-all}.table-comment[data-v-85bfbdca]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);margin-left:22px;word-break:break-all}@media(max-width:768px){.drawer-header[data-v-85bfbdca],.drawer-body[data-v-85bfbdca]{padding:12px}.empty-state[data-v-85bfbdca]{height:auto;min-height:150px;padding:20px}.table-list[data-v-85bfbdca]{gap:8px}.table-item[data-v-85bfbdca]{padding:14px 12px}.table-name[data-v-85bfbdca]{font-size:15px}.table-comment[data-v-85bfbdca]{font-size:13px;margin-top:4px;margin-left:0}}.table-drawer-layout[data-v-3e0df31e]{display:flex;flex-direction:column;height:100%;min-height:500px}.layout-content[data-v-3e0df31e]{flex:1;display:flex;overflow:hidden;position:relative}.layout-drawer[data-v-3e0df31e]{width:240px;flex-shrink:0;border-right:1px solid var(--SmartThemeBorderColor)}.layout-main[data-v-3e0df31e]{flex:1;overflow:hidden}.drawer-slide-enter-active[data-v-3e0df31e],.drawer-slide-leave-active[data-v-3e0df31e]{transition:all .3s ease}.drawer-slide-enter-from[data-v-3e0df31e],.drawer-slide-leave-to[data-v-3e0df31e]{width:0;opacity:0}@media(max-width:768px){.table-drawer-layout[data-v-3e0df31e]{min-height:400px}.layout-drawer[data-v-3e0df31e]{width:100%}}.tab-container[data-v-9d94b988]{display:flex;flex-direction:column;height:100%}.tab-header[data-v-9d94b988]{display:flex;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);overflow-x:auto;scrollbar-width:none}.tab-header[data-v-9d94b988]::-webkit-scrollbar{display:none}.tab-item[data-v-9d94b988]{padding:12px 24px;cursor:pointer;border-bottom:2px solid transparent;transition:all .2s;display:flex;align-items:center;gap:8px;font-size:14px;color:var(--SmartThemeEmColor)}.tab-item[data-v-9d94b988]:hover{color:var(--SmartThemeBodyColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.tab-item.active[data-v-9d94b988]{color:var(--SmartThemeBodyColor);border-bottom-color:var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.tab-item i[data-v-9d94b988]{font-size:14px}.tab-body[data-v-9d94b988]{flex:1;overflow:hidden}@media(max-width:768px){.tab-header .tab-item[data-v-9d94b988]{width:40vw;flex-shrink:0;justify-content:center;padding:14px 16px;font-size:13px;white-space:nowrap}.tab-item[data-v-9d94b988]{gap:6px}}.drawer-toggle[data-v-04d4da93]{background:none;border:none;cursor:pointer;padding:7.2px;display:flex;align-items:center;justify-content:center;color:var(--SmartThemeBodyColor);transition:all .2s;border-radius:3.6px;transform:scale(.9)}.drawer-toggle[data-v-04d4da93]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.drawer-toggle[data-v-04d4da93]:active{transform:scale(.855)}.drawer-toggle.fab[data-v-04d4da93]{position:fixed;bottom:80px;right:20px;width:56px;height:56px;border-radius:50%;background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);box-shadow:0 4px 12px var(--SmartThemeShadowColor);z-index:1001}.drawer-toggle.fab[data-v-04d4da93]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.drawer-toggle.fab .hamburger-icon[data-v-04d4da93]{width:24px;height:24px}@media(min-width:769px){.drawer-toggle.fab[data-v-04d4da93]{display:none}}.hamburger-icon[data-v-04d4da93]{width:21.6px;height:16.2px;display:flex;flex-direction:column;justify-content:space-between;position:relative}.line[data-v-04d4da93]{width:100%;height:1.8px;background:var(--SmartThemeBodyColor);border-radius:1.8px;transition:all .3s ease}.toast-notification[data-v-76c92735]{position:fixed;top:20px;left:50%;transform:translate(-50%);display:flex;align-items:center;gap:10px;padding:12px 20px;border-radius:6px;font-size:14px;font-weight:500;z-index:10000;box-shadow:0 4px 12px #00000026}.toast-notification.success[data-v-76c92735]{background:#10b981;color:#fff}.toast-notification.error[data-v-76c92735]{background:#ef4444;color:#fff}.toast-notification i[data-v-76c92735]{font-size:16px}.toast-enter-active[data-v-76c92735],.toast-leave-active[data-v-76c92735]{transition:all .3s ease}.toast-enter-from[data-v-76c92735],.toast-leave-to[data-v-76c92735]{opacity:0;transform:translate(-50%) translateY(-20px)}@media(max-width:768px){.toast-notification[data-v-76c92735]{left:16px;right:16px;transform:none;justify-content:center}.toast-enter-from[data-v-76c92735],.toast-leave-to[data-v-76c92735]{transform:translateY(-20px)}}.empty-state[data-v-5ddb0dfd]{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.empty-state span[data-v-5ddb0dfd]{font-size:14px}.empty-state.compact[data-v-5ddb0dfd]{gap:12px;padding:40px 20px}.empty-state.compact span[data-v-5ddb0dfd]{font-size:14px}.auto-resize-wrapper[data-v-fd129974]{position:relative;width:100%;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);transition:all .25s cubic-bezier(.4,0,.2,1)}.auto-resize-wrapper[data-v-fd129974]:hover:not(.disabled){border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.auto-resize-wrapper.focused[data-v-fd129974]{border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.auto-resize-wrapper.disabled[data-v-fd129974]{opacity:.6;cursor:not-allowed}.textarea-mirror[data-v-fd129974]{position:absolute;top:0;left:0;visibility:hidden;pointer-events:none;height:auto;overflow:hidden;z-index:-1}.auto-resize-textarea[data-v-fd129974]{display:block;width:100%;padding:12px 16px;border:none;outline:none;background:transparent;font-family:inherit;font-size:14px;line-height:1.5;color:var(--SmartThemeBodyColor);resize:none;overflow:hidden;box-sizing:border-box;transition:height .15s ease}.auto-resize-textarea[data-v-fd129974]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.auto-resize-textarea[data-v-fd129974]:disabled{cursor:not-allowed}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar{width:8px}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-track{background:transparent}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-thumb{background:color-mix(in srgb,var(--SmartThemeBorderColor) 60%,transparent);border-radius:4px}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-thumb:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 80%,transparent)}.textarea-footer[data-v-fd129974]{display:flex;justify-content:flex-end;padding:2px 14px 8px;margin-top:-4px}.char-count[data-v-fd129974]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);transition:color .2s}.char-count.warning[data-v-fd129974]{color:#ef4444;font-weight:600}@media(max-width:768px){.auto-resize-textarea[data-v-fd129974]{padding:14px 16px;font-size:16px}}.form-wrapper[data-v-08eccbfb]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-08eccbfb]{display:flex;flex-direction:column;gap:24px;max-height:65vh;overflow-y:auto}.form-section[data-v-08eccbfb]{display:flex;flex-direction:column;gap:16px}.form-item[data-v-08eccbfb]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-08eccbfb]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);display:flex;align-items:center;gap:4px;letter-spacing:.3px}.required[data-v-08eccbfb]{color:#ef4444;margin-left:4px}.form-input[data-v-08eccbfb],.form-select[data-v-08eccbfb]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-08eccbfb]:hover,.form-select[data-v-08eccbfb]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-08eccbfb]:focus,.form-select[data-v-08eccbfb]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-08eccbfb]::placeholder,.form-select[data-v-08eccbfb]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input.has-error[data-v-08eccbfb],.form-select.has-error[data-v-08eccbfb]{border-color:#ef4444}.form-input.has-error[data-v-08eccbfb]:focus,.form-select.has-error[data-v-08eccbfb]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-08eccbfb]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-08eccbfb]{font-size:14px}.section-error[data-v-08eccbfb]{padding:10px 12px;background:#ef44441a;border-radius:6px;margin-bottom:8px}.field-hint[data-v-08eccbfb]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.columns-section[data-v-08eccbfb]{border-top:1.5px solid var(--SmartThemeBorderColor);padding-top:20px}.section-header[data-v-08eccbfb]{display:flex;justify-content:space-between;align-items:center}.column-count[data-v-08eccbfb]{font-size:13px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);padding:4px 10px;border-radius:12px}.columns-list[data-v-08eccbfb]{display:flex;flex-direction:column;gap:12px}.column-card[data-v-08eccbfb]{background:var(--SmartThemeBlurTintColor);border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;overflow:hidden}.column-card.has-error[data-v-08eccbfb]{border-color:#ef4444}.column-card-header[data-v-08eccbfb]{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:color-mix(in srgb,var(--SmartThemeBorderColor) 20%,transparent);border-bottom:1.5px solid var(--SmartThemeBorderColor)}.column-number[data-v-08eccbfb]{font-size:12px;font-weight:600;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.remove-btn[data-v-08eccbfb]{background:none;border:none;cursor:pointer;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);padding:6px;border-radius:4px;transition:all .2s}.remove-btn[data-v-08eccbfb]:hover{color:#ef4444;background:#ef44441a}.remove-btn i[data-v-08eccbfb]{font-size:14px}.column-card-body[data-v-08eccbfb]{padding:16px;display:flex;flex-direction:column;gap:12px}.form-row[data-v-08eccbfb]{display:flex;gap:12px}.form-col[data-v-08eccbfb]{display:flex;flex-direction:column;gap:6px}.form-col.form-col-name[data-v-08eccbfb]{flex:2}.form-col.form-col-type[data-v-08eccbfb],.form-col.form-col-default[data-v-08eccbfb],.form-col.form-col-comment[data-v-08eccbfb]{flex:1}.field-label[data-v-08eccbfb]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 70%,transparent)}.field-label .required[data-v-08eccbfb]{font-size:12px;margin-left:4px}.checkbox-label[data-v-08eccbfb]{display:flex;align-items:center;gap:8px;color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;width:fit-content}.checkbox-label input[data-v-08eccbfb]{cursor:pointer;width:16px;height:16px}.add-column-btn[data-v-08eccbfb]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px;border:2px dashed var(--SmartThemeBorderColor);border-radius:8px;background:transparent;color:color-mix(in srgb,var(--SmartThemeBodyColor) 70%,transparent);font-size:14px;cursor:pointer;transition:all .2s}.add-column-btn[data-v-08eccbfb]:hover{border-color:var(--SmartThemeBorderColor);color:var(--SmartThemeBodyColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 10%,transparent)}.add-column-btn i[data-v-08eccbfb]{font-size:14px}.form-actions[data-v-08eccbfb]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-08eccbfb]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-08eccbfb]{--form-modal-width: 100%}.form-container[data-v-08eccbfb]{gap:20px}.form-row[data-v-08eccbfb]{flex-direction:column;gap:12px}.form-col.form-col-name[data-v-08eccbfb],.form-col.form-col-type[data-v-08eccbfb],.form-col.form-col-default[data-v-08eccbfb],.form-col.form-col-comment[data-v-08eccbfb]{flex:1}.column-card-body[data-v-08eccbfb]{padding:12px}.form-actions[data-v-08eccbfb]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-08eccbfb]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-58e374f4]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-58e374f4]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-58e374f4]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-58e374f4]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-58e374f4]{color:#ef4444;margin-left:4px}.form-input[data-v-58e374f4]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-58e374f4]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-58e374f4]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-58e374f4]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-58e374f4]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-input.has-error[data-v-58e374f4]{border-color:#ef4444}.form-input.has-error[data-v-58e374f4]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-58e374f4]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-58e374f4]{font-size:14px}.field-hint[data-v-58e374f4]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.form-actions[data-v-58e374f4]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-58e374f4]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-58e374f4]{--form-modal-width: 100%}.form-container[data-v-58e374f4]{gap:16px}.form-item[data-v-58e374f4]{gap:8px}.form-label[data-v-58e374f4]{font-size:15px}.form-input[data-v-58e374f4]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-58e374f4]::placeholder{font-size:15px}.field-hint[data-v-58e374f4]{font-size:13px}.form-actions[data-v-58e374f4]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-58e374f4]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-03532044]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-03532044]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-03532044]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-03532044]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.form-actions[data-v-03532044]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-03532044]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-03532044]{--form-modal-width: 100%}.form-container[data-v-03532044]{gap:16px}.form-item[data-v-03532044]{gap:8px}.form-label[data-v-03532044]{font-size:15px}.form-actions[data-v-03532044]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-03532044]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.drop-table-confirm-wrapper[data-v-4629727b]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-4629727b]{padding:24px 20px;text-align:center}.confirm-icon-wrapper[data-v-4629727b]{margin-bottom:16px}.warning-icon[data-v-4629727b]{font-size:48px;color:#f59e0b}.confirm-content[data-v-4629727b]{margin-bottom:24px}.confirm-message[data-v-4629727b]{font-size:16px;color:var(--SmartThemeBodyColor);margin-bottom:12px;line-height:1.5}.confirm-message strong[data-v-4629727b]{color:#ef4444;font-weight:600}.confirm-warning[data-v-4629727b]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#ef44441a;border-radius:6px;font-size:13px;color:#ef4444;text-align:left}.confirm-warning i[data-v-4629727b]{font-size:14px;flex-shrink:0}.form-actions[data-v-4629727b]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.drop-table-confirm-wrapper[data-v-4629727b]{--confirm-modal-width: 90vw}.confirm-container[data-v-4629727b]{padding:20px 16px}.warning-icon[data-v-4629727b]{font-size:40px}.confirm-message[data-v-4629727b]{font-size:15px}.form-actions[data-v-4629727b]{flex-direction:column-reverse}.form-actions[data-v-4629727b]>*{width:100%}}.form-wrapper[data-v-019138f2]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-019138f2]{display:flex;flex-direction:column;gap:20px;max-height:70vh;overflow-y:auto}.form-item[data-v-019138f2]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-019138f2]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-019138f2]{color:#ef4444;margin-left:4px}.form-input[data-v-019138f2],.form-select[data-v-019138f2]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-019138f2]:hover,.form-select[data-v-019138f2]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-019138f2]:focus,.form-select[data-v-019138f2]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-019138f2]::placeholder,.form-select[data-v-019138f2]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input.has-error[data-v-019138f2],.form-select.has-error[data-v-019138f2]{border-color:#ef4444}.form-input.has-error[data-v-019138f2]:focus,.form-select.has-error[data-v-019138f2]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-019138f2]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-019138f2]{font-size:14px}.field-hint[data-v-019138f2]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.checkbox-label[data-v-019138f2]{display:flex;align-items:center;gap:8px;color:var(--SmartThemeEmColor);font-size:14px;cursor:pointer;width:fit-content}.checkbox-label input[data-v-019138f2]{cursor:pointer;width:18px;height:18px}.checkbox-label span[data-v-019138f2]{cursor:pointer}.form-actions[data-v-019138f2]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-019138f2]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-019138f2]{--form-modal-width: 100%}.form-container[data-v-019138f2]{gap:16px}.form-item[data-v-019138f2]{gap:8px}.form-label[data-v-019138f2]{font-size:15px}.form-input[data-v-019138f2],.form-select[data-v-019138f2]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-019138f2]::placeholder,.form-select[data-v-019138f2]::placeholder{font-size:15px}.field-hint[data-v-019138f2]{font-size:13px}.form-actions[data-v-019138f2]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-019138f2]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-36708f97]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-36708f97]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-36708f97]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-36708f97]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-36708f97]{color:#ef4444;margin-left:4px}.form-input[data-v-36708f97]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-36708f97]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-36708f97]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-36708f97]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-36708f97]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-input.has-error[data-v-36708f97]{border-color:#ef4444}.form-input.has-error[data-v-36708f97]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-36708f97]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-36708f97]{font-size:14px}.field-hint[data-v-36708f97]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.form-actions[data-v-36708f97]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-36708f97]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-36708f97]{--form-modal-width: 100%}.form-container[data-v-36708f97]{gap:16px}.form-item[data-v-36708f97]{gap:8px}.form-label[data-v-36708f97]{font-size:15px}.form-input[data-v-36708f97]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-36708f97]::placeholder{font-size:15px}.field-hint[data-v-36708f97]{font-size:13px}.form-actions[data-v-36708f97]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-36708f97]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-1f79f493]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-1f79f493]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-1f79f493]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-1f79f493]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.form-input[data-v-1f79f493]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-1f79f493]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-1f79f493]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-1f79f493]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-1f79f493]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-actions[data-v-1f79f493]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-1f79f493]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-1f79f493]{--form-modal-width: 100%}.form-container[data-v-1f79f493]{gap:16px}.form-item[data-v-1f79f493]{gap:8px}.form-label[data-v-1f79f493]{font-size:15px}.form-input[data-v-1f79f493]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-1f79f493]::placeholder{font-size:15px}.form-actions[data-v-1f79f493]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-1f79f493]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.drop-column-confirm-wrapper[data-v-7565defa]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-7565defa]{padding:24px 20px;text-align:center}.confirm-icon-wrapper[data-v-7565defa]{margin-bottom:16px}.warning-icon[data-v-7565defa]{font-size:48px;color:#f59e0b}.confirm-content[data-v-7565defa]{margin-bottom:24px}.confirm-message[data-v-7565defa]{font-size:16px;color:var(--SmartThemeBodyColor);margin-bottom:12px;line-height:1.5}.confirm-message strong[data-v-7565defa]{color:#ef4444;font-weight:600}.confirm-warning[data-v-7565defa]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#ef44441a;border-radius:6px;font-size:13px;color:#ef4444;text-align:left}.confirm-warning i[data-v-7565defa]{font-size:14px;flex-shrink:0}.form-actions[data-v-7565defa]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.drop-column-confirm-wrapper[data-v-7565defa]{--confirm-modal-width: 90vw}.confirm-container[data-v-7565defa]{padding:20px 16px}.warning-icon[data-v-7565defa]{font-size:40px}.confirm-message[data-v-7565defa]{font-size:15px}.form-actions[data-v-7565defa]{flex-direction:column-reverse}.form-actions[data-v-7565defa]>*{width:100%}}.ddl-container[data-v-da039aee]{padding:20px}.ddl-header[data-v-da039aee]{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.ddl-title[data-v-da039aee]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.copy-btn[data-v-da039aee]{display:flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--SmartThemeBorderColor);border-radius:4px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s}.copy-btn[data-v-da039aee]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.copy-btn i[data-v-da039aee]{font-size:12px}.ddl-content[data-v-da039aee]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:6px;padding:16px;margin-bottom:20px;max-height:400px;overflow:auto}.ddl-code[data-v-da039aee]{margin:0;font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;color:var(--SmartThemeBodyColor);white-space:pre-wrap;word-wrap:break-word}.form-actions[data-v-da039aee]{display:flex;gap:12px;justify-content:flex-end}@media(max-width:768px){.ddl-container[data-v-da039aee]{padding:16px}.ddl-content[data-v-da039aee]{padding:12px;max-height:300px}.ddl-code[data-v-da039aee]{font-size:12px}.form-actions[data-v-da039aee]>*{width:100%}}.table-management-tab[data-v-f00e195b]{display:flex;flex-direction:column;height:100%;overflow:hidden}.table-detail[data-v-f00e195b]{flex:1;display:flex;flex-direction:column;overflow:hidden}.table-header[data-v-f00e195b]{padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.table-title-section[data-v-f00e195b]{margin-bottom:12px}.table-name-row[data-v-f00e195b],.table-comment-row[data-v-f00e195b]{display:flex;align-items:center;gap:8px;margin-bottom:8px}.table-name-row[data-v-f00e195b]:last-child,.table-comment-row[data-v-f00e195b]:last-child{margin-bottom:0}.table-label[data-v-f00e195b]{font-size:13px;color:var(--SmartThemeEmColor);min-width:50px;flex-shrink:0}.table-name[data-v-f00e195b]{font-size:15px;font-weight:600;color:var(--SmartThemeBodyColor);flex:1;word-break:break-all}.table-comment[data-v-f00e195b]{font-size:14px;color:var(--SmartThemeEmColor);flex:1;word-break:break-all}.table-comment.placeholder[data-v-f00e195b]{color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent);font-style:italic}.table-actions[data-v-f00e195b]{display:flex;gap:8px}.columns-section[data-v-f00e195b]{flex:1;display:flex;flex-direction:column;overflow:hidden}.section-header[data-v-f00e195b]{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.section-title[data-v-f00e195b]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.columns-list[data-v-f00e195b]{flex:1;overflow-y:auto;padding:12px}.column-item[data-v-f00e195b]{display:flex;justify-content:space-between;align-items:flex-start;padding:12px;border-radius:6px;background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);margin-bottom:8px;transition:all .2s}.column-item[data-v-f00e195b]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent)}.column-main[data-v-f00e195b]{flex:1;min-width:0;margin-right:12px}.column-first-row[data-v-f00e195b]{display:flex;align-items:center;gap:24px;margin-bottom:6px}.column-name-wrapper[data-v-f00e195b]{display:flex;align-items:center;gap:6px;min-width:0}.column-icon[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);flex-shrink:0}.column-name[data-v-f00e195b]{font-size:14px;font-weight:500;color:var(--SmartThemeBodyColor);word-break:break-all;min-width:0}.type-badge[data-v-f00e195b]{display:inline-block;padding:2px 8px;border-radius:4px;font-size:12px;font-weight:500;background:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent);color:var(--SmartThemeEmColor);flex-shrink:0}.primary-key-badge[data-v-f00e195b]{display:inline-flex;align-items:center;justify-content:center;width:24px;height:24px;border-radius:4px;background:#f59e0b26;border:1px solid rgba(245,158,11,.3);flex-shrink:0}.primary-key-badge i[data-v-f00e195b]{font-size:12px;color:#f59e0b}.column-comment[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);word-break:break-all;line-height:1.4;max-height:2.8em;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical}.default-value[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);margin-top:4px}.column-actions[data-v-f00e195b]{display:flex;gap:4px;flex-shrink:0}@media(max-width:768px){.tab-toolbar[data-v-f00e195b]{flex-wrap:wrap;padding:10px 12px}.table-header[data-v-f00e195b]{padding:12px}.table-name-row[data-v-f00e195b],.table-comment-row[data-v-f00e195b]{flex-wrap:wrap}.table-actions[data-v-f00e195b]{width:100%;justify-content:stretch;margin-top:12px}.table-actions>button[data-v-f00e195b]{flex:1}.section-header[data-v-f00e195b]{padding:10px 12px}.columns-list[data-v-f00e195b]{padding:8px}.column-item[data-v-f00e195b]{flex-direction:column;gap:10px;padding:10px}.column-main[data-v-f00e195b]{margin-right:0}.column-first-row[data-v-f00e195b]{flex-wrap:wrap;gap:6px}.column-name-wrapper[data-v-f00e195b]{flex:1;min-width:0}.column-actions[data-v-f00e195b]{gap:2px;width:100%;justify-content:flex-end;border-top:1px solid var(--SmartThemeBorderColor);padding-top:8px;margin-top:4px}}.sql-panel-tab[data-v-34ac73ac]{display:flex;flex-direction:column;height:100%;gap:16px;overflow:hidden}.sql-editor-container[data-v-34ac73ac]{display:flex;flex-direction:column;height:100%;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.sql-toolbar[data-v-34ac73ac]{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-bottom:1px solid var(--SmartThemeBorderColor)}.toolbar-title[data-v-34ac73ac]{font-size:13px;font-weight:500;color:var(--SmartThemeEmColor)}.sql-editor[data-v-34ac73ac]{min-height:200px;max-height:400px;padding:16px;background:var(--SmartThemeBlurTintColor);border:none;outline:none;color:var(--SmartThemeBodyColor);font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;resize:vertical;overflow-y:auto;height:100%}.sql-editor[data-v-34ac73ac]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.sql-footer[data-v-34ac73ac]{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-top:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.result-status[data-v-34ac73ac]{font-size:12px;font-weight:500;color:var(--SmartThemeBodyColor)}.editor-stats[data-v-34ac73ac]{display:flex;gap:16px}.stat-item[data-v-34ac73ac]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.result-message[data-v-34ac73ac]{padding:10px 16px;font-size:12px;border-top:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.result-message.error[data-v-34ac73ac]{background:color-mix(in srgb,#e74c3c 20%,transparent);color:#e74c3c}@media(max-width:768px){.sql-panel-tab[data-v-34ac73ac]{gap:12px}.sql-editor[data-v-34ac73ac]{font-size:12px;min-height:150px;height:100%}.sql-footer[data-v-34ac73ac]{gap:8px}}.data-form-wrapper[data-v-dd6bd7a8]{--form-modal-width: 50vw;--form-modal-height: auto}.data-form[data-v-dd6bd7a8]{display:flex;flex-direction:column;gap:24px;max-height:65vh}.form-content[data-v-dd6bd7a8]{display:flex;flex-direction:column;gap:20px;overflow-y:auto;padding:8px 4px}.form-item[data-v-dd6bd7a8]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-dd6bd7a8]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required-mark[data-v-dd6bd7a8]{color:#ef4444;margin-left:4px;font-size:14px}.form-input[data-v-dd6bd7a8]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-dd6bd7a8]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-dd6bd7a8]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-dd6bd7a8]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-dd6bd7a8]:disabled{opacity:.6;cursor:not-allowed}.form-hint[data-v-dd6bd7a8]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);margin-top:-4px;line-height:1.5;padding-left:2px}.form-actions[data-v-dd6bd7a8]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-dd6bd7a8]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.data-form-wrapper[data-v-dd6bd7a8]{--form-modal-width: 100%}.data-form[data-v-dd6bd7a8]{gap:20px;max-height:70vh}.form-content[data-v-dd6bd7a8]{gap:16px;padding:4px}.form-item[data-v-dd6bd7a8]{gap:8px}.form-label[data-v-dd6bd7a8]{font-size:15px}.form-input[data-v-dd6bd7a8]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-dd6bd7a8]::placeholder{font-size:15px}.form-hint[data-v-dd6bd7a8]{font-size:13px}.form-actions[data-v-dd6bd7a8]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-dd6bd7a8]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.delete-data-confirm-wrapper[data-v-b672c047]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-b672c047]{padding:20px}.confirm-content[data-v-b672c047]{display:flex;flex-direction:column;align-items:center;gap:16px;padding:20px 0}.warning-icon[data-v-b672c047]{font-size:48px;color:#f59e0b}.confirm-message[data-v-b672c047]{font-size:14px;color:var(--SmartThemeBodyColor);text-align:center;line-height:1.6;margin:0}.form-actions[data-v-b672c047]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.delete-data-confirm-wrapper[data-v-b672c047]{--confirm-modal-width: 90vw}.confirm-container[data-v-b672c047]{padding:16px}.form-actions[data-v-b672c047]{flex-direction:column-reverse}.form-actions>button[data-v-b672c047]{width:100%}}.export-container[data-v-affef56e]{padding:20px}.export-header[data-v-affef56e]{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.export-title[data-v-affef56e]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.copy-btn[data-v-affef56e]{display:flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--SmartThemeBorderColor);border-radius:4px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s}.copy-btn[data-v-affef56e]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.copy-btn i[data-v-affef56e]{font-size:12px}.export-content[data-v-affef56e]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:6px;padding:16px;margin-bottom:20px;max-height:400px;overflow:auto}.export-code[data-v-affef56e]{margin:0;font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;color:var(--SmartThemeBodyColor);white-space:pre-wrap;word-wrap:break-word}.form-actions[data-v-affef56e]{display:flex;gap:12px;justify-content:flex-end}@media(max-width:768px){.export-container[data-v-affef56e]{padding:16px}.export-content[data-v-affef56e]{padding:12px;max-height:300px}.export-code[data-v-affef56e]{font-size:12px}.form-actions[data-v-affef56e]>*{width:100%}}.chat-data-management-tab[data-v-c1523f72]{display:flex;flex-direction:column;height:100%;overflow:hidden}.data-detail[data-v-c1523f72]{flex:1;display:flex;flex-direction:column;overflow:hidden}.data-toolbar[data-v-c1523f72]{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.data-title[data-v-c1523f72]{display:flex;flex-direction:column;gap:4px}.table-name[data-v-c1523f72]{font-size:15px;font-weight:600;color:var(--SmartThemeBodyColor)}.table-comment[data-v-c1523f72]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.data-actions[data-v-c1523f72]{display:flex;gap:8px}.data-list[data-v-c1523f72]{flex:1;overflow:hidden;display:flex;flex-direction:column}.table-container[data-v-c1523f72]{flex:1;overflow:auto}.data-table[data-v-c1523f72]{width:100%;border-collapse:collapse;font-size:13px}thead[data-v-c1523f72]{position:sticky;top:0;z-index:30;background:var(--SmartThemeBlurTintColor)}thead th[data-v-c1523f72]{padding:12px 16px;border-bottom:2px solid var(--SmartThemeBorderColor);font-weight:600;color:var(--SmartThemeBodyColor);white-space:nowrap;background:var(--SmartThemeBlurTintColor)}tbody th[data-v-c1523f72]{text-align:left;padding:12px 16px;font-weight:600;color:var(--SmartThemeBodyColor);white-space:nowrap}.checkbox-header[data-v-c1523f72]{width:50px;text-align:center;padding:12px 8px}.column-header[data-v-c1523f72]{min-width:120px}.actions-header[data-v-c1523f72]{width:100px;text-align:center;padding:12px 8px}.sticky-col[data-v-c1523f72]{position:sticky;background:var(--SmartThemeBlurTintColor);z-index:20;left:0}thead th.sticky-col[data-v-c1523f72]{z-index:32;left:0}.primary-key[data-v-c1523f72]{background:color-mix(in srgb,rgba(218,165,32,.15) 50%,var(--SmartThemeBlurTintColor));border-right:2px solid color-mix(in srgb,rgba(218,165,32,.3) 50%,var(--SmartThemeBorderColor))}thead th.primary-key[data-v-c1523f72]{background:color-mix(in srgb,rgba(218,165,32,.2) 50%,var(--SmartThemeBlurTintColor))}thead th.actions-header.sticky-col[data-v-c1523f72]{z-index:31}thead th.checkbox-header.sticky-col[data-v-c1523f72]{z-index:32}.table-row[data-v-c1523f72]{border-bottom:1px solid var(--SmartThemeBorderColor);transition:background-color .2s}.table-row[data-v-c1523f72]:hover{background-color:color-mix(in srgb,var(--SmartThemeBorderColor) 20%,transparent)}.table-row[data-v-c1523f72]:last-child{border-bottom:none}.table-cell[data-v-c1523f72]{padding:10px 16px;border-right:1px solid var(--SmartThemeBorderColor);max-width:300px;min-width:120px;background:var(--SmartThemeBlurTintColor);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.table-cell[data-v-c1523f72]:last-child{border-right:none}.table-cell.primary-key[data-v-c1523f72]{background:color-mix(in srgb,rgba(59,130,246,.1) 50%,var(--SmartThemeBlurTintColor));border-right:2px solid color-mix(in srgb,rgba(59,130,246,.3) 50%,var(--SmartThemeBorderColor))}.cell-value[data-v-c1523f72]{color:var(--SmartThemeBodyColor);text-align:center;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;line-height:1.5}.checkbox-cell[data-v-c1523f72]{width:50px;text-align:center;padding:10px 8px;border-right:1px solid var(--SmartThemeBorderColor)}.actions-cell[data-v-c1523f72]{width:100px;padding:10px 8px;text-align:center;border-right:1px solid var(--SmartThemeBorderColor)}.actions-cell.sticky-col[data-v-c1523f72]{box-shadow:3px 0 10px -3px #00000040}.checkbox-cell.sticky-col[data-v-c1523f72]{box-shadow:2px 0 10px -3px #00000026}.checkbox-wrapper[data-v-c1523f72]{display:flex;align-items:center;justify-content:center;cursor:pointer}.checkbox-wrapper input[type=checkbox][data-v-c1523f72]{width:16px;height:16px;cursor:pointer}.row-actions[data-v-c1523f72]{display:flex;gap:4px;justify-content:center}@media(max-width:768px){.data-toolbar[data-v-c1523f72]{flex-direction:column;align-items:stretch;gap:12px;padding:12px}.data-title[data-v-c1523f72]{align-items:flex-start}.data-actions[data-v-c1523f72]{width:100%}.data-actions>button[data-v-c1523f72]{flex:1}thead th[data-v-c1523f72],.table-cell[data-v-c1523f72]{padding:8px 10px}.column-header[data-v-c1523f72]{min-width:80px}.table-cell[data-v-c1523f72]{max-width:150px;min-width:80px}.actions-header[data-v-c1523f72],.actions-cell[data-v-c1523f72]{width:70px}}.translation_settings[data-v-d18c04a2],.inline-drawer[data-v-d18c04a2]{width:100%}.inline-drawer-toggle[data-v-d18c04a2]{cursor:pointer}.inline-drawer-icon[data-v-d18c04a2]{transition:transform .2s}.inline-drawer-icon.down[data-v-d18c04a2]{transform:rotate(0)}.inline-drawer-icon.up[data-v-d18c04a2]{transform:rotate(180deg)}')),document.head.appendChild(a)}}catch(r){console.error("vite-plugin-css-injected-by-js",r)}})();
var Rr = {};
// @__NO_SIDE_EFFECTS__
function Jt(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const s of t.split(",")) e[s] = 1;
  return (s) => s in e;
}
const ye = Rr.NODE_ENV !== "production" ? Object.freeze({}) : {}, ws = Rr.NODE_ENV !== "production" ? Object.freeze([]) : [], qe = () => {
}, Lr = () => !1, an = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter
(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), Rn = (t) => t.startsWith("onUpdate:"), Ve = Object.assign, Hi = (t, e) => {
  const s = t.indexOf(e);
  s > -1 && t.splice(s, 1);
}, pl = Object.prototype.hasOwnProperty, Ee = (t, e) => pl.call(t, e), z = Array.isArray, hs = (t) => ln(t) === "[object Map]", Rs = (t) => ln(t) === "[object Set]", Do = (t) => ln(t) === "[object Date]", Z = (t) => typeof t == "function", Me = (t) => typeof t == "string", gt = (t) => typeof t == "symbol", ve = (t) => t !== null && typeof t == "object", Wi = (t) => (ve(t) || Z(t)) && Z(t.then) && Z(t.catch), kr = Object.prototype.toString, ln = (t) => kr.call(t), Ki = (t) => ln(t).slice(8, -1), Pr = (t) => ln(t) === "[object Object]", zi = (t) => Me(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Ks = /* @__PURE__ */ Jt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), hl = /* @__PURE__ */ Jt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), Jn = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return ((s) => e[s] || (e[s] = t(s)));
}, ml = /-\w/g, ut = Jn(
  (t) => t.replace(ml, (e) => e.slice(1).toUpperCase())
), vl = /\B([A-Z])/g, Yt = Jn(
  (t) => t.replace(vl, "-$1").toLowerCase()
), Qn = Jn((t) => t.charAt(0).toUpperCase() + t.slice(1)), us = Jn(
  (t) => t ? `on${Qn(t)}` : ""
), st = (t, e) => !Object.is(t, e), Ss = (t, ...e) => {
  for (let s = 0; s < t.length; s++)
    t[s](...e);
}, Ln = (t, e, s, n = !1) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    writable: n,
    value: s
  });
}, Xn = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, bl = (t) => {
  const e = Me(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let Oo;
const cn = () => Oo || (Oo = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {});
function Ke(t) {
  if (z(t)) {
    const e = {};
    for (let s = 0; s < t.length; s++) {
      const n = t[s], i = Me(n) ? _l(n) : Ke(n);
      if (i)
        for (const o in i)
          e[o] = i[o];
    }
    return e;
  } else if (Me(t) || ve(t))
    return t;
}
const gl = /;(?![^(]*\))/g, El = /:([^]+)/, yl = /\/\*[^]*?\*\//g;
function _l(t) {
  const e = {};
  return t.replace(yl, "").split(gl).forEach((s) => {
    if (s) {
      const n = s.split(El);
      n.length > 1 && (e[n[0].trim()] = n[1].trim());
    }
  }), e;
}
function Re(t) {
  let e = "";
  if (Me(t))
    e = t;
  else if (z(t))
    for (let s = 0; s < t.length; s++) {
      const n = Re(t[s]);
      n && (e += n + " ");
    }
  else if (ve(t))
    for (const s in t)
      t[s] && (e += s + " ");
  return e.trim();
}
const Tl = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Nl = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", xl = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", Sl = /* @__PURE__ */ Jt(Tl), Cl = /* @__PURE__ */ Jt(Nl), wl = /* @__PURE__ */ Jt(xl), Dl = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Ol = /* @__PURE__ */ Jt(Dl);
function Br(t) {
  return !!t || t === "";
}
function $l(t, e) {
  if (t.length !== e.length) return !1;
  let s = !0;
  for (let n = 0; s && n < t.length; n++)
    s = is(t[n], e[n]);
  return s;
}
function is(t, e) {
  if (t === e) return !0;
  let s = Do(t), n = Do(e);
  if (s || n)
    return s && n ? t.getTime() === e.getTime() : !1;
  if (s = gt(t), n = gt(e), s || n)
    return t === e;
  if (s = z(t), n = z(e), s || n)
    return s && n ? $l(t, e) : !1;
  if (s = ve(t), n = ve(e), s || n) {
    if (!s || !n)
      return !1;
    const i = Object.keys(t).length, o = Object.keys(e).length;
    if (i !== o)
      return !1;
    for (const r in t) {
      const a = t.hasOwnProperty(r), l = e.hasOwnProperty(r);
      if (a && !l || !a && l || !is(t[r], e[r]))
        return !1;
    }
  }
  return String(t) === String(e);
}
function Gi(t, e) {
  return t.findIndex((s) => is(s, e));
}
const Fr = (t) => !!(t && t.__v_isRef === !0), ue = (t) => Me(t) ? t : t == null ? "" : z(t) || ve(t) && (t.toString === kr || !Z(t.toString)) ? Fr(t) ? ue(t.value) : JSON.stringify(t, Ur, 2) : String(t), Ur = (t, e) => Fr(e) ? Ur(t, e.value) : hs(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (s, [n, i], o) => (s[fi(n, o) + " =>"] = i, s),
    {}
  )
} : Rs(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((s) => fi(s))
} : gt(e) ? fi(e) : ve(e) && !z(e) && !Pr(e) ? String(e) : e, fi = (t, e = "") => {
  var s;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    gt(t) ? `Symbol(${(s = t.description) != null ? s : e})` : t
  );
};
var Ce = {};
function Et(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
let tt;
class Al {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.__v_skip = !0, this.parent = tt, !e && tt && (this.index = (tt.scopes || (tt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, s;
      if (this.scopes)
        for (e = 0, s = this.scopes.length; e < s; e++)
          this.scopes[e].pause();
      for (e = 0, s = this.effects.length; e < s; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, s;
      if (this.scopes)
        for (e = 0, s = this.scopes.length; e < s; e++)
          this.scopes[e].resume();
      for (e = 0, s = this.effects.length; e < s; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const s = tt;
      try {
        return tt = this, e();
      } finally {
        tt = s;
      }
    } else Ce.NODE_ENV !== "production" && Et("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = tt, tt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (tt = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let s, n;
      for (s = 0, n = this.effects.length; s < n; s++)
        this.effects[s].stop();
      for (this.effects.length = 0, s = 0, n = this.cleanups.length; s < n; s++)
        this.cleanups[s]();
      if (this.cleanups.length = 0, this.scopes) {
        for (s = 0, n = this.scopes.length; s < n; s++)
          this.scopes[s].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Vl() {
  return tt;
}
let Te;
const pi = /* @__PURE__ */ new WeakSet();
class jr {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, tt && tt.active && tt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, pi.has(this) && (pi.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Hr(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, $o(this), Wr(this);
    const e = Te, s = mt;
    Te = this, mt = !0;
    try {
      return this.fn();
    } finally {
      Ce.NODE_ENV !== "production" && Te !== this && Et(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), Kr(this), Te = e, mt = s, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        Qi(e);
      this.deps = this.depsTail = void 0, $o(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? pi.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    xi(this) && this.run();
  }
  get dirty() {
    return xi(this);
  }
}
let qr = 0, zs, Gs;
function Hr(t, e = !1) {
  if (t.flags |= 8, e) {
    t.next = Gs, Gs = t;
    return;
  }
  t.next = zs, zs = t;
}
function Yi() {
  qr++;
}
function Ji() {
  if (--qr > 0)
    return;
  if (Gs) {
    let e = Gs;
    for (Gs = void 0; e; ) {
      const s = e.next;
      e.next = void 0, e.flags &= -9, e = s;
    }
  }
  let t;
  for (; zs; ) {
    let e = zs;
    for (zs = void 0; e; ) {
      const s = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (n) {
          t || (t = n);
        }
      e = s;
    }
  }
  if (t) throw t;
}
function Wr(t) {
  for (let e = t.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function Kr(t) {
  let e, s = t.depsTail, n = s;
  for (; n; ) {
    const i = n.prevDep;
    n.version === -1 ? (n === s && (s = i), Qi(n), Ml(n)) : e = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = i;
  }
  t.deps = e, t.depsTail = s;
}
function xi(t) {
  for (let e = t.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (zr(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!t._dirty;
}
function zr(t) {
  if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17, t.globalVersion === Zs) || (t.globalVersion = Zs, !t.isSSR && t.flags & 128 && (!t.deps && !t._dirty || !xi(t))))
    return;
  t.flags |= 2;
  const e = t.dep, s = Te, n = mt;
  Te = t, mt = !0;
  try {
    Wr(t);
    const i = t.fn(t._value);
    (e.version === 0 || st(i, t._value)) && (t.flags |= 128, t._value = i, e.version++);
  } catch (i) {
    throw e.version++, i;
  } finally {
    Te = s, mt = n, Kr(t), t.flags &= -3;
  }
}
function Qi(t, e = !1) {
  const { dep: s, prevSub: n, nextSub: i } = t;
  if (n && (n.nextSub = i, t.prevSub = void 0), i && (i.prevSub = n, t.nextSub = void 0), Ce.NODE_ENV !== "production" && s.subsHead === t && (s.subsHead = i), s.subs === t && (s.subs = n, !n && s.computed)) {
    s.computed.flags &= -5;
    for (let o = s.computed.deps; o; o = o.nextDep)
      Qi(o, !0);
  }
  !e && !--s.sc && s.map && s.map.delete(s.key);
}
function Ml(t) {
  const { prevDep: e, nextDep: s } = t;
  e && (e.nextDep = s, t.prevDep = void 0), s && (s.prevDep = e, t.nextDep = void 0);
}
let mt = !0;
const Gr = [];
function yt() {
  Gr.push(mt), mt = !1;
}
function _t() {
  const t = Gr.pop();
  mt = t === void 0 ? !0 : t;
}
function $o(t) {
  const { cleanup: e } = t;
  if (t.cleanup = void 0, e) {
    const s = Te;
    Te = void 0;
    try {
      e();
    } finally {
      Te = s;
    }
  }
}
let Zs = 0;
class Il {
  constructor(e, s) {
    this.sub = e, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Zn {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0, Ce.NODE_ENV !== "production" && (this.subsHead = void 0);
  }
  track(e) {
    if (!Te || !mt || Te === this.computed)
      return;
    let s = this.activeLink;
    if (s === void 0 || s.sub !== Te)
      s = this.activeLink = new Il(Te, this), Te.deps ? (s.prevDep = Te.depsTail, Te.depsTail.nextDep = s, Te.depsTail = s) : Te.deps = Te.depsTail = s, Yr(s);
    else if (s.version === -1 && (s.version = this.version, s.nextDep)) {
      const n = s.nextDep;
      n.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = n), s.prevDep = Te.depsTail, s.nextDep = void 0, Te.depsTail.nextDep = s, Te.depsTail = s, Te.deps === s && (Te.deps = n);
    }
    return Ce.NODE_ENV !== "production" && Te.onTrack && Te.onTrack(
      Ve(
        {
          effect: Te
        },
        e
      )
    ), s;
  }
  trigger(e) {
    this.version++, Zs++, this.notify(e);
  }
  notify(e) {
    Yi();
    try {
      if (Ce.NODE_ENV !== "production")
        for (let s = this.subsHead; s; s = s.nextSub)
          s.sub.onTrigger && !(s.sub.flags & 8) && s.sub.onTrigger(
            Ve(
              {
                effect: s.sub
              },
              e
            )
          );
      for (let s = this.subs; s; s = s.prevSub)
        s.sub.notify() && s.sub.dep.notify();
    } finally {
      Ji();
    }
  }
}
function Yr(t) {
  if (t.dep.sc++, t.sub.flags & 4) {
    const e = t.dep.computed;
    if (e && !t.dep.subs) {
      e.flags |= 20;
      for (let n = e.deps; n; n = n.nextDep)
        Yr(n);
    }
    const s = t.dep.subs;
    s !== t && (t.prevSub = s, s && (s.nextSub = t)), Ce.NODE_ENV !== "production" && t.dep.subsHead === void 0 && (t.dep.subsHead = t), t.dep.subs = t;
  }
}
const Si = /* @__PURE__ */ new WeakMap(), ms = /* @__PURE__ */ Symbol(
  Ce.NODE_ENV !== "production" ? "Object iterate" : ""
), Ci = /* @__PURE__ */ Symbol(
  Ce.NODE_ENV !== "production" ? "Map keys iterate" : ""
), en = /* @__PURE__ */ Symbol(
  Ce.NODE_ENV !== "production" ? "Array iterate" : ""
);
function je(t, e, s) {
  if (mt && Te) {
    let n = Si.get(t);
    n || Si.set(t, n = /* @__PURE__ */ new Map());
    let i = n.get(s);
    i || (n.set(s, i = new Zn()), i.map = n, i.key = s), Ce.NODE_ENV !== "production" ? i.track({
      target: t,
      type: e,
      key: s
    }) : i.track();
  }
}
function Vt(t, e, s, n, i, o) {
  const r = Si.get(t);
  if (!r) {
    Zs++;
    return;
  }
  const a = (l) => {
    l && (Ce.NODE_ENV !== "production" ? l.trigger({
      target: t,
      type: e,
      key: s,
      newValue: n,
      oldValue: i,
      oldTarget: o
    }) : l.trigger());
  };
  if (Yi(), e === "clear")
    r.forEach(a);
  else {
    const l = z(t), u = l && zi(s);
    if (l && s === "length") {
      const c = Number(n);
      r.forEach((d, m) => {
        (m === "length" || m === en || !gt(m) && m >= c) && a(d);
      });
    } else
      switch ((s !== void 0 || r.has(void 0)) && a(r.get(s)), u && a(r.get(en)), e) {
        case "add":
          l ? u && a(r.get("length")) : (a(r.get(ms)), hs(t) && a(r.get(Ci)));
          break;
        case "delete":
          l || (a(r.get(ms)), hs(t) && a(r.get(Ci)));
          break;
        case "set":
          hs(t) && a(r.get(ms));
          break;
      }
  }
  Ji();
}
function Ts(t) {
  const e = /* @__PURE__ */ ce(t);
  return e === t ? e : (je(e, "iterate", en), /* @__PURE__ */ Xe(t) ? e : e.map(Nt));
}
function ei(t) {
  return je(t = /* @__PURE__ */ ce(t), "iterate", en), t;
}
function es(t, e) {
  return /* @__PURE__ */ Tt(t) ? Vs(/* @__PURE__ */ ns(t) ? Nt(e) : e) : Nt(e);
}
const Rl = {
  __proto__: null,
  [Symbol.iterator]() {
    return hi(this, Symbol.iterator, (t) => es(this, t));
  },
  concat(...t) {
    return Ts(this).concat(
      ...t.map((e) => z(e) ? Ts(e) : e)
    );
  },
  entries() {
    return hi(this, "entries", (t) => (t[1] = es(this, t[1]), t));
  },
  every(t, e) {
    return Ut(this, "every", t, e, void 0, arguments);
  },
  filter(t, e) {
    return Ut(
      this,
      "filter",
      t,
      e,
      (s) => s.map((n) => es(this, n)),
      arguments
    );
  },
  find(t, e) {
    return Ut(
      this,
      "find",
      t,
      e,
      (s) => es(this, s),
      arguments
    );
  },
  findIndex(t, e) {
    return Ut(this, "findIndex", t, e, void 0, arguments);
  },
  findLast(t, e) {
    return Ut(
      this,
      "findLast",
      t,
      e,
      (s) => es(this, s),
      arguments
    );
  },
  findLastIndex(t, e) {
    return Ut(this, "findLastIndex", t, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(t, e) {
    return Ut(this, "forEach", t, e, void 0, arguments);
  },
  includes(...t) {
    return mi(this, "includes", t);
  },
  indexOf(...t) {
    return mi(this, "indexOf", t);
  },
  join(t) {
    return Ts(this).join(t);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...t) {
    return mi(this, "lastIndexOf", t);
  },
  map(t, e) {
    return Ut(this, "map", t, e, void 0, arguments);
  },
  pop() {
    return Fs(this, "pop");
  },
  push(...t) {
    return Fs(this, "push", t);
  },
  reduce(t, ...e) {
    return Ao(this, "reduce", t, e);
  },
  reduceRight(t, ...e) {
    return Ao(this, "reduceRight", t, e);
  },
  shift() {
    return Fs(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(t, e) {
    return Ut(this, "some", t, e, void 0, arguments);
  },
  splice(...t) {
    return Fs(this, "splice", t);
  },
  toReversed() {
    return Ts(this).toReversed();
  },
  toSorted(t) {
    return Ts(this).toSorted(t);
  },
  toSpliced(...t) {
    return Ts(this).toSpliced(...t);
  },
  unshift(...t) {
    return Fs(this, "unshift", t);
  },
  values() {
    return hi(this, "values", (t) => es(this, t));
  }
};
function hi(t, e, s) {
  const n = ei(t), i = n[e]();
  return n !== t && !/* @__PURE__ */ Xe(t) && (i._next = i.next, i.next = () => {
    const o = i._next();
    return o.done || (o.value = s(o.value)), o;
  }), i;
}
const Ll = Array.prototype;
function Ut(t, e, s, n, i, o) {
  const r = ei(t), a = r !== t && !/* @__PURE__ */ Xe(t), l = r[e];
  if (l !== Ll[e]) {
    const d = l.apply(t, o);
    return a ? Nt(d) : d;
  }
  let u = s;
  r !== t && (a ? u = function(d, m) {
    return s.call(this, es(t, d), m, t);
  } : s.length > 2 && (u = function(d, m) {
    return s.call(this, d, m, t);
  }));
  const c = l.call(r, u, n);
  return a && i ? i(c) : c;
}
function Ao(t, e, s, n) {
  const i = ei(t);
  let o = s;
  return i !== t && (/* @__PURE__ */ Xe(t) ? s.length > 3 && (o = function(r, a, l) {
    return s.call(this, r, a, l, t);
  }) : o = function(r, a, l) {
    return s.call(this, r, es(t, a), l, t);
  }), i[e](o, ...n);
}
function mi(t, e, s) {
  const n = /* @__PURE__ */ ce(t);
  je(n, "iterate", en);
  const i = n[e](...s);
  return (i === -1 || i === !1) && /* @__PURE__ */ kn(s[0]) ? (s[0] = /* @__PURE__ */ ce(s[0]), n[e](...s)) : i;
}
function Fs(t, e, s = []) {
  yt(), Yi();
  const n = (/* @__PURE__ */ ce(t))[e].apply(t, s);
  return Ji(), _t(), n;
}
const kl = /* @__PURE__ */ Jt("__proto__,__v_isRef,__isVue"), Jr = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(gt)
);
function Pl(t) {
  gt(t) || (t = String(t));
  const e = /* @__PURE__ */ ce(this);
  return je(e, "has", t), e.hasOwnProperty(t);
}
class Qr {
  constructor(e = !1, s = !1) {
    this._isReadonly = e, this._isShallow = s;
  }
  get(e, s, n) {
    if (s === "__v_skip") return e.__v_skip;
    const i = this._isReadonly, o = this._isShallow;
    if (s === "__v_isReactive")
      return !i;
    if (s === "__v_isReadonly")
      return i;
    if (s === "__v_isShallow")
      return o;
    if (s === "__v_raw")
      return n === (i ? o ? na : sa : o ? ta : ea).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
    const r = z(e);
    if (!i) {
      let l;
      if (r && (l = Rl[s]))
        return l;
      if (s === "hasOwnProperty")
        return Pl;
    }
    const a = Reflect.get(
      e,
      s,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      /* @__PURE__ */ Fe(e) ? e : n
    );
    if ((gt(s) ? Jr.has(s) : kl(s)) || (i || je(e, "get", s), o))
      return a;
    if (/* @__PURE__ */ Fe(a)) {
      const l = r && zi(s) ? a : a.value;
      return i && ve(l) ? /* @__PURE__ */ Di(l) : l;
    }
    return ve(a) ? i ? /* @__PURE__ */ Di(a) : /* @__PURE__ */ _s(a) : a;
  }
}
class Xr extends Qr {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, s, n, i) {
    let o = e[s];
    const r = z(e) && zi(s);
    if (!this._isShallow) {
      const u = /* @__PURE__ */ Tt(o);
      if (!/* @__PURE__ */ Xe(n) && !/* @__PURE__ */ Tt(n) && (o = /* @__PURE__ */ ce(o), n = /* @__PURE__ */ ce(n)), !r && /* @__PURE__ */ Fe(o) && !/* @__PURE__ */ Fe(n))
        return u ? (Ce.NODE_ENV !== "production" && Et(
          `Set operation on key "${String(s)}" failed: target is readonly.`,
          e[s]
        ), !0) : (o.value = n, !0);
    }
    const a = r ? Number(s) < e.length : Ee(e, s), l = Reflect.set(
      e,
      s,
      n,
      /* @__PURE__ */ Fe(e) ? e : i
    );
    return e === /* @__PURE__ */ ce(i) && (a ? st(n, o) && Vt(e, "set", s, n, o) : Vt(e, "add", s, n)), l;
  }
  deleteProperty(e, s) {
    const n = Ee(e, s), i = e[s], o = Reflect.deleteProperty(e, s);
    return o && n && Vt(e, "delete", s, void 0, i), o;
  }
  has(e, s) {
    const n = Reflect.has(e, s);
    return (!gt(s) || !Jr.has(s)) && je(e, "has", s), n;
  }
  ownKeys(e) {
    return je(
      e,
      "iterate",
      z(e) ? "length" : ms
    ), Reflect.ownKeys(e);
  }
}
class Zr extends Qr {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, s) {
    return Ce.NODE_ENV !== "production" && Et(
      `Set operation on key "${String(s)}" failed: target is readonly.`,
      e
    ), !0;
  }
  deleteProperty(e, s) {
    return Ce.NODE_ENV !== "production" && Et(
      `Delete operation on key "${String(s)}" failed: target is readonly.`,
      e
    ), !0;
  }
}
const Bl = /* @__PURE__ */ new Xr(), Fl = /* @__PURE__ */ new Zr(), Ul = /* @__PURE__ */ new Xr(!0), jl = /* @__PURE__ */ new Zr(!0), wi = (t) => t, En = (t) => Reflect.getPrototypeOf(t);
function ql(t, e, s) {
  return function(...n) {
    const i = this.__v_raw, o = /* @__PURE__ */ ce(i), r = hs(o), a = t === "entries" || t === Symbol.iterator && r, l = t === "keys" && r, u = i[t](...n), c = s ? wi : e ? Vs : Nt;
    return !e && je(
      o,
      "iterate",
      l ? Ci : ms
    ), Ve(
      // inheriting all iterator properties
      Object.create(u),
      {
        // iterator protocol
        next() {
          const { value: d, done: m } = u.next();
          return m ? { value: d, done: m } : {
            value: a ? [c(d[0]), c(d[1])] : c(d),
            done: m
          };
        }
      }
    );
  };
}
function yn(t) {
  return function(...e) {
    if (Ce.NODE_ENV !== "production") {
      const s = e[0] ? `on key "${e[0]}" ` : "";
      Et(
        `${Qn(t)} operation ${s}failed: target is readonly.`,
        /* @__PURE__ */ ce(this)
      );
    }
    return t === "delete" ? !1 : t === "clear" ? void 0 : this;
  };
}
function Hl(t, e) {
  const s = {
    get(i) {
      const o = this.__v_raw, r = /* @__PURE__ */ ce(o), a = /* @__PURE__ */ ce(i);
      t || (st(i, a) && je(r, "get", i), je(r, "get", a));
      const { has: l } = En(r), u = e ? wi : t ? Vs : Nt;
      if (l.call(r, i))
        return u(o.get(i));
      if (l.call(r, a))
        return u(o.get(a));
      o !== r && o.get(i);
    },
    get size() {
      const i = this.__v_raw;
      return !t && je(/* @__PURE__ */ ce(i), "iterate", ms), i.size;
    },
    has(i) {
      const o = this.__v_raw, r = /* @__PURE__ */ ce(o), a = /* @__PURE__ */ ce(i);
      return t || (st(i, a) && je(r, "has", i), je(r, "has", a)), i === a ? o.has(i) : o.has(i) || o.has(a);
    },
    forEach(i, o) {
      const r = this, a = r.__v_raw, l = /* @__PURE__ */ ce(a), u = e ? wi : t ? Vs : Nt;
      return !t && je(l, "iterate", ms), a.forEach((c, d) => i.call(o, u(c), u(d), r));
    }
  };
  return Ve(
    s,
    t ? {
      add: yn("add"),
      set: yn("set"),
      delete: yn("delete"),
      clear: yn("clear")
    } : {
      add(i) {
        !e && !/* @__PURE__ */ Xe(i) && !/* @__PURE__ */ Tt(i) && (i = /* @__PURE__ */ ce(i));
        const o = /* @__PURE__ */ ce(this);
        return En(o).has.call(o, i) || (o.add(i), Vt(o, "add", i, i)), this;
      },
      set(i, o) {
        !e && !/* @__PURE__ */ Xe(o) && !/* @__PURE__ */ Tt(o) && (o = /* @__PURE__ */ ce(o));
        const r = /* @__PURE__ */ ce(this), { has: a, get: l } = En(r);
        let u = a.call(r, i);
        u ? Ce.NODE_ENV !== "production" && Vo(r, a, i) : (i = /* @__PURE__ */ ce(i), u = a.call(r, i));
        const c = l.call(r, i);
        return r.set(i, o), u ? st(o, c) && Vt(r, "set", i, o, c) : Vt(r, "add", i, o), this;
      },
      delete(i) {
        const o = /* @__PURE__ */ ce(this), { has: r, get: a } = En(o);
        let l = r.call(o, i);
        l ? Ce.NODE_ENV !== "production" && Vo(o, r, i) : (i = /* @__PURE__ */ ce(i), l = r.call(o, i));
        const u = a ? a.call(o, i) : void 0, c = o.delete(i);
        return l && Vt(o, "delete", i, void 0, u), c;
      },
      clear() {
        const i = /* @__PURE__ */ ce(this), o = i.size !== 0, r = Ce.NODE_ENV !== "production" ? hs(i) ? new Map(i) : new Set(i) : void 0, a = i.clear();
        return o && Vt(
          i,
          "clear",
          void 0,
          void 0,
          r
        ), a;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((i) => {
    s[i] = ql(i, t, e);
  }), s;
}
function ti(t, e) {
  const s = Hl(t, e);
  return (n, i, o) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? n : Reflect.get(
    Ee(s, i) && i in n ? s : n,
    i,
    o
  );
}
const Wl = {
  get: /* @__PURE__ */ ti(!1, !1)
}, Kl = {
  get: /* @__PURE__ */ ti(!1, !0)
}, zl = {
  get: /* @__PURE__ */ ti(!0, !1)
}, Gl = {
  get: /* @__PURE__ */ ti(!0, !0)
};
function Vo(t, e, s) {
  const n = /* @__PURE__ */ ce(s);
  if (n !== s && e.call(t, n)) {
    const i = Ki(t);
    Et(
      `Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const ea = /* @__PURE__ */ new WeakMap(), ta = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap(), na = /* @__PURE__ */ new WeakMap();
function Yl(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Jl(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : Yl(Ki(t));
}
// @__NO_SIDE_EFFECTS__
function _s(t) {
  return /* @__PURE__ */ Tt(t) ? t : si(
    t,
    !1,
    Bl,
    Wl,
    ea
  );
}
// @__NO_SIDE_EFFECTS__
function Ql(t) {
  return si(
    t,
    !1,
    Ul,
    Kl,
    ta
  );
}
// @__NO_SIDE_EFFECTS__
function Di(t) {
  return si(
    t,
    !0,
    Fl,
    zl,
    sa
  );
}
// @__NO_SIDE_EFFECTS__
function It(t) {
  return si(
    t,
    !0,
    jl,
    Gl,
    na
  );
}
function si(t, e, s, n, i) {
  if (!ve(t))
    return Ce.NODE_ENV !== "production" && Et(
      `value cannot be made ${e ? "readonly" : "reactive"}: ${String(
        t
      )}`
    ), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const o = Jl(t);
  if (o === 0)
    return t;
  const r = i.get(t);
  if (r)
    return r;
  const a = new Proxy(
    t,
    o === 2 ? n : s
  );
  return i.set(t, a), a;
}
// @__NO_SIDE_EFFECTS__
function ns(t) {
  return /* @__PURE__ */ Tt(t) ? /* @__PURE__ */ ns(t.__v_raw) : !!(t && t.__v_isReactive);
}
// @__NO_SIDE_EFFECTS__
function Tt(t) {
  return !!(t && t.__v_isReadonly);
}
// @__NO_SIDE_EFFECTS__
function Xe(t) {
  return !!(t && t.__v_isShallow);
}
// @__NO_SIDE_EFFECTS__
function kn(t) {
  return t ? !!t.__v_raw : !1;
}
// @__NO_SIDE_EFFECTS__
function ce(t) {
  const e = t && t.__v_raw;
  return e ? /* @__PURE__ */ ce(e) : t;
}
function Xl(t) {
  return !Ee(t, "__v_skip") && Object.isExtensible(t) && Ln(t, "__v_skip", !0), t;
}
const Nt = (t) => ve(t) ? /* @__PURE__ */ _s(t) : t, Vs = (t) => ve(t) ? /* @__PURE__ */ Di(t) : t;
// @__NO_SIDE_EFFECTS__
function Fe(t) {
  return t ? t.__v_isRef === !0 : !1;
}
// @__NO_SIDE_EFFECTS__
function q(t) {
  return Zl(t, !1);
}
function Zl(t, e) {
  return /* @__PURE__ */ Fe(t) ? t : new ec(t, e);
}
class ec {
  constructor(e, s) {
    this.dep = new Zn(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? e : /* @__PURE__ */ ce(e), this._value = s ? e : Nt(e), this.__v_isShallow = s;
  }
  get value() {
    return Ce.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track(), this._value;
  }
  set value(e) {
    const s = this._rawValue, n = this.__v_isShallow || /* @__PURE__ */ Xe(e) || /* @__PURE__ */ Tt(e);
    e = n ? e : /* @__PURE__ */ ce(e), st(e, s) && (this._rawValue = e, this._value = n ? e : Nt(e), Ce.NODE_ENV !== "production" ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: e,
      oldValue: s
    }) : this.dep.trigger());
  }
}
function Y(t) {
  return /* @__PURE__ */ Fe(t) ? t.value : t;
}
const tc = {
  get: (t, e, s) => e === "__v_raw" ? t : Y(Reflect.get(t, e, s)),
  set: (t, e, s, n) => {
    const i = t[e];
    return /* @__PURE__ */ Fe(i) && !/* @__PURE__ */ Fe(s) ? (i.value = s, !0) : Reflect.set(t, e, s, n);
  }
};
function ia(t) {
  return /* @__PURE__ */ ns(t) ? t : new Proxy(t, tc);
}
class sc {
  constructor(e) {
    this.__v_isRef = !0, this._value = void 0;
    const s = this.dep = new Zn(), { get: n, set: i } = e(s.track.bind(s), s.trigger.bind(s));
    this._get = n, this._set = i;
  }
  get value() {
    return this._value = this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function nc(t) {
  return new sc(t);
}
class ic {
  constructor(e, s, n) {
    this.fn = e, this.setter = s, this._value = void 0, this.dep = new Zn(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Zs - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !s, this.isSSR = n;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Te !== this)
      return Hr(this, !0), !0;
  }
  get value() {
    const e = Ce.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    return zr(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter ? this.setter(e) : Ce.NODE_ENV !== "production" && Et("Write operation failed: computed value is readonly");
  }
}
// @__NO_SIDE_EFFECTS__
function oc(t, e, s = !1) {
  let n, i;
  return Z(t) ? n = t : (n = t.get, i = t.set), new ic(n, i, s);
}
const _n = {}, Pn = /* @__PURE__ */ new WeakMap();
let ds;
function rc(t, e = !1, s = ds) {
  if (s) {
    let n = Pn.get(s);
    n || Pn.set(s, n = []), n.push(t);
  } else Ce.NODE_ENV !== "production" && !e && Et(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function ac(t, e, s = ye) {
  const { immediate: n, deep: i, once: o, scheduler: r, augmentJob: a, call: l } = s, u = (B) => {
    (s.onWarn || Et)(
      "Invalid watch source: ",
      B,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, c = (B) => i ? B : /* @__PURE__ */ Xe(B) || i === !1 || i === 0 ? Kt(B, 1) : Kt(B);
  let d, m, h, b, E = !1, y = !1;
  if (/* @__PURE__ */ Fe(t) ? (m = () => t.value, E = /* @__PURE__ */ Xe(t)) : /* @__PURE__ */ ns(t) ? (m = () => c(t), E = !0) : z(t) ? (y = !0, E = t.some((B) => /* @__PURE__ */ ns(B) || /* @__PURE__ */ Xe(B)), m = () => t.map((B) => {
    if (/* @__PURE__ */ Fe(B))
      return B.value;
    if (/* @__PURE__ */ ns(B))
      return c(B);
    if (Z(B))
      return l ? l(B, 2) : B();
    Ce.NODE_ENV !== "production" && u(B);
  })) : Z(t) ? e ? m = l ? () => l(t, 2) : t : m = () => {
    if (h) {
      yt();
      try {
        h();
      } finally {
        _t();
      }
    }
    const B = ds;
    ds = d;
    try {
      return l ? l(t, 3, [b]) : t(b);
    } finally {
      ds = B;
    }
  } : (m = qe, Ce.NODE_ENV !== "production" && u(t)), e && i) {
    const B = m, K = i === !0 ? 1 / 0 : i;
    m = () => Kt(B(), K);
  }
  const _ = Vl(), S = () => {
    d.stop(), _ && _.active && Hi(_.effects, d);
  };
  if (o && e) {
    const B = e;
    e = (...K) => {
      B(...K), S();
    };
  }
  let T = y ? new Array(t.length).fill(_n) : _n;
  const I = (B) => {
    if (!(!(d.flags & 1) || !d.dirty && !B))
      if (e) {
        const K = d.run();
        if (i || E || (y ? K.some((pe, he) => st(pe, T[he])) : st(K, T))) {
          h && h();
          const pe = ds;
          ds = d;
          try {
            const he = [
              K,
              // pass undefined as the old value when it's changed for the first time
              T === _n ? void 0 : y && T[0] === _n ? [] : T,
              b
            ];
            T = K, l ? l(e, 3, he) : (
              // @ts-expect-error
              e(...he)
            );
          } finally {
            ds = pe;
          }
        }
      } else
        d.run();
  };
  return a && a(I), d = new jr(m), d.scheduler = r ? () => r(I, !1) : I, b = (B) => rc(B, !1, d), h = d.onStop = () => {
    const B = Pn.get(d);
    if (B) {
      if (l)
        l(B, 4);
      else
        for (const K of B) K();
      Pn.delete(d);
    }
  }, Ce.NODE_ENV !== "production" && (d.onTrack = s.onTrack, d.onTrigger = s.onTrigger), e ? n ? I(!0) : T = d.run() : r ? r(I.bind(null, !0), !0) : d.run(), S.pause = d.pause.bind(d), S.resume = d.resume.bind(d), S.stop = S, S;
}
function Kt(t, e = 1 / 0, s) {
  if (e <= 0 || !ve(t) || t.__v_skip || (s = s || /* @__PURE__ */ new Map(), (s.get(t) || 0) >= e))
    return t;
  if (s.set(t, e), e--, /* @__PURE__ */ Fe(t))
    Kt(t.value, e, s);
  else if (z(t))
    for (let n = 0; n < t.length; n++)
      Kt(t[n], e, s);
  else if (Rs(t) || hs(t))
    t.forEach((n) => {
      Kt(n, e, s);
    });
  else if (Pr(t)) {
    for (const n in t)
      Kt(t[n], e, s);
    for (const n of Object.getOwnPropertySymbols(t))
      Object.prototype.propertyIsEnumerable.call(t, n) && Kt(t[n], e, s);
  }
  return t;
}
var g = {};
const vs = [];
function wn(t) {
  vs.push(t);
}
function Dn() {
  vs.pop();
}
let vi = !1;
function M(t, ...e) {
  if (vi) return;
  vi = !0, yt();
  const s = vs.length ? vs[vs.length - 1].component : null, n = s && s.appContext.config.warnHandler, i = lc();
  if (n)
    Ls(
      n,
      s,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        t + e.map((o) => {
          var r, a;
          return (a = (r = o.toString) == null ? void 0 : r.call(o)) != null ? a : JSON.stringify(o);
        }).join(""),
        s && s.proxy,
        i.map(
          ({ vnode: o }) => `at <${vn(s, o.type)}>`
        ).join(`
`),
        i
      ]
    );
  else {
    const o = [`[Vue warn]: ${t}`, ...e];
    i.length && o.push(`
`, ...cc(i)), console.warn(...o);
  }
  _t(), vi = !1;
}
function lc() {
  let t = vs[vs.length - 1];
  if (!t)
    return [];
  const e = [];
  for (; t; ) {
    const s = e[0];
    s && s.vnode === t ? s.recurseCount++ : e.push({
      vnode: t,
      recurseCount: 0
    });
    const n = t.component && t.component.parent;
    t = n && n.vnode;
  }
  return e;
}
function cc(t) {
  const e = [];
  return t.forEach((s, n) => {
    e.push(...n === 0 ? [] : [`
`], ...uc(s));
  }), e;
}
function uc({ vnode: t, recurseCount: e }) {
  const s = e > 0 ? `... (${e} recursive calls)` : "", n = t.component ? t.component.parent == null : !1, i = ` at <${vn(
    t.component,
    t.type,
    n
  )}`, o = ">" + s;
  return t.props ? [i, ...dc(t.props), o] : [i + o];
}
function dc(t) {
  const e = [], s = Object.keys(t);
  return s.slice(0, 3).forEach((n) => {
    e.push(...oa(n, t[n]));
  }), s.length > 3 && e.push(" ..."), e;
}
function oa(t, e, s) {
  return Me(e) ? (e = JSON.stringify(e), s ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? s ? e : [`${t}=${e}`] : /* @__PURE__ */ Fe(e) ? (e = oa(t, /* @__PURE__ */ ce(e.value), !0), s ? e : [`${t}=Ref<`, e, ">"]) : Z(e) ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`] : (e = /* @__PURE__ */ ce(e), s ? e : [`${t}=`, e]);
}
function fc(t, e) {
  g.NODE_ENV !== "production" && t !== void 0 && (typeof t != "number" ? M(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && M(`${e} is NaN - the duration expression might be incorrect.`));
}
const Xi = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function Ls(t, e, s, n) {
  try {
    return n ? t(...n) : t();
  } catch (i) {
    un(i, e, s);
  }
}
function xt(t, e, s, n) {
  if (Z(t)) {
    const i = Ls(t, e, s, n);
    return i && Wi(i) && i.catch((o) => {
      un(o, e, s);
    }), i;
  }
  if (z(t)) {
    const i = [];
    for (let o = 0; o < t.length; o++)
      i.push(xt(t[o], e, s, n));
    return i;
  } else g.NODE_ENV !== "production" && M(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof t}`
  );
}
function un(t, e, s, n = !0) {
  const i = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: r } = e && e.appContext.config || ye;
  if (e) {
    let a = e.parent;
    const l = e.proxy, u = g.NODE_ENV !== "production" ? Xi[s] : `https://vuejs.org/error-reference/#runtime-${s}`;
    for (; a; ) {
      const c = a.ec;
      if (c) {
        for (let d = 0; d < c.length; d++)
          if (c[d](t, l, u) === !1)
            return;
      }
      a = a.parent;
    }
    if (o) {
      yt(), Ls(o, null, 10, [
        t,
        l,
        u
      ]), _t();
      return;
    }
  }
  pc(t, s, i, n, r);
}
function pc(t, e, s, n = !0, i = !1) {
  if (g.NODE_ENV !== "production") {
    const o = Xi[e];
    if (s && wn(s), M(`Unhandled error${o ? ` during execution of ${o}` : ""}`), s && Dn(), n)
      throw t;
    console.error(t);
  } else {
    if (i)
      throw t;
    console.error(t);
  }
}
const Qe = [];
let $t = -1;
const Ds = [];
let ts = null, Cs = 0;
const ra = /* @__PURE__ */ Promise.resolve();
let Bn = null;
const hc = 100;
function Lt(t) {
  const e = Bn || ra;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function mc(t) {
  let e = $t + 1, s = Qe.length;
  for (; e < s; ) {
    const n = e + s >>> 1, i = Qe[n], o = tn(i);
    o < t || o === t && i.flags & 2 ? e = n + 1 : s = n;
  }
  return e;
}
function ni(t) {
  if (!(t.flags & 1)) {
    const e = tn(t), s = Qe[Qe.length - 1];
    !s || // fast path when the job id is larger than the tail
    !(t.flags & 2) && e >= tn(s) ? Qe.push(t) : Qe.splice(mc(e), 0, t), t.flags |= 1, aa();
  }
}
function aa() {
  Bn || (Bn = ra.then(ua));
}
function la(t) {
  z(t) ? Ds.push(...t) : ts && t.id === -1 ? ts.splice(Cs + 1, 0, t) : t.flags & 1 || (Ds.push(t), t.flags |= 1), aa();
}
function Mo(t, e, s = $t + 1) {
  for (g.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()); s < Qe.length; s++) {
    const n = Qe[s];
    if (n && n.flags & 2) {
      if (t && n.id !== t.uid || g.NODE_ENV !== "production" && Zi(e, n))
        continue;
      Qe.splice(s, 1), s--, n.flags & 4 && (n.flags &= -2), n(), n.flags & 4 || (n.flags &= -2);
    }
  }
}
function ca(t) {
  if (Ds.length) {
    const e = [...new Set(Ds)].sort(
      (s, n) => tn(s) - tn(n)
    );
    if (Ds.length = 0, ts) {
      ts.push(...e);
      return;
    }
    for (ts = e, g.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), Cs = 0; Cs < ts.length; Cs++) {
      const s = ts[Cs];
      g.NODE_ENV !== "production" && Zi(t, s) || (s.flags & 4 && (s.flags &= -2), s.flags & 8 || s(), s.flags &= -2);
    }
    ts = null, Cs = 0;
  }
}
const tn = (t) => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id;
function ua(t) {
  g.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map());
  const e = g.NODE_ENV !== "production" ? (s) => Zi(t, s) : qe;
  try {
    for ($t = 0; $t < Qe.length; $t++) {
      const s = Qe[$t];
      if (s && !(s.flags & 8)) {
        if (g.NODE_ENV !== "production" && e(s))
          continue;
        s.flags & 4 && (s.flags &= -2), Ls(
          s,
          s.i,
          s.i ? 15 : 14
        ), s.flags & 4 || (s.flags &= -2);
      }
    }
  } finally {
    for (; $t < Qe.length; $t++) {
      const s = Qe[$t];
      s && (s.flags &= -2);
    }
    $t = -1, Qe.length = 0, ca(t), Bn = null, (Qe.length || Ds.length) && ua(t);
  }
}
function Zi(t, e) {
  const s = t.get(e) || 0;
  if (s > hc) {
    const n = e.i, i = n && tl(n.type);
    return un(
      `Maximum recursive updates exceeded${i ? ` in component <${i}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), !0;
  }
  return t.set(e, s + 1), !1;
}
let ht = !1;
const On = /* @__PURE__ */ new Map();
g.NODE_ENV !== "production" && (cn().__VUE_HMR_RUNTIME__ = {
  createRecord: bi(da),
  rerender: bi(gc),
  reload: bi(Ec)
});
const Es = /* @__PURE__ */ new Map();
function vc(t) {
  const e = t.type.__hmrId;
  let s = Es.get(e);
  s || (da(e, t.type), s = Es.get(e)), s.instances.add(t);
}
function bc(t) {
  Es.get(t.type.__hmrId).instances.delete(t);
}
function da(t, e) {
  return Es.has(t) ? !1 : (Es.set(t, {
    initialDef: Fn(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Fn(t) {
  return sl(t) ? t.__vccOpts : t;
}
function gc(t, e) {
  const s = Es.get(t);
  s && (s.initialDef.render = e, [...s.instances].forEach((n) => {
    e && (n.render = e, Fn(n.type).render = e), n.renderCache = [], ht = !0, n.job.flags & 8 || n.update(), ht = !1;
  }));
}
function Ec(t, e) {
  const s = Es.get(t);
  if (!s) return;
  e = Fn(e), Io(s.initialDef, e);
  const n = [...s.instances];
  for (let i = 0; i < n.length; i++) {
    const o = n[i], r = Fn(o.type);
    let a = On.get(r);
    a || (r !== s.initialDef && Io(r, e), On.set(r, a = /* @__PURE__ */ new Set())), a.add(o), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (a.add(o), o.ceReload(e.styles), a.delete(o)) : o.parent ? ni(() => {
      o.job.flags & 8 || (ht = !0, o.parent.update(), ht = !1, a.delete(o));
    }) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), o.root.ce && o !== o.root && o.root.ce._removeChildStyle(r);
  }
  la(() => {
    On.clear();
  });
}
function Io(t, e) {
  Ve(t, e);
  for (const s in t)
    s !== "__file" && !(s in e) && delete t[s];
}
function bi(t) {
  return (e, s) => {
    try {
      return t(e, s);
    } catch (n) {
      console.error(n), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let Mt, Hs = [], Oi = !1;
function dn(t, ...e) {
  Mt ? Mt.emit(t, ...e) : Oi || Hs.push({ event: t, args: e });
}
function fa(t, e) {
  var s, n;
  Mt = t, Mt ? (Mt.enabled = !0, Hs.forEach(({ event: i, args: o }) => Mt.emit(i, ...o)), Hs = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((n = (s = window.navigator) == null ? void 0 : s.userAgent) != null && n.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((o) => {
    fa(o, e);
  }), setTimeout(() => {
    Mt || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Oi = !0, Hs = []);
  }, 3e3)) : (Oi = !0, Hs = []);
}
function yc(t, e) {
  dn("app:init", t, e, {
    Fragment: Ae,
    Text: hn,
    Comment: Be,
    Static: Vn
  });
}
function _c(t) {
  dn("app:unmount", t);
}
const Tc = /* @__PURE__ */ eo(
  "component:added"
  /* COMPONENT_ADDED */
), pa = /* @__PURE__ */ eo(
  "component:updated"
  /* COMPONENT_UPDATED */
), Nc = /* @__PURE__ */ eo(
  "component:removed"
  /* COMPONENT_REMOVED */
), xc = (t) => {
  Mt && typeof Mt.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !Mt.cleanupBuffer(t) && Nc(t);
};
// @__NO_SIDE_EFFECTS__
function eo(t) {
  return (e) => {
    dn(
      t,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const Sc = /* @__PURE__ */ ha(
  "perf:start"
  /* PERFORMANCE_START */
), Cc = /* @__PURE__ */ ha(
  "perf:end"
  /* PERFORMANCE_END */
);
function ha(t) {
  return (e, s, n) => {
    dn(t, e.appContext.app, e.uid, e, s, n);
  };
}
function wc(t, e, s) {
  dn(
    "component:emit",
    t.appContext.app,
    t,
    e,
    s
  );
}
let He = null, ma = null;
function Un(t) {
  const e = He;
  return He = t, ma = t && t.type.__scopeId || null, e;
}
function P(t, e = He, s) {
  if (!e || t._n)
    return t;
  const n = (...i) => {
    n._d && zn(-1);
    const o = Un(e);
    let r;
    try {
      r = t(...i);
    } finally {
      Un(o), n._d && zn(1);
    }
    return g.NODE_ENV !== "production" && pa(e), r;
  };
  return n._n = !0, n._c = !0, n._d = !0, n;
}
function va(t) {
  hl(t) && M("Do not use built-in directive ids as custom directive id: " + t);
}
function nt(t, e) {
  if (He === null)
    return g.NODE_ENV !== "production" && M("withDirectives can only be used inside render functions."), t;
  const s = ai(He), n = t.dirs || (t.dirs = []);
  for (let i = 0; i < e.length; i++) {
    let [o, r, a, l = ye] = e[i];
    o && (Z(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Kt(r), n.push({
      dir: o,
      instance: s,
      value: r,
      oldValue: void 0,
      arg: a,
      modifiers: l
    }));
  }
  return t;
}
function rs(t, e, s, n) {
  const i = t.dirs, o = e && e.dirs;
  for (let r = 0; r < i.length; r++) {
    const a = i[r];
    o && (a.oldValue = o[r].value);
    let l = a.dir[n];
    l && (yt(), xt(l, s, 8, [
      t.el,
      a,
      t,
      e
    ]), _t());
  }
}
function Dc(t, e) {
  if (g.NODE_ENV !== "production" && (!Ue || Ue.isMounted) && M("provide() can only be used inside setup()."), Ue) {
    let s = Ue.provides;
    const n = Ue.parent && Ue.parent.provides;
    n === s && (s = Ue.provides = Object.create(n)), s[t] = e;
  }
}
function $n(t, e, s = !1) {
  const n = ri();
  if (n || $s) {
    let i = $s ? $s._context.provides : n ? n.parent == null || n.ce ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0;
    if (i && t in i)
      return i[t];
    if (arguments.length > 1)
      return s && Z(e) ? e.call(n && n.proxy) : e;
    g.NODE_ENV !== "production" && M(`injection "${String(t)}" not found.`);
  } else g.NODE_ENV !== "production" && M("inject() can only be used inside setup() or functional components.");
}
const Oc = /* @__PURE__ */ Symbol.for("v-scx"), $c = () => {
  {
    const t = $n(Oc);
    return t || g.NODE_ENV !== "production" && M(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), t;
  }
};
function Ac(t, e) {
  return to(
    t,
    null,
    g.NODE_ENV !== "production" ? Ve({}, e, { flush: "sync" }) : { flush: "sync" }
  );
}
function lt(t, e, s) {
  return g.NODE_ENV !== "production" && !Z(e) && M(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), to(t, e, s);
}
function to(t, e, s = ye) {
  const { immediate: n, deep: i, flush: o, once: r } = s;
  g.NODE_ENV !== "production" && !e && (n !== void 0 && M(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), i !== void 0 && M(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), r !== void 0 && M(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const a = Ve({}, s);
  g.NODE_ENV !== "production" && (a.onWarn = M);
  const l = e && n || !e && o !== "post";
  let u;
  if (on) {
    if (o === "sync") {
      const h = $c();
      u = h.__watcherHandles || (h.__watcherHandles = []);
    } else if (!l) {
      const h = () => {
      };
      return h.stop = qe, h.resume = qe, h.pause = qe, h;
    }
  }
  const c = Ue;
  a.call = (h, b, E) => xt(h, c, b, E);
  let d = !1;
  o === "post" ? a.scheduler = (h) => {
    ze(h, c && c.suspense);
  } : o !== "sync" && (d = !0, a.scheduler = (h, b) => {
    b ? h() : ni(h);
  }), a.augmentJob = (h) => {
    e && (h.flags |= 4), d && (h.flags |= 2, c && (h.id = c.uid, h.i = c));
  };
  const m = ac(t, e, a);
  return on && (u ? u.push(m) : l && m()), m;
}
function Vc(t, e, s) {
  const n = this.proxy, i = Me(t) ? t.includes(".") ? ba(n, t) : () => n[t] : t.bind(n, n);
  let o;
  Z(e) ? o = e : (o = e.handler, s = e);
  const r = mn(this), a = to(i, o.bind(n), s);
  return r(), a;
}
function ba(t, e) {
  const s = e.split(".");
  return () => {
    let n = t;
    for (let i = 0; i < s.length && n; i++)
      n = n[s[i]];
    return n;
  };
}
const ga = /* @__PURE__ */ Symbol("_vte"), Ea = (t) => t.__isTeleport, bs = (t) => t && (t.disabled || t.disabled === ""), Ro = (t) => t && (t.defer || t.defer === ""), Lo = (t) => typeof SVGElement < "u" && t instanceof SVGElement, ko = (t) => typeof MathMLElement == "function" && t instanceof MathMLElement, $i = (t, e) => {
  const s = t && t.to;
  if (Me(s))
    if (e) {
      const n = e(s);
      return g.NODE_ENV !== "production" && !n && !bs(t) && M(
        `Failed to locate Teleport target with selector "${s}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), n;
    } else
      return g.NODE_ENV !== "production" && M(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return g.NODE_ENV !== "production" && !s && !bs(t) && M(`Invalid Teleport target: ${s}`), s;
}, ya = {
  name: "Teleport",
  __isTeleport: !0,
  process(t, e, s, n, i, o, r, a, l, u) {
    const {
      mc: c,
      pc: d,
      pbc: m,
      o: { insert: h, querySelector: b, createText: E, createComment: y }
    } = u, _ = bs(e.props);
    let { shapeFlag: S, children: T, dynamicChildren: I } = e;
    if (g.NODE_ENV !== "production" && ht && (l = !1, I = null), t == null) {
      const B = e.el = g.NODE_ENV !== "production" ? y("teleport start") : E(""), K = e.anchor = g.NODE_ENV !== "production" ? y("teleport end") : E("");
      h(B, s, n), h(K, s, n);
      const pe = (H, re) => {
        S & 16 && c(
          T,
          H,
          re,
          i,
          o,
          r,
          a,
          l
        );
      }, he = () => {
        const H = e.target = $i(e.props, b), re = Ai(H, e, E, h);
        H ? (r !== "svg" && Lo(H) ? r = "svg" : r !== "mathml" && ko(H) && (r = "mathml"), i && i.isCE && (i.ce._teleportTargets || (i.ce._teleportTargets = /* @__PURE__ */ new Set())).add(H), _ || (pe(H, re), An(e, !1))) : g.NODE_ENV !== "production" && !_ && M(
          "Invalid Teleport target on mount:",
          H,
          `(${typeof H})`
        );
      };
      _ && (pe(s, K), An(e, !0)), Ro(e.props) ? (e.el.__isMounted = !1, ze(() => {
        he(), delete e.el.__isMounted;
      }, o)) : he();
    } else {
      if (Ro(e.props) && t.el.__isMounted === !1) {
        ze(() => {
          ya.process(
            t,
            e,
            s,
            n,
            i,
            o,
            r,
            a,
            l,
            u
          );
        }, o);
        return;
      }
      e.el = t.el, e.targetStart = t.targetStart;
      const B = e.anchor = t.anchor, K = e.target = t.target, pe = e.targetAnchor = t.targetAnchor, he = bs(t.props), H = he ? s : K, re = he ? B : pe;
      if (r === "svg" || Lo(K) ? r = "svg" : (r === "mathml" || ko(K)) && (r = "mathml"), I ? (m(
        t.dynamicChildren,
        I,
        H,
        i,
        o,
        r,
        a
      ), Js(t, e, g.NODE_ENV === "production")) : l || d(
        t,
        e,
        H,
        re,
        i,
        o,
        r,
        a,
        !1
      ), _)
        he ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : Tn(
          e,
          s,
          B,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
        const me = e.target = $i(
          e.props,
          b
        );
        me ? Tn(
          e,
          me,
          null,
          u,
          0
        ) : g.NODE_ENV !== "production" && M(
          "Invalid Teleport target on update:",
          K,
          `(${typeof K})`
        );
      } else he && Tn(
        e,
        K,
        pe,
        u,
        1
      );
      An(e, _);
    }
  },
  remove(t, e, s, { um: n, o: { remove: i } }, o) {
    const {
      shapeFlag: r,
      children: a,
      anchor: l,
      targetStart: u,
      targetAnchor: c,
      target: d,
      props: m
    } = t;
    if (d && (i(u), i(c)), o && i(l), r & 16) {
      const h = o || !bs(m);
      for (let b = 0; b < a.length; b++) {
        const E = a[b];
        n(
          E,
          e,
          s,
          h,
          !!E.dynamicChildren
        );
      }
    }
  },
  move: Tn,
  hydrate: Mc
};
function Tn(t, e, s, { o: { insert: n }, m: i }, o = 2) {
  o === 0 && n(t.targetAnchor, e, s);
  const { el: r, anchor: a, shapeFlag: l, children: u, props: c } = t, d = o === 2;
  if (d && n(r, e, s), (!d || bs(c)) && l & 16)
    for (let m = 0; m < u.length; m++)
      i(
        u[m],
        e,
        s,
        2
      );
  d && n(a, e, s);
}
function Mc(t, e, s, n, i, o, {
  o: { nextSibling: r, parentNode: a, querySelector: l, insert: u, createText: c }
}, d) {
  function m(y, _) {
    let S = _;
    for (; S; ) {
      if (S && S.nodeType === 8) {
        if (S.data === "teleport start anchor")
          e.targetStart = S;
        else if (S.data === "teleport anchor") {
          e.targetAnchor = S, y._lpa = e.targetAnchor && r(e.targetAnchor);
          break;
        }
      }
      S = r(S);
    }
  }
  function h(y, _) {
    _.anchor = d(
      r(y),
      _,
      a(y),
      s,
      n,
      i,
      o
    );
  }
  const b = e.target = $i(
    e.props,
    l
  ), E = bs(e.props);
  if (b) {
    const y = b._lpa || b.firstChild;
    e.shapeFlag & 16 && (E ? (h(t, e), m(b, y), e.targetAnchor || Ai(
      b,
      e,
      c,
      u,
      // if target is the same as the main view, insert anchors before current node
      // to avoid hydrating mismatch
      a(t) === b ? t : null
    )) : (e.anchor = r(t), m(b, y), e.targetAnchor || Ai(b, e, c, u), d(
      y && r(y),
      e,
      b,
      s,
      n,
      i,
      o
    ))), An(e, E);
  } else E && e.shapeFlag & 16 && (h(t, e), e.targetStart = t, e.targetAnchor = r(t));
  return e.anchor && r(e.anchor);
}
const _a = ya;
function An(t, e) {
  const s = t.ctx;
  if (s && s.ut) {
    let n, i;
    for (e ? (n = t.el, i = t.anchor) : (n = t.targetStart, i = t.targetAnchor); n && n !== i; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", s.uid), n = n.nextSibling;
    s.ut();
  }
}
function Ai(t, e, s, n, i = null) {
  const o = e.targetStart = s(""), r = e.targetAnchor = s("");
  return o[ga] = r, t && (n(o, t, i), n(r, t, i)), r;
}
const At = /* @__PURE__ */ Symbol("_leaveCb"), Us = /* @__PURE__ */ Symbol("_enterCb");
function Ic() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return it(() => {
    t.isMounted = !0;
  }), Ft(() => {
    t.isUnmounting = !0;
  }), t;
}
const ct = [Function, Array], Ta = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: ct,
  onEnter: ct,
  onAfterEnter: ct,
  onEnterCancelled: ct,
  // leave
  onBeforeLeave: ct,
  onLeave: ct,
  onAfterLeave: ct,
  onLeaveCancelled: ct,
  // appear
  onBeforeAppear: ct,
  onAppear: ct,
  onAfterAppear: ct,
  onAppearCancelled: ct
}, Na = (t) => {
  const e = t.subTree;
  return e.component ? Na(e.component) : e;
}, Rc = {
  name: "BaseTransition",
  props: Ta,
  setup(t, { slots: e }) {
    const s = ri(), n = Ic();
    return () => {
      const i = e.default && Ca(e.default(), !0);
      if (!i || !i.length)
        return;
      const o = xa(i), r = /* @__PURE__ */ ce(t), { mode: a } = r;
      if (g.NODE_ENV !== "production" && a && a !== "in-out" && a !== "out-in" && a !== "default" && M(`invalid <transition> mode: ${a}`), n.isLeaving)
        return gi(o);
      const l = Po(o);
      if (!l)
        return gi(o);
      let u = Vi(
        l,
        r,
        n,
        s,
        // #11061, ensure enterHooks is fresh after clone
        (d) => u = d
      );
      l.type !== Be && sn(l, u);
      let c = s.subTree && Po(s.subTree);
      if (c && c.type !== Be && !ps(c, l) && Na(s).type !== Be) {
        let d = Vi(
          c,
          r,
          n,
          s
        );
        if (sn(c, d), a === "out-in" && l.type !== Be)
          return n.isLeaving = !0, d.afterLeave = () => {
            n.isLeaving = !1, s.job.flags & 8 || s.update(), delete d.afterLeave, c = void 0;
          }, gi(o);
        a === "in-out" && l.type !== Be ? d.delayLeave = (m, h, b) => {
          const E = Sa(
            n,
            c
          );
          E[String(c.key)] = c, m[At] = () => {
            h(), m[At] = void 0, delete u.delayedLeave, c = void 0;
          }, u.delayedLeave = () => {
            b(), delete u.delayedLeave, c = void 0;
          };
        } : c = void 0;
      } else c && (c = void 0);
      return o;
    };
  }
};
function xa(t) {
  let e = t[0];
  if (t.length > 1) {
    let s = !1;
    for (const n of t)
      if (n.type !== Be) {
        if (g.NODE_ENV !== "production" && s) {
          M(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        if (e = n, s = !0, g.NODE_ENV === "production") break;
      }
  }
  return e;
}
const Lc = Rc;
function Sa(t, e) {
  const { leavingVNodes: s } = t;
  let n = s.get(e.type);
  return n || (n = /* @__PURE__ */ Object.create(null), s.set(e.type, n)), n;
}
function Vi(t, e, s, n, i) {
  const {
    appear: o,
    mode: r,
    persisted: a = !1,
    onBeforeEnter: l,
    onEnter: u,
    onAfterEnter: c,
    onEnterCancelled: d,
    onBeforeLeave: m,
    onLeave: h,
    onAfterLeave: b,
    onLeaveCancelled: E,
    onBeforeAppear: y,
    onAppear: _,
    onAfterAppear: S,
    onAppearCancelled: T
  } = e, I = String(t.key), B = Sa(s, t), K = (H, re) => {
    H && xt(
      H,
      n,
      9,
      re
    );
  }, pe = (H, re) => {
    const me = re[1];
    K(H, re), z(H) ? H.every((w) => w.length <= 1) && me() : H.length <= 1 && me();
  }, he = {
    mode: r,
    persisted: a,
    beforeEnter(H) {
      let re = l;
      if (!s.isMounted)
        if (o)
          re = y || l;
        else
          return;
      H[At] && H[At](
        !0
        /* cancelled */
      );
      const me = B[I];
      me && ps(t, me) && me.el[At] && me.el[At](), K(re, [H]);
    },
    enter(H) {
      let re = u, me = c, w = d;
      if (!s.isMounted)
        if (o)
          re = _ || u, me = S || c, w = T || d;
        else
          return;
      let W = !1;
      H[Us] = (be) => {
        W || (W = !0, be ? K(w, [H]) : K(me, [H]), he.delayedLeave && he.delayedLeave(), H[Us] = void 0);
      };
      const oe = H[Us].bind(null, !1);
      re ? pe(re, [H, oe]) : oe();
    },
    leave(H, re) {
      const me = String(t.key);
      if (H[Us] && H[Us](
        !0
        /* cancelled */
      ), s.isUnmounting)
        return re();
      K(m, [H]);
      let w = !1;
      H[At] = (oe) => {
        w || (w = !0, re(), oe ? K(E, [H]) : K(b, [H]), H[At] = void 0, B[me] === t && delete B[me]);
      };
      const W = H[At].bind(null, !1);
      B[me] = t, h ? pe(h, [H, W]) : W();
    },
    clone(H) {
      const re = Vi(
        H,
        e,
        s,
        n,
        i
      );
      return i && i(re), re;
    }
  };
  return he;
}
function gi(t) {
  if (fn(t))
    return t = Bt(t), t.children = null, t;
}
function Po(t) {
  if (!fn(t))
    return Ea(t.type) && t.children ? xa(t.children) : t;
  if (t.component)
    return t.component.subTree;
  const { shapeFlag: e, children: s } = t;
  if (s) {
    if (e & 16)
      return s[0];
    if (e & 32 && Z(s.default))
      return s.default();
  }
}
function sn(t, e) {
  t.shapeFlag & 6 && t.component ? (t.transition = e, sn(t.component.subTree, e)) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function Ca(t, e = !1, s) {
  let n = [], i = 0;
  for (let o = 0; o < t.length; o++) {
    let r = t[o];
    const a = s == null ? r.key : String(s) + String(r.key != null ? r.key : o);
    r.type === Ae ? (r.patchFlag & 128 && i++, n = n.concat(
      Ca(r.children, e, a)
    )) : (e || r.type !== Be) && n.push(a != null ? Bt(r, { key: a }) : r);
  }
  if (i > 1)
    for (let o = 0; o < n.length; o++)
      n[o].patchFlag = -2;
  return n;
}
// @__NO_SIDE_EFFECTS__
function _e(t, e) {
  return Z(t) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Ve({ name: t.name }, e, { setup: t })
  ) : t;
}
function wa(t) {
  t.ids = [t.ids[0] + t.ids[2]++ + "-", 0, 0];
}
const Bo = /* @__PURE__ */ new WeakSet();
function Fo(t, e) {
  let s;
  return !!((s = Object.getOwnPropertyDescriptor(t, e)) && !s.configurable);
}
const jn = /* @__PURE__ */ new WeakMap();
function Ys(t, e, s, n, i = !1) {
  if (z(t)) {
    t.forEach(
      (E, y) => Ys(
        E,
        e && (z(e) ? e[y] : e),
        s,
        n,
        i
      )
    );
    return;
  }
  if (Os(n) && !i) {
    n.shapeFlag & 512 && n.type.__asyncResolved && n.component.subTree.component && Ys(t, e, s, n.component.subTree);
    return;
  }
  const o = n.shapeFlag & 4 ? ai(n.component) : n.el, r = i ? null : o, { i: a, r: l } = t;
  if (g.NODE_ENV !== "production" && !a) {
    M(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const u = e && e.r, c = a.refs === ye ? a.refs = {} : a.refs, d = a.setupState, m = /* @__PURE__ */ ce(d), h = d === ye ? Lr : (E) => g.NODE_ENV !== "production" && (Ee(m, E) && !/* @__PURE__ */ Fe(m[E]) && M(
    `Template ref "${E}" used on a non-ref value. It will not work in the production build.`
  ), Bo.has(m[E])) || Fo(c, E) ? !1 : Ee(m, E), b = (E, y) => !(g.NODE_ENV !== "production" && Bo.has(E) || y && Fo(c, y));
  if (u != null && u !== l) {
    if (Uo(e), Me(u))
      c[u] = null, h(u) && (d[u] = null);
    else if (/* @__PURE__ */ Fe(u)) {
      const E = e;
      b(u, E.k) && (u.value = null), E.k && (c[E.k] = null);
    }
  }
  if (Z(l))
    Ls(l, a, 12, [r, c]);
  else {
    const E = Me(l), y = /* @__PURE__ */ Fe(l);
    if (E || y) {
      const _ = () => {
        if (t.f) {
          const S = E ? h(l) ? d[l] : c[l] : b(l) || !t.k ? l.value : c[t.k];
          if (i)
            z(S) && Hi(S, o);
          else if (z(S))
            S.includes(o) || S.push(o);
          else if (E)
            c[l] = [o], h(l) && (d[l] = c[l]);
          else {
            const T = [o];
            b(l, t.k) && (l.value = T), t.k && (c[t.k] = T);
          }
        } else E ? (c[l] = r, h(l) && (d[l] = r)) : y ? (b(l, t.k) && (l.value = r), t.k && (c[t.k] = r)) : g.NODE_ENV !== "production" && M("Invalid template ref type:", l, `(${typeof l})`);
      };
      if (r) {
        const S = () => {
          _(), jn.delete(t);
        };
        S.id = -1, jn.set(t, S), ze(S, s);
      } else
        Uo(t), _();
    } else g.NODE_ENV !== "production" && M("Invalid template ref type:", l, `(${typeof l})`);
  }
}
function Uo(t) {
  const e = jn.get(t);
  e && (e.flags |= 8, jn.delete(t));
}
cn().requestIdleCallback;
cn().cancelIdleCallback;
const Os = (t) => !!t.type.__asyncLoader, fn = (t) => t.type.__isKeepAlive;
function kc(t, e) {
  Da(t, "a", e);
}
function Pc(t, e) {
  Da(t, "da", e);
}
function Da(t, e, s = Ue) {
  const n = t.__wdc || (t.__wdc = () => {
    let i = s;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return t();
  });
  if (ii(e, n, s), s) {
    let i = s.parent;
    for (; i && i.parent; )
      fn(i.parent.vnode) && Bc(n, e, s, i), i = i.parent;
  }
}
function Bc(t, e, s, n) {
  const i = ii(
    e,
    t,
    n,
    !0
    /* prepend */
  );
  pn(() => {
    Hi(n[e], i);
  }, s);
}
function ii(t, e, s = Ue, n = !1) {
  if (s) {
    const i = s[t] || (s[t] = []), o = e.__weh || (e.__weh = (...r) => {
      yt();
      const a = mn(s), l = xt(e, s, t, r);
      return a(), _t(), l;
    });
    return n ? i.unshift(o) : i.push(o), o;
  } else if (g.NODE_ENV !== "production") {
    const i = us(Xi[t].replace(/ hook$/, ""));
    M(
      `${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const Qt = (t) => (e, s = Ue) => {
  (!on || t === "sp") && ii(t, (...n) => e(...n), s);
}, Fc = Qt("bm"), it = Qt("m"), Uc = Qt(
  "bu"
), jc = Qt("u"), Ft = Qt(
  "bum"
), pn = Qt("um"), qc = Qt(
  "sp"
), Hc = Qt("rtg"), Wc = Qt("rtc");
function Kc(t, e = Ue) {
  ii("ec", t, e);
}
const zc = /* @__PURE__ */ Symbol.for("v-ndc");
function Gt(t, e, s, n) {
  let i;
  const o = s, r = z(t);
  if (r || Me(t)) {
    const a = r && /* @__PURE__ */ ns(t);
    let l = !1, u = !1;
    a && (l = !/* @__PURE__ */ Xe(t), u = /* @__PURE__ */ Tt(t), t = ei(t)), i = new Array(t.length);
    for (let c = 0, d = t.length; c < d; c++)
      i[c] = e(
        l ? u ? Vs(Nt(t[c])) : Nt(t[c]) : t[c],
        c,
        void 0,
        o
      );
  } else if (typeof t == "number") {
    g.NODE_ENV !== "production" && !Number.isInteger(t) && M(`The v-for range expect an integer value but got ${t}.`), i = new Array(t);
    for (let a = 0; a < t; a++)
      i[a] = e(a + 1, a, void 0, o);
  } else if (ve(t))
    if (t[Symbol.iterator])
      i = Array.from(
        t,
        (a, l) => e(a, l, void 0, o)
      );
    else {
      const a = Object.keys(t);
      i = new Array(a.length);
      for (let l = 0, u = a.length; l < u; l++) {
        const c = a[l];
        i[l] = e(t[c], c, l, o);
      }
    }
  else
    i = [];
  return i;
}
function vt(t, e, s = {}, n, i) {
  if (He.ce || He.parent && Os(He.parent) && He.parent.ce) {
    const u = Object.keys(s).length > 0;
    return e !== "default" && (s.name = e), x(), Ie(
      Ae,
      null,
      [C("slot", s, n)],
      u ? -2 : 64
    );
  }
  let o = t[e];
  g.NODE_ENV !== "production" && o && o.length > 1 && (M(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), o = () => []), o && o._c && (o._d = !1), x();
  const r = o && Oa(o(s)), a = s.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  r && r.key, l = Ie(
    Ae,
    {
      key: (a && !gt(a) ? a : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!r && n ? "_fb" : "")
    },
    r || [],
    r && t._ === 1 ? 64 : -2
  );
  return !i && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), o && o._c && (o._d = !0), l;
}
function Oa(t) {
  return t.some((e) => ys(e) ? !(e.type === Be || e.type === Ae && !Oa(e.children)) : !0) ? t : null;
}
const Mi = (t) => t ? Za(t) ? ai(t) : Mi(t.parent) : null, gs = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Ve(/* @__PURE__ */ Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ It(t.props) : t.props,
    $attrs: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ It(t.attrs) : t.attrs,
    $slots: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ It(t.slots) : t.slots,
    $refs: (t) => g.NODE_ENV !== "production" ? /* @__PURE__ */ It(t.refs) : t.refs,
    $parent: (t) => Mi(t.parent),
    $root: (t) => Mi(t.root),
    $host: (t) => t.ce,
    $emit: (t) => t.emit,
    $options: (t) => Va(t),
    $forceUpdate: (t) => t.f || (t.f = () => {
      ni(t.update);
    }),
    $nextTick: (t) => t.n || (t.n = Lt.bind(t.proxy)),
    $watch: (t) => Vc.bind(t)
  })
), so = (t) => t === "_" || t === "$", Ei = (t, e) => t !== ye && !t.__isScriptSetup && Ee(t, e), $a = {
  get({ _: t }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: s, setupState: n, data: i, props: o, accessCache: r, type: a, appContext: l } = t;
    if (g.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    if (e[0] !== "$") {
      const m = r[e];
      if (m !== void 0)
        switch (m) {
          case 1:
            return n[e];
          case 2:
            return i[e];
          case 4:
            return s[e];
          case 3:
            return o[e];
        }
      else {
        if (Ei(n, e))
          return r[e] = 1, n[e];
        if (i !== ye && Ee(i, e))
          return r[e] = 2, i[e];
        if (Ee(o, e))
          return r[e] = 3, o[e];
        if (s !== ye && Ee(s, e))
          return r[e] = 4, s[e];
        Ii && (r[e] = 0);
      }
    }
    const u = gs[e];
    let c, d;
    if (u)
      return e === "$attrs" ? (je(t.attrs, "get", ""), g.NODE_ENV !== "production" && Wn()) : g.NODE_ENV !== "production" && e === "$slots" && je(t, "get", e), u(t);
    if (
      // css module (injected by vue-loader)
      (c = a.__cssModules) && (c = c[e])
    )
      return c;
    if (s !== ye && Ee(s, e))
      return r[e] = 4, s[e];
    if (
      // global properties
      d = l.config.globalProperties, Ee(d, e)
    )
      return d[e];
    g.NODE_ENV !== "production" && He && (!Me(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (i !== ye && so(e[0]) && Ee(i, e) ? M(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : t === He && M(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: t }, e, s) {
    const { data: n, setupState: i, ctx: o } = t;
    return Ei(i, e) ? (i[e] = s, !0) : g.NODE_ENV !== "production" && i.__isScriptSetup && Ee(i, e) ? (M(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : n !== ye && Ee(n, e) ? (n[e] = s, !0) : Ee(t.props, e) ? (g.NODE_ENV !== "production" && M(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (g.NODE_ENV !== "production" && M(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : (g.NODE_ENV !== "production" && e in t.appContext.config.globalProperties ? Object.defineProperty(o, e, {
      enumerable: !0,
      configurable: !0,
      value: s
    }) : o[e] = s, !0);
  },
  has({
    _: { data: t, setupState: e, accessCache: s, ctx: n, appContext: i, props: o, type: r }
  }, a) {
    let l;
    return !!(s[a] || t !== ye && a[0] !== "$" && Ee(t, a) || Ei(e, a) || Ee(o, a) || Ee(n, a) || Ee(gs, a) || Ee(i.config.globalProperties, a) || (l = r.__cssModules) && l[a]);
  },
  defineProperty(t, e, s) {
    return s.get != null ? t._.accessCache[e] = 0 : Ee(s, "value") && this.set(t, e, s.value, null), Reflect.defineProperty(t, e, s);
  }
};
g.NODE_ENV !== "production" && ($a.ownKeys = (t) => (M(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(t)));
function Gc(t) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => t
  }), Object.keys(gs).forEach((s) => {
    Object.defineProperty(e, s, {
      configurable: !0,
      enumerable: !1,
      get: () => gs[s](t),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: qe
    });
  }), e;
}
function Yc(t) {
  const {
    ctx: e,
    propsOptions: [s]
  } = t;
  s && Object.keys(s).forEach((n) => {
    Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[n],
      set: qe
    });
  });
}
function Jc(t) {
  const { ctx: e, setupState: s } = t;
  Object.keys(/* @__PURE__ */ ce(s)).forEach((n) => {
    if (!s.__isScriptSetup) {
      if (so(n[0])) {
        M(
          `setup() return property ${JSON.stringify(
            n
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, n, {
        enumerable: !0,
        configurable: !0,
        get: () => s[n],
        set: qe
      });
    }
  });
}
function qn(t) {
  return z(t) ? t.reduce(
    (e, s) => (e[s] = null, e),
    {}
  ) : t;
}
function no(t, e) {
  return !t || !e ? t || e : z(t) && z(e) ? t.concat(e) : Ve({}, qn(t), qn(e));
}
function Qc() {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, s) => {
    t[s] ? M(`${e} property "${s}" is already defined in ${t[s]}.`) : t[s] = e;
  };
}
let Ii = !0;
function Xc(t) {
  const e = Va(t), s = t.proxy, n = t.ctx;
  Ii = !1, e.beforeCreate && jo(e.beforeCreate, t, "bc");
  const {
    // state
    data: i,
    computed: o,
    methods: r,
    watch: a,
    provide: l,
    inject: u,
    // lifecycle
    created: c,
    beforeMount: d,
    mounted: m,
    beforeUpdate: h,
    updated: b,
    activated: E,
    deactivated: y,
    beforeDestroy: _,
    beforeUnmount: S,
    destroyed: T,
    unmounted: I,
    render: B,
    renderTracked: K,
    renderTriggered: pe,
    errorCaptured: he,
    serverPrefetch: H,
    // public API
    expose: re,
    inheritAttrs: me,
    // assets
    components: w,
    directives: W,
    filters: oe
  } = e, be = g.NODE_ENV !== "production" ? Qc() : null;
  if (g.NODE_ENV !== "production") {
    const [le] = t.propsOptions;
    if (le)
      for (const de in le)
        be("Props", de);
  }
  if (u && Zc(u, n, be), r)
    for (const le in r) {
      const de = r[le];
      Z(de) ? (g.NODE_ENV !== "production" ? Object.defineProperty(n, le, {
        value: de.bind(s),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : n[le] = de.bind(s), g.NODE_ENV !== "production" && be("Methods", le)) : g.NODE_ENV !== "production" && M(
        `Method "${le}" has type "${typeof de}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (i) {
    g.NODE_ENV !== "production" && !Z(i) && M(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const le = i.call(s, s);
    if (g.NODE_ENV !== "production" && Wi(le) && M(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !ve(le))
      g.NODE_ENV !== "production" && M("data() should return an object.");
    else if (t.data = /* @__PURE__ */ _s(le), g.NODE_ENV !== "production")
      for (const de in le)
        be("Data", de), so(de[0]) || Object.defineProperty(n, de, {
          configurable: !0,
          enumerable: !0,
          get: () => le[de],
          set: qe
        });
  }
  if (Ii = !0, o)
    for (const le in o) {
      const de = o[le], Q = Z(de) ? de.bind(s, s) : Z(de.get) ? de.get.bind(s, s) : qe;
      g.NODE_ENV !== "production" && Q === qe && M(`Computed property "${le}" has no getter.`);
      const R = !Z(de) && Z(de.set) ? de.set.bind(s) : g.NODE_ENV !== "production" ? () => {
        M(
          `Write operation failed: computed property "${le}" is readonly.`
        );
      } : qe, Oe = se({
        get: Q,
        set: R
      });
      Object.defineProperty(n, le, {
        enumerable: !0,
        configurable: !0,
        get: () => Oe.value,
        set: (We) => Oe.value = We
      }), g.NODE_ENV !== "production" && be("Computed", le);
    }
  if (a)
    for (const le in a)
      Aa(a[le], n, s, le);
  if (l) {
    const le = Z(l) ? l.call(s) : l;
    Reflect.ownKeys(le).forEach((de) => {
      Dc(de, le[de]);
    });
  }
  c && jo(c, t, "c");
  function fe(le, de) {
    z(de) ? de.forEach((Q) => le(Q.bind(s))) : de && le(de.bind(s));
  }
  if (fe(Fc, d), fe(it, m), fe(Uc, h), fe(jc, b), fe(kc, E), fe(Pc, y), fe(Kc, he), fe(Wc, K), fe(Hc, pe), fe(Ft, S), fe(pn, I), fe(qc, H), z(re))
    if (re.length) {
      const le = t.exposed || (t.exposed = {});
      re.forEach((de) => {
        Object.defineProperty(le, de, {
          get: () => s[de],
          set: (Q) => s[de] = Q,
          enumerable: !0
        });
      });
    } else t.exposed || (t.exposed = {});
  B && t.render === qe && (t.render = B), me != null && (t.inheritAttrs = me), w && (t.components = w), W && (t.directives = W), H && wa(t);
}
function Zc(t, e, s = qe) {
  z(t) && (t = Ri(t));
  for (const n in t) {
    const i = t[n];
    let o;
    ve(i) ? "default" in i ? o = $n(
      i.from || n,
      i.default,
      !0
    ) : o = $n(i.from || n) : o = $n(i), /* @__PURE__ */ Fe(o) ? Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (r) => o.value = r
    }) : e[n] = o, g.NODE_ENV !== "production" && s("Inject", n);
  }
}
function jo(t, e, s) {
  xt(
    z(t) ? t.map((n) => n.bind(e.proxy)) : t.bind(e.proxy),
    e,
    s
  );
}
function Aa(t, e, s, n) {
  let i = n.includes(".") ? ba(s, n) : () => s[n];
  if (Me(t)) {
    const o = e[t];
    Z(o) ? lt(i, o) : g.NODE_ENV !== "production" && M(`Invalid watch handler specified by key "${t}"`, o);
  } else if (Z(t))
    lt(i, t.bind(s));
  else if (ve(t))
    if (z(t))
      t.forEach((o) => Aa(o, e, s, n));
    else {
      const o = Z(t.handler) ? t.handler.bind(s) : e[t.handler];
      Z(o) ? lt(i, o, t) : g.NODE_ENV !== "production" && M(`Invalid watch handler specified by key "${t.handler}"`, o);
    }
  else g.NODE_ENV !== "production" && M(`Invalid watch option: "${n}"`, t);
}
function Va(t) {
  const e = t.type, { mixins: s, extends: n } = e, {
    mixins: i,
    optionsCache: o,
    config: { optionMergeStrategies: r }
  } = t.appContext, a = o.get(e);
  let l;
  return a ? l = a : !i.length && !s && !n ? l = e : (l = {}, i.length && i.forEach(
    (u) => Hn(l, u, r, !0)
  ), Hn(l, e, r)), ve(e) && o.set(e, l), l;
}
function Hn(t, e, s, n = !1) {
  const { mixins: i, extends: o } = e;
  o && Hn(t, o, s, !0), i && i.forEach(
    (r) => Hn(t, r, s, !0)
  );
  for (const r in e)
    if (n && r === "expose")
      g.NODE_ENV !== "production" && M(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const a = eu[r] || s && s[r];
      t[r] = a ? a(t[r], e[r]) : e[r];
    }
  return t;
}
const eu = {
  data: qo,
  props: Ho,
  emits: Ho,
  // objects
  methods: Ws,
  computed: Ws,
  // lifecycle
  beforeCreate: Je,
  created: Je,
  beforeMount: Je,
  mounted: Je,
  beforeUpdate: Je,
  updated: Je,
  beforeDestroy: Je,
  beforeUnmount: Je,
  destroyed: Je,
  unmounted: Je,
  activated: Je,
  deactivated: Je,
  errorCaptured: Je,
  serverPrefetch: Je,
  // assets
  components: Ws,
  directives: Ws,
  // watch
  watch: su,
  // provide / inject
  provide: qo,
  inject: tu
};
function qo(t, e) {
  return e ? t ? function() {
    return Ve(
      Z(t) ? t.call(this, this) : t,
      Z(e) ? e.call(this, this) : e
    );
  } : e : t;
}
function tu(t, e) {
  return Ws(Ri(t), Ri(e));
}
function Ri(t) {
  if (z(t)) {
    const e = {};
    for (let s = 0; s < t.length; s++)
      e[t[s]] = t[s];
    return e;
  }
  return t;
}
function Je(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function Ws(t, e) {
  return t ? Ve(/* @__PURE__ */ Object.create(null), t, e) : e;
}
function Ho(t, e) {
  return t ? z(t) && z(e) ? [.../* @__PURE__ */ new Set([...t, ...e])] : Ve(
    /* @__PURE__ */ Object.create(null),
    qn(t),
    qn(e ?? {})
  ) : e;
}
function su(t, e) {
  if (!t) return e;
  if (!e) return t;
  const s = Ve(/* @__PURE__ */ Object.create(null), t);
  for (const n in e)
    s[n] = Je(t[n], e[n]);
  return s;
}
function Ma() {
  return {
    app: null,
    config: {
      isNativeTag: Lr,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let nu = 0;
function iu(t, e) {
  return function(n, i = null) {
    Z(n) || (n = Ve({}, n)), i != null && !ve(i) && (g.NODE_ENV !== "production" && M("root props passed to app.mount() must be an object."), i = null);
    const o = Ma(), r = /* @__PURE__ */ new WeakSet(), a = [];
    let l = !1;
    const u = o.app = {
      _uid: nu++,
      _component: n,
      _props: i,
      _container: null,
      _context: o,
      _instance: null,
      version: tr,
      get config() {
        return o.config;
      },
      set config(c) {
        g.NODE_ENV !== "production" && M(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(c, ...d) {
        return r.has(c) ? g.NODE_ENV !== "production" && M("Plugin has already been applied to target app.") : c && Z(c.install) ? (r.add(c), c.install(u, ...d)) : Z(c) ? (r.add(c), c(u, ...d)) : g.NODE_ENV !== "production" && M(
          'A plugin must either be a function or an object with an "install" function.'
        ), u;
      },
      mixin(c) {
        return o.mixins.includes(c) ? g.NODE_ENV !== "production" && M(
          "Mixin has already been applied to target app" + (c.name ? `: ${c.name}` : "")
        ) : o.mixins.push(c), u;
      },
      component(c, d) {
        return g.NODE_ENV !== "production" && Fi(c, o.config), d ? (g.NODE_ENV !== "production" && o.components[c] && M(`Component "${c}" has already been registered in target app.`), o.components[c] = d, u) : o.components[c];
      },
      directive(c, d) {
        return g.NODE_ENV !== "production" && va(c), d ? (g.NODE_ENV !== "production" && o.directives[c] && M(`Directive "${c}" has already been registered in target app.`), o.directives[c] = d, u) : o.directives[c];
      },
      mount(c, d, m) {
        if (l)
          g.NODE_ENV !== "production" && M(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          g.NODE_ENV !== "production" && c.__vue_app__ && M(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const h = u._ceVNode || C(n, i);
          return h.appContext = o, m === !0 ? m = "svg" : m === !1 && (m = void 0), g.NODE_ENV !== "production" && (o.reload = () => {
            const b = Bt(h);
            b.el = null, t(b, c, m);
          }), t(h, c, m), l = !0, u._container = c, c.__vue_app__ = u, g.NODE_ENV !== "production" && (u._instance = h.component, yc(u, tr)), ai(h.component);
        }
      },
      onUnmount(c) {
        g.NODE_ENV !== "production" && typeof c != "function" && M(
          `Expected function as first argument to app.onUnmount(), but got ${typeof c}`
        ), a.push(c);
      },
      unmount() {
        l ? (xt(
          a,
          u._instance,
          16
        ), t(null, u._container), g.NODE_ENV !== "production" && (u._instance = null, _c(u)), delete u._container.__vue_app__) : g.NODE_ENV !== "production" && M("Cannot unmount an app that is not mounted.");
      },
      provide(c, d) {
        return g.NODE_ENV !== "production" && c in o.provides && (Ee(o.provides, c) ? M(
          `App already provides property with key "${String(c)}". It will be overwritten with the new value.`
        ) : M(
          `App already provides property with key "${String(c)}" inherited from its parent element. It will be overwritten with the new value.`
        )), o.provides[c] = d, u;
      },
      runWithContext(c) {
        const d = $s;
        $s = u;
        try {
          return c();
        } finally {
          $s = d;
        }
      }
    };
    return u;
  };
}
let $s = null;
function io(t, e, s = ye) {
  const n = ri();
  if (g.NODE_ENV !== "production" && !n)
    return M("useModel() called without active instance."), /* @__PURE__ */ q();
  const i = ut(e);
  if (g.NODE_ENV !== "production" && !n.propsOptions[0][i])
    return M(`useModel() called with prop "${e}" which is not declared.`), /* @__PURE__ */ q();
  const o = Yt(e), r = Ia(t, i), a = nc((l, u) => {
    let c, d = ye, m;
    return Ac(() => {
      const h = t[i];
      st(c, h) && (c = h, u());
    }), {
      get() {
        return l(), s.get ? s.get(c) : c;
      },
      set(h) {
        const b = s.set ? s.set(h) : h;
        if (!st(b, c) && !(d !== ye && st(h, d)))
          return;
        const E = n.vnode.props;
        E && // check if parent has passed v-model
        (e in E || i in E || o in E) && (`onUpdate:${e}` in E || `onUpdate:${i}` in E || `onUpdate:${o}` in E) || (c = h, u()), n.emit(`update:${e}`, b), st(h, b) && st(h, d) && !st(b, m) && u(), d = h, m = b;
      }
    };
  });
  return a[Symbol.iterator] = () => {
    let l = 0;
    return {
      next() {
        return l < 2 ? { value: l++ ? r || ye : a, done: !1 } : { done: !0 };
      }
    };
  }, a;
}
const Ia = (t, e) => e === "modelValue" || e === "model-value" ? t.modelModifiers : t[`${e}Modifiers`] || t[`${ut(e)}Modifiers`] || t[`${Yt(e)}Modifiers`];
function ou(t, e, ...s) {
  if (t.isUnmounted) return;
  const n = t.vnode.props || ye;
  if (g.NODE_ENV !== "production") {
    const {
      emitsOptions: c,
      propsOptions: [d]
    } = t;
    if (c)
      if (!(e in c))
        (!d || !(us(ut(e)) in d)) && M(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${us(ut(e))}" prop.`
        );
      else {
        const m = c[e];
        Z(m) && (m(...s) || M(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let i = s;
  const o = e.startsWith("update:"), r = o && Ia(n, e.slice(7));
  if (r && (r.trim && (i = s.map((c) => Me(c) ? c.trim() : c)), r.number && (i = s.map(Xn))), g.NODE_ENV !== "production" && wc(t, e, i), g.NODE_ENV !== "production") {
    const c = e.toLowerCase();
    c !== e && n[us(c)] && M(
      `Event "${c}" is emitted in component ${vn(
        t,
        t.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Yt(
        e
      )}" instead of "${e}".`
    );
  }
  let a, l = n[a = us(e)] || // also try camelCase event handler (#2249)
  n[a = us(ut(e))];
  !l && o && (l = n[a = us(Yt(e))]), l && xt(
    l,
    t,
    6,
    i
  );
  const u = n[a + "Once"];
  if (u) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[a])
      return;
    t.emitted[a] = !0, xt(
      u,
      t,
      6,
      i
    );
  }
}
const ru = /* @__PURE__ */ new WeakMap();
function Ra(t, e, s = !1) {
  const n = s ? ru : e.emitsCache, i = n.get(t);
  if (i !== void 0)
    return i;
  const o = t.emits;
  let r = {}, a = !1;
  if (!Z(t)) {
    const l = (u) => {
      const c = Ra(u, e, !0);
      c && (a = !0, Ve(r, c));
    };
    !s && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l);
  }
  return !o && !a ? (ve(t) && n.set(t, null), null) : (z(o) ? o.forEach((l) => r[l] = null) : Ve(r, o), ve(t) && n.set(t, r), r);
}
function oi(t, e) {
  return !t || !an(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Ee(t, e[0].toLowerCase() + e.slice(1)) || Ee(t, Yt(e)) || Ee(t, e));
}
let Li = !1;
function Wn() {
  Li = !0;
}
function Wo(t) {
  const {
    type: e,
    vnode: s,
    proxy: n,
    withProxy: i,
    propsOptions: [o],
    slots: r,
    attrs: a,
    emit: l,
    render: u,
    renderCache: c,
    props: d,
    data: m,
    setupState: h,
    ctx: b,
    inheritAttrs: E
  } = t, y = Un(t);
  let _, S;
  g.NODE_ENV !== "production" && (Li = !1);
  try {
    if (s.shapeFlag & 4) {
      const B = i || n, K = g.NODE_ENV !== "production" && h.__isScriptSetup ? new Proxy(B, {
        get(pe, he, H) {
          return M(
            `Property '${String(
              he
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(pe, he, H);
        }
      }) : B;
      _ = pt(
        u.call(
          K,
          B,
          c,
          g.NODE_ENV !== "production" ? /* @__PURE__ */ It(d) : d,
          h,
          m,
          b
        )
      ), S = a;
    } else {
      const B = e;
      g.NODE_ENV !== "production" && a === d && Wn(), _ = pt(
        B.length > 1 ? B(
          g.NODE_ENV !== "production" ? /* @__PURE__ */ It(d) : d,
          g.NODE_ENV !== "production" ? {
            get attrs() {
              return Wn(), /* @__PURE__ */ It(a);
            },
            slots: r,
            emit: l
          } : { attrs: a, slots: r, emit: l }
        ) : B(
          g.NODE_ENV !== "production" ? /* @__PURE__ */ It(d) : d,
          null
        )
      ), S = e.props ? a : au(a);
    }
  } catch (B) {
    Qs.length = 0, un(B, t, 1), _ = C(Be);
  }
  let T = _, I;
  if (g.NODE_ENV !== "production" && _.patchFlag > 0 && _.patchFlag & 2048 && ([T, I] = La(_)), S && E !== !1) {
    const B = Object.keys(S), { shapeFlag: K } = T;
    if (B.length) {
      if (K & 7)
        o && B.some(Rn) && (S = lu(
          S,
          o
        )), T = Bt(T, S, !1, !0);
      else if (g.NODE_ENV !== "production" && !Li && T.type !== Be) {
        const pe = Object.keys(a), he = [], H = [];
        for (let re = 0, me = pe.length; re < me; re++) {
          const w = pe[re];
          an(w) ? Rn(w) || he.push(w[2].toLowerCase() + w.slice(3)) : H.push(w);
        }
        H.length && M(
          `Extraneous non-props attributes (${H.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
        ), he.length && M(
          `Extraneous non-emits event listeners (${he.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return s.dirs && (g.NODE_ENV !== "production" && !Ko(T) && M(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), T = Bt(T, null, !1, !0), T.dirs = T.dirs ? T.dirs.concat(s.dirs) : s.dirs), s.transition && (g.NODE_ENV !== "production" && !Ko(T) && M(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), sn(T, s.transition)), g.NODE_ENV !== "production" && I ? I(T) : _ = T, Un(y), _;
}
const La = (t) => {
  const e = t.children, s = t.dynamicChildren, n = oo(e, !1);
  if (n) {
    if (g.NODE_ENV !== "production" && n.patchFlag > 0 && n.patchFlag & 2048)
      return La(n);
  } else return [t, void 0];
  const i = e.indexOf(n), o = s ? s.indexOf(n) : -1, r = (a) => {
    e[i] = a, s && (o > -1 ? s[o] = a : a.patchFlag > 0 && (t.dynamicChildren = [...s, a]));
  };
  return [pt(n), r];
};
function oo(t, e = !0) {
  let s;
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    if (ys(i)) {
      if (i.type !== Be || i.children === "v-if") {
        if (s)
          return;
        if (s = i, g.NODE_ENV !== "production" && e && s.patchFlag > 0 && s.patchFlag & 2048)
          return oo(s.children);
      }
    } else
      return;
  }
  return s;
}
const au = (t) => {
  let e;
  for (const s in t)
    (s === "class" || s === "style" || an(s)) && ((e || (e = {}))[s] = t[s]);
  return e;
}, lu = (t, e) => {
  const s = {};
  for (const n in t)
    (!Rn(n) || !(n.slice(9) in e)) && (s[n] = t[n]);
  return s;
}, Ko = (t) => t.shapeFlag & 7 || t.type === Be;
function cu(t, e, s) {
  const { props: n, children: i, component: o } = t, { props: r, children: a, patchFlag: l } = e, u = o.emitsOptions;
  if (g.NODE_ENV !== "production" && (i || a) && ht || e.dirs || e.transition)
    return !0;
  if (s && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return n ? zo(n, r, u) : !!r;
    if (l & 8) {
      const c = e.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        const m = c[d];
        if (ka(r, n, m) && !oi(u, m))
          return !0;
      }
    }
  } else
    return (i || a) && (!a || !a.$stable) ? !0 : n === r ? !1 : n ? r ? zo(n, r, u) : !0 : !!r;
  return !1;
}
function zo(t, e, s) {
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !0;
  for (let i = 0; i < n.length; i++) {
    const o = n[i];
    if (ka(e, t, o) && !oi(s, o))
      return !0;
  }
  return !1;
}
function ka(t, e, s) {
  const n = t[s], i = e[s];
  return s === "style" && ve(n) && ve(i) ? !is(n, i) : n !== i;
}
function uu({ vnode: t, parent: e }, s) {
  for (; e; ) {
    const n = e.subTree;
    if (n.suspense && n.suspense.activeBranch === t && (n.el = t.el), n === t)
      (t = e.vnode).el = s, e = e.parent;
    else
      break;
  }
}
const Pa = {}, Ba = () => Object.create(Pa), Fa = (t) => Object.getPrototypeOf(t) === Pa;
function du(t, e, s, n = !1) {
  const i = {}, o = Ba();
  t.propsDefaults = /* @__PURE__ */ Object.create(null), Ua(t, e, i, o);
  for (const r in t.propsOptions[0])
    r in i || (i[r] = void 0);
  g.NODE_ENV !== "production" && qa(e || {}, i, t), s ? t.props = n ? i : /* @__PURE__ */ Ql(i) : t.type.props ? t.props = i : t.props = o, t.attrs = o;
}
function fu(t) {
  for (; t; ) {
    if (t.type.__hmrId) return !0;
    t = t.parent;
  }
}
function pu(t, e, s, n) {
  const {
    props: i,
    attrs: o,
    vnode: { patchFlag: r }
  } = t, a = /* @__PURE__ */ ce(i), [l] = t.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(g.NODE_ENV !== "production" && fu(t)) && (n || r > 0) && !(r & 16)
  ) {
    if (r & 8) {
      const c = t.vnode.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        let m = c[d];
        if (oi(t.emitsOptions, m))
          continue;
        const h = e[m];
        if (l)
          if (Ee(o, m))
            h !== o[m] && (o[m] = h, u = !0);
          else {
            const b = ut(m);
            i[b] = ki(
              l,
              a,
              b,
              h,
              t,
              !1
            );
          }
        else
          h !== o[m] && (o[m] = h, u = !0);
      }
    }
  } else {
    Ua(t, e, i, o) && (u = !0);
    let c;
    for (const d in a)
      (!e || // for camelCase
      !Ee(e, d) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((c = Yt(d)) === d || !Ee(e, c))) && (l ? s && // for camelCase
      (s[d] !== void 0 || // for kebab-case
      s[c] !== void 0) && (i[d] = ki(
        l,
        a,
        d,
        void 0,
        t,
        !0
      )) : delete i[d]);
    if (o !== a)
      for (const d in o)
        (!e || !Ee(e, d)) && (delete o[d], u = !0);
  }
  u && Vt(t.attrs, "set", ""), g.NODE_ENV !== "production" && qa(e || {}, i, t);
}
function Ua(t, e, s, n) {
  const [i, o] = t.propsOptions;
  let r = !1, a;
  if (e)
    for (let l in e) {
      if (Ks(l))
        continue;
      const u = e[l];
      let c;
      i && Ee(i, c = ut(l)) ? !o || !o.includes(c) ? s[c] = u : (a || (a = {}))[c] = u : oi(t.emitsOptions, l) || (!(l in n) || u !== n[l]) && (n[l] = u, r = !0);
    }
  if (o) {
    const l = /* @__PURE__ */ ce(s), u = a || ye;
    for (let c = 0; c < o.length; c++) {
      const d = o[c];
      s[d] = ki(
        i,
        l,
        d,
        u[d],
        t,
        !Ee(u, d)
      );
    }
  }
  return r;
}
function ki(t, e, s, n, i, o) {
  const r = t[s];
  if (r != null) {
    const a = Ee(r, "default");
    if (a && n === void 0) {
      const l = r.default;
      if (r.type !== Function && !r.skipFactory && Z(l)) {
        const { propsDefaults: u } = i;
        if (s in u)
          n = u[s];
        else {
          const c = mn(i);
          n = u[s] = l.call(
            null,
            e
          ), c();
        }
      } else
        n = l;
      i.ce && i.ce._setProp(s, n);
    }
    r[
      0
      /* shouldCast */
    ] && (o && !a ? n = !1 : r[
      1
      /* shouldCastTrue */
    ] && (n === "" || n === Yt(s)) && (n = !0));
  }
  return n;
}
const hu = /* @__PURE__ */ new WeakMap();
function ja(t, e, s = !1) {
  const n = s ? hu : e.propsCache, i = n.get(t);
  if (i)
    return i;
  const o = t.props, r = {}, a = [];
  let l = !1;
  if (!Z(t)) {
    const c = (d) => {
      l = !0;
      const [m, h] = ja(d, e, !0);
      Ve(r, m), h && a.push(...h);
    };
    !s && e.mixins.length && e.mixins.forEach(c), t.extends && c(t.extends), t.mixins && t.mixins.forEach(c);
  }
  if (!o && !l)
    return ve(t) && n.set(t, ws), ws;
  if (z(o))
    for (let c = 0; c < o.length; c++) {
      g.NODE_ENV !== "production" && !Me(o[c]) && M("props must be strings when using array syntax.", o[c]);
      const d = ut(o[c]);
      Go(d) && (r[d] = ye);
    }
  else if (o) {
    g.NODE_ENV !== "production" && !ve(o) && M("invalid props options", o);
    for (const c in o) {
      const d = ut(c);
      if (Go(d)) {
        const m = o[c], h = r[d] = z(m) || Z(m) ? { type: m } : Ve({}, m), b = h.type;
        let E = !1, y = !0;
        if (z(b))
          for (let _ = 0; _ < b.length; ++_) {
            const S = b[_], T = Z(S) && S.name;
            if (T === "Boolean") {
              E = !0;
              break;
            } else T === "String" && (y = !1);
          }
        else
          E = Z(b) && b.name === "Boolean";
        h[
          0
          /* shouldCast */
        ] = E, h[
          1
          /* shouldCastTrue */
        ] = y, (E || Ee(h, "default")) && a.push(d);
      }
    }
  }
  const u = [r, a];
  return ve(t) && n.set(t, u), u;
}
function Go(t) {
  return t[0] !== "$" && !Ks(t) ? !0 : (g.NODE_ENV !== "production" && M(`Invalid prop name: "${t}" is a reserved property.`), !1);
}
function mu(t) {
  return t === null ? "null" : typeof t == "function" ? t.name || "" : typeof t == "object" && t.constructor && t.constructor.name || "";
}
function qa(t, e, s) {
  const n = /* @__PURE__ */ ce(e), i = s.propsOptions[0], o = Object.keys(t).map((r) => ut(r));
  for (const r in i) {
    let a = i[r];
    a != null && vu(
      r,
      n[r],
      a,
      g.NODE_ENV !== "production" ? /* @__PURE__ */ It(n) : n,
      !o.includes(r)
    );
  }
}
function vu(t, e, s, n, i) {
  const { type: o, required: r, validator: a, skipCheck: l } = s;
  if (r && i) {
    M('Missing required prop: "' + t + '"');
    return;
  }
  if (!(e == null && !r)) {
    if (o != null && o !== !0 && !l) {
      let u = !1;
      const c = z(o) ? o : [o], d = [];
      for (let m = 0; m < c.length && !u; m++) {
        const { valid: h, expectedType: b } = gu(e, c[m]);
        d.push(b || ""), u = h;
      }
      if (!u) {
        M(Eu(t, e, d));
        return;
      }
    }
    a && !a(e, n) && M('Invalid prop: custom validator check failed for prop "' + t + '".');
  }
}
const bu = /* @__PURE__ */ Jt(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function gu(t, e) {
  let s;
  const n = mu(e);
  if (n === "null")
    s = t === null;
  else if (bu(n)) {
    const i = typeof t;
    s = i === n.toLowerCase(), !s && i === "object" && (s = t instanceof e);
  } else n === "Object" ? s = ve(t) : n === "Array" ? s = z(t) : s = t instanceof e;
  return {
    valid: s,
    expectedType: n
  };
}
function Eu(t, e, s) {
  if (s.length === 0)
    return `Prop type [] for prop "${t}" won't match anything. Did you mean to use type Array instead?`;
  let n = `Invalid prop: type check failed for prop "${t}". Expected ${s.map(Qn).join(" | ")}`;
  const i = s[0], o = Ki(e), r = Yo(e, i), a = Yo(e, o);
  return s.length === 1 && Jo(i) && !yu(i, o) && (n += ` with value ${r}`), n += `, got ${o} `, Jo(o) && (n += `with value ${a}.`), n;
}
function Yo(t, e) {
  return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`;
}
function Jo(t) {
  return ["string", "number", "boolean"].some((s) => t.toLowerCase() === s);
}
function yu(...t) {
  return t.some((e) => e.toLowerCase() === "boolean");
}
const ro = (t) => t === "_" || t === "_ctx" || t === "$stable", ao = (t) => z(t) ? t.map(pt) : [pt(t)], _u = (t, e, s) => {
  if (e._n)
    return e;
  const n = P((...i) => (g.NODE_ENV !== "production" && Ue && !(s === null && He) && !(s && s.root !== Ue.root) && M(
    `Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), ao(e(...i))), s);
  return n._c = !1, n;
}, Ha = (t, e, s) => {
  const n = t._ctx;
  for (const i in t) {
    if (ro(i)) continue;
    const o = t[i];
    if (Z(o))
      e[i] = _u(i, o, n);
    else if (o != null) {
      g.NODE_ENV !== "production" && M(
        `Non-function value encountered for slot "${i}". Prefer function slots for better performance.`
      );
      const r = ao(o);
      e[i] = () => r;
    }
  }
}, Wa = (t, e) => {
  g.NODE_ENV !== "production" && !fn(t.vnode) && M(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const s = ao(e);
  t.slots.default = () => s;
}, Pi = (t, e, s) => {
  for (const n in e)
    (s || !ro(n)) && (t[n] = e[n]);
}, Tu = (t, e, s) => {
  const n = t.slots = Ba();
  if (t.vnode.shapeFlag & 32) {
    const i = e._;
    i ? (Pi(n, e, s), s && Ln(n, "_", i, !0)) : Ha(e, n);
  } else e && Wa(t, e);
}, Nu = (t, e, s) => {
  const { vnode: n, slots: i } = t;
  let o = !0, r = ye;
  if (n.shapeFlag & 32) {
    const a = e._;
    a ? g.NODE_ENV !== "production" && ht ? (Pi(i, e, s), Vt(t, "set", "$slots")) : s && a === 1 ? o = !1 : Pi(i, e, s) : (o = !e.$stable, Ha(e, i)), r = e;
  } else e && (Wa(t, e), r = { default: 1 });
  if (o)
    for (const a in i)
      !ro(a) && r[a] == null && delete i[a];
};
let js, Ht;
function Ns(t, e) {
  t.appContext.config.performance && Kn() && Ht.mark(`vue-${e}-${t.uid}`), g.NODE_ENV !== "production" && Sc(t, e, Kn() ? Ht.now() : Date.now());
}
function xs(t, e) {
  if (t.appContext.config.performance && Kn()) {
    const s = `vue-${e}-${t.uid}`, n = s + ":end", i = `<${vn(t, t.type)}> ${e}`;
    Ht.mark(n), Ht.measure(i, s, n), Ht.clearMeasures(i), Ht.clearMarks(s), Ht.clearMarks(n);
  }
  g.NODE_ENV !== "production" && Cc(t, e, Kn() ? Ht.now() : Date.now());
}
function Kn() {
  return js !== void 0 || (typeof window < "u" && window.performance ? (js = !0, Ht = window.performance) : js = !1), js;
}
function xu() {
  const t = [];
  if (g.NODE_ENV !== "production" && t.length) {
    const e = t.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${t.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const ze = Ou;
function Su(t) {
  return Cu(t);
}
function Cu(t, e) {
  xu();
  const s = cn();
  s.__VUE__ = !0, g.NODE_ENV !== "production" && fa(s.__VUE_DEVTOOLS_GLOBAL_HOOK__, s);
  const {
    insert: n,
    remove: i,
    patchProp: o,
    createElement: r,
    createText: a,
    createComment: l,
    setText: u,
    setElementText: c,
    parentNode: d,
    nextSibling: m,
    setScopeId: h = qe,
    insertStaticContent: b
  } = t, E = (p, v, N, V = null, D = null, O = null, U = void 0, F = null, k = g.NODE_ENV !== "production" && ht ? !1 : !!v.dynamicChildren) => {
    if (p === v)
      return;
    p && !ps(p, v) && (V = gn(p), ft(p, D, O, !0), p = null), v.patchFlag === -2 && (k = !1, v.dynamicChildren = null);
    const { type: A, ref: X, shapeFlag: j } = v;
    switch (A) {
      case hn:
        y(p, v, N, V);
        break;
      case Be:
        _(p, v, N, V);
        break;
      case Vn:
        p == null ? S(v, N, V, U) : g.NODE_ENV !== "production" && T(p, v, N, U);
        break;
      case Ae:
        W(
          p,
          v,
          N,
          V,
          D,
          O,
          U,
          F,
          k
        );
        break;
      default:
        j & 1 ? K(
          p,
          v,
          N,
          V,
          D,
          O,
          U,
          F,
          k
        ) : j & 6 ? oe(
          p,
          v,
          N,
          V,
          D,
          O,
          U,
          F,
          k
        ) : j & 64 || j & 128 ? A.process(
          p,
          v,
          N,
          V,
          D,
          O,
          U,
          F,
          k,
          Ps
        ) : g.NODE_ENV !== "production" && M("Invalid VNode type:", A, `(${typeof A})`);
    }
    X != null && D ? Ys(X, p && p.ref, O, v || p, !v) : X == null && p && p.ref != null && Ys(p.ref, null, O, p, !0);
  }, y = (p, v, N, V) => {
    if (p == null)
      n(
        v.el = a(v.children),
        N,
        V
      );
    else {
      const D = v.el = p.el;
      v.children !== p.children && u(D, v.children);
    }
  }, _ = (p, v, N, V) => {
    p == null ? n(
      v.el = l(v.children || ""),
      N,
      V
    ) : v.el = p.el;
  }, S = (p, v, N, V) => {
    [p.el, p.anchor] = b(
      p.children,
      v,
      N,
      V,
      p.el,
      p.anchor
    );
  }, T = (p, v, N, V) => {
    if (v.children !== p.children) {
      const D = m(p.anchor);
      B(p), [v.el, v.anchor] = b(
        v.children,
        N,
        D,
        V
      );
    } else
      v.el = p.el, v.anchor = p.anchor;
  }, I = ({ el: p, anchor: v }, N, V) => {
    let D;
    for (; p && p !== v; )
      D = m(p), n(p, N, V), p = D;
    n(v, N, V);
  }, B = ({ el: p, anchor: v }) => {
    let N;
    for (; p && p !== v; )
      N = m(p), i(p), p = N;
    i(v);
  }, K = (p, v, N, V, D, O, U, F, k) => {
    if (v.type === "svg" ? U = "svg" : v.type === "math" && (U = "mathml"), p == null)
      pe(
        v,
        N,
        V,
        D,
        O,
        U,
        F,
        k
      );
    else {
      const A = p.el && p.el._isVueCE ? p.el : null;
      try {
        A && A._beginPatch(), re(
          p,
          v,
          D,
          O,
          U,
          F,
          k
        );
      } finally {
        A && A._endPatch();
      }
    }
  }, pe = (p, v, N, V, D, O, U, F) => {
    let k, A;
    const { props: X, shapeFlag: j, transition: G, dirs: ie } = p;
    if (k = p.el = r(
      p.type,
      O,
      X && X.is,
      X
    ), j & 8 ? c(k, p.children) : j & 16 && H(
      p.children,
      k,
      null,
      V,
      D,
      yi(p, O),
      U,
      F
    ), ie && rs(p, null, V, "created"), he(k, p, p.scopeId, U, V), X) {
      for (const we in X)
        we !== "value" && !Ks(we) && o(k, we, null, X[we], O, V);
      "value" in X && o(k, "value", null, X.value, O), (A = X.onVnodeBeforeMount) && Ot(A, V, p);
    }
    g.NODE_ENV !== "production" && (Ln(k, "__vnode", p, !0), Ln(k, "__vueParentComponent", V, !0)), ie && rs(p, null, V, "beforeMount");
    const ge = wu(D, G);
    ge && G.beforeEnter(k), n(k, v, N), ((A = X && X.onVnodeMounted) || ge || ie) && ze(() => {
      A && Ot(A, V, p), ge && G.enter(k), ie && rs(p, null, V, "mounted");
    }, D);
  }, he = (p, v, N, V, D) => {
    if (N && h(p, N), V)
      for (let O = 0; O < V.length; O++)
        h(p, V[O]);
    if (D) {
      let O = D.subTree;
      if (g.NODE_ENV !== "production" && O.patchFlag > 0 && O.patchFlag & 2048 && (O = oo(O.children) || O), v === O || Ga(O.type) && (O.ssContent === v || O.ssFallback === v)) {
        const U = D.vnode;
        he(
          p,
          U,
          U.scopeId,
          U.slotScopeIds,
          D.parent
        );
      }
    }
  }, H = (p, v, N, V, D, O, U, F, k = 0) => {
    for (let A = k; A < p.length; A++) {
      const X = p[A] = F ? Wt(p[A]) : pt(p[A]);
      E(
        null,
        X,
        v,
        N,
        V,
        D,
        O,
        U,
        F
      );
    }
  }, re = (p, v, N, V, D, O, U) => {
    const F = v.el = p.el;
    g.NODE_ENV !== "production" && (F.__vnode = v);
    let { patchFlag: k, dynamicChildren: A, dirs: X } = v;
    k |= p.patchFlag & 16;
    const j = p.props || ye, G = v.props || ye;
    let ie;
    if (N && as(N, !1), (ie = G.onVnodeBeforeUpdate) && Ot(ie, N, v, p), X && rs(v, p, N, "beforeUpdate"), N && as(N, !0), g.NODE_ENV !== "production" && ht && (k = 0, U = !1, A = null), (j.innerHTML && G.innerHTML == null || j.textContent && G.textContent == null) && c(F, ""), A ? (me(
      p.dynamicChildren,
      A,
      F,
      N,
      V,
      yi(v, D),
      O
    ), g.NODE_ENV !== "production" && Js(p, v)) : U || Q(
      p,
      v,
      F,
      null,
      N,
      V,
      yi(v, D),
      O,
      !1
    ), k > 0) {
      if (k & 16)
        w(F, j, G, N, D);
      else if (k & 2 && j.class !== G.class && o(F, "class", null, G.class, D), k & 4 && o(F, "style", j.style, G.style, D), k & 8) {
        const ge = v.dynamicProps;
        for (let we = 0; we < ge.length; we++) {
          const Ne = ge[we], Ze = j[Ne], et = G[Ne];
          (et !== Ze || Ne === "value") && o(F, Ne, Ze, et, D, N);
        }
      }
      k & 1 && p.children !== v.children && c(F, v.children);
    } else !U && A == null && w(F, j, G, N, D);
    ((ie = G.onVnodeUpdated) || X) && ze(() => {
      ie && Ot(ie, N, v, p), X && rs(v, p, N, "updated");
    }, V);
  }, me = (p, v, N, V, D, O, U) => {
    for (let F = 0; F < v.length; F++) {
      const k = p[F], A = v[F], X = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        k.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (k.type === Ae || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ps(k, A) || // - In the case of a component, it could contain anything.
        k.shapeFlag & 198) ? d(k.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          N
        )
      );
      E(
        k,
        A,
        X,
        null,
        V,
        D,
        O,
        U,
        !0
      );
    }
  }, w = (p, v, N, V, D) => {
    if (v !== N) {
      if (v !== ye)
        for (const O in v)
          !Ks(O) && !(O in N) && o(
            p,
            O,
            v[O],
            null,
            D,
            V
          );
      for (const O in N) {
        if (Ks(O)) continue;
        const U = N[O], F = v[O];
        U !== F && O !== "value" && o(p, O, F, U, D, V);
      }
      "value" in N && o(p, "value", v.value, N.value, D);
    }
  }, W = (p, v, N, V, D, O, U, F, k) => {
    const A = v.el = p ? p.el : a(""), X = v.anchor = p ? p.anchor : a("");
    let { patchFlag: j, dynamicChildren: G, slotScopeIds: ie } = v;
    g.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (ht || j & 2048) && (j = 0, k = !1, G = null), ie && (F = F ? F.concat(ie) : ie), p == null ? (n(A, N, V), n(X, N, V), H(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      v.children || [],
      N,
      X,
      D,
      O,
      U,
      F,
      k
    )) : j > 0 && j & 64 && G && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    p.dynamicChildren && p.dynamicChildren.length === G.length ? (me(
      p.dynamicChildren,
      G,
      N,
      D,
      O,
      U,
      F
    ), g.NODE_ENV !== "production" ? Js(p, v) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (v.key != null || D && v === D.subTree) && Js(
        p,
        v,
        !0
        /* shallow */
      )
    )) : Q(
      p,
      v,
      N,
      X,
      D,
      O,
      U,
      F,
      k
    );
  }, oe = (p, v, N, V, D, O, U, F, k) => {
    v.slotScopeIds = F, p == null ? v.shapeFlag & 512 ? D.ctx.activate(
      v,
      N,
      V,
      U,
      k
    ) : be(
      v,
      N,
      V,
      D,
      O,
      U,
      k
    ) : fe(p, v, k);
  }, be = (p, v, N, V, D, O, U) => {
    const F = p.component = Lu(
      p,
      V,
      D
    );
    if (g.NODE_ENV !== "production" && F.type.__hmrId && vc(F), g.NODE_ENV !== "production" && (wn(p), Ns(F, "mount")), fn(p) && (F.ctx.renderer = Ps), g.NODE_ENV !== "production" && Ns(F, "init"), Pu(F, !1, U), g.NODE_ENV !== "production" && xs(F, "init"), g.NODE_ENV !== "production" && ht && (p.el = null), F.asyncDep) {
      if (D && D.registerDep(F, le, U), !p.el) {
        const k = F.subTree = C(Be);
        _(null, k, v, N), p.placeholder = k.el;
      }
    } else
      le(
        F,
        p,
        v,
        N,
        D,
        O,
        U
      );
    g.NODE_ENV !== "production" && (Dn(), xs(F, "mount"));
  }, fe = (p, v, N) => {
    const V = v.component = p.component;
    if (cu(p, v, N))
      if (V.asyncDep && !V.asyncResolved) {
        g.NODE_ENV !== "production" && wn(v), de(V, v, N), g.NODE_ENV !== "production" && Dn();
        return;
      } else
        V.next = v, V.update();
    else
      v.el = p.el, V.vnode = v;
  }, le = (p, v, N, V, D, O, U) => {
    const F = () => {
      if (p.isMounted) {
        let { next: j, bu: G, u: ie, parent: ge, vnode: we } = p;
        {
          const wt = Ka(p);
          if (wt) {
            j && (j.el = we.el, de(p, j, U)), wt.asyncDep.then(() => {
              ze(() => {
                p.isUnmounted || A();
              }, D);
            });
            return;
          }
        }
        let Ne = j, Ze;
        g.NODE_ENV !== "production" && wn(j || p.vnode), as(p, !1), j ? (j.el = we.el, de(p, j, U)) : j = we, G && Ss(G), (Ze = j.props && j.props.onVnodeBeforeUpdate) && Ot(Ze, ge, j, we), as(p, !0), g.NODE_ENV !== "production" && Ns(p, "render");
        const et = Wo(p);
        g.NODE_ENV !== "production" && xs(p, "render");
        const Ct = p.subTree;
        p.subTree = et, g.NODE_ENV !== "production" && Ns(p, "patch"), E(
          Ct,
          et,
          // parent may have changed if it's in a teleport
          d(Ct.el),
          // anchor may have changed if it's in a fragment
          gn(Ct),
          p,
          D,
          O
        ), g.NODE_ENV !== "production" && xs(p, "patch"), j.el = et.el, Ne === null && uu(p, et.el), ie && ze(ie, D), (Ze = j.props && j.props.onVnodeUpdated) && ze(
          () => Ot(Ze, ge, j, we),
          D
        ), g.NODE_ENV !== "production" && pa(p), g.NODE_ENV !== "production" && Dn();
      } else {
        let j;
        const { el: G, props: ie } = v, { bm: ge, m: we, parent: Ne, root: Ze, type: et } = p, Ct = Os(v);
        as(p, !1), ge && Ss(ge), !Ct && (j = ie && ie.onVnodeBeforeMount) && Ot(j, Ne, v), as(p, !0);
        {
          Ze.ce && Ze.ce._hasShadowRoot() && Ze.ce._injectChildStyle(et), g.NODE_ENV !== "production" && Ns(p, "render");
          const wt = p.subTree = Wo(p);
          g.NODE_ENV !== "production" && xs(p, "render"), g.NODE_ENV !== "production" && Ns(p, "patch"), E(
            null,
            wt,
            N,
            V,
            p,
            D,
            O
          ), g.NODE_ENV !== "production" && xs(p, "patch"), v.el = wt.el;
        }
        if (we && ze(we, D), !Ct && (j = ie && ie.onVnodeMounted)) {
          const wt = v;
          ze(
            () => Ot(j, Ne, wt),
            D
          );
        }
        (v.shapeFlag & 256 || Ne && Os(Ne.vnode) && Ne.vnode.shapeFlag & 256) && p.a && ze(p.a, D), p.isMounted = !0, g.NODE_ENV !== "production" && Tc(p), v = N = V = null;
      }
    };
    p.scope.on();
    const k = p.effect = new jr(F);
    p.scope.off();
    const A = p.update = k.run.bind(k), X = p.job = k.runIfDirty.bind(k);
    X.i = p, X.id = p.uid, k.scheduler = () => ni(X), as(p, !0), g.NODE_ENV !== "production" && (k.onTrack = p.rtc ? (j) => Ss(p.rtc, j) : void 0, k.onTrigger = p.rtg ? (j) => Ss(p.rtg, j) : void 0), A();
  }, de = (p, v, N) => {
    v.component = p;
    const V = p.vnode.props;
    p.vnode = v, p.next = null, pu(p, v.props, V, N), Nu(p, v.children, N), yt(), Mo(p), _t();
  }, Q = (p, v, N, V, D, O, U, F, k = !1) => {
    const A = p && p.children, X = p ? p.shapeFlag : 0, j = v.children, { patchFlag: G, shapeFlag: ie } = v;
    if (G > 0) {
      if (G & 128) {
        Oe(
          A,
          j,
          N,
          V,
          D,
          O,
          U,
          F,
          k
        );
        return;
      } else if (G & 256) {
        R(
          A,
          j,
          N,
          V,
          D,
          O,
          U,
          F,
          k
        );
        return;
      }
    }
    ie & 8 ? (X & 16 && ks(A, D, O), j !== A && c(N, j)) : X & 16 ? ie & 16 ? Oe(
      A,
      j,
      N,
      V,
      D,
      O,
      U,
      F,
      k
    ) : ks(A, D, O, !0) : (X & 8 && c(N, ""), ie & 16 && H(
      j,
      N,
      V,
      D,
      O,
      U,
      F,
      k
    ));
  }, R = (p, v, N, V, D, O, U, F, k) => {
    p = p || ws, v = v || ws;
    const A = p.length, X = v.length, j = Math.min(A, X);
    let G;
    for (G = 0; G < j; G++) {
      const ie = v[G] = k ? Wt(v[G]) : pt(v[G]);
      E(
        p[G],
        ie,
        N,
        null,
        D,
        O,
        U,
        F,
        k
      );
    }
    A > X ? ks(
      p,
      D,
      O,
      !0,
      !1,
      j
    ) : H(
      v,
      N,
      V,
      D,
      O,
      U,
      F,
      k,
      j
    );
  }, Oe = (p, v, N, V, D, O, U, F, k) => {
    let A = 0;
    const X = v.length;
    let j = p.length - 1, G = X - 1;
    for (; A <= j && A <= G; ) {
      const ie = p[A], ge = v[A] = k ? Wt(v[A]) : pt(v[A]);
      if (ps(ie, ge))
        E(
          ie,
          ge,
          N,
          null,
          D,
          O,
          U,
          F,
          k
        );
      else
        break;
      A++;
    }
    for (; A <= j && A <= G; ) {
      const ie = p[j], ge = v[G] = k ? Wt(v[G]) : pt(v[G]);
      if (ps(ie, ge))
        E(
          ie,
          ge,
          N,
          null,
          D,
          O,
          U,
          F,
          k
        );
      else
        break;
      j--, G--;
    }
    if (A > j) {
      if (A <= G) {
        const ie = G + 1, ge = ie < X ? v[ie].el : V;
        for (; A <= G; )
          E(
            null,
            v[A] = k ? Wt(v[A]) : pt(v[A]),
            N,
            ge,
            D,
            O,
            U,
            F,
            k
          ), A++;
      }
    } else if (A > G)
      for (; A <= j; )
        ft(p[A], D, O, !0), A++;
    else {
      const ie = A, ge = A, we = /* @__PURE__ */ new Map();
      for (A = ge; A <= G; A++) {
        const Ye = v[A] = k ? Wt(v[A]) : pt(v[A]);
        Ye.key != null && (g.NODE_ENV !== "production" && we.has(Ye.key) && M(
          "Duplicate keys found during update:",
          JSON.stringify(Ye.key),
          "Make sure keys are unique."
        ), we.set(Ye.key, A));
      }
      let Ne, Ze = 0;
      const et = G - ge + 1;
      let Ct = !1, wt = 0;
      const Bs = new Array(et);
      for (A = 0; A < et; A++) Bs[A] = 0;
      for (A = ie; A <= j; A++) {
        const Ye = p[A];
        if (Ze >= et) {
          ft(Ye, D, O, !0);
          continue;
        }
        let Dt;
        if (Ye.key != null)
          Dt = we.get(Ye.key);
        else
          for (Ne = ge; Ne <= G; Ne++)
            if (Bs[Ne - ge] === 0 && ps(Ye, v[Ne])) {
              Dt = Ne;
              break;
            }
        Dt === void 0 ? ft(Ye, D, O, !0) : (Bs[Dt - ge] = A + 1, Dt >= wt ? wt = Dt : Ct = !0, E(
          Ye,
          v[Dt],
          N,
          null,
          D,
          O,
          U,
          F,
          k
        ), Ze++);
      }
      const So = Ct ? Du(Bs) : ws;
      for (Ne = So.length - 1, A = et - 1; A >= 0; A--) {
        const Ye = ge + A, Dt = v[Ye], Co = v[Ye + 1], wo = Ye + 1 < X ? (
          // #13559, #14173 fallback to el placeholder for unresolved async component
          Co.el || za(Co)
        ) : V;
        Bs[A] === 0 ? E(
          null,
          Dt,
          N,
          wo,
          D,
          O,
          U,
          F,
          k
        ) : Ct && (Ne < 0 || A !== So[Ne] ? We(Dt, N, wo, 2) : Ne--);
      }
    }
  }, We = (p, v, N, V, D = null) => {
    const { el: O, type: U, transition: F, children: k, shapeFlag: A } = p;
    if (A & 6) {
      We(p.component.subTree, v, N, V);
      return;
    }
    if (A & 128) {
      p.suspense.move(v, N, V);
      return;
    }
    if (A & 64) {
      U.move(p, v, N, Ps);
      return;
    }
    if (U === Ae) {
      n(O, v, N);
      for (let j = 0; j < k.length; j++)
        We(k[j], v, N, V);
      n(p.anchor, v, N);
      return;
    }
    if (U === Vn) {
      I(p, v, N);
      return;
    }
    if (V !== 2 && A & 1 && F)
      if (V === 0)
        F.beforeEnter(O), n(O, v, N), ze(() => F.enter(O), D);
      else {
        const { leave: j, delayLeave: G, afterLeave: ie } = F, ge = () => {
          p.ctx.isUnmounted ? i(O) : n(O, v, N);
        }, we = () => {
          O._isLeaving && O[At](
            !0
            /* cancelled */
          ), j(O, () => {
            ge(), ie && ie();
          });
        };
        G ? G(O, ge, we) : we();
      }
    else
      n(O, v, N);
  }, ft = (p, v, N, V = !1, D = !1) => {
    const {
      type: O,
      props: U,
      ref: F,
      children: k,
      dynamicChildren: A,
      shapeFlag: X,
      patchFlag: j,
      dirs: G,
      cacheIndex: ie
    } = p;
    if (j === -2 && (D = !1), F != null && (yt(), Ys(F, null, N, p, !0), _t()), ie != null && (v.renderCache[ie] = void 0), X & 256) {
      v.ctx.deactivate(p);
      return;
    }
    const ge = X & 1 && G, we = !Os(p);
    let Ne;
    if (we && (Ne = U && U.onVnodeBeforeUnmount) && Ot(Ne, v, p), X & 6)
      fl(p.component, N, V);
    else {
      if (X & 128) {
        p.suspense.unmount(N, V);
        return;
      }
      ge && rs(p, null, v, "beforeUnmount"), X & 64 ? p.type.remove(
        p,
        v,
        N,
        Ps,
        V
      ) : A && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !A.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (O !== Ae || j > 0 && j & 64) ? ks(
        A,
        v,
        N,
        !1,
        !0
      ) : (O === Ae && j & 384 || !D && X & 16) && ks(k, v, N), V && ui(p);
    }
    (we && (Ne = U && U.onVnodeUnmounted) || ge) && ze(() => {
      Ne && Ot(Ne, v, p), ge && rs(p, null, v, "unmounted");
    }, N);
  }, ui = (p) => {
    const { type: v, el: N, anchor: V, transition: D } = p;
    if (v === Ae) {
      g.NODE_ENV !== "production" && p.patchFlag > 0 && p.patchFlag & 2048 && D && !D.persisted ? p.children.forEach((U) => {
        U.type === Be ? i(U.el) : ui(U);
      }) : dl(N, V);
      return;
    }
    if (v === Vn) {
      B(p);
      return;
    }
    const O = () => {
      i(N), D && !D.persisted && D.afterLeave && D.afterLeave();
    };
    if (p.shapeFlag & 1 && D && !D.persisted) {
      const { leave: U, delayLeave: F } = D, k = () => U(N, O);
      F ? F(p.el, O, k) : k();
    } else
      O();
  }, dl = (p, v) => {
    let N;
    for (; p !== v; )
      N = m(p), i(p), p = N;
    i(v);
  }, fl = (p, v, N) => {
    g.NODE_ENV !== "production" && p.type.__hmrId && bc(p);
    const { bum: V, scope: D, job: O, subTree: U, um: F, m: k, a: A } = p;
    Qo(k), Qo(A), V && Ss(V), D.stop(), O && (O.flags |= 8, ft(U, p, v, N)), F && ze(F, v), ze(() => {
      p.isUnmounted = !0;
    }, v), g.NODE_ENV !== "production" && xc(p);
  }, ks = (p, v, N, V = !1, D = !1, O = 0) => {
    for (let U = O; U < p.length; U++)
      ft(p[U], v, N, V, D);
  }, gn = (p) => {
    if (p.shapeFlag & 6)
      return gn(p.component.subTree);
    if (p.shapeFlag & 128)
      return p.suspense.next();
    const v = m(p.anchor || p.el), N = v && v[ga];
    return N ? m(N) : v;
  };
  let di = !1;
  const xo = (p, v, N) => {
    let V;
    p == null ? v._vnode && (ft(v._vnode, null, null, !0), V = v._vnode.component) : E(
      v._vnode || null,
      p,
      v,
      null,
      null,
      null,
      N
    ), v._vnode = p, di || (di = !0, Mo(V), ca(), di = !1);
  }, Ps = {
    p: E,
    um: ft,
    m: We,
    r: ui,
    mt: be,
    mc: H,
    pc: Q,
    pbc: me,
    n: gn,
    o: t
  };
  return {
    render: xo,
    hydrate: void 0,
    createApp: iu(xo)
  };
}
function yi({ type: t, props: e }, s) {
  return s === "svg" && t === "foreignObject" || s === "mathml" && t === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : s;
}
function as({ effect: t, job: e }, s) {
  s ? (t.flags |= 32, e.flags |= 4) : (t.flags &= -33, e.flags &= -5);
}
function wu(t, e) {
  return (!t || t && !t.pendingBranch) && e && !e.persisted;
}
function Js(t, e, s = !1) {
  const n = t.children, i = e.children;
  if (z(n) && z(i))
    for (let o = 0; o < n.length; o++) {
      const r = n[o];
      let a = i[o];
      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[o] = Wt(i[o]), a.el = r.el), !s && a.patchFlag !== -2 && Js(r, a)), a.type === hn && (a.patchFlag === -1 && (a = i[o] = Wt(a)), a.el = r.el), a.type === Be && !a.el && (a.el = r.el), g.NODE_ENV !== "production" && a.el && (a.el.__vnode = a);
    }
}
function Du(t) {
  const e = t.slice(), s = [0];
  let n, i, o, r, a;
  const l = t.length;
  for (n = 0; n < l; n++) {
    const u = t[n];
    if (u !== 0) {
      if (i = s[s.length - 1], t[i] < u) {
        e[n] = i, s.push(n);
        continue;
      }
      for (o = 0, r = s.length - 1; o < r; )
        a = o + r >> 1, t[s[a]] < u ? o = a + 1 : r = a;
      u < t[s[o]] && (o > 0 && (e[n] = s[o - 1]), s[o] = n);
    }
  }
  for (o = s.length, r = s[o - 1]; o-- > 0; )
    s[o] = r, r = e[r];
  return s;
}
function Ka(t) {
  const e = t.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : Ka(e);
}
function Qo(t) {
  if (t)
    for (let e = 0; e < t.length; e++)
      t[e].flags |= 8;
}
function za(t) {
  if (t.placeholder)
    return t.placeholder;
  const e = t.component;
  return e ? za(e.subTree) : null;
}
const Ga = (t) => t.__isSuspense;
function Ou(t, e) {
  e && e.pendingBranch ? z(t) ? e.effects.push(...t) : e.effects.push(t) : la(t);
}
const Ae = /* @__PURE__ */ Symbol.for("v-fgt"), hn = /* @__PURE__ */ Symbol.for("v-txt"), Be = /* @__PURE__ */ Symbol.for("v-cmt"), Vn = /* @__PURE__ */ Symbol.for("v-stc"), Qs = [];
let at = null;
function x(t = !1) {
  Qs.push(at = t ? null : []);
}
function $u() {
  Qs.pop(), at = Qs[Qs.length - 1] || null;
}
let nn = 1;
function zn(t, e = !1) {
  nn += t, t < 0 && at && e && (at.hasOnce = !0);
}
function Ya(t) {
  return t.dynamicChildren = nn > 0 ? at || ws : null, $u(), nn > 0 && at && at.push(t), t;
}
function L(t, e, s, n, i, o) {
  return Ya(
    f(
      t,
      e,
      s,
      n,
      i,
      o,
      !0
    )
  );
}
function Ie(t, e, s, n, i) {
  return Ya(
    C(
      t,
      e,
      s,
      n,
      i,
      !0
    )
  );
}
function ys(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function ps(t, e) {
  if (g.NODE_ENV !== "production" && e.shapeFlag & 6 && t.component) {
    const s = On.get(e.type);
    if (s && s.has(t.component))
      return t.shapeFlag &= -257, e.shapeFlag &= -513, !1;
  }
  return t.type === e.type && t.key === e.key;
}
const Au = (...t) => Qa(
  ...t
), Ja = ({ key: t }) => t ?? null, Mn = ({
  ref: t,
  ref_key: e,
  ref_for: s
}) => (typeof t == "number" && (t = "" + t), t != null ? Me(t) || /* @__PURE__ */ Fe(t) || Z(t) ? { i: He, r: t, k: e, f: !!s } : t : null);
function f(t, e = null, s = null, n = 0, i = null, o = t === Ae ? 0 : 1, r = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && Ja(e),
    ref: e && Mn(e),
    scopeId: ma,
    slotScopeIds: null,
    children: s,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: n,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: He
  };
  return a ? (lo(l, s), o & 128 && t.normalize(l)) : s && (l.shapeFlag |= Me(s) ? 8 : 16), g.NODE_ENV !== "production" && l.key !== l.key && M("VNode created with invalid key (NaN). VNode type:", l.type), nn > 0 && // avoid a block node from tracking itself
  !r && // has current parent block
  at && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && at.push(l), l;
}
const C = g.NODE_ENV !== "production" ? Au : Qa;
function Qa(t, e = null, s = null, n = 0, i = null, o = !1) {
  if ((!t || t === zc) && (g.NODE_ENV !== "production" && !t && M(`Invalid vnode type when creating vnode: ${t}.`), t = Be), ys(t)) {
    const a = Bt(
      t,
      e,
      !0
      /* mergeRef: true */
    );
    return s && lo(a, s), nn > 0 && !o && at && (a.shapeFlag & 6 ? at[at.indexOf(t)] = a : at.push(a)), a.patchFlag = -2, a;
  }
  if (sl(t) && (t = t.__vccOpts), e) {
    e = Vu(e);
    let { class: a, style: l } = e;
    a && !Me(a) && (e.class = Re(a)), ve(l) && (/* @__PURE__ */ kn(l) && !z(l) && (l = Ve({}, l)), e.style = Ke(l));
  }
  const r = Me(t) ? 1 : Ga(t) ? 128 : Ea(t) ? 64 : ve(t) ? 4 : Z(t) ? 2 : 0;
  return g.NODE_ENV !== "production" && r & 4 && /* @__PURE__ */ kn(t) && (t = /* @__PURE__ */ ce(t), M(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    t
  )), f(
    t,
    e,
    s,
    n,
    i,
    r,
    o,
    !0
  );
}
function Vu(t) {
  return t ? /* @__PURE__ */ kn(t) || Fa(t) ? Ve({}, t) : t : null;
}
function Bt(t, e, s = !1, n = !1) {
  const { props: i, ref: o, patchFlag: r, children: a, transition: l } = t, u = e ? Mu(i || {}, e) : i, c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: u,
    key: u && Ja(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      s && o ? z(o) ? o.concat(Mn(e)) : [o, Mn(e)] : Mn(e)
    ) : o,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: g.NODE_ENV !== "production" && r === -1 && z(a) ? a.map(Xa) : a,
    target: t.target,
    targetStart: t.targetStart,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && t.type !== Ae ? r === -1 ? 16 : r | 16 : r,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: l,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && Bt(t.ssContent),
    ssFallback: t.ssFallback && Bt(t.ssFallback),
    placeholder: t.placeholder,
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
  return l && n && sn(
    c,
    l.clone(c)
  ), c;
}
function Xa(t) {
  const e = Bt(t);
  return z(t.children) && (e.children = t.children.map(Xa)), e;
}
function ne(t = " ", e = 0) {
  return C(hn, null, t, e);
}
function te(t = "", e = !1) {
  return e ? (x(), Ie(Be, null, t)) : C(Be, null, t);
}
function pt(t) {
  return t == null || typeof t == "boolean" ? C(Be) : z(t) ? C(
    Ae,
    null,
    // #3666, avoid reference pollution when reusing vnode
    t.slice()
  ) : ys(t) ? Wt(t) : C(hn, null, String(t));
}
function Wt(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : Bt(t);
}
function lo(t, e) {
  let s = 0;
  const { shapeFlag: n } = t;
  if (e == null)
    e = null;
  else if (z(e))
    s = 16;
  else if (typeof e == "object")
    if (n & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), lo(t, i()), i._c && (i._d = !0));
      return;
    } else {
      s = 32;
      const i = e._;
      !i && !Fa(e) ? e._ctx = He : i === 3 && He && (He.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else Z(e) ? (e = { default: e, _ctx: He }, s = 32) : (e = String(e), n & 64 ? (s = 16, e = [ne(e)]) : s = 8);
  t.children = e, t.shapeFlag |= s;
}
function Mu(...t) {
  const e = {};
  for (let s = 0; s < t.length; s++) {
    const n = t[s];
    for (const i in n)
      if (i === "class")
        e.class !== n.class && (e.class = Re([e.class, n.class]));
      else if (i === "style")
        e.style = Ke([e.style, n.style]);
      else if (an(i)) {
        const o = e[i], r = n[i];
        r && o !== r && !(z(o) && o.includes(r)) && (e[i] = o ? [].concat(o, r) : r);
      } else i !== "" && (e[i] = n[i]);
  }
  return e;
}
function Ot(t, e, s, n = null) {
  xt(t, e, 7, [
    s,
    n
  ]);
}
const Iu = Ma();
let Ru = 0;
function Lu(t, e, s) {
  const n = t.type, i = (e ? e.appContext : t.appContext) || Iu, o = {
    uid: Ru++,
    vnode: t,
    type: n,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Al(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: ja(n, i),
    emitsOptions: Ra(n, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: ye,
    // inheritAttrs
    inheritAttrs: n.inheritAttrs,
    // state
    ctx: ye,
    data: ye,
    props: ye,
    attrs: ye,
    slots: ye,
    refs: ye,
    setupState: ye,
    setupContext: null,
    // suspense related
    suspense: s,
    suspenseId: s ? s.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return g.NODE_ENV !== "production" ? o.ctx = Gc(o) : o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = ou.bind(null, o), t.ce && t.ce(o), o;
}
let Ue = null;
const ri = () => Ue || He;
let Gn, Bi;
{
  const t = cn(), e = (s, n) => {
    let i;
    return (i = t[s]) || (i = t[s] = []), i.push(n), (o) => {
      i.length > 1 ? i.forEach((r) => r(o)) : i[0](o);
    };
  };
  Gn = e(
    "__VUE_INSTANCE_SETTERS__",
    (s) => Ue = s
  ), Bi = e(
    "__VUE_SSR_SETTERS__",
    (s) => on = s
  );
}
const mn = (t) => {
  const e = Ue;
  return Gn(t), t.scope.on(), () => {
    t.scope.off(), Gn(e);
  };
}, Xo = () => {
  Ue && Ue.scope.off(), Gn(null);
}, ku = /* @__PURE__ */ Jt("slot,component");
function Fi(t, { isNativeTag: e }) {
  (ku(t) || e(t)) && M(
    "Do not use built-in or reserved HTML elements as component id: " + t
  );
}
function Za(t) {
  return t.vnode.shapeFlag & 4;
}
let on = !1;
function Pu(t, e = !1, s = !1) {
  e && Bi(e);
  const { props: n, children: i } = t.vnode, o = Za(t);
  du(t, n, o, e), Tu(t, i, s || e);
  const r = o ? Bu(t, e) : void 0;
  return e && Bi(!1), r;
}
function Bu(t, e) {
  const s = t.type;
  if (g.NODE_ENV !== "production") {
    if (s.name && Fi(s.name, t.appContext.config), s.components) {
      const i = Object.keys(s.components);
      for (let o = 0; o < i.length; o++)
        Fi(i[o], t.appContext.config);
    }
    if (s.directives) {
      const i = Object.keys(s.directives);
      for (let o = 0; o < i.length; o++)
        va(i[o]);
    }
    s.compilerOptions && Fu() && M(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = new Proxy(t.ctx, $a), g.NODE_ENV !== "production" && Yc(t);
  const { setup: n } = s;
  if (n) {
    yt();
    const i = t.setupContext = n.length > 1 ? ju(t) : null, o = mn(t), r = Ls(
      n,
      t,
      0,
      [
        g.NODE_ENV !== "production" ? /* @__PURE__ */ It(t.props) : t.props,
        i
      ]
    ), a = Wi(r);
    if (_t(), o(), (a || t.sp) && !Os(t) && wa(t), a) {
      if (r.then(Xo, Xo), e)
        return r.then((l) => {
          Zo(t, l, e);
        }).catch((l) => {
          un(l, t, 0);
        });
      if (t.asyncDep = r, g.NODE_ENV !== "production" && !t.suspense) {
        const l = vn(t, s);
        M(
          `Component <${l}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      Zo(t, r, e);
  } else
    el(t, e);
}
function Zo(t, e, s) {
  Z(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : ve(e) ? (g.NODE_ENV !== "production" && ys(e) && M(
    "setup() should not return VNodes directly - return a render function instead."
  ), g.NODE_ENV !== "production" && (t.devtoolsRawSetupState = e), t.setupState = ia(e), g.NODE_ENV !== "production" && Jc(t)) : g.NODE_ENV !== "production" && e !== void 0 && M(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), el(t, s);
}
const Fu = () => !0;
function el(t, e, s) {
  const n = t.type;
  t.render || (t.render = n.render || qe);
  {
    const i = mn(t);
    yt();
    try {
      Xc(t);
    } finally {
      _t(), i();
    }
  }
  g.NODE_ENV !== "production" && !n.render && t.render === qe && !e && (n.template ? M(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : M("Component is missing template or render function: ", n));
}
const er = g.NODE_ENV !== "production" ? {
  get(t, e) {
    return Wn(), je(t, "get", ""), t[e];
  },
  set() {
    return M("setupContext.attrs is readonly."), !1;
  },
  deleteProperty() {
    return M("setupContext.attrs is readonly."), !1;
  }
} : {
  get(t, e) {
    return je(t, "get", ""), t[e];
  }
};
function Uu(t) {
  return new Proxy(t.slots, {
    get(e, s) {
      return je(t, "get", "$slots"), e[s];
    }
  });
}
function ju(t) {
  const e = (s) => {
    if (g.NODE_ENV !== "production" && (t.exposed && M("expose() should be called only once per setup()."), s != null)) {
      let n = typeof s;
      n === "object" && (z(s) ? n = "array" : /* @__PURE__ */ Fe(s) && (n = "ref")), n !== "object" && M(
        `expose() should be passed a plain object, received ${n}.`
      );
    }
    t.exposed = s || {};
  };
  if (g.NODE_ENV !== "production") {
    let s, n;
    return Object.freeze({
      get attrs() {
        return s || (s = new Proxy(t.attrs, er));
      },
      get slots() {
        return n || (n = Uu(t));
      },
      get emit() {
        return (i, ...o) => t.emit(i, ...o);
      },
      expose: e
    });
  } else
    return {
      attrs: new Proxy(t.attrs, er),
      slots: t.slots,
      emit: t.emit,
      expose: e
    };
}
function ai(t) {
  return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(ia(Xl(t.exposed)), {
    get(e, s) {
      if (s in e)
        return e[s];
      if (s in gs)
        return gs[s](t);
    },
    has(e, s) {
      return s in e || s in gs;
    }
  })) : t.proxy;
}
const qu = /(?:^|[-_])\w/g, Hu = (t) => t.replace(qu, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function tl(t, e = !0) {
  return Z(t) ? t.displayName || t.name : t.name || e && t.__name;
}
function vn(t, e, s = !1) {
  let n = tl(e);
  if (!n && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (n = i[1]);
  }
  if (!n && t) {
    const i = (o) => {
      for (const r in o)
        if (o[r] === e)
          return r;
    };
    n = i(t.components) || t.parent && i(
      t.parent.type.components
    ) || i(t.appContext.components);
  }
  return n ? Hu(n) : s ? "App" : "Anonymous";
}
function sl(t) {
  return Z(t) && "__vccOpts" in t;
}
const se = (t, e) => {
  const s = /* @__PURE__ */ oc(t, e, on);
  if (g.NODE_ENV !== "production") {
    const n = ri();
    n && n.appContext.config.warnRecursiveComputed && (s._warnRecursive = !0);
  }
  return s;
};
function Wu(t, e, s) {
  try {
    zn(-1);
    const n = arguments.length;
    return n === 2 ? ve(e) && !z(e) ? ys(e) ? C(t, null, [e]) : C(t, e) : C(t, null, e) : (n > 3 ? s = Array.prototype.slice.call(arguments, 2) : n === 3 && ys(s) && (s = [s]), C(t, e, s));
  } finally {
    zn(1);
  }
}
function Ku() {
  if (g.NODE_ENV === "production" || typeof window > "u")
    return;
  const t = { style: "color:#3ba776" }, e = { style: "color:#1677ff" }, s = { style: "color:#f5222d" }, n = { style: "color:#eb2f96" }, i = {
    __vue_custom_formatter: !0,
    header(d) {
      if (!ve(d))
        return null;
      if (d.__isVue)
        return ["div", t, "VueInstance"];
      if (/* @__PURE__ */ Fe(d)) {
        yt();
        const m = d.value;
        return _t(), [
          "div",
          {},
          ["span", t, c(d)],
          "<",
          a(m),
          ">"
        ];
      } else {
        if (/* @__PURE__ */ ns(d))
          return [
            "div",
            {},
            ["span", t, /* @__PURE__ */ Xe(d) ? "ShallowReactive" : "Reactive"],
            "<",
            a(d),
            `>${/* @__PURE__ */ Tt(d) ? " (readonly)" : ""}`
          ];
        if (/* @__PURE__ */ Tt(d))
          return [
            "div",
            {},
            ["span", t, /* @__PURE__ */ Xe(d) ? "ShallowReadonly" : "Readonly"],
            "<",
            a(d),
            ">"
          ];
      }
      return null;
    },
    hasBody(d) {
      return d && d.__isVue;
    },
    body(d) {
      if (d && d.__isVue)
        return [
          "div",
          {},
          ...o(d.$)
        ];
    }
  };
  function o(d) {
    const m = [];
    d.type.props && d.props && m.push(r("props", /* @__PURE__ */ ce(d.props))), d.setupState !== ye && m.push(r("setup", d.setupState)), d.data !== ye && m.push(r("data", /* @__PURE__ */ ce(d.data)));
    const h = l(d, "computed");
    h && m.push(r("computed", h));
    const b = l(d, "inject");
    return b && m.push(r("injected", b)), m.push([
      "div",
      {},
      [
        "span",
        {
          style: n.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: d }]
    ]), m;
  }
  function r(d, m) {
    return m = Ve({}, m), Object.keys(m).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        d
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(m).map((h) => [
          "div",
          {},
          ["span", n, h + ": "],
          a(m[h], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function a(d, m = !0) {
    return typeof d == "number" ? ["span", e, d] : typeof d == "string" ? ["span", s, JSON.stringify(d)] : typeof d == "boolean" ? ["span", n, d] : ve(d) ? ["object", { object: m ? /* @__PURE__ */ ce(d) : d }] : ["span", s, String(d)];
  }
  function l(d, m) {
    const h = d.type;
    if (Z(h))
      return;
    const b = {};
    for (const E in d.ctx)
      u(h, E, m) && (b[E] = d.ctx[E]);
    return b;
  }
  function u(d, m, h) {
    const b = d[h];
    if (z(b) && b.includes(m) || ve(b) && m in b || d.extends && u(d.extends, m, h) || d.mixins && d.mixins.some((E) => u(E, m, h)))
      return !0;
  }
  function c(d) {
    return /* @__PURE__ */ Xe(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];
}
const tr = "3.5.28", kt = g.NODE_ENV !== "production" ? M : qe;
var St = {};
let Ui;
const sr = typeof window < "u" && window.trustedTypes;
if (sr)
  try {
    Ui = /* @__PURE__ */ sr.createPolicy("vue", {
      createHTML: (t) => t
    });
  } catch (t) {
    St.NODE_ENV !== "production" && kt(`Error creating trusted types policy: ${t}`);
  }
const nl = Ui ? (t) => Ui.createHTML(t) : (t) => t, zu = "http://www.w3.org/2000/svg", Gu = "http://www.w3.org/1998/Math/MathML", qt = typeof document < "u" ? document : null, nr = qt && /* @__PURE__ */ qt.createElement("template"), Yu = {
  insert: (t, e, s) => {
    e.insertBefore(t, s || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, s, n) => {
    const i = e === "svg" ? qt.createElementNS(zu, t) : e === "mathml" ? qt.createElementNS(Gu, t) : s ? qt.createElement(t, { is: s }) : qt.createElement(t);
    return t === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple), i;
  },
  createText: (t) => qt.createTextNode(t),
  createComment: (t) => qt.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => qt.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(t, e, s, n, i, o) {
    const r = s ? s.previousSibling : e.lastChild;
    if (i && (i === o || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), s), !(i === o || !(i = i.nextSibling)); )
        ;
    else {
      nr.innerHTML = nl(
        n === "svg" ? `<svg>${t}</svg>` : n === "mathml" ? `<math>${t}</math>` : t
      );
      const a = nr.content;
      if (n === "svg" || n === "mathml") {
        const l = a.firstChild;
        for (; l.firstChild; )
          a.appendChild(l.firstChild);
        a.removeChild(l);
      }
      e.insertBefore(a, s);
    }
    return [
      // first
      r ? r.nextSibling : e.firstChild,
      // last
      s ? s.previousSibling : e.lastChild
    ];
  }
}, Xt = "transition", qs = "animation", rn = /* @__PURE__ */ Symbol("_vtc"), il = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, Ju = /* @__PURE__ */ Ve(
  {},
  Ta,
  il
), Qu = (t) => (t.displayName = "Transition", t.props = Ju, t), co = /* @__PURE__ */ Qu(
  (t, { slots: e }) => Wu(Lc, Xu(t), e)
), ls = (t, e = []) => {
  z(t) ? t.forEach((s) => s(...e)) : t && t(...e);
}, ir = (t) => t ? z(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function Xu(t) {
  const e = {};
  for (const w in t)
    w in il || (e[w] = t[w]);
  if (t.css === !1)
    return e;
  const {
    name: s = "v",
    type: n,
    duration: i,
    enterFromClass: o = `${s}-enter-from`,
    enterActiveClass: r = `${s}-enter-active`,
    enterToClass: a = `${s}-enter-to`,
    appearFromClass: l = o,
    appearActiveClass: u = r,
    appearToClass: c = a,
    leaveFromClass: d = `${s}-leave-from`,
    leaveActiveClass: m = `${s}-leave-active`,
    leaveToClass: h = `${s}-leave-to`
  } = t, b = Zu(i), E = b && b[0], y = b && b[1], {
    onBeforeEnter: _,
    onEnter: S,
    onEnterCancelled: T,
    onLeave: I,
    onLeaveCancelled: B,
    onBeforeAppear: K = _,
    onAppear: pe = S,
    onAppearCancelled: he = T
  } = e, H = (w, W, oe, be) => {
    w._enterCancelled = be, cs(w, W ? c : a), cs(w, W ? u : r), oe && oe();
  }, re = (w, W) => {
    w._isLeaving = !1, cs(w, d), cs(w, h), cs(w, m), W && W();
  }, me = (w) => (W, oe) => {
    const be = w ? pe : S, fe = () => H(W, w, oe);
    ls(be, [W, fe]), or(() => {
      cs(W, w ? l : o), jt(W, w ? c : a), ir(be) || rr(W, n, E, fe);
    });
  };
  return Ve(e, {
    onBeforeEnter(w) {
      ls(_, [w]), jt(w, o), jt(w, r);
    },
    onBeforeAppear(w) {
      ls(K, [w]), jt(w, l), jt(w, u);
    },
    onEnter: me(!1),
    onAppear: me(!0),
    onLeave(w, W) {
      w._isLeaving = !0;
      const oe = () => re(w, W);
      jt(w, d), w._enterCancelled ? (jt(w, m), cr(w)) : (cr(w), jt(w, m)), or(() => {
        w._isLeaving && (cs(w, d), jt(w, h), ir(I) || rr(w, n, y, oe));
      }), ls(I, [w, oe]);
    },
    onEnterCancelled(w) {
      H(w, !1, void 0, !0), ls(T, [w]);
    },
    onAppearCancelled(w) {
      H(w, !0, void 0, !0), ls(he, [w]);
    },
    onLeaveCancelled(w) {
      re(w), ls(B, [w]);
    }
  });
}
function Zu(t) {
  if (t == null)
    return null;
  if (ve(t))
    return [_i(t.enter), _i(t.leave)];
  {
    const e = _i(t);
    return [e, e];
  }
}
function _i(t) {
  const e = bl(t);
  return St.NODE_ENV !== "production" && fc(e, "<transition> explicit duration"), e;
}
function jt(t, e) {
  e.split(/\s+/).forEach((s) => s && t.classList.add(s)), (t[rn] || (t[rn] = /* @__PURE__ */ new Set())).add(e);
}
function cs(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.remove(n));
  const s = t[rn];
  s && (s.delete(e), s.size || (t[rn] = void 0));
}
function or(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let ed = 0;
function rr(t, e, s, n) {
  const i = t._endId = ++ed, o = () => {
    i === t._endId && n();
  };
  if (s != null)
    return setTimeout(o, s);
  const { type: r, timeout: a, propCount: l } = td(t, e);
  if (!r)
    return n();
  const u = r + "end";
  let c = 0;
  const d = () => {
    t.removeEventListener(u, m), o();
  }, m = (h) => {
    h.target === t && ++c >= l && d();
  };
  setTimeout(() => {
    c < l && d();
  }, a + 1), t.addEventListener(u, m);
}
function td(t, e) {
  const s = window.getComputedStyle(t), n = (b) => (s[b] || "").split(", "), i = n(`${Xt}Delay`), o = n(`${Xt}Duration`), r = ar(i, o), a = n(`${qs}Delay`), l = n(`${qs}Duration`), u = ar(a, l);
  let c = null, d = 0, m = 0;
  e === Xt ? r > 0 && (c = Xt, d = r, m = o.length) : e === qs ? u > 0 && (c = qs, d = u, m = l.length) : (d = Math.max(r, u), c = d > 0 ? r > u ? Xt : qs : null, m = c ? c === Xt ? o.length : l.length : 0);
  const h = c === Xt && /\b(?:transform|all)(?:,|$)/.test(
    n(`${Xt}Property`).toString()
  );
  return {
    type: c,
    timeout: d,
    propCount: m,
    hasTransform: h
  };
}
function ar(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((s, n) => lr(s) + lr(t[n])));
}
function lr(t) {
  return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function cr(t) {
  return (t ? t.ownerDocument : document).body.offsetHeight;
}
function sd(t, e, s) {
  const n = t[rn];
  n && (e = (e ? [e, ...n] : [...n]).join(" ")), e == null ? t.removeAttribute("class") : s ? t.setAttribute("class", e) : t.className = e;
}
const ur = /* @__PURE__ */ Symbol("_vod"), nd = /* @__PURE__ */ Symbol("_vsh"), id = /* @__PURE__ */ Symbol(St.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""), od = /(?:^|;)\s*display\s*:/;
function rd(t, e, s) {
  const n = t.style, i = Me(s);
  let o = !1;
  if (s && !i) {
    if (e)
      if (Me(e))
        for (const r of e.split(";")) {
          const a = r.slice(0, r.indexOf(":")).trim();
          s[a] == null && In(n, a, "");
        }
      else
        for (const r in e)
          s[r] == null && In(n, r, "");
    for (const r in s)
      r === "display" && (o = !0), In(n, r, s[r]);
  } else if (i) {
    if (e !== s) {
      const r = n[id];
      r && (s += ";" + r), n.cssText = s, o = od.test(s);
    }
  } else e && t.removeAttribute("style");
  ur in t && (t[ur] = o ? n.display : "", t[nd] && (n.display = "none"));
}
const ad = /[^\\];\s*$/, dr = /\s*!important$/;
function In(t, e, s) {
  if (z(s))
    s.forEach((n) => In(t, e, n));
  else if (s == null && (s = ""), St.NODE_ENV !== "production" && ad.test(s) && kt(
    `Unexpected semicolon at the end of '${e}' style value: '${s}'`
  ), e.startsWith("--"))
    t.setProperty(e, s);
  else {
    const n = ld(t, e);
    dr.test(s) ? t.setProperty(
      Yt(n),
      s.replace(dr, ""),
      "important"
    ) : t[n] = s;
  }
}
const fr = ["Webkit", "Moz", "ms"], Ti = {};
function ld(t, e) {
  const s = Ti[e];
  if (s)
    return s;
  let n = ut(e);
  if (n !== "filter" && n in t)
    return Ti[e] = n;
  n = Qn(n);
  for (let i = 0; i < fr.length; i++) {
    const o = fr[i] + n;
    if (o in t)
      return Ti[e] = o;
  }
  return e;
}
const pr = "http://www.w3.org/1999/xlink";
function hr(t, e, s, n, i, o = Ol(e)) {
  n && e.startsWith("xlink:") ? s == null ? t.removeAttributeNS(pr, e.slice(6, e.length)) : t.setAttributeNS(pr, e, s) : s == null || o && !Br(s) ? t.removeAttribute(e) : t.setAttribute(
    e,
    o ? "" : gt(s) ? String(s) : s
  );
}
function mr(t, e, s, n, i) {
  if (e === "innerHTML" || e === "textContent") {
    s != null && (t[e] = e === "innerHTML" ? nl(s) : s);
    return;
  }
  const o = t.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const a = o === "OPTION" ? t.getAttribute("value") || "" : t.value, l = s == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      t.type === "checkbox" ? "on" : ""
    ) : String(s);
    (a !== l || !("_value" in t)) && (t.value = l), s == null && t.removeAttribute(e), t._value = s;
    return;
  }
  let r = !1;
  if (s === "" || s == null) {
    const a = typeof t[e];
    a === "boolean" ? s = Br(s) : s == null && a === "string" ? (s = "", r = !0) : a === "number" && (s = 0, r = !0);
  }
  try {
    t[e] = s;
  } catch (a) {
    St.NODE_ENV !== "production" && !r && kt(
      `Failed setting prop "${e}" on <${o.toLowerCase()}>: value ${s} is invalid.`,
      a
    );
  }
  r && t.removeAttribute(i || e);
}
function zt(t, e, s, n) {
  t.addEventListener(e, s, n);
}
function cd(t, e, s, n) {
  t.removeEventListener(e, s, n);
}
const vr = /* @__PURE__ */ Symbol("_vei");
function ud(t, e, s, n, i = null) {
  const o = t[vr] || (t[vr] = {}), r = o[e];
  if (n && r)
    r.value = St.NODE_ENV !== "production" ? gr(n, e) : n;
  else {
    const [a, l] = dd(e);
    if (n) {
      const u = o[e] = hd(
        St.NODE_ENV !== "production" ? gr(n, e) : n,
        i
      );
      zt(t, a, u, l);
    } else r && (cd(t, a, r, l), o[e] = void 0);
  }
}
const br = /(?:Once|Passive|Capture)$/;
function dd(t) {
  let e;
  if (br.test(t)) {
    e = {};
    let n;
    for (; n = t.match(br); )
      t = t.slice(0, t.length - n[0].length), e[n[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : Yt(t.slice(2)), e];
}
let Ni = 0;
const fd = /* @__PURE__ */ Promise.resolve(), pd = () => Ni || (fd.then(() => Ni = 0), Ni = Date.now());
function hd(t, e) {
  const s = (n) => {
    if (!n._vts)
      n._vts = Date.now();
    else if (n._vts <= s.attached)
      return;
    xt(
      md(n, s.value),
      e,
      5,
      [n]
    );
  };
  return s.value = t, s.attached = pd(), s;
}
function gr(t, e) {
  return Z(t) || z(t) ? t : (kt(
    `Wrong type passed as event handler to ${e} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof t}.`
  ), qe);
}
function md(t, e) {
  if (z(e)) {
    const s = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      s.call(t), t._stopped = !0;
    }, e.map(
      (n) => (i) => !i._stopped && n && n(i)
    );
  } else
    return e;
}
const Er = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // lowercase letter
t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, vd = (t, e, s, n, i, o) => {
  const r = i === "svg";
  e === "class" ? sd(t, n, r) : e === "style" ? rd(t, s, n) : an(e) ? Rn(e) || ud(t, e, s, n, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : bd(t, e, n, r)) ? (mr(t, e, n), !t.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && hr(t, e, n, r, o, e !== "value")) : /* #11081 force set props for possible async custom element */ t._isVueCE && (/[A-Z]/.test(e) || !Me(n)) ? mr(t, ut(e), n, o, e) : (e === "true-value" ? t._trueValue = n : e === "false-value" && (t._falseValue = n), hr(t, e, n, r));
};
function bd(t, e, s, n) {
  if (n)
    return !!(e === "innerHTML" || e === "textContent" || e in t && Er(e) && Z(s));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && t.tagName === "IFRAME" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = t.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return Er(e) && Me(s) ? !1 : e in t;
}
const os = (t) => {
  const e = t.props["onUpdate:modelValue"] || !1;
  return z(e) ? (s) => Ss(e, s) : e;
};
function gd(t) {
  t.target.composing = !0;
}
function yr(t) {
  const e = t.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const dt = /* @__PURE__ */ Symbol("_assign");
function _r(t, e, s) {
  return e && (t = t.trim()), s && (t = Xn(t)), t;
}
const bt = {
  created(t, { modifiers: { lazy: e, trim: s, number: n } }, i) {
    t[dt] = os(i);
    const o = n || i.props && i.props.type === "number";
    zt(t, e ? "change" : "input", (r) => {
      r.target.composing || t[dt](_r(t.value, s, o));
    }), (s || o) && zt(t, "change", () => {
      t.value = _r(t.value, s, o);
    }), e || (zt(t, "compositionstart", gd), zt(t, "compositionend", yr), zt(t, "change", yr));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(t, { value: e }) {
    t.value = e ?? "";
  },
  beforeUpdate(t, { value: e, oldValue: s, modifiers: { lazy: n, trim: i, number: o } }, r) {
    if (t[dt] = os(r), t.composing) return;
    const a = (o || t.type === "number") && !/^0\d/.test(t.value) ? Xn(t.value) : t.value, l = e ?? "";
    a !== l && (document.activeElement === t && t.type !== "range" && (n && e === s || i && t.value.trim() === l) || (t.value = l));
  }
}, uo = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(t, e, s) {
    t[dt] = os(s), zt(t, "change", () => {
      const n = t._modelValue, i = Ms(t), o = t.checked, r = t[dt];
      if (z(n)) {
        const a = Gi(n, i), l = a !== -1;
        if (o && !l)
          r(n.concat(i));
        else if (!o && l) {
          const u = [...n];
          u.splice(a, 1), r(u);
        }
      } else if (Rs(n)) {
        const a = new Set(n);
        o ? a.add(i) : a.delete(i), r(a);
      } else
        r(ol(t, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Tr,
  beforeUpdate(t, e, s) {
    t[dt] = os(s), Tr(t, e, s);
  }
};
function Tr(t, { value: e, oldValue: s }, n) {
  t._modelValue = e;
  let i;
  if (z(e))
    i = Gi(e, n.props.value) > -1;
  else if (Rs(e))
    i = e.has(n.props.value);
  else {
    if (e === s) return;
    i = is(e, ol(t, !0));
  }
  t.checked !== i && (t.checked = i);
}
const Ed = {
  created(t, { value: e }, s) {
    t.checked = is(e, s.props.value), t[dt] = os(s), zt(t, "change", () => {
      t[dt](Ms(t));
    });
  },
  beforeUpdate(t, { value: e, oldValue: s }, n) {
    t[dt] = os(n), e !== s && (t.checked = is(e, n.props.value));
  }
}, fo = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(t, { value: e, modifiers: { number: s } }, n) {
    const i = Rs(e);
    zt(t, "change", () => {
      const o = Array.prototype.filter.call(t.options, (r) => r.selected).map(
        (r) => s ? Xn(Ms(r)) : Ms(r)
      );
      t[dt](
        t.multiple ? i ? new Set(o) : o : o[0]
      ), t._assigning = !0, Lt(() => {
        t._assigning = !1;
      });
    }), t[dt] = os(n);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(t, { value: e }) {
    Nr(t, e);
  },
  beforeUpdate(t, e, s) {
    t[dt] = os(s);
  },
  updated(t, { value: e }) {
    t._assigning || Nr(t, e);
  }
};
function Nr(t, e) {
  const s = t.multiple, n = z(e);
  if (s && !n && !Rs(e)) {
    St.NODE_ENV !== "production" && kt(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let i = 0, o = t.options.length; i < o; i++) {
    const r = t.options[i], a = Ms(r);
    if (s)
      if (n) {
        const l = typeof a;
        l === "string" || l === "number" ? r.selected = e.some((u) => String(u) === String(a)) : r.selected = Gi(e, a) > -1;
      } else
        r.selected = e.has(a);
    else if (is(Ms(r), e)) {
      t.selectedIndex !== i && (t.selectedIndex = i);
      return;
    }
  }
  !s && t.selectedIndex !== -1 && (t.selectedIndex = -1);
}
function Ms(t) {
  return "_value" in t ? t._value : t.value;
}
function ol(t, e) {
  const s = e ? "_trueValue" : "_falseValue";
  return s in t ? t[s] : e;
}
const yd = {
  created(t, e, s) {
    Nn(t, e, s, null, "created");
  },
  mounted(t, e, s) {
    Nn(t, e, s, null, "mounted");
  },
  beforeUpdate(t, e, s, n) {
    Nn(t, e, s, n, "beforeUpdate");
  },
  updated(t, e, s, n) {
    Nn(t, e, s, n, "updated");
  }
};
function _d(t, e) {
  switch (t) {
    case "SELECT":
      return fo;
    case "TEXTAREA":
      return bt;
    default:
      switch (e) {
        case "checkbox":
          return uo;
        case "radio":
          return Ed;
        default:
          return bt;
      }
  }
}
function Nn(t, e, s, n, i) {
  const r = _d(
    t.tagName,
    s.props && s.props.type
  )[i];
  r && r(t, e, s, n);
}
const Td = ["ctrl", "shift", "alt", "meta"], Nd = {
  stop: (t) => t.stopPropagation(),
  prevent: (t) => t.preventDefault(),
  self: (t) => t.target !== t.currentTarget,
  ctrl: (t) => !t.ctrlKey,
  shift: (t) => !t.shiftKey,
  alt: (t) => !t.altKey,
  meta: (t) => !t.metaKey,
  left: (t) => "button" in t && t.button !== 0,
  middle: (t) => "button" in t && t.button !== 1,
  right: (t) => "button" in t && t.button !== 2,
  exact: (t, e) => Td.some((s) => t[`${s}Key`] && !e.includes(s))
}, xd = (t, e) => {
  if (!t) return t;
  const s = t._withMods || (t._withMods = {}), n = e.join(".");
  return s[n] || (s[n] = ((i, ...o) => {
    for (let r = 0; r < e.length; r++) {
      const a = Nd[e[r]];
      if (a && a(i, e)) return;
    }
    return t(i, ...o);
  }));
}, Sd = /* @__PURE__ */ Ve({ patchProp: vd }, Yu);
let xr;
function Cd() {
  return xr || (xr = Su(Sd));
}
const wd = ((...t) => {
  const e = Cd().createApp(...t);
  St.NODE_ENV !== "production" && (Od(e), $d(e));
  const { mount: s } = e;
  return e.mount = (n) => {
    const i = Ad(n);
    if (!i) return;
    const o = e._component;
    !Z(o) && !o.render && !o.template && (o.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
    const r = s(i, !1, Dd(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), r;
  }, e;
});
function Dd(t) {
  if (t instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && t instanceof MathMLElement)
    return "mathml";
}
function Od(t) {
  Object.defineProperty(t.config, "isNativeTag", {
    value: (e) => Sl(e) || Cl(e) || wl(e),
    writable: !1
  });
}
function $d(t) {
  {
    const e = t.config.isCustomElement;
    Object.defineProperty(t.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        kt(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const s = t.config.compilerOptions, n = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(t.config, "compilerOptions", {
      get() {
        return kt(n), s;
      },
      set() {
        kt(n);
      }
    });
  }
}
function Ad(t) {
  if (Me(t)) {
    const e = document.querySelector(t);
    return St.NODE_ENV !== "production" && !e && kt(
      `Failed to mount app: mount target selector "${t}" returned null.`
    ), e;
  }
  return St.NODE_ENV !== "production" && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && kt(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), t;
}
var Vd = {};
function Md() {
  Ku();
}
Vd.NODE_ENV !== "production" && Md();
const De = (t, e) => {
  const s = t.__vccOpts || t;
  for (const [n, i] of e)
    s[n] = i;
  return s;
}, Id = {}, Rd = { class: "card st-card-unified" }, Ld = { style: { display: "flex", "align-items": "center", "justify-content": "space-between" } };
function kd(t, e) {
  return x(), L("div", Rd, [
    f("div", Ld, [
      vt(t.$slots, "left", {}, void 0, !0),
      vt(t.$slots, "right", {}, void 0, !0)
    ])
  ]);
}
const xn = /* @__PURE__ */ De(Id, [["render", kd], ["__scopeId", "data-v-5b66fbc1"]]), Pd = { class: "st-toggle-switch" }, Bd = ["checked"], Fd = /* @__PURE__ */ _e({
  __name: "ToggleSwitch",
  props: {
    checked: { type: Boolean }
  },
  emits: ["change"],
  setup(t) {
    return (e, s) => (x(), L("label", Pd, [
      f("input", {
        type: "checkbox",
        checked: t.checked,
        onChange: s[0] || (s[0] = (n) => e.$emit("change", n.target.checked))
      }, null, 40, Bd),
      s[1] || (s[1] = f("span", { class: "st-toggle-slider" }, null, -1))
    ]));
  }
}), Sr = /* @__PURE__ */ De(Fd, [["__scopeId", "data-v-f73e4a93"]]), Ud = { class: "button-content" }, jd = /* @__PURE__ */ _e({
  __name: "Button",
  emits: ["click"],
  setup(t) {
    return (e, s) => (x(), L("button", {
      class: "menu_button button-wrapper",
      onClick: s[0] || (s[0] = (n) => e.$emit("click"))
    }, [
      f("span", Ud, [
        vt(e.$slots, "default", {}, void 0, !0)
      ])
    ]));
  }
}), ae = /* @__PURE__ */ De(jd, [["__scopeId", "data-v-8b9ccff3"]]), qd = {
  key: 0,
  class: "popup-modal-header"
}, Hd = { class: "popup-modal-title" }, Wd = { class: "popup-modal-body" }, Kd = {
  key: 1,
  class: "popup-modal-footer"
}, zd = /* @__PURE__ */ _e({
  __name: "PopupModal",
  props: {
    visible: { type: Boolean },
    title: {},
    closable: { type: Boolean, default: !0 },
    maskClosable: { type: Boolean, default: !0 },
    height: {},
    width: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = se(() => {
      const a = {};
      return s.height && (a.height = s.height, a["max-height"] = s.height), s.width && (a.width = s.width, a["max-width"] = s.width), a;
    }), i = e, o = () => {
      i("close");
    }, r = () => {
      s.maskClosable && o();
    };
    return (a, l) => (x(), Ie(_a, { to: "body" }, [
      C(co, { name: "modal" }, {
        default: P(() => [
          t.visible ? (x(), L("div", {
            key: 0,
            class: "popup-modal-overlay",
            onClick: xd(r, ["self"])
          }, [
            f("div", {
              class: "popup-modal",
              style: Ke(n.value)
            }, [
              t.title || t.closable || a.$slots.titlePrefix ? (x(), L("div", qd, [
                f("div", Hd, [
                  vt(a.$slots, "titlePrefix", {}, void 0, !0),
                  f("span", null, ue(t.title), 1)
                ]),
                t.closable ? (x(), L("div", {
                  key: 0,
                  class: "popup-modal-close",
                  onClick: o
                }, [...l[0] || (l[0] = [
                  f("i", { class: "fa-solid fa-xmark" }, null, -1)
                ])])) : te("", !0)
              ])) : te("", !0),
              f("div", Wd, [
                vt(a.$slots, "default", {}, void 0, !0)
              ]),
              a.$slots.footer ? (x(), L("div", Kd, [
                vt(a.$slots, "footer", {}, void 0, !0)
              ])) : te("", !0)
            ], 4)
          ])) : te("", !0)
        ]),
        _: 3
      })
    ]));
  }
}), Ge = /* @__PURE__ */ De(zd, [["__scopeId", "data-v-546209e7"]]), Gd = { class: "drawer-header" }, Yd = { class: "header-actions" }, Jd = { class: "drawer-body" }, Qd = {
  key: 0,
  class: "empty-state"
}, Xd = {
  key: 1,
  class: "table-list"
}, Zd = ["onClick"], ef = { class: "table-item-main" }, tf = { class: "table-name" }, sf = {
  key: 0,
  class: "table-comment"
}, nf = /* @__PURE__ */ _e({
  __name: "TableListDrawer",
  props: {
    tables: {},
    selectedTable: {},
    isDrawer: { type: Boolean, default: !0 },
    showSyncButtons: { type: Boolean, default: !1 }
  },
  emits: ["select", "create", "closeDrawer", "sync", "push"],
  setup(t, { emit: e }) {
    const s = e, n = /* @__PURE__ */ q(window.innerWidth), i = () => {
      n.value = window.innerWidth;
    };
    it(() => {
      window.addEventListener("resize", i);
    }), pn(() => {
      window.removeEventListener("resize", i);
    });
    const o = () => n.value <= 768, r = (c) => {
      s("select", c), o() && s("closeDrawer");
    }, a = () => {
      s("create");
    }, l = () => {
      s("sync");
    }, u = () => {
      s("push");
    };
    return (c, d) => (x(), L("div", {
      class: Re(["table-list-drawer", { "is-drawer": t.isDrawer }])
    }, [
      f("div", Gd, [
        d[3] || (d[3] = f("span", { class: "drawer-title" }, "", -1)),
        f("div", Yd, [
          t.showSyncButtons ? (x(), L("button", {
            key: 0,
            class: "sync-btn",
            title: "",
            onClick: l
          }, [...d[0] || (d[0] = [
            f("i", { class: "fa-solid fa-rotate" }, null, -1)
          ])])) : te("", !0),
          t.showSyncButtons ? (x(), L("button", {
            key: 1,
            class: "push-btn",
            title: "",
            onClick: u
          }, [...d[1] || (d[1] = [
            f("i", { class: "fa-solid fa-share-from-square" }, null, -1)
          ])])) : te("", !0),
          f("button", {
            class: "create-table-btn",
            title: "",
            onClick: a
          }, [...d[2] || (d[2] = [
            f("i", { class: "fa-solid fa-plus" }, null, -1)
          ])])
        ])
      ]),
      f("div", Jd, [
        t.tables.length === 0 ? (x(), L("div", Qd, [
          d[5] || (d[5] = f("i", { class: "fa-solid fa-table" }, null, -1)),
          d[6] || (d[6] = f("span", null, "", -1)),
          f("button", {
            class: "empty-create-btn",
            onClick: a
          }, [...d[4] || (d[4] = [
            f("i", { class: "fa-solid fa-plus" }, null, -1),
            ne("  ", -1)
          ])])
        ])) : (x(), L("div", Xd, [
          (x(!0), L(Ae, null, Gt(t.tables, (m) => (x(), L("div", {
            key: m.tableName,
            class: Re(["table-item", { active: t.selectedTable === m.tableName }]),
            onClick: (h) => r(m.tableName)
          }, [
            f("div", ef, [
              d[7] || (d[7] = f("i", { class: "fa-solid fa-table table-icon" }, null, -1)),
              f("span", tf, ue(m.tableName), 1)
            ]),
            m.comment ? (x(), L("div", sf, ue(m.comment), 1)) : te("", !0)
          ], 10, Zd))), 128))
        ]))
      ])
    ], 2));
  }
}), of = /* @__PURE__ */ De(nf, [["__scopeId", "data-v-85bfbdca"]]), rf = { class: "table-drawer-layout" }, af = { class: "layout-content" }, lf = {
  key: 0,
  class: "layout-drawer"
}, cf = { class: "layout-main" }, uf = /* @__PURE__ */ _e({
  __name: "TableDrawerLayout",
  props: {
    drawerExpanded: { type: Boolean },
    tables: {},
    selectedTable: {},
    showSyncButtons: { type: Boolean, default: !1 }
  },
  emits: ["update:drawerExpanded", "selectTable", "createTable", "sync", "push"],
  setup(t, { emit: e }) {
    const s = e, n = (l) => {
      s("selectTable", l);
    }, i = () => {
      s("createTable");
    }, o = () => {
      s("update:drawerExpanded", !1);
    }, r = () => {
      s("sync");
    }, a = () => {
      s("push");
    };
    return (l, u) => (x(), L("div", rf, [
      f("div", af, [
        C(co, { name: "drawer-slide" }, {
          default: P(() => [
            t.drawerExpanded ? (x(), L("div", lf, [
              C(of, {
                tables: t.tables,
                "selected-table": t.selectedTable,
                "show-sync-buttons": t.showSyncButtons,
                onSelect: n,
                onCreate: i,
                onCloseDrawer: o,
                onSync: r,
                onPush: a
              }, null, 8, ["tables", "selected-table", "show-sync-buttons"])
            ])) : te("", !0)
          ]),
          _: 1
        }),
        f("div", cf, [
          vt(l.$slots, "default", {}, void 0, !0)
        ])
      ])
    ]));
  }
}), po = /* @__PURE__ */ De(uf, [["__scopeId", "data-v-3e0df31e"]]), df = { class: "tab-container" }, ff = { class: "tab-header" }, pf = ["onClick"], hf = { class: "tab-body" }, mf = /* @__PURE__ */ _e({
  __name: "TabContainer",
  props: {
    tabs: {},
    activeTab: {}
  },
  emits: ["update:activeTab"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(window.innerWidth), o = () => {
      i.value = window.innerWidth;
    };
    it(() => {
      window.addEventListener("resize", o);
    }), pn(() => {
      window.removeEventListener("resize", o);
    });
    const r = se(() => {
      const l = i.value <= 768;
      return s.tabs.filter((u) => !(u.mobileOnly && !l || u.desktopOnly && l));
    }), a = (l) => {
      n("update:activeTab", l);
    };
    return (l, u) => (x(), L("div", df, [
      f("div", ff, [
        (x(!0), L(Ae, null, Gt(r.value, (c) => (x(), L("div", {
          key: c.key,
          class: Re(["tab-item", { active: t.activeTab === c.key }]),
          onClick: (d) => a(c.key)
        }, [
          c.icon ? (x(), L("i", {
            key: 0,
            class: Re(c.icon)
          }, null, 2)) : te("", !0),
          f("span", null, ue(c.label), 1)
        ], 10, pf))), 128))
      ]),
      f("div", hf, [
        (x(!0), L(Ae, null, Gt(t.tabs, (c) => (x(), L(Ae, {
          key: c.key
        }, [
          t.activeTab === c.key ? vt(l.$slots, c.key, { key: 0 }, void 0, !0) : te("", !0)
        ], 64))), 128))
      ])
    ]));
  }
}), ho = /* @__PURE__ */ De(mf, [["__scopeId", "data-v-9d94b988"]]), vf = /* @__PURE__ */ _e({
  __name: "DrawerToggle",
  props: {
    expanded: { type: Boolean },
    fab: { type: Boolean, default: !1 }
  },
  emits: ["toggle"],
  setup(t, { emit: e }) {
    const s = e, n = () => {
      s("toggle");
    };
    return (i, o) => (x(), L("button", {
      class: Re(["drawer-toggle", { fab: t.fab }]),
      onClick: n
    }, [...o[0] || (o[0] = [
      f("div", { class: "hamburger-icon" }, [
        f("span", { class: "line" }),
        f("span", { class: "line" }),
        f("span", { class: "line" })
      ], -1)
    ])], 2));
  }
}), mo = /* @__PURE__ */ De(vf, [["__scopeId", "data-v-04d4da93"]]), bf = /* @__PURE__ */ _e({
  __name: "ToastNotification",
  props: {
    visible: { type: Boolean },
    message: {},
    type: {},
    icon: {}
  },
  setup(t) {
    return (e, s) => (x(), Ie(co, { name: "toast" }, {
      default: P(() => [
        t.visible ? (x(), L("div", {
          key: 0,
          class: Re(["toast-notification", t.type])
        }, [
          f("i", {
            class: Re(t.icon)
          }, null, 2),
          f("span", null, ue(t.message), 1)
        ], 2)) : te("", !0)
      ]),
      _: 1
    }));
  }
}), rl = /* @__PURE__ */ De(bf, [["__scopeId", "data-v-76c92735"]]), gf = /* @__PURE__ */ _e({
  __name: "EmptyState",
  props: {
    icon: {},
    text: {},
    iconSize: { default: 48 },
    variant: { default: "default" }
  },
  setup(t) {
    return (e, s) => (x(), L("div", {
      class: Re([t.variant, "empty-state"])
    }, [
      f("i", {
        class: Re(t.icon),
        style: Ke({ fontSize: `${t.iconSize}px` })
      }, null, 6),
      f("span", null, ue(t.text), 1)
    ], 2));
  }
}), Yn = /* @__PURE__ */ De(gf, [["__scopeId", "data-v-5ddb0dfd"]]);
function al() {
  const t = /* @__PURE__ */ _s({
    visible: !1,
    message: "",
    type: "success",
    icon: "fa-solid fa-check-circle"
  });
  let e = null;
  return {
    toast: t,
    showToast: (n, i = "success") => {
      e && clearTimeout(e), t.message = n, t.type = i, t.icon = i === "success" ? "fa-solid fa-check-circle" : "fa-solid fa-circle-xmark", t.visible = !0, e = setTimeout(() => {
        t.visible = !1;
      }, 3e3);
    }
  };
}
function Ef() {
  return {
    showCreateTableModal: /* @__PURE__ */ q(!1),
    showEditTableNameModal: /* @__PURE__ */ q(!1),
    showEditTableCommentModal: /* @__PURE__ */ q(!1),
    showDropTableModal: /* @__PURE__ */ q(!1),
    showAddColumnModal: /* @__PURE__ */ q(!1),
    showEditColumnNameModal: /* @__PURE__ */ q(!1),
    showEditColumnCommentModal: /* @__PURE__ */ q(!1),
    showDropColumnModal: /* @__PURE__ */ q(!1),
    showDDLModal: /* @__PURE__ */ q(!1),
    editingColumn: /* @__PURE__ */ q(null),
    exportedDDL: /* @__PURE__ */ q("")
  };
}
const yf = ["value", "placeholder", "disabled", "readonly", "maxlength"], _f = {
  key: 0,
  class: "textarea-footer"
}, Tf = /* @__PURE__ */ _e({
  __name: "AutoResizeTextarea",
  props: {
    modelValue: { default: "" },
    placeholder: { default: "..." },
    minRows: { default: 1 },
    maxRows: { default: 15 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    maxlength: { default: void 0 },
    showCount: { type: Boolean, default: !1 },
    submitOnEnter: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "focus", "blur", "submit"],
  setup(t, { expose: e, emit: s }) {
    const n = t, i = s, o = /* @__PURE__ */ q(null), r = /* @__PURE__ */ q(null), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q(24), u = se(() => (n.modelValue || "").length);
    function c() {
      const S = o.value, T = r.value;
      if (!S || !T) return;
      const I = window.getComputedStyle(S), B = parseFloat(I.lineHeight) || 24;
      l.value = B;
      const K = parseFloat(I.paddingTop) || 0, pe = parseFloat(I.paddingBottom) || 0, he = parseFloat(I.borderTopWidth) || 0, H = parseFloat(I.borderBottomWidth) || 0;
      T.style.width = `${S.clientWidth}px`, T.style.fontSize = I.fontSize, T.style.fontFamily = I.fontFamily, T.style.fontWeight = I.fontWeight, T.style.letterSpacing = I.letterSpacing, T.style.wordSpacing = I.wordSpacing, T.style.lineHeight = I.lineHeight, T.style.paddingTop = I.paddingTop, T.style.paddingBottom = I.paddingBottom, T.style.paddingLeft = I.paddingLeft, T.style.paddingRight = I.paddingRight, T.style.wordBreak = I.wordBreak, T.style.whiteSpace = "pre-wrap", T.style.overflowWrap = "break-word", T.style.boxSizing = "border-box";
      const re = n.modelValue || "";
      T.textContent = re + `
`;
      const me = T.scrollHeight, w = B * n.minRows + K + pe, W = B * n.maxRows + K + pe, oe = Math.min(Math.max(me, w), W);
      S.style.height = `${oe + he + H}px`, S.style.overflowY = me > W ? "auto" : "hidden";
    }
    function d(S) {
      const T = S.target;
      i("update:modelValue", T.value), c(), Lt(c);
    }
    function m(S) {
      a.value = !0, i("focus", S);
    }
    function h(S) {
      a.value = !1, i("blur", S);
    }
    function b(S) {
      n.submitOnEnter && S.key === "Enter" && !S.shiftKey && (S.preventDefault(), i("submit", n.modelValue || ""));
    }
    function E() {
      o.value?.focus();
    }
    function y() {
      o.value?.blur();
    }
    e({ focus: E, blur: y, adjustHeight: c }), lt(() => n.modelValue, () => {
      Lt(c);
    }), lt([() => n.minRows, () => n.maxRows], () => {
      Lt(c);
    });
    let _ = null;
    return it(() => {
      c(), window.ResizeObserver && o.value && (_ = new ResizeObserver(() => c()), _.observe(o.value.parentElement));
    }), Ft(() => {
      _?.disconnect();
    }), (S, T) => (x(), L("div", {
      class: Re(["auto-resize-wrapper", { focused: a.value, disabled: t.disabled }])
    }, [
      f("div", {
        ref_key: "mirrorRef",
        ref: r,
        class: "textarea-mirror",
        "aria-hidden": "true"
      }, null, 512),
      f("textarea", {
        ref_key: "textareaRef",
        ref: o,
        class: "auto-resize-textarea",
        value: t.modelValue,
        placeholder: t.placeholder,
        disabled: t.disabled,
        readonly: t.readonly,
        maxlength: t.maxlength,
        rows: 1,
        onInput: d,
        onFocus: m,
        onBlur: h,
        onKeydown: b
      }, null, 40, yf),
      t.showCount && t.maxlength ? (x(), L("div", _f, [
        f("span", {
          class: Re(["char-count", { warning: u.value > t.maxlength * 0.9 }])
        }, ue(u.value) + " / " + ue(t.maxlength), 3)
      ])) : te("", !0)
    ], 2));
  }
}), Is = /* @__PURE__ */ De(Tf, [["__scopeId", "data-v-fd129974"]]);
var Pt = /* @__PURE__ */ ((t) => (t.NUMBER = "NUMBER", t.STRING = "STRING", t))(Pt || {});
function li() {
  const t = /* @__PURE__ */ q([]), e = se(() => t.value.length > 0), s = (h) => t.value.find((b) => b.field === h)?.message, n = () => {
    t.value = [];
  }, i = (h, b) => {
    t.value.push({ field: h, message: b });
  }, o = (h, b) => {
    const E = h.trim();
    return E ? E.length > 64 ? (i("tableName", "64"), !1) : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(E) ? b?.checkTableNameExists && b.checkTableNameExists(E) ? b.excludeName && E === b.excludeName ? !0 : (i("tableName", ` "${E}" `), !1) : !0 : (i("tableName", ""), !1) : (i("tableName", ""), !1);
  }, r = (h, b) => {
    const E = h.trim();
    return E ? E.length > 64 ? (i("columnName", "64"), !1) : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(E) ? b?.checkColumnNameExists && b.checkColumnNameExists(E) ? b.excludeName && E === b.excludeName ? !0 : (i("columnName", ` "${E}" `), !1) : !0 : (i("columnName", ""), !1) : (i("columnName", ""), !1);
  }, a = (h) => {
    const b = h.map((_) => _.name.trim()).filter((_) => _), E = [], y = /* @__PURE__ */ new Set();
    for (const _ of b)
      y.has(_) && (E.includes(_) || E.push(_)), y.add(_);
    return E.length > 0 ? (i("columns", `: ${E.join(", ")}`), !1) : !0;
  };
  return {
    errors: t,
    hasErrors: e,
    getFieldError: s,
    clearErrors: n,
    addError: i,
    validateTableName: o,
    validateColumnName: r,
    validateDuplicateColumnNames: a,
    validateCreateTableForm: (h, b, E) => {
      n();
      const y = E.map((_) => _.tableName);
      return o(h, {
        checkTableNameExists: (_) => y.includes(_)
      }), b.length === 0 && i("columns", ""), b.forEach((_, S) => {
        const T = _.name.trim();
        T ? /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(T) || i(`column_${S}`, ` "${T}" `) : i(`column_${S}`, ` ${S + 1} `);
      }), a(b), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateAddColumnForm: (h, b) => {
      n();
      const E = b.map((y) => y.name);
      return r(h, {
        checkColumnNameExists: (y) => E.includes(y)
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateEditTableNameForm: (h, b, E) => {
      n();
      const y = E.map((_) => _.tableName);
      return o(h, {
        checkTableNameExists: (_) => y.includes(_),
        excludeName: b
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateEditColumnNameForm: (h, b, E) => {
      n();
      const y = E.map((_) => _.name);
      return r(h, {
        checkColumnNameExists: (_) => y.includes(_),
        excludeName: b
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateComment: (h, b = 500) => h && h.length > b ? (i("comment", ` ${b} `), !1) : !0
  };
}
const Nf = { class: "form-container" }, xf = { class: "form-section" }, Sf = { class: "form-item" }, Cf = {
  key: 0,
  class: "field-error"
}, wf = { class: "form-item" }, Df = { class: "form-section columns-section" }, Of = { class: "section-header" }, $f = { class: "column-count" }, Af = {
  key: 0,
  class: "field-error section-error"
}, Vf = { class: "columns-list" }, Mf = { class: "column-card-header" }, If = { class: "column-number" }, Rf = ["onClick"], Lf = { class: "column-card-body" }, kf = { class: "form-row" }, Pf = { class: "form-col form-col-name" }, Bf = ["onUpdate:modelValue"], Ff = { class: "form-col form-col-type" }, Uf = ["onUpdate:modelValue"], jf = ["value"], qf = ["value"], Hf = {
  key: 0,
  class: "field-error"
}, Wf = { class: "form-row" }, Kf = { class: "form-col form-col-default" }, zf = ["onUpdate:modelValue"], Gf = { class: "form-col form-col-comment" }, Yf = { class: "checkbox-label" }, Jf = ["onUpdate:modelValue"], Qf = { class: "form-actions" }, Xf = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Zf = "auto", ep = /* @__PURE__ */ _e({
  __name: "CreateTableForm",
  props: {
    existingTables: { default: () => [] }
  },
  emits: ["create", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateCreateTableForm: o, clearErrors: r } = li(), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q(!1), u = () => {
      l.value = window.innerWidth <= 768;
    };
    it(() => {
      u(), window.addEventListener("resize", u);
    }), Ft(() => {
      window.removeEventListener("resize", u);
    });
    const c = se(() => l.value ? "100%" : "50vw"), d = se(() => {
      const S = {};
      return S["--form-modal-width"] = l.value ? "100%" : "50vw", S;
    });
    let m = 0;
    const h = /* @__PURE__ */ _s({
      tableName: "",
      comment: "",
      columns: []
    }), b = () => {
      h.columns.push({
        id: ++m,
        name: "",
        type: Pt.STRING,
        primitiveKey: !1,
        comment: ""
      });
    }, E = (S) => {
      h.columns.splice(S, 1);
    }, y = () => {
      if (r(), a.value = !0, !o(
        h.tableName,
        h.columns,
        s.existingTables
      ).valid) {
        a.value = !1;
        return;
      }
      const T = h.columns.map((I) => ({
        name: I.name.trim(),
        type: I.type,
        primitiveKey: I.primitiveKey,
        defaultValue: I.defaultValue || void 0,
        comment: I.comment || void 0
      }));
      n("create", {
        tableName: h.tableName.trim(),
        columns: T,
        comment: h.comment.trim() || void 0
      }), a.value = !1;
    }, _ = () => {
      r(), n("cancel");
    };
    return h.columns.length === 0 && b(), (S, T) => (x(), L("div", {
      class: "form-wrapper",
      style: Ke(d.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: c.value,
        height: Zf,
        closable: !1,
        onClose: _
      }, {
        default: P(() => [
          f("div", Nf, [
            f("div", xf, [
              f("div", Sf, [
                T[3] || (T[3] = f("label", { class: "form-label" }, [
                  ne("  "),
                  f("span", { class: "required" }, "*")
                ], -1)),
                nt(f("input", {
                  "onUpdate:modelValue": T[0] || (T[0] = (I) => h.tableName = I),
                  class: Re(["form-input", { "has-error": Y(i)("tableName") }]),
                  type: "text",
                  placeholder: "user_info"
                }, null, 2), [
                  [bt, h.tableName]
                ]),
                Y(i)("tableName") ? (x(), L("div", Cf, [
                  T[2] || (T[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                  ne(" " + ue(Y(i)("tableName")), 1)
                ])) : te("", !0),
                T[4] || (T[4] = f("div", { class: "field-hint" }, "", -1))
              ]),
              f("div", wf, [
                T[5] || (T[5] = f("label", { class: "form-label" }, "", -1)),
                C(Is, {
                  modelValue: h.comment,
                  "onUpdate:modelValue": T[1] || (T[1] = (I) => h.comment = I),
                  placeholder: "",
                  "min-rows": 2,
                  "max-rows": 6
                }, null, 8, ["modelValue"]),
                T[6] || (T[6] = f("div", { class: "field-hint" }, "", -1))
              ])
            ]),
            f("div", Df, [
              f("div", Of, [
                T[7] || (T[7] = f("label", { class: "form-label" }, [
                  ne("  "),
                  f("span", { class: "required" }, "*")
                ], -1)),
                f("span", $f, ue(h.columns.length) + " ", 1)
              ]),
              Y(i)("columns") ? (x(), L("div", Af, [
                T[8] || (T[8] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                ne(" " + ue(Y(i)("columns")), 1)
              ])) : te("", !0),
              f("div", Vf, [
                (x(!0), L(Ae, null, Gt(h.columns, (I, B) => (x(), L("div", {
                  key: I.id,
                  class: Re(["column-card", { "has-error": Y(i)(`column_${B}`) }])
                }, [
                  f("div", Mf, [
                    f("span", If, "#" + ue(B + 1), 1),
                    f("button", {
                      class: "remove-btn",
                      onClick: (K) => E(B),
                      title: ""
                    }, [...T[9] || (T[9] = [
                      f("i", { class: "fa-solid fa-trash" }, null, -1)
                    ])], 8, Rf)
                  ]),
                  f("div", Lf, [
                    f("div", kf, [
                      f("div", Pf, [
                        T[10] || (T[10] = f("label", { class: "field-label" }, [
                          ne(" "),
                          f("span", { class: "required" }, "*")
                        ], -1)),
                        nt(f("input", {
                          "onUpdate:modelValue": (K) => I.name = K,
                          class: "form-input",
                          type: "text",
                          placeholder: ""
                        }, null, 8, Bf), [
                          [bt, I.name]
                        ])
                      ]),
                      f("div", Ff, [
                        T[11] || (T[11] = f("label", { class: "field-label" }, "", -1)),
                        nt(f("select", {
                          "onUpdate:modelValue": (K) => I.type = K,
                          class: "form-select"
                        }, [
                          f("option", {
                            value: Y(Pt).STRING
                          }, "STRING", 8, jf),
                          f("option", {
                            value: Y(Pt).NUMBER
                          }, "NUMBER", 8, qf)
                        ], 8, Uf), [
                          [fo, I.type]
                        ])
                      ])
                    ]),
                    Y(i)(`column_${B}`) ? (x(), L("div", Hf, [
                      T[12] || (T[12] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                      ne(" " + ue(Y(i)(`column_${B}`)), 1)
                    ])) : te("", !0),
                    f("div", Wf, [
                      f("div", Kf, [
                        T[13] || (T[13] = f("label", { class: "field-label" }, "", -1)),
                        nt(f("input", {
                          "onUpdate:modelValue": (K) => I.defaultValue = K,
                          class: "form-input",
                          type: "text",
                          placeholder: ""
                        }, null, 8, zf), [
                          [bt, I.defaultValue]
                        ])
                      ]),
                      f("div", Gf, [
                        T[14] || (T[14] = f("label", { class: "field-label" }, "", -1)),
                        C(Is, {
                          modelValue: I.comment,
                          "onUpdate:modelValue": (K) => I.comment = K,
                          placeholder: "",
                          "min-rows": 1,
                          "max-rows": 4
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ])
                    ]),
                    f("label", Yf, [
                      nt(f("input", {
                        "onUpdate:modelValue": (K) => I.primitiveKey = K,
                        type: "checkbox"
                      }, null, 8, Jf), [
                        [uo, I.primitiveKey]
                      ]),
                      T[15] || (T[15] = f("span", null, "", -1))
                    ])
                  ])
                ], 2))), 128)),
                f("button", {
                  class: "add-column-btn",
                  onClick: b
                }, [...T[16] || (T[16] = [
                  f("i", { class: "fa-solid fa-plus" }, null, -1),
                  f("span", null, "", -1)
                ])])
              ])
            ]),
            f("div", Qf, [
              C(ae, { onClick: _ }, {
                default: P(() => [...T[17] || (T[17] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: a.value,
                onClick: y
              }, {
                default: P(() => [
                  a.value ? (x(), L("i", Xf)) : te("", !0),
                  T[18] || (T[18] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), tp = /* @__PURE__ */ De(ep, [["__scopeId", "data-v-08eccbfb"]]), sp = { class: "form-container" }, np = { class: "form-item" }, ip = ["value"], op = { class: "form-item" }, rp = {
  key: 0,
  class: "field-error"
}, ap = { class: "form-actions" }, lp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, cp = "auto", up = /* @__PURE__ */ _e({
  __name: "EditTableNameForm",
  props: {
    tableName: {},
    existingTables: { default: () => [] }
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateEditTableNameForm: o, clearErrors: r } = li(), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q(s.tableName), u = /* @__PURE__ */ q(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    it(() => {
      c(), window.addEventListener("resize", c);
    }), Ft(() => {
      window.removeEventListener("resize", c);
    });
    const d = se(() => u.value ? "100%" : "50vw"), m = se(() => {
      const y = {};
      return y["--form-modal-width"] = u.value ? "100%" : "50vw", y;
    }), h = se(() => l.value.trim() !== s.tableName);
    lt(() => s.tableName, (y) => {
      l.value = y, r();
    });
    const b = () => {
      if (r(), a.value = !0, !o(
        l.value,
        s.tableName,
        s.existingTables
      ).valid) {
        a.value = !1;
        return;
      }
      n("save", l.value.trim()), a.value = !1;
    }, E = () => {
      l.value = s.tableName, r(), n("cancel");
    };
    return (y, _) => (x(), L("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: cp,
        closable: !1,
        onClose: E
      }, {
        default: P(() => [
          f("div", sp, [
            f("div", np, [
              _[1] || (_[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.tableName,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, ip)
            ]),
            f("div", op, [
              _[3] || (_[3] = f("label", { class: "form-label" }, [
                ne("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              nt(f("input", {
                "onUpdate:modelValue": _[0] || (_[0] = (S) => l.value = S),
                class: Re(["form-input", { "has-error": Y(i)("tableName") }]),
                type: "text",
                placeholder: ""
              }, null, 2), [
                [bt, l.value]
              ]),
              Y(i)("tableName") ? (x(), L("div", rp, [
                _[2] || (_[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                ne(" " + ue(Y(i)("tableName")), 1)
              ])) : te("", !0),
              _[4] || (_[4] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", ap, [
              C(ae, { onClick: E }, {
                default: P(() => [..._[5] || (_[5] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: a.value || !h.value,
                onClick: b
              }, {
                default: P(() => [
                  a.value ? (x(), L("i", lp)) : te("", !0),
                  _[6] || (_[6] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), dp = /* @__PURE__ */ De(up, [["__scopeId", "data-v-58e374f4"]]), fp = { class: "form-container" }, pp = { class: "form-item" }, hp = { class: "form-actions" }, mp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, vp = "auto", bp = /* @__PURE__ */ _e({
  __name: "EditTableCommentForm",
  props: {
    comment: {}
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(s.comment || ""), o = /* @__PURE__ */ q(!1), r = /* @__PURE__ */ q(!1), a = () => {
      r.value = window.innerWidth <= 768;
    };
    it(() => {
      a(), window.addEventListener("resize", a);
    }), Ft(() => {
      window.removeEventListener("resize", a);
    });
    const l = se(() => r.value ? "100%" : "50vw"), u = se(() => {
      const m = {};
      return m["--form-modal-width"] = r.value ? "100%" : "50vw", m;
    }), c = () => {
      o.value = !0, n("save", i.value), o.value = !1;
    }, d = () => {
      i.value = s.comment || "", n("cancel");
    };
    return (m, h) => (x(), L("div", {
      class: "form-wrapper",
      style: Ke(u.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: l.value,
        height: vp,
        closable: !1,
        onClose: d
      }, {
        default: P(() => [
          f("div", fp, [
            f("div", pp, [
              h[1] || (h[1] = f("label", { class: "form-label" }, "", -1)),
              C(Is, {
                modelValue: i.value,
                "onUpdate:modelValue": h[0] || (h[0] = (b) => i.value = b),
                placeholder: "",
                maxlength: 500,
                "show-count": !0,
                "min-rows": 3,
                "max-rows": 10
              }, null, 8, ["modelValue"])
            ]),
            f("div", hp, [
              C(ae, { onClick: d }, {
                default: P(() => [...h[2] || (h[2] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: o.value,
                onClick: c
              }, {
                default: P(() => [
                  o.value ? (x(), L("i", mp)) : te("", !0),
                  h[3] || (h[3] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), gp = /* @__PURE__ */ De(bp, [["__scopeId", "data-v-03532044"]]), Ep = { class: "confirm-container" }, yp = { class: "confirm-content" }, _p = { class: "confirm-message" }, Tp = { class: "form-actions" }, Np = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, xp = /* @__PURE__ */ _e({
  __name: "DropTableConfirm",
  props: {
    tableName: {},
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1), o = se(() => {
      const l = {};
      return s.modalWidth && (l["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (l["--confirm-modal-height"] = s.modalHeight), l;
    }), r = () => {
      i.value = !0, n("confirm");
    }, a = () => {
      n("cancel");
    };
    return (l, u) => (x(), L("div", {
      class: "drop-table-confirm-wrapper",
      style: Ke(o.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: a
      }, {
        default: P(() => [
          f("div", Ep, [
            u[5] || (u[5] = f("div", { class: "confirm-icon-wrapper" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" })
            ], -1)),
            f("div", yp, [
              f("div", _p, [
                u[0] || (u[0] = ne("  ", -1)),
                f("strong", null, ue(t.tableName), 1),
                u[1] || (u[1] = ne("  ", -1))
              ]),
              u[2] || (u[2] = f("div", { class: "confirm-warning" }, [
                f("i", { class: "fa-solid fa-circle-info" }),
                f("span", null, "")
              ], -1))
            ]),
            f("div", Tp, [
              C(ae, { onClick: a }, {
                default: P(() => [...u[3] || (u[3] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "danger",
                disabled: i.value,
                onClick: r
              }, {
                default: P(() => [
                  i.value ? (x(), L("i", Np)) : te("", !0),
                  u[4] || (u[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), Sp = /* @__PURE__ */ De(xp, [["__scopeId", "data-v-4629727b"]]), Cp = { class: "form-container" }, wp = { class: "form-item" }, Dp = {
  key: 0,
  class: "field-error"
}, Op = { class: "form-item" }, $p = ["value"], Ap = ["value"], Vp = { class: "form-item" }, Mp = { class: "checkbox-label" }, Ip = { class: "form-item" }, Rp = { class: "form-item" }, Lp = { class: "form-actions" }, kp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Pp = "auto", Bp = /* @__PURE__ */ _e({
  __name: "AddColumnForm",
  props: {
    existingColumns: { default: () => [] }
  },
  emits: ["create", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateAddColumnForm: o, clearErrors: r } = li(), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ _s({
      name: "",
      type: Pt.STRING,
      primitiveKey: !1
    }), u = /* @__PURE__ */ q(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    it(() => {
      c(), window.addEventListener("resize", c);
    }), Ft(() => {
      window.removeEventListener("resize", c);
    });
    const d = se(() => u.value ? "100%" : "50vw"), m = se(() => {
      const E = {};
      return E["--form-modal-width"] = u.value ? "100%" : "50vw", E;
    }), h = () => {
      if (r(), a.value = !0, !o(l.name, s.existingColumns).valid) {
        a.value = !1;
        return;
      }
      const y = {
        name: l.name.trim(),
        type: l.type,
        primitiveKey: l.primitiveKey,
        defaultValue: l.defaultValue || void 0,
        comment: l.comment || void 0
      };
      n("create", y), a.value = !1;
    }, b = () => {
      r(), n("cancel");
    };
    return (E, y) => (x(), L("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: Pp,
        closable: !1,
        onClose: b
      }, {
        default: P(() => [
          f("div", Cp, [
            f("div", wp, [
              y[6] || (y[6] = f("label", { class: "form-label" }, [
                ne("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              nt(f("input", {
                "onUpdate:modelValue": y[0] || (y[0] = (_) => l.name = _),
                class: Re(["form-input", { "has-error": Y(i)("columnName") }]),
                type: "text",
                placeholder: "username"
              }, null, 2), [
                [bt, l.name]
              ]),
              Y(i)("columnName") ? (x(), L("div", Dp, [
                y[5] || (y[5] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                ne(" " + ue(Y(i)("columnName")), 1)
              ])) : te("", !0),
              y[7] || (y[7] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Op, [
              y[8] || (y[8] = f("label", { class: "form-label" }, "", -1)),
              nt(f("select", {
                "onUpdate:modelValue": y[1] || (y[1] = (_) => l.type = _),
                class: "form-select"
              }, [
                f("option", {
                  value: Y(Pt).STRING
                }, "STRING", 8, $p),
                f("option", {
                  value: Y(Pt).NUMBER
                }, "NUMBER", 8, Ap)
              ], 512), [
                [fo, l.type]
              ])
            ]),
            f("div", Vp, [
              f("label", Mp, [
                nt(f("input", {
                  "onUpdate:modelValue": y[2] || (y[2] = (_) => l.primitiveKey = _),
                  type: "checkbox"
                }, null, 512), [
                  [uo, l.primitiveKey]
                ]),
                y[9] || (y[9] = f("span", null, "", -1))
              ])
            ]),
            f("div", Ip, [
              y[10] || (y[10] = f("label", { class: "form-label" }, "", -1)),
              nt(f("input", {
                "onUpdate:modelValue": y[3] || (y[3] = (_) => l.defaultValue = _),
                class: "form-input",
                type: "text",
                placeholder: ""
              }, null, 512), [
                [bt, l.defaultValue]
              ]),
              y[11] || (y[11] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Rp, [
              y[12] || (y[12] = f("label", { class: "form-label" }, "", -1)),
              C(Is, {
                modelValue: l.comment,
                "onUpdate:modelValue": y[4] || (y[4] = (_) => l.comment = _),
                placeholder: "",
                "min-rows": 1,
                "max-rows": 4
              }, null, 8, ["modelValue"])
            ]),
            f("div", Lp, [
              C(ae, { onClick: b }, {
                default: P(() => [...y[13] || (y[13] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: a.value,
                onClick: h
              }, {
                default: P(() => [
                  a.value ? (x(), L("i", kp)) : te("", !0),
                  y[14] || (y[14] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Fp = /* @__PURE__ */ De(Bp, [["__scopeId", "data-v-019138f2"]]), Up = { class: "form-container" }, jp = { class: "form-item" }, qp = ["value"], Hp = { class: "form-item" }, Wp = {
  key: 0,
  class: "field-error"
}, Kp = { class: "form-actions" }, zp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Gp = "auto", Yp = /* @__PURE__ */ _e({
  __name: "EditColumnNameForm",
  props: {
    column: {},
    existingColumns: { default: () => [] }
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateEditColumnNameForm: o, clearErrors: r } = li(), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q(s.column.name), u = /* @__PURE__ */ q(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    it(() => {
      c(), window.addEventListener("resize", c);
    }), Ft(() => {
      window.removeEventListener("resize", c);
    });
    const d = se(() => u.value ? "100%" : "50vw"), m = se(() => {
      const y = {};
      return y["--form-modal-width"] = u.value ? "100%" : "50vw", y;
    }), h = se(() => l.value.trim() !== s.column.name);
    lt(() => s.column, (y) => {
      l.value = y.name, r();
    }, { deep: !0 });
    const b = () => {
      if (r(), a.value = !0, !o(
        l.value,
        s.column.name,
        s.existingColumns
      ).valid) {
        a.value = !1;
        return;
      }
      n("save", l.value.trim()), a.value = !1;
    }, E = () => {
      l.value = s.column.name, r(), n("cancel");
    };
    return (y, _) => (x(), L("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: Gp,
        closable: !1,
        onClose: E
      }, {
        default: P(() => [
          f("div", Up, [
            f("div", jp, [
              _[1] || (_[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.column.name,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, qp)
            ]),
            f("div", Hp, [
              _[3] || (_[3] = f("label", { class: "form-label" }, [
                ne("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              nt(f("input", {
                "onUpdate:modelValue": _[0] || (_[0] = (S) => l.value = S),
                class: Re(["form-input", { "has-error": Y(i)("columnName") }]),
                type: "text",
                placeholder: ""
              }, null, 2), [
                [bt, l.value]
              ]),
              Y(i)("columnName") ? (x(), L("div", Wp, [
                _[2] || (_[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                ne(" " + ue(Y(i)("columnName")), 1)
              ])) : te("", !0),
              _[4] || (_[4] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Kp, [
              C(ae, { onClick: E }, {
                default: P(() => [..._[5] || (_[5] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: a.value || !h.value,
                onClick: b
              }, {
                default: P(() => [
                  a.value ? (x(), L("i", zp)) : te("", !0),
                  _[6] || (_[6] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Jp = /* @__PURE__ */ De(Yp, [["__scopeId", "data-v-36708f97"]]), Qp = { class: "form-container" }, Xp = { class: "form-item" }, Zp = ["value"], eh = { class: "form-item" }, th = { class: "form-actions" }, sh = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, nh = "auto", ih = /* @__PURE__ */ _e({
  __name: "EditColumnCommentForm",
  props: {
    column: {}
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(s.column.comment || ""), o = /* @__PURE__ */ q(!1), r = /* @__PURE__ */ q(!1), a = () => {
      r.value = window.innerWidth <= 768;
    };
    it(() => {
      a(), window.addEventListener("resize", a);
    }), Ft(() => {
      window.removeEventListener("resize", a);
    });
    const l = se(() => r.value ? "100%" : "50vw"), u = se(() => {
      const m = {};
      return m["--form-modal-width"] = r.value ? "100%" : "50vw", m;
    }), c = () => {
      o.value = !0, n("save", i.value), o.value = !1;
    }, d = () => {
      i.value = s.column.comment || "", n("cancel");
    };
    return (m, h) => (x(), L("div", {
      class: "form-wrapper",
      style: Ke(u.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: l.value,
        height: nh,
        closable: !1,
        onClose: d
      }, {
        default: P(() => [
          f("div", Qp, [
            f("div", Xp, [
              h[1] || (h[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.column.name,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, Zp)
            ]),
            f("div", eh, [
              h[2] || (h[2] = f("label", { class: "form-label" }, "", -1)),
              C(Is, {
                modelValue: i.value,
                "onUpdate:modelValue": h[0] || (h[0] = (b) => i.value = b),
                placeholder: "",
                maxlength: 500,
                "show-count": !0,
                "min-rows": 3,
                "max-rows": 10
              }, null, 8, ["modelValue"])
            ]),
            f("div", th, [
              C(ae, { onClick: d }, {
                default: P(() => [...h[3] || (h[3] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: o.value,
                onClick: c
              }, {
                default: P(() => [
                  o.value ? (x(), L("i", sh)) : te("", !0),
                  h[4] || (h[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), oh = /* @__PURE__ */ De(ih, [["__scopeId", "data-v-1f79f493"]]), rh = { class: "confirm-container" }, ah = { class: "confirm-content" }, lh = { class: "confirm-message" }, ch = { class: "form-actions" }, uh = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, dh = /* @__PURE__ */ _e({
  __name: "DropColumnConfirm",
  props: {
    column: {},
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1), o = se(() => {
      const l = {};
      return s.modalWidth && (l["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (l["--confirm-modal-height"] = s.modalHeight), l;
    }), r = () => {
      i.value = !0, n("confirm");
    }, a = () => {
      n("cancel");
    };
    return (l, u) => (x(), L("div", {
      class: "drop-column-confirm-wrapper",
      style: Ke(o.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: a
      }, {
        default: P(() => [
          f("div", rh, [
            u[5] || (u[5] = f("div", { class: "confirm-icon-wrapper" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" })
            ], -1)),
            f("div", ah, [
              f("div", lh, [
                u[0] || (u[0] = ne("  ", -1)),
                f("strong", null, ue(t.column.name), 1),
                u[1] || (u[1] = ne("  ", -1))
              ]),
              u[2] || (u[2] = f("div", { class: "confirm-warning" }, [
                f("i", { class: "fa-solid fa-circle-info" }),
                f("span", null, "")
              ], -1))
            ]),
            f("div", ch, [
              C(ae, { onClick: a }, {
                default: P(() => [...u[3] || (u[3] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "danger",
                disabled: i.value,
                onClick: r
              }, {
                default: P(() => [
                  i.value ? (x(), L("i", uh)) : te("", !0),
                  u[4] || (u[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), fh = /* @__PURE__ */ De(dh, [["__scopeId", "data-v-7565defa"]]), ph = { class: "ddl-container" }, hh = { class: "ddl-header" }, mh = { class: "ddl-content" }, vh = { class: "ddl-code" }, bh = { class: "form-actions" }, gh = /* @__PURE__ */ _e({
  __name: "DDLDisplay",
  props: {
    ddl: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1);
    let o = null;
    const r = async () => {
      try {
        await navigator.clipboard.writeText(s.ddl), i.value = !0, o && clearTimeout(o), o = setTimeout(() => {
          i.value = !1;
        }, 2e3);
      } catch (l) {
        console.error(":", l);
      }
    }, a = () => {
      n("close");
    };
    return (l, u) => (x(), L("div", ph, [
      f("div", hh, [
        u[0] || (u[0] = f("span", { class: "ddl-title" }, "DDL ", -1)),
        f("button", {
          class: "copy-btn",
          onClick: r
        }, [
          f("i", {
            class: Re(i.value ? "fa-solid fa-check" : "fa-solid fa-copy")
          }, null, 2),
          ne(" " + ue(i.value ? "" : ""), 1)
        ])
      ]),
      f("div", mh, [
        f("pre", vh, ue(t.ddl), 1)
      ]),
      f("div", bh, [
        C(ae, { onClick: a }, {
          default: P(() => [...u[1] || (u[1] = [
            ne("", -1)
          ])]),
          _: 1
        })
      ])
    ]));
  }
}), Eh = /* @__PURE__ */ De(gh, [["__scopeId", "data-v-da039aee"]]), yh = { class: "table-management-tab" }, _h = {
  key: 1,
  class: "table-detail"
}, Th = { class: "table-header" }, Nh = { class: "table-title-section" }, xh = { class: "table-name-row" }, Sh = { class: "table-name" }, Ch = {
  key: 0,
  class: "table-comment-row"
}, wh = { class: "table-comment" }, Dh = {
  key: 1,
  class: "table-comment-row"
}, Oh = { class: "table-actions" }, $h = { class: "columns-section" }, Ah = { class: "section-header" }, Vh = { class: "columns-list" }, Mh = { key: 1 }, Ih = { class: "column-main" }, Rh = { class: "column-first-row" }, Lh = { class: "column-name-wrapper" }, kh = { class: "column-name" }, Ph = { class: "type-badge" }, Bh = {
  key: 0,
  class: "primary-key-badge",
  title: ""
}, Fh = {
  key: 0,
  class: "column-comment"
}, Uh = {
  key: 1,
  class: "default-value"
}, jh = { class: "column-actions" }, qh = /* @__PURE__ */ _e({
  __name: "TableManagementTab",
  props: {
    tableService: {},
    tables: {},
    selectedTable: {}
  },
  emits: ["refresh", "update:selectedTable"],
  setup(t, { expose: e, emit: s }) {
    const n = t, i = s, o = se(() => n.tables.find((Q) => Q.tableName === n.selectedTable) || {}), r = se(() => o.value.columnSchemas ? Object.entries(o.value.columnSchemas).map(([Q, R]) => [parseInt(Q), R]) : []), a = se(() => o.value.columnSchemas ? Object.values(o.value.columnSchemas) : []), l = se(() => !o.value.columnSchemas || !I.value ? [] : Object.values(o.value.columnSchemas).filter((Q) => Q.name !== I.value?.column.name)), { toast: u, showToast: c } = al(), {
      showCreateTableModal: d,
      showEditTableNameModal: m,
      showEditTableCommentModal: h,
      showDropTableModal: b,
      showAddColumnModal: E,
      showEditColumnNameModal: y,
      showEditColumnCommentModal: _,
      showDropColumnModal: S,
      showDDLModal: T,
      editingColumn: I,
      exportedDDL: B
    } = Ef(), K = (Q) => Q === null ? "NULL" : Q === void 0 ? "" : String(Q), pe = (Q) => {
      const R = n.tableService.createTable(Q.tableName, Q.columns, Q.comment);
      R.success ? (d.value = !1, i("refresh"), c(` "${Q.tableName}" `)) : c(R.message || "", "error");
    }, he = (Q) => {
      if (o.value.tableName) {
        const R = n.tableService.alterTableName(o.value.tableName, Q);
        R.success ? (m.value = !1, i("update:selectedTable", Q), i("refresh"), c("")) : c(R.message || "", "error");
      }
    }, H = (Q) => {
      if (o.value.tableName) {
        const R = n.tableService.alterTableComment(o.value.tableName, Q);
        R.success ? (h.value = !1, i("refresh"), c("")) : c(R.message || "", "error");
      }
    }, re = () => {
      if (o.value.tableName) {
        const Q = n.tableService.dropTable(o.value.tableName);
        Q.success ? (b.value = !1, i("update:selectedTable", ""), i("refresh"), c("")) : c(Q.message || "", "error");
      }
    }, me = (Q) => {
      if (o.value.tableName) {
        const R = n.tableService.addColumn(o.value.tableName, Q.name, Q);
        R.success ? (E.value = !1, i("refresh"), c(` "${Q.name}" `)) : c(R.message || "", "error");
      }
    }, w = (Q, R) => {
      I.value = { fieldId: Q, column: R }, y.value = !0;
    }, W = (Q) => {
      if (o.value.tableName && I.value) {
        const R = n.tableService.alterColumnName(
          o.value.tableName,
          I.value.column.name,
          Q
        );
        R.success ? (y.value = !1, I.value = null, i("refresh"), c("")) : c(R.message || "", "error");
      }
    }, oe = (Q, R) => {
      I.value = { fieldId: Q, column: R }, _.value = !0;
    }, be = (Q) => {
      if (o.value.tableName && I.value) {
        const R = n.tableService.alterColumnComment(
          o.value.tableName,
          I.value.column.name,
          Q
        );
        R.success ? (_.value = !1, I.value = null, i("refresh"), c("")) : c(R.message || "", "error");
      }
    }, fe = (Q, R) => {
      I.value = { fieldId: Q, column: R }, S.value = !0;
    }, le = () => {
      if (o.value.tableName && I.value) {
        const Q = n.tableService.dropColumn(
          o.value.tableName,
          I.value.column.name
        );
        Q.success ? (S.value = !1, I.value = null, i("refresh"), c("")) : c(Q.message || "", "error");
      }
    }, de = () => {
      o.value.tableName && (B.value = n.tableService.exportDDL(o.value.tableName), T.value = !0);
    };
    return e({
      openCreateTableModal: () => {
        d.value = !0;
      }
    }), (Q, R) => (x(), L("div", yh, [
      t.selectedTable ? (x(), L("div", _h, [
        f("div", Th, [
          f("div", Nh, [
            f("div", xh, [
              R[16] || (R[16] = f("span", { class: "table-label" }, "", -1)),
              f("span", Sh, ue(o.value.tableName), 1),
              C(ae, {
                size: "small",
                onClick: R[0] || (R[0] = (Oe) => m.value = !0)
              }, {
                default: P(() => [...R[15] || (R[15] = [
                  f("i", { class: "fa-solid fa-pen" }, null, -1)
                ])]),
                _: 1
              })
            ]),
            o.value.comment ? (x(), L("div", Ch, [
              R[18] || (R[18] = f("span", { class: "table-label" }, "", -1)),
              f("span", wh, ue(o.value.comment), 1),
              C(ae, {
                size: "small",
                onClick: R[1] || (R[1] = (Oe) => h.value = !0)
              }, {
                default: P(() => [...R[17] || (R[17] = [
                  f("i", { class: "fa-solid fa-pen" }, null, -1)
                ])]),
                _: 1
              })
            ])) : (x(), L("div", Dh, [
              R[20] || (R[20] = f("span", { class: "table-label" }, "", -1)),
              R[21] || (R[21] = f("span", { class: "table-comment placeholder" }, "", -1)),
              C(ae, {
                size: "small",
                onClick: R[2] || (R[2] = (Oe) => h.value = !0)
              }, {
                default: P(() => [...R[19] || (R[19] = [
                  f("i", { class: "fa-solid fa-plus" }, null, -1)
                ])]),
                _: 1
              })
            ]))
          ]),
          f("div", Oh, [
            C(ae, { onClick: de }, {
              default: P(() => [...R[22] || (R[22] = [
                f("i", {
                  class: "fa-solid fa-download",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne(" DDL ", -1)
              ])]),
              _: 1
            }),
            C(ae, {
              type: "danger",
              onClick: R[3] || (R[3] = (Oe) => b.value = !0)
            }, {
              default: P(() => [...R[23] || (R[23] = [
                f("i", {
                  class: "fa-solid fa-trash",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            })
          ])
        ]),
        f("div", $h, [
          f("div", Ah, [
            R[25] || (R[25] = f("span", { class: "section-title" }, "", -1)),
            C(ae, {
              size: "small",
              onClick: R[4] || (R[4] = (Oe) => E.value = !0)
            }, {
              default: P(() => [...R[24] || (R[24] = [
                f("i", {
                  class: "fa-solid fa-plus",
                  style: { "margin-right": "4px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            })
          ]),
          f("div", Vh, [
            r.value.length === 0 ? (x(), Ie(Yn, {
              key: 0,
              icon: "fa-solid fa-columns",
              text: "",
              variant: "compact"
            })) : (x(), L("div", Mh, [
              (x(!0), L(Ae, null, Gt(r.value, ([Oe, We]) => (x(), L("div", {
                key: Oe,
                class: "column-item"
              }, [
                f("div", Ih, [
                  f("div", Rh, [
                    f("div", Lh, [
                      R[26] || (R[26] = f("i", { class: "fa-solid fa-hashtag column-icon" }, null, -1)),
                      f("span", kh, ue(We.name), 1)
                    ]),
                    f("span", Ph, ue(We.type), 1),
                    We.primitiveKey ? (x(), L("span", Bh, [...R[27] || (R[27] = [
                      f("i", { class: "fa-solid fa-key" }, null, -1)
                    ])])) : te("", !0)
                  ]),
                  We.comment ? (x(), L("div", Fh, ue(We.comment), 1)) : te("", !0),
                  We.defaultValue !== void 0 ? (x(), L("div", Uh, " : " + ue(K(We.defaultValue)), 1)) : te("", !0)
                ]),
                f("div", jh, [
                  C(ae, {
                    size: "small",
                    title: "",
                    onClick: (ft) => w(Oe, We)
                  }, {
                    default: P(() => [...R[28] || (R[28] = [
                      f("i", { class: "fa-solid fa-pen" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"]),
                  C(ae, {
                    size: "small",
                    title: "",
                    onClick: (ft) => oe(Oe, We)
                  }, {
                    default: P(() => [...R[29] || (R[29] = [
                      f("i", { class: "fa-solid fa-comment" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"]),
                  C(ae, {
                    type: "danger",
                    size: "small",
                    title: "",
                    onClick: (ft) => fe(Oe, We)
                  }, {
                    default: P(() => [...R[30] || (R[30] = [
                      f("i", { class: "fa-solid fa-trash" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"])
                ])
              ]))), 128))
            ]))
          ])
        ])
      ])) : (x(), Ie(Yn, {
        key: 0,
        icon: "fa-solid fa-table",
        text: ""
      })),
      C(rl, {
        visible: Y(u).visible,
        message: Y(u).message,
        type: Y(u).type,
        icon: Y(u).icon
      }, null, 8, ["visible", "message", "type", "icon"]),
      Y(d) ? (x(), Ie(tp, {
        key: 2,
        "existing-tables": t.tables,
        onCreate: pe,
        onCancel: R[5] || (R[5] = (Oe) => d.value = !1)
      }, null, 8, ["existing-tables"])) : te("", !0),
      Y(m) ? (x(), Ie(dp, {
        key: 3,
        "table-name": o.value.tableName,
        "existing-tables": t.tables,
        onSave: he,
        onCancel: R[6] || (R[6] = (Oe) => m.value = !1)
      }, null, 8, ["table-name", "existing-tables"])) : te("", !0),
      Y(h) ? (x(), Ie(gp, {
        key: 4,
        comment: o.value.comment,
        onSave: H,
        onCancel: R[7] || (R[7] = (Oe) => h.value = !1)
      }, null, 8, ["comment"])) : te("", !0),
      Y(b) ? (x(), Ie(Sp, {
        key: 5,
        "table-name": o.value.tableName,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: re,
        onCancel: R[8] || (R[8] = (Oe) => b.value = !1)
      }, null, 8, ["table-name"])) : te("", !0),
      Y(E) ? (x(), Ie(Fp, {
        key: 6,
        "existing-columns": a.value,
        onCreate: me,
        onCancel: R[9] || (R[9] = (Oe) => E.value = !1)
      }, null, 8, ["existing-columns"])) : te("", !0),
      Y(y) && Y(I) ? (x(), Ie(Jp, {
        key: 7,
        column: Y(I).column,
        "existing-columns": l.value,
        onSave: W,
        onCancel: R[10] || (R[10] = (Oe) => y.value = !1)
      }, null, 8, ["column", "existing-columns"])) : te("", !0),
      Y(_) && Y(I) ? (x(), Ie(oh, {
        key: 8,
        column: Y(I).column,
        onSave: be,
        onCancel: R[11] || (R[11] = (Oe) => _.value = !1)
      }, null, 8, ["column"])) : te("", !0),
      Y(S) && Y(I) ? (x(), Ie(fh, {
        key: 9,
        column: Y(I).column,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: le,
        onCancel: R[12] || (R[12] = (Oe) => S.value = !1)
      }, null, 8, ["column"])) : te("", !0),
      Y(T) ? (x(), Ie(Ge, {
        key: 10,
        visible: "",
        title: "DDL",
        onClose: R[14] || (R[14] = (Oe) => T.value = !1)
      }, {
        default: P(() => [
          C(Eh, {
            ddl: Y(B),
            onClose: R[13] || (R[13] = (Oe) => T.value = !1)
          }, null, 8, ["ddl"])
        ]),
        _: 1
      })) : te("", !0)
    ]));
  }
}), vo = /* @__PURE__ */ De(qh, [["__scopeId", "data-v-f00e195b"]]), Hh = { class: "sql-panel-tab" }, Wh = { class: "sql-editor-container" }, Kh = { class: "sql-toolbar" }, zh = { class: "sql-footer" }, Gh = { class: "editor-stats" }, Yh = { class: "stat-item" }, Jh = { class: "stat-item" }, Qh = {
  key: 0,
  class: "result-status"
}, Xh = { key: 0 }, Zh = { key: 1 }, em = /* @__PURE__ */ _e({
  __name: "SqlPanelTab",
  props: {
    sqlExecutorService: {}
  },
  emits: ["refresh"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(""), o = /* @__PURE__ */ q({ success: !1, message: "", data: 0, type: "DQL" }), r = se(() => i.value.split(`
`).length), a = se(() => i.value.length), l = se(() => u.value && Array.isArray(o.value.data) ? o.value.data : []), u = se(() => Array.isArray(o.value.data)), c = se(() => o.value.success || o.value.message !== ""), d = () => {
      if (!i.value.trim()) {
        o.value = { success: !1, message: "SQL", data: 0, type: "DQL" };
        return;
      }
      try {
        o.value = s.sqlExecutorService.execute(i.value), o.value.success && n("refresh");
      } catch (m) {
        o.value = {
          success: !1,
          message: m instanceof Error ? m.message : "",
          data: 0,
          type: "DQL"
        };
      }
    };
    return (m, h) => (x(), L("div", Hh, [
      f("div", Wh, [
        f("div", Kh, [
          h[2] || (h[2] = f("span", { class: "toolbar-title" }, "SQL", -1)),
          C(ae, { onClick: d }, {
            default: P(() => [...h[1] || (h[1] = [
              f("i", {
                class: "fa-solid fa-play",
                style: { "margin-right": "6px" }
              }, null, -1),
              ne("  ", -1)
            ])]),
            _: 1
          })
        ]),
        nt(f("textarea", {
          "onUpdate:modelValue": h[0] || (h[0] = (b) => i.value = b),
          class: "sql-editor",
          placeholder: "SQL...",
          spellcheck: "false"
        }, null, 512), [
          [bt, i.value]
        ]),
        f("div", zh, [
          f("div", Gh, [
            f("span", Yh, ": " + ue(r.value), 1),
            f("span", Jh, ": " + ue(a.value), 1)
          ]),
          c.value ? (x(), L("div", Qh, [
            u.value ? (x(), L("span", Xh, ": " + ue(l.value.length) + " ", 1)) : (x(), L("span", Zh, ": " + ue(o.value.data) + " ", 1))
          ])) : te("", !0)
        ]),
        o.value.message ? (x(), L("div", {
          key: 0,
          class: Re(["result-message", { error: !o.value.success }])
        }, ue(o.value.message), 3)) : te("", !0)
      ])
    ]));
  }
}), bo = /* @__PURE__ */ De(em, [["__scopeId", "data-v-34ac73ac"]]);
var ee = /* @__PURE__ */ ((t) => (t.DDL = "DDL", t.DML = "DML", t.DQL = "DQL", t.ROW = "ROW", t))(ee || {}), rt = /* @__PURE__ */ ((t) => (t.INSERT_SQL = "INSERT_SQL", t.TABLE_SCHEMA = "TABLE_SCHEMA", t.DDL = "DDL", t.MARKDOWN = "MARKDOWN", t.STANDARD_DATA = "STANDARD_DATA", t))(rt || {}), ji = /* @__PURE__ */ ((t) => (t.INNER = "INNER", t.LEFT = "LEFT", t))(ji || {}), ci = /* @__PURE__ */ ((t) => (t.SYNTAX_ERROR = "SYNTAX_ERROR", t.VALIDATION_ERROR = "VALIDATION_ERROR", t.EXECUTION_ERROR = "EXECUTION_ERROR", t.TABLE_NOT_FOUND = "TABLE_NOT_FOUND", t.COLUMN_NOT_FOUND = "COLUMN_NOT_FOUND", t.TYPE_MISMATCH = "TYPE_MISMATCH", t))(ci || {});
class go extends Error {
  /**  */
  code;
  /** SQL */
  position;
  /** SQL */
  sql;
  constructor(e, s, n, i) {
    super(s), this.name = "SqlError", this.code = e, this.position = n, this.sql = i;
  }
}
class Sn extends go {
  constructor(e, s, n) {
    super(ci.SYNTAX_ERROR, e, s, n), this.name = "SqlSyntaxError";
  }
}
class Le extends go {
  constructor(e, s) {
    super(ci.VALIDATION_ERROR, e, void 0, s), this.name = "SqlValidationError";
  }
}
class ss extends go {
  constructor(e, s) {
    super(ci.EXECUTION_ERROR, e, void 0, s), this.name = "SqlExecutionError";
  }
}
var J = /* @__PURE__ */ ((t) => (t.KEYWORD = "KEYWORD", t.IDENTIFIER = "IDENTIFIER", t.STRING = "STRING", t.NUMBER = "NUMBER", t.OPERATOR = "OPERATOR", t.COMMA = "COMMA", t.SEMICOLON = "SEMICOLON", t.LPAREN = "LPAREN", t.RPAREN = "RPAREN", t.DOT = "DOT", t.EOF = "EOF", t))(J || {}), $e = /* @__PURE__ */ ((t) => (t.CREATE_TABLE = "CREATE_TABLE", t.ALTER_TABLE = "ALTER_TABLE", t.DROP_TABLE = "DROP_TABLE", t.INSERT = "INSERT", t.UPDATE = "UPDATE", t.DELETE = "DELETE", t.APPEND = "APPEND", t.SELECT = "SELECT", t.ROW = "ROW", t))($e || {}), Zt = /* @__PURE__ */ ((t) => (t.ADD_COLUMN = "ADD_COLUMN", t.DROP_COLUMN = "DROP_COLUMN", t.RENAME = "RENAME", t.RENAME_COLUMN = "RENAME_COLUMN", t.MODIFY_COLUMN_COMMENT = "MODIFY_COLUMN_COMMENT", t.MODIFY_COLUMN_PRIMITIVE_KEY = "MODIFY_COLUMN_PRIMITIVE_KEY", t.ALTER_TABLE_COMMENT = "ALTER_TABLE_COMMENT", t))(Zt || {});
const tm = /* @__PURE__ */ new Set([
  "SELECT",
  "FROM",
  "WHERE",
  "INSERT",
  "INTO",
  "VALUES",
  "UPDATE",
  "SET",
  "DELETE",
  "CREATE",
  "TABLE",
  "ALTER",
  "DROP",
  "ADD",
  "COLUMN",
  "RENAME",
  "TO",
  "APPEND",
  "AND",
  "OR",
  "NOT",
  "NULL",
  "IS",
  "BETWEEN",
  "IN",
  "ORDER",
  "BY",
  "ASC",
  "DESC",
  "INNER",
  "LEFT",
  "JOIN",
  "ON",
  "DISTINCT",
  "STRING",
  "NUMBER",
  "PRIMARY",
  "KEY",
  "DEFAULT",
  "COMMENT",
  "MODIFY"
]), Cr = ["=", "!=", "<>", ">", "<", ">=", "<="];
class sm {
  input;
  pos = 0;
  length;
  constructor(e) {
    this.input = e, this.length = e.length;
  }
  /**
   * 
   */
  peek(e = 0) {
    const s = this.pos + e;
    return this.input[s] ?? "";
  }
  /**
   * 
   */
  advance() {
    return this.pos >= this.length ? "" : this.input[this.pos++] ?? "";
  }
  /**
   * 
   */
  skipWhitespace() {
    for (; this.pos < this.length && /\s/.test(this.peek()); )
      this.pos++;
  }
  /**
   * 
   */
  skipComment() {
    if (this.peek() === "-" && this.peek(1) === "-")
      for (; this.pos < this.length && this.peek() !== `
`; )
        this.pos++;
  }
  /**
   * 
   */
  readIdentifier() {
    let e = "";
    for (; this.pos < this.length && /[\w]/.test(this.peek()); )
      e += this.advance();
    return e;
  }
  /**
   * 
   */
  readString(e) {
    let s = "";
    for (this.advance(); this.pos < this.length; ) {
      const n = this.peek();
      if (n === e)
        if (this.advance(), this.peek() === e)
          s += e, this.advance();
        else
          break;
      else n === "\\" ? (this.advance(), s += this.advance()) : s += this.advance();
    }
    return s;
  }
  /**
   * 
   */
  readNumber() {
    let e = "";
    for (; this.pos < this.length && /[\d.]/.test(this.peek()); )
      e += this.advance();
    return e;
  }
  /**
   * 
   */
  readOperator() {
    const e = this.peek() + this.peek(1);
    return Cr.includes(e) ? (this.advance(), this.advance(), e) : this.advance();
  }
  /**
   * Token
   */
  nextToken() {
    if (this.skipWhitespace(), this.skipComment(), this.pos >= this.length)
      return { type: J.EOF, value: "", position: this.pos };
    const e = this.pos, s = this.peek();
    if (s === "(")
      return this.advance(), { type: J.LPAREN, value: "(", position: e };
    if (s === ")")
      return this.advance(), { type: J.RPAREN, value: ")", position: e };
    if (s === ",")
      return this.advance(), { type: J.COMMA, value: ",", position: e };
    if (s === ";")
      return this.advance(), { type: J.SEMICOLON, value: ";", position: e };
    if (s === ".")
      return this.advance(), { type: J.DOT, value: ".", position: e };
    if (s === "'") {
      const n = this.readString(s);
      return { type: J.STRING, value: n, position: e };
    }
    if (s === '"') {
      const n = this.readString(s);
      return { type: J.STRING, value: n, position: e };
    }
    if (s === "*")
      return this.advance(), { type: J.KEYWORD, value: "*", position: e };
    if (/[\d]/.test(s)) {
      const n = this.readNumber();
      return { type: J.NUMBER, value: n, position: e };
    }
    if (/[a-zA-Z_]/.test(s)) {
      const n = this.readIdentifier(), i = n.toUpperCase();
      return tm.has(i) ? { type: J.KEYWORD, value: i, position: e } : { type: J.IDENTIFIER, value: n, position: e };
    }
    if (Cr.some((n) => n.startsWith(s))) {
      const n = this.readOperator();
      return { type: J.OPERATOR, value: n, position: e };
    }
    throw new Error(`Unexpected character: ${s} at position ${e}`);
  }
  /**
   * Token
   */
  tokenize() {
    const e = [];
    let s;
    do
      s = this.nextToken(), e.push(s);
    while (s.type !== J.EOF);
    return e;
  }
}
class Eo {
  lexer;
  current;
  peekToken;
  errors = [];
  constructor(e) {
    this.lexer = e, this.current = this.lexer.nextToken(), this.peekToken = this.lexer.nextToken();
  }
  /**
   * Token
   */
  nextToken() {
    this.current = this.peekToken, this.peekToken = this.lexer.nextToken();
  }
  /**
   * Token
   */
  isCurrentType(e) {
    return this.current.type === e;
  }
  /**
   * Token
   */
  isCurrentValue(e) {
    return (this.current.type === J.KEYWORD || this.current.type === J.OPERATOR) && this.current.value === e;
  }
  /**
   * Token
   */
  expectType(e) {
    if (!this.isCurrentType(e))
      throw this.errors.push(`Expected ${e}, got ${this.current.type} at position ${this.current.position}`), new Error(`Parse error at position ${this.current.position}`);
    const s = this.current;
    return this.nextToken(), s;
  }
  /**
   * Token
   */
  expectValue(e) {
    if (!this.isCurrentValue(e))
      throw this.errors.push(`Expected ${e}, got ${this.current.value} at position ${this.current.position}`), new Error(`Parse error at position ${this.current.position}`);
    const s = this.current;
    return this.nextToken(), s;
  }
  /**
   * Token
   */
  matchValue(e) {
    return this.current.value === e && (this.current.type === J.KEYWORD || this.current.type === J.OPERATOR || this.current.type === J.COMMA || this.current.type === J.SEMICOLON) ? (this.nextToken(), !0) : !1;
  }
  /**
   * 
   */
  parseIdentifier() {
    if (this.isCurrentType(J.IDENTIFIER) || this.isCurrentType(J.KEYWORD)) {
      const e = this.current.value;
      return this.nextToken(), e;
    }
    throw new Error(`Expected identifier at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseFieldType() {
    if (this.isCurrentValue("STRING"))
      return this.nextToken(), Pt.STRING;
    if (this.isCurrentValue("NUMBER"))
      return this.nextToken(), Pt.NUMBER;
    throw new Error(`Expected field type at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseColumnDef() {
    const e = this.parseIdentifier(), s = this.parseFieldType(), n = { name: e, type: s };
    if (this.matchValue("PRIMARY") && (this.expectValue("KEY"), n.primitiveKey = !0), this.matchValue("DEFAULT"))
      if (this.isCurrentType(J.STRING))
        n.defaultValue = this.current.value, this.nextToken();
      else if (this.isCurrentType(J.NUMBER))
        n.defaultValue = Number(this.current.value), this.nextToken();
      else if (this.matchValue("NULL"))
        n.defaultValue = null;
      else
        throw new Error(`Expected default value at position ${this.current.position}`);
    if (this.matchValue("COMMENT"))
      if (this.isCurrentType(J.STRING))
        n.comment = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    return n;
  }
  /**
   * 
   */
  parseExpression() {
    return this.parseLogicalOr();
  }
  /**
   * OR
   */
  parseLogicalOr() {
    let e = this.parseLogicalAnd();
    for (; this.matchValue("OR"); ) {
      const s = this.parseLogicalAnd();
      e = { type: "binary", operator: "OR", left: e, right: s };
    }
    return e;
  }
  /**
   * AND
   */
  parseLogicalAnd() {
    let e = this.parseNot();
    for (; this.matchValue("AND"); ) {
      const s = this.parseNot();
      e = { type: "binary", operator: "AND", left: e, right: s };
    }
    return e;
  }
  /**
   * NOT
   */
  parseNot() {
    if (this.matchValue("NOT")) {
      const e = this.parseNot();
      return e.type === "binary" ? { ...e, operator: `NOT ${e.operator}` } : e;
    }
    return this.parseComparison();
  }
  /**
   * 
   */
  parseComparison() {
    let e = this.parseIs();
    const s = ["=", "!=", "<>", ">", "<", ">=", "<="];
    for (; s.includes(this.current.value); ) {
      const n = this.current.value;
      this.nextToken();
      const i = this.parseIs();
      e = { type: "binary", operator: n, left: e, right: i };
    }
    if (this.matchValue("IN")) {
      this.expectType(J.LPAREN);
      const n = [];
      for (n.push(this.parseExpression()); this.matchValue(","); )
        n.push(this.parseExpression());
      return this.expectType(J.RPAREN), { type: "in", value: e, values: n };
    }
    if (this.matchValue("BETWEEN")) {
      const n = this.parseAdditive();
      this.expectValue("AND");
      const i = this.parseAdditive();
      return { type: "between", value: e, min: n, max: i };
    }
    return e;
  }
  /**
   * IS
   */
  parseIs() {
    const e = this.parseAdditive();
    if (this.matchValue("IS"))
      if (this.matchValue("NOT")) {
        const s = this.parseAdditive();
        return s.type === "null" ? { type: "null", value: e, not: !0 } : { type: "binary", operator: "IS NOT", left: e, right: s };
      } else {
        const s = this.parseAdditive();
        return s.type === "null" ? { type: "null", value: e } : { type: "binary", operator: "IS", left: e, right: s };
      }
    return e;
  }
  /**
   * 
   */
  parseAdditive() {
    let e = this.parseMultiplicative();
    for (; this.current.value === "+" || this.current.value === "-"; ) {
      const s = this.current.value;
      this.nextToken();
      const n = this.parseMultiplicative();
      e = { type: "binary", operator: s, left: e, right: n };
    }
    return e;
  }
  /**
   * 
   */
  parseMultiplicative() {
    let e = this.parsePrimary();
    for (; this.current.value === "*" || this.current.value === "/"; ) {
      const s = this.current.value;
      this.nextToken();
      const n = this.parsePrimary();
      e = { type: "binary", operator: s, left: e, right: n };
    }
    return e;
  }
  /**
   * 
   */
  parsePrimary() {
    if (this.isCurrentType(J.NUMBER)) {
      const e = Number(this.current.value);
      return this.nextToken(), { type: "value", value: e };
    }
    if (this.isCurrentType(J.STRING)) {
      const e = this.current.value;
      return this.nextToken(), { type: "value", value: e };
    }
    if (this.matchValue("NULL"))
      return { type: "null", value: { type: "value", value: null } };
    if (this.isCurrentType(J.IDENTIFIER) || this.isCurrentType(J.KEYWORD))
      return this.parseColumnExpression();
    if (this.isCurrentType(J.LPAREN)) {
      this.nextToken();
      const e = this.parseExpression();
      return this.expectType(J.RPAREN), e;
    }
    throw new Error(`Unexpected token at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseColumnExpression() {
    const e = this.parseIdentifier();
    if (this.matchValue(".")) {
      const s = e, n = this.parseIdentifier();
      return { type: "column", tableName: s, name: n };
    }
    return { type: "column", name: e };
  }
  /**
   * CREATE TABLE
   */
  parseCreateTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    this.expectType(J.LPAREN);
    const s = [];
    for (s.push(this.parseColumnDef()); this.matchValue(","); )
      s.push(this.parseColumnDef());
    this.expectType(J.RPAREN);
    const n = {
      type: $e.CREATE_TABLE,
      tableName: e,
      columns: s,
      position: this.current.position
    };
    if (this.matchValue("COMMENT"))
      if (this.isCurrentType(J.STRING))
        n.comment = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    return n;
  }
  /**
   * ALTER TABLE
   */
  parseAlterTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    let s, n, i, o, r, a;
    if (this.matchValue("ADD"))
      this.expectValue("COLUMN"), s = Zt.ADD_COLUMN, i = this.parseColumnDef();
    else if (this.matchValue("DROP"))
      this.expectValue("COLUMN"), s = Zt.DROP_COLUMN, n = this.parseIdentifier();
    else if (this.matchValue("RENAME"))
      this.matchValue("COLUMN") ? (s = Zt.RENAME_COLUMN, n = this.parseIdentifier(), this.expectValue("TO"), r = this.parseIdentifier()) : (this.expectValue("TO"), s = Zt.RENAME, o = this.parseIdentifier());
    else if (this.matchValue("MODIFY")) {
      this.expectValue("COLUMN"), n = this.parseIdentifier();
      const l = this.parseFieldType();
      let u = !1;
      if (this.matchValue("PRIMARY") && (this.expectValue("KEY"), u = !0), this.matchValue("COMMENT"))
        if (this.isCurrentType(J.STRING))
          a = this.current.value, this.nextToken();
        else
          throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
      if (u)
        s = Zt.MODIFY_COLUMN_PRIMITIVE_KEY, i = { name: n, type: l, primitiveKey: u, comment: a };
      else if (a !== void 0)
        s = Zt.MODIFY_COLUMN_COMMENT;
      else
        throw new Error(`Expected PRIMARY KEY or COMMENT after MODIFY COLUMN at position ${this.current.position}`);
    } else if (this.matchValue("COMMENT"))
      if (s = Zt.ALTER_TABLE_COMMENT, this.isCurrentType(J.STRING))
        a = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    else
      throw new Error(`Expected ADD, DROP, RENAME, MODIFY COLUMN or COMMENT after ALTER TABLE at position ${this.current.position}`);
    return {
      type: $e.ALTER_TABLE,
      tableName: e,
      opType: s,
      columnName: n,
      columnDef: i,
      newTableName: o,
      newColumnName: r,
      comment: a,
      position: this.current.position
    };
  }
  /**
   * DROP TABLE
   */
  parseDropTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    return {
      type: $e.DROP_TABLE,
      tableName: e,
      position: this.current.position
    };
  }
  /**
   * INSERT
   */
  parseInsert() {
    this.expectValue("INTO");
    const e = this.parseIdentifier();
    this.expectType(J.LPAREN);
    const s = [];
    for (s.push(this.parseIdentifier()); this.matchValue(","); )
      s.push(this.parseIdentifier());
    this.expectType(J.RPAREN), this.expectValue("VALUES"), this.expectType(J.LPAREN);
    const n = [], i = [];
    for (i.push(this.parseExpression()); this.matchValue(","); )
      i.push(this.parseExpression());
    for (n.push(i), this.expectType(J.RPAREN); this.matchValue(","); ) {
      this.expectType(J.LPAREN);
      const o = [];
      for (o.push(this.parseExpression()); this.matchValue(","); )
        o.push(this.parseExpression());
      n.push(o), this.expectType(J.RPAREN);
    }
    return {
      type: $e.INSERT,
      tableName: e,
      columns: s,
      values: n,
      position: this.current.position
    };
  }
  /**
   * UPDATE
   */
  parseUpdate() {
    const e = this.parseIdentifier();
    this.expectValue("SET");
    const s = [], n = this.parseIdentifier();
    this.expectValue("=");
    const i = this.parseExpression();
    for (s.push({ column: n, value: i }); this.matchValue(","); ) {
      const r = this.parseIdentifier();
      this.expectValue("=");
      const a = this.parseExpression();
      s.push({ column: r, value: a });
    }
    let o;
    return this.matchValue("WHERE") && (o = this.parseExpression()), {
      type: $e.UPDATE,
      tableName: e,
      sets: s,
      where: o,
      position: this.current.position
    };
  }
  /**
   * DELETE
   */
  parseDelete() {
    this.expectValue("FROM");
    const e = this.parseIdentifier();
    let s;
    return this.matchValue("WHERE") && (s = this.parseExpression()), {
      type: $e.DELETE,
      tableName: e,
      where: s,
      position: this.current.position
    };
  }
  /**
   * APPEND
   */
  parseAppend() {
    this.expectValue("INTO");
    const e = this.parseIdentifier();
    this.expectType(J.LPAREN);
    const s = this.parseIdentifier();
    this.expectType(J.RPAREN), this.expectValue("VALUES");
    const n = this.parseExpression();
    let i;
    return this.matchValue("WHERE") && (i = this.parseExpression()), {
      type: $e.APPEND,
      tableName: e,
      column: s,
      value: n,
      where: i,
      position: this.current.position
    };
  }
  /**
   * SELECT
   */
  parseSelectList() {
    const e = [];
    if (this.matchValue("*"))
      e.push({ type: "star" });
    else
      for (e.push(this.parseSelectItem()); this.matchValue(","); )
        e.push(this.parseSelectItem());
    return e;
  }
  /**
   * SELECT
   */
  parseSelectItem() {
    return this.parseColumnExpression();
  }
  /**
   * JOIN
   */
  parseJoin() {
    if (this.matchValue("INNER")) {
      this.expectValue("JOIN");
      const e = this.parseIdentifier();
      this.expectValue("ON");
      const s = this.parseColumnExpression(), n = this.parseColumnExpression();
      return {
        type: ji.INNER,
        tableName: e,
        on: { left: s, right: n }
      };
    }
    if (this.matchValue("LEFT")) {
      this.expectValue("JOIN");
      const e = this.parseIdentifier();
      this.expectValue("ON");
      const s = this.parseColumnExpression(), n = this.parseColumnExpression();
      return {
        type: ji.LEFT,
        tableName: e,
        on: { left: s, right: n }
      };
    }
  }
  /**
   * ORDER BY
   */
  parseOrderBy() {
    if (!this.matchValue("ORDER")) return;
    this.expectValue("BY");
    const e = [];
    if (e.push({
      column: this.parseIdentifier(),
      ascending: !this.matchValue("DESC")
    }), this.matchValue("ASC")) {
      const s = e[e.length - 1];
      s && (s.ascending = !0);
    }
    for (; this.matchValue(","); )
      if (e.push({
        column: this.parseIdentifier(),
        ascending: !this.matchValue("DESC")
      }), this.matchValue("ASC")) {
        const s = e[e.length - 1];
        s && (s.ascending = !0);
      }
    return e;
  }
  /**
   * SELECT
   */
  parseSelect() {
    let e = !1;
    this.matchValue("DISTINCT") && (e = !0);
    const s = this.parseSelectList();
    this.expectValue("FROM");
    const n = this.parseIdentifier(), i = [];
    for (; ; ) {
      const a = this.parseJoin();
      if (!a) break;
      i.push(a);
    }
    let o;
    this.matchValue("WHERE") && (o = this.parseExpression());
    let r;
    return this.isCurrentValue("ORDER") && (r = this.parseOrderBy()), {
      type: $e.SELECT,
      distinct: e,
      columns: s,
      from: n,
      joins: i,
      where: o,
      orderBy: r,
      position: this.current.position
    };
  }
  /**
   * 
   */
  parseStatement() {
    return this.isCurrentValue("CREATE") ? (this.nextToken(), this.parseCreateTable()) : this.isCurrentValue("ALTER") ? (this.nextToken(), this.parseAlterTable()) : this.isCurrentValue("DROP") ? (this.nextToken(), this.parseDropTable()) : this.isCurrentValue("INSERT") ? (this.nextToken(), this.parseInsert()) : this.isCurrentValue("UPDATE") ? (this.nextToken(), this.parseUpdate()) : this.isCurrentValue("DELETE") ? (this.nextToken(), this.parseDelete()) : this.isCurrentValue("APPEND") ? (this.nextToken(), this.parseAppend()) : this.isCurrentValue("SELECT") ? (this.nextToken(), this.parseSelect()) : null;
  }
  /**
   * 
   */
  parse() {
    const e = [], s = [];
    for (; !this.isCurrentType(J.EOF); )
      try {
        const n = this.parseStatement();
        n && e.push(n), this.matchValue(";") || this.isCurrentType(J.EOF) || s.push(`Expected ';' at position ${this.current.position}`);
      } catch (n) {
        for (s.push(n.message); !this.isCurrentType(J.EOF) && !this.isCurrentType(J.SEMICOLON); )
          this.nextToken();
        this.isCurrentType(J.SEMICOLON) && this.nextToken();
      }
    return { statements: e, errors: s };
  }
  /**
   * SQL
   */
  static parse(e) {
    const s = new sm(e);
    return new Eo(s).parse();
  }
}
class ll {
  evaluateExpression(e, s, n, i) {
    if (e.type === "value")
      return e.value;
    if (e.type === "column") {
      if (i === null)
        throw new Error("Cannot evaluate column expression without row context");
      const o = e.name, r = s.fieldName2id[o];
      if (r === void 0)
        throw new Error(`Column '${o}' does not exist`);
      return i[r];
    }
    if (e.type === "binary") {
      const o = this.evaluateExpression(e.left, s, n, i), r = this.evaluateExpression(e.right, s, n, i);
      switch (e.operator) {
        case "+":
          return Number(o) + Number(r);
        case "-":
          return Number(o) - Number(r);
        case "*":
          return Number(o) * Number(r);
        case "/":
          return Number(o) / Number(r);
        case "=":
          return o === r;
        case "!=":
        case "<>":
          return o !== r;
        case ">":
          return Number(o) > Number(r);
        case "<":
          return Number(o) < Number(r);
        case ">=":
          return Number(o) >= Number(r);
        case "<=":
          return Number(o) <= Number(r);
        case "AND":
          return !!o && !!r;
        case "OR":
          return !!o || !!r;
        case "IS":
          return o === r;
        case "IS NOT":
          return o !== r;
        default:
          throw new Error(`Unknown operator: ${e.operator}`);
      }
    }
    if (e.type === "null") {
      if (e.value && e.value.type === "value" && e.value.value === null)
        return null;
      const o = this.evaluateExpression(e.value, s, n, i);
      return e.not ? o !== null : o === null;
    }
    if (e.type === "in") {
      const o = this.evaluateExpression(e.value, s, n, i);
      return e.values.map((a) => this.evaluateExpression(a, s, n, i)).some((a) => a === o);
    }
    if (e.type === "between") {
      const o = this.evaluateExpression(e.value, s, n, i), r = this.evaluateExpression(e.min, s, n, i), a = this.evaluateExpression(e.max, s, n, i);
      return o >= r && o <= a;
    }
    throw new Error(`Unknown expression type: ${e.type}`);
  }
  evaluateWhere(e, s, n, i) {
    return !!this.evaluateExpression(e, s, n, i);
  }
}
class yo {
  static exportTable(e, s) {
    if (s.length === 0)
      return `**${e.tableName}**

*()*`;
    const n = Object.keys(e.id2fieldName).map((a) => parseInt(a)), i = n.map((a) => e.id2fieldName[a]), o = i.map(() => "---"), r = [];
    for (const a of s) {
      const l = [];
      for (const u of n) {
        const c = a[u];
        l.push(yo.formatValue(c));
      }
      r.push(l.join(" | "));
    }
    return `**${e.tableName}**

| ${i.join(" | ")} |
| ${o.join(" | ")} |
${r.map((a) => `| ${a} |`).join(`
`)}`;
  }
  static formatValue(e) {
    return e === null ? "*NULL*" : typeof e == "string" ? e.replace(/\n/g, "<br>") : String(e);
  }
}
class nm {
  export(e, s, n, i, o) {
    if (i) {
      if (!o)
        throw new ss("getTableIdxByName function is required when exporting a specific table");
      const a = o(i);
      if (a === void 0)
        throw new ss(`Table '${i}' does not exist`);
      const l = s[a];
      if (!l)
        throw new ss(`Schema for table '${i}' not found`);
      const u = e.getTableData(a);
      return this.exportTable(l, u, n, a);
    }
    if (n === rt.STANDARD_DATA) {
      const a = {};
      for (const [l, u] of Object.entries(s)) {
        const c = parseInt(l), d = e.getTableData(c), m = this.exportAsStandardData(u, d), h = JSON.parse(m);
        Object.assign(a, h);
      }
      return JSON.stringify(a, null, 2);
    }
    const r = [];
    for (const [a, l] of Object.entries(s)) {
      const u = parseInt(a), c = e.getTableData(u);
      r.push(this.exportTable(l, c, n, u));
    }
    return r.join(`

`);
  }
  exportTable(e, s, n, i) {
    switch (n) {
      case rt.INSERT_SQL:
        return this.exportAsInsertSql(e, s);
      case rt.TABLE_SCHEMA:
        return JSON.stringify(e, null, 2);
      case rt.DDL:
        return this.exportAsDDL(e);
      case rt.MARKDOWN:
        return this.exportAsMarkdown(e, s);
      case rt.STANDARD_DATA:
        return this.exportAsStandardData(e, s);
      default:
        throw new ss(`Unknown export format: ${n}`);
    }
  }
  exportAsInsertSql(e, s) {
    const n = [];
    for (const i of s) {
      const o = [];
      for (const [a] of Object.entries(e.id2fieldName)) {
        const l = parseInt(a), u = i[l];
        u === null ? o.push("NULL") : typeof u == "string" ? o.push(`'${u.replace(/'/g, "''")}'`) : o.push(String(u));
      }
      const r = Object.values(e.id2fieldName).join(", ");
      n.push(`INSERT INTO ${e.tableName} (${r}) VALUES (${o.join(", ")});`);
    }
    return n.join(`
`);
  }
  exportAsMarkdown(e, s) {
    return yo.exportTable(e, s);
  }
  exportAsStandardData(e, s) {
    const n = {}, i = [];
    for (const o of s) {
      const r = {};
      for (const [a, l] of Object.entries(e.id2fieldName)) {
        const u = parseInt(a);
        r[l] = o[u] ?? null;
      }
      i.push(r);
    }
    return n[e.tableName] = i, JSON.stringify(n, null, 2);
  }
  exportAsDDL(e) {
    const s = {}, n = {};
    for (const [r] of Object.entries(e.id2fieldName)) {
      const a = parseInt(r), l = e.columnSchemas[a];
      if (l) {
        const u = l.type + (l.primitiveKey ? " PRIMARY KEY" : "");
        s[l.name] = u, l.comment && (n[l.name] = l.comment);
      }
    }
    const i = new Map(Object.entries(s)), o = new Map(Object.entries(n));
    return ot.ddl().createTable(e.tableName, i, e.comment, o);
  }
}
class _o {
  structure;
  dataStorage;
  ddlExecutor;
  dmlExecutor;
  dqlExecutor;
  dataExporter;
  constructor(e, s) {
    this.dataStorage = e || fs.newStorage(), this.structure = s || this.createEmptyStructure(), this.ddlExecutor = new wr(
      this.structure,
      this.dataStorage,
      this.getTableIdxByName.bind(this)
    ), this.dmlExecutor = new Dr(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dqlExecutor = new Or(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dataExporter = new nm();
  }
  createEmptyStructure() {
    return {
      tableSchemas: {},
      tableName2Idx: {},
      tableIdxCounter: 0
    };
  }
  getTables() {
    return Object.values(this.structure.tableSchemas).map((s) => ({
      ...s,
      id2fieldName: { ...s.id2fieldName },
      fieldName2id: { ...s.fieldName2id },
      columnSchemas: { ...s.columnSchemas }
    }));
  }
  execute(e, s) {
    try {
      const n = Eo.parse(e);
      if (n.errors.length > 0)
        throw new Sn(
          n.errors.join("; "),
          0,
          e
        );
      const i = n.statements;
      if (i.length === 0)
        throw new Sn("No valid SQL statement found", 0, e);
      let o;
      for (let r = 0; r < i.length; r++) {
        const a = i[r];
        if (!a) continue;
        const l = this.getStatementType(a);
        if (!s.includes(l))
          throw new Le(
            `Expected SQL type ${s.join(" or ")}, got ${l}`,
            e
          );
        o = this.executeStatement(a);
      }
      if (!o)
        throw new Sn("No valid statement executed", 0, e);
      return o;
    } catch (n) {
      throw n instanceof Sn || n instanceof Le || n instanceof ss ? n : new ss(n.message, e);
    }
  }
  getStatementType(e) {
    const s = e.type;
    switch (s) {
      case $e.CREATE_TABLE:
      case $e.ALTER_TABLE:
      case $e.DROP_TABLE:
        return ee.DDL;
      case $e.INSERT:
      case $e.UPDATE:
      case $e.DELETE:
      case $e.APPEND:
        return ee.DML;
      case $e.SELECT:
        return ee.DQL;
      default:
        throw new ss(`Unknown statement type: ${s}`);
    }
  }
  executeStatement(e) {
    switch (e.type) {
      case $e.CREATE_TABLE:
        return this.ddlExecutor.executeCreateTable(e);
      case $e.ALTER_TABLE:
        return this.ddlExecutor.executeAlterTable(e);
      case $e.DROP_TABLE:
        return this.ddlExecutor.executeDropTable(e);
      case $e.INSERT:
        return this.dmlExecutor.executeInsert(e);
      case $e.UPDATE:
        return this.dmlExecutor.executeUpdate(e);
      case $e.DELETE:
        return this.dmlExecutor.executeDelete(e);
      case $e.APPEND:
        return this.dmlExecutor.executeAppend(e);
      case $e.SELECT:
        return this.dqlExecutor.executeSelect(e);
      default:
        throw new ss("Unsupported statement type");
    }
  }
  getTableIdxByName(e) {
    return this.structure.tableName2Idx[e];
  }
  getTableNameByIdx(e) {
    return this.structure.tableSchemas[e]?.tableName;
  }
  validateTableExists(e) {
    const s = this.getTableIdxByName(e);
    if (s === void 0)
      throw new Le(
        `Table '${e}' does not exist`,
        `Table '${e}' does not exist`
      );
    return s;
  }
  getDataStorage() {
    return this.dataStorage;
  }
  setDataStorage(e) {
    this.dataStorage = e;
  }
  export(e, s) {
    return this.dataExporter.export(
      this.dataStorage,
      this.structure.tableSchemas,
      e,
      s,
      this.getTableIdxByName.bind(this)
    );
  }
  clone() {
    const e = JSON.parse(JSON.stringify(this.structure));
    return new _o(void 0, e);
  }
  serialize() {
    return {
      structure: this.structure,
      dataStorage: this.dataStorage.serialize()
    };
  }
  deserialize(e) {
    const s = e;
    s.structure ? this.structure = s.structure : this.structure = this.createEmptyStructure(), s.dataStorage ? this.dataStorage.deserialize(s.dataStorage) : this.dataStorage.clear(), this.rebuildExecutors();
  }
  rebuildExecutors() {
    this.ddlExecutor = new wr(
      this.structure,
      this.dataStorage,
      this.getTableIdxByName.bind(this)
    ), this.dmlExecutor = new Dr(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dqlExecutor = new Or(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    );
  }
}
class To {
  data = {};
  constructor(e) {
    e && Object.keys(e).forEach((s) => {
      const n = parseInt(s), i = e[n];
      i && (this.data[n] = i.map((o) => ({ ...o })));
    });
  }
  /**
   * 
   */
  clone() {
    const e = {};
    return Object.keys(this.data).forEach((s) => {
      const n = parseInt(s), i = this.data[n];
      i && (e[n] = i.map((o) => ({ ...o })));
    }), new To(e);
  }
  /**
   * 
   */
  getTableData(e) {
    return this.data[e] || [];
  }
  /**
   * 
   */
  setTableData(e, s) {
    this.data[e] = s.map((n) => ({ ...n }));
  }
  /**
   * 
   */
  clear() {
    this.data = {};
  }
  /**
   * 
   */
  serialize() {
    return this.data;
  }
  /**
   * 
   */
  deserialize(e) {
    this.data = {};
    const s = e;
    Object.keys(s).forEach((n) => {
      const i = parseInt(n), o = s[n];
      Array.isArray(o) ? this.data[i] = o.map((r) => ({ ...r })) : this.data[i] = [];
    });
  }
}
class wr {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.getTableIdxByName = n;
  }
  executeCreateTable(e) {
    const s = e.tableName;
    this.validateTableNotExists(s);
    const n = this.allocateTableIdx(), i = e.columns, o = {}, r = {}, a = {};
    let l = 0;
    for (const c of i) {
      const d = l++;
      o[d] = c.name, r[c.name] = d;
      const m = {
        name: c.name,
        type: c.type,
        primitiveKey: c.primitiveKey || !1,
        defaultValue: c.defaultValue,
        comment: c.comment || ""
      };
      a[d] = m;
    }
    const u = {
      tableName: s,
      id2fieldName: o,
      fieldName2id: r,
      columnSchemas: a,
      counter: l,
      comment: e.comment || ""
    };
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [n]: u }, this.structure.tableName2Idx = { ...this.structure.tableName2Idx, [s]: n }, {
      success: !0,
      message: `Table '${s}' created successfully`,
      data: 0,
      type: ee.DDL
    };
  }
  executeAlterTable(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.structure.tableSchemas[n];
    switch (e.opType) {
      case "ADD_COLUMN":
        return this.addColumn(i, s, e.columnDef);
      case "DROP_COLUMN":
        return this.removeColumn(i, s, e.columnName);
      case "RENAME":
        return this.renameTable(i, n, s, e.newTableName);
      case "RENAME_COLUMN":
        return this.renameColumn(i, s, e.columnName, e.newColumnName);
      case "MODIFY_COLUMN_COMMENT":
        return this.modifyColumnComment(i, s, e.columnName, e.comment);
      case "MODIFY_COLUMN_PRIMITIVE_KEY":
        return this.modifyColumnPrimitiveKey(i, s, e.columnName, e.columnDef);
      case "ALTER_TABLE_COMMENT":
        return this.modifyTableComment(i, s, e.comment);
    }
    throw new Error("Invalid ALTER TABLE statement");
  }
  executeDropTable(e) {
    const s = e.tableName, n = this.validateTableExists(s), { [n]: i, ...o } = this.structure.tableSchemas, { [s]: r, ...a } = this.structure.tableName2Idx;
    return this.structure.tableSchemas = o, this.structure.tableName2Idx = a, this.dataStorage.setTableData(n, []), Object.keys(this.structure.tableSchemas).length === 0 && (this.structure.tableIdxCounter = 0), {
      success: !0,
      message: `Table '${s}' dropped`,
      data: 0,
      type: ee.DDL
    };
  }
  addColumn(e, s, n) {
    if (e.fieldName2id[n.name] !== void 0)
      throw new Le(
        `Column '${n.name}' already exists in table '${s}'`,
        `ALTER TABLE ${s} ADD COLUMN ${n.name}`
      );
    const i = e.counter, o = {
      name: n.name,
      type: n.type,
      primitiveKey: n.primitiveKey || !1,
      defaultValue: n.defaultValue,
      comment: n.comment || ""
    };
    e.id2fieldName = { ...e.id2fieldName, [i]: o.name }, e.fieldName2id = { ...e.fieldName2id, [o.name]: i }, e.columnSchemas = { ...e.columnSchemas, [i]: o }, e.counter = i + 1;
    const r = { ...e }, a = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [a]: r }, {
      success: !0,
      message: `Column '${n.name}' added to table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  removeColumn(e, s, n) {
    const i = e.fieldName2id[n];
    if (i === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} DROP COLUMN ${n}`
      );
    const { [i]: o, ...r } = e.id2fieldName, { [n]: a, ...l } = e.fieldName2id, { [i]: u, ...c } = e.columnSchemas;
    e.id2fieldName = r, e.fieldName2id = l, e.columnSchemas = c;
    const d = { ...e }, m = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [m]: d }, {
      success: !0,
      message: `Column '${n}' dropped from table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  renameTable(e, s, n, i) {
    if (!i)
      throw new Le("New table name is required", `ALTER TABLE ${n} RENAME TO`);
    if (this.getTableIdxByName(i) !== void 0)
      throw new Le(
        `Table '${i}' already exists`,
        `ALTER TABLE ${n} RENAME TO ${i}`
      );
    const o = { ...e, tableName: i }, { [n]: r, ...a } = this.structure.tableName2Idx;
    return this.structure.tableName2Idx = { ...a, [i]: s }, this.structure.tableSchemas = { ...this.structure.tableSchemas, [s]: o }, {
      success: !0,
      message: `Table renamed from '${n}' to '${i}'`,
      data: 0,
      type: ee.DDL
    };
  }
  renameColumn(e, s, n, i) {
    if (!n || !i)
      throw new Le("Column names are required", `ALTER TABLE ${s} RENAME COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} RENAME COLUMN ${n} TO ${i}`
      );
    if (e.fieldName2id[i] !== void 0)
      throw new Le(
        `Column '${i}' already exists in table '${s}'`,
        `ALTER TABLE ${s} RENAME COLUMN ${n} TO ${i}`
      );
    const { [n]: r, ...a } = e.fieldName2id, l = { ...e.id2fieldName, [o]: i }, u = e.columnSchemas[o], c = {
      name: i,
      type: u.type,
      primitiveKey: u.primitiveKey,
      defaultValue: u.defaultValue,
      comment: u.comment
    }, { [o]: d, ...m } = e.columnSchemas, h = { ...m, [o]: c };
    e.fieldName2id = { ...a, [i]: o }, e.id2fieldName = l, e.columnSchemas = h;
    const b = { ...e }, E = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [E]: b }, {
      success: !0,
      message: `Column '${n}' renamed to '${i}' in table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  modifyColumnComment(e, s, n, i) {
    if (!n)
      throw new Le("Column name is required", `ALTER TABLE ${s} MODIFY COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} MODIFY COLUMN ${n}`
      );
    const r = e.columnSchemas[o], a = {
      name: r.name,
      type: r.type,
      primitiveKey: r.primitiveKey,
      defaultValue: r.defaultValue,
      comment: i
    }, { [o]: l, ...u } = e.columnSchemas;
    e.columnSchemas = { ...u, [o]: a };
    const c = { ...e }, d = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [d]: c }, {
      success: !0,
      message: `Column '${n}' comment updated in table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  modifyTableComment(e, s, n) {
    const i = { ...e, comment: n }, o = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [o]: i }, {
      success: !0,
      message: `Table '${s}' comment updated`,
      data: 0,
      type: ee.DDL
    };
  }
  modifyColumnPrimitiveKey(e, s, n, i) {
    if (!n)
      throw new Le("Column name is required", `ALTER TABLE ${s} MODIFY COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} MODIFY COLUMN ${n}`
      );
    const r = e.columnSchemas[o], a = {
      name: r.name,
      type: r.type,
      primitiveKey: i.primitiveKey,
      defaultValue: r.defaultValue,
      comment: i.comment !== void 0 ? i.comment : r.comment
    }, { [o]: l, ...u } = e.columnSchemas;
    e.columnSchemas = { ...u, [o]: a };
    const c = { ...e }, d = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [d]: c }, {
      success: !0,
      message: `Column '${n}' primary key updated in table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  allocateTableIdx() {
    return this.structure.tableIdxCounter++;
  }
  validateTableExists(e) {
    const s = this.getTableIdxByName(e);
    if (s === void 0)
      throw new Le(
        `Table '${e}' does not exist`,
        `Table '${e}' does not exist`
      );
    return s;
  }
  validateTableNotExists(e) {
    if (this.getTableIdxByName(e) !== void 0)
      throw new Le(
        `Table '${e}' already exists`,
        `Table '${e}' already exists`
      );
  }
}
class Dr {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.validateTableExists = n, this.expressionEvaluator = new ll();
  }
  expressionEvaluator;
  get tableSchemas() {
    return this.structure.tableSchemas;
  }
  executeInsert(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = 0;
    const r = Object.entries(i.columnSchemas).filter(([a, l]) => l.primitiveKey).map(([a, l]) => parseInt(a)).sort((a, l) => a - l);
    for (const a of e.values) {
      const l = {}, u = {};
      for (let c = 0; c < e.columns.length; c++) {
        const d = e.columns[c];
        if (i.fieldName2id[d] === void 0)
          throw new Le(
            `Column '${d}' does not exist in table '${s}'`,
            `INSERT INTO ${s}`
          );
        u[d] = c;
      }
      for (const [c, d] of Object.entries(i.columnSchemas)) {
        const m = parseInt(c), h = d.name, b = u[h];
        if (b !== void 0) {
          const E = a[b], y = this.expressionEvaluator.evaluateExpression(E, i, n, null);
          y === null && d.defaultValue !== void 0 ? l[m] = d.defaultValue : l[m] = y;
        } else d.defaultValue !== void 0 ? l[m] = d.defaultValue : l[m] = null;
      }
      if (r.length > 0) {
        const c = this.dataStorage.getTableData(n), d = c.find((m) => r.every((h) => JSON.stringify(m[h]) === JSON.stringify(l[h])));
        if (d) {
          for (const [m] of Object.entries(u)) {
            const h = i.fieldName2id[m];
            if (h !== void 0) {
              const b = l[h];
              d[h] = b !== void 0 ? b : null;
            }
          }
          this.dataStorage.setTableData(n, c);
        } else
          c.push(l), this.dataStorage.setTableData(n, c);
      } else {
        const c = this.dataStorage.getTableData(n);
        c.push(l), this.dataStorage.setTableData(n, c);
      }
      o++;
    }
    return {
      success: !0,
      message: `Inserted ${o} row(s) into '${s}'`,
      data: o,
      type: ee.DML
    };
  }
  executeUpdate(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = 0;
    const r = this.dataStorage.getTableData(n);
    for (const a of r)
      if (e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, a)) {
        for (const u of e.sets) {
          const c = i.fieldName2id[u.column];
          if (c === void 0)
            throw new Le(
              `Column '${u.column}' does not exist in table '${s}'`,
              `UPDATE ${s}`
            );
          const d = this.expressionEvaluator.evaluateExpression(u.value, i, n, a);
          a[c] = d;
        }
        o++;
      }
    return this.dataStorage.setTableData(n, r), {
      success: !0,
      message: `Updated ${o} row(s) in '${s}'`,
      data: o,
      type: ee.DML
    };
  }
  executeDelete(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n], o = this.dataStorage.getTableData(n), r = [];
    for (const l of o)
      e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, l) || r.push(l);
    const a = o.length - r.length;
    return this.dataStorage.setTableData(n, r), {
      success: !0,
      message: `Deleted ${a} row(s) from '${s}'`,
      data: a,
      type: ee.DML
    };
  }
  executeAppend(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n], o = e.column, r = i.fieldName2id[o];
    if (r === void 0)
      throw new Le(
        `Column '${o}' does not exist in table '${s}'`,
        `APPEND INTO ${s}`
      );
    const a = i.columnSchemas[r];
    if (!a)
      throw new Le(
        `Column '${o}' does not exist in table '${s}'`,
        `APPEND INTO ${s}`
      );
    if (a.primitiveKey)
      throw new Le(
        `Cannot APPEND to primary key column '${o}'`,
        `APPEND INTO ${s}`
      );
    if (a.type !== Pt.STRING)
      throw new Le(
        `Column '${o}' must be STRING type for APPEND operation`,
        `APPEND INTO ${s}`
      );
    let l = 0;
    const u = this.dataStorage.getTableData(n);
    for (const c of u)
      if (e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, c)) {
        let m = c[r];
        m == null && (m = "");
        const h = this.expressionEvaluator.evaluateExpression(e.value, i, n, c);
        c[r] = m + h, l++;
      }
    return this.dataStorage.setTableData(n, u), {
      success: !0,
      message: `Appended to ${l} row(s) in '${s}'`,
      data: l,
      type: ee.DML
    };
  }
}
class Or {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.validateTableExists = n, this.expressionEvaluator = new ll();
  }
  expressionEvaluator;
  get tableSchemas() {
    return this.structure.tableSchemas;
  }
  executeSelect(e) {
    const s = e.from, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = this.dataStorage.getTableData(n);
    e.where && (o = o.filter(
      (a) => this.expressionEvaluator.evaluateWhere(e.where, i, n, a)
    ));
    const r = [];
    for (const a of o) {
      const l = {};
      for (const u of e.columns)
        if (u.type === "star")
          for (const [c, d] of Object.entries(i.id2fieldName)) {
            const m = parseInt(c);
            l[d] = a[m];
          }
        else if (u.type === "column") {
          const c = (u.tableName, u.name), d = i.fieldName2id[c];
          d !== void 0 && (l[c] = a[d]);
        }
      r.push(l);
    }
    if (e.orderBy) {
      const a = e.orderBy[0];
      if (a) {
        const l = a.column;
        i.fieldName2id[l] !== void 0 && r.sort((c, d) => {
          const m = c[l], h = d[l];
          return m === null && h === null ? 0 : m === null ? a.ascending ? -1 : 1 : h === null ? a.ascending ? 1 : -1 : m < h ? a.ascending ? -1 : 1 : m > h ? a.ascending ? 1 : -1 : 0;
        });
      }
    }
    return {
      success: !0,
      message: `Selected ${r.length} row(s)`,
      data: r,
      type: ee.DQL
    };
  }
}
class fs {
  static newExecutor() {
    return new _o();
  }
  static newStorage() {
    return new To();
  }
}
class Se {
  static COMMITTED_START_TAG = "<committed>";
  static COMMITTED_END_TAG = "</committed>";
  static COMMIT_START_TAG = "<commit>";
  static COMMIT_END_TAG = "</commit>";
  static getCommitted() {
    const s = SillyTavern.getContext()?.chat || [], n = [];
    for (const i of s)
      if (i.mes) {
        const o = this.extractTagContent(i.mes, Se.COMMITTED_START_TAG, Se.COMMITTED_END_TAG);
        o && n.push(o);
      }
    return n.join(`;
`);
  }
  static processMessage(e, s, n, i) {
    const o = SillyTavern.getContext(), a = (o?.chat || [])[e];
    if (!a)
      return;
    const l = a.mes || "", u = this.extractTagContent(l, s, n), c = i(u);
    if (u === null)
      a.mes = l + c;
    else {
      const d = l.lastIndexOf(n), m = l.lastIndexOf(s, d), h = l.substring(0, m), b = l.substring(d + n.length);
      a.mes = h + c + b;
    }
    o?.saveChat();
  }
  static processCommit(e, s) {
    return Se.processMessage(e, Se.COMMIT_START_TAG, Se.COMMIT_END_TAG, s);
  }
  static processCommitted(e, s) {
    return Se.processMessage(e, Se.COMMITTED_START_TAG, Se.COMMITTED_END_TAG, s);
  }
  static processLastCommitted(e) {
    const s = SillyTavern.getContext();
    (s?.chat || []).length == 0 && s?.chat.push({
      id: 0,
      name: "",
      role: "assistant",
      mes: "",
      date: Date.now()
    }), this.processCommitted(s?.chat.length - 1, e);
  }
  static extractCommit(e) {
    return this.extractTagContent(e, Se.COMMIT_START_TAG, Se.COMMIT_END_TAG);
  }
  static extractCommitted(e) {
    return this.extractTagContent(e, Se.COMMITTED_START_TAG, Se.COMMITTED_END_TAG);
  }
  static replaceCommitWithCommitted(e, s) {
    const n = SillyTavern.getContext(), o = (n?.chat || [])[e];
    if (!o)
      return;
    let r = o.mes || "";
    const a = r.lastIndexOf(Se.COMMIT_END_TAG);
    if (a !== -1) {
      const u = r.lastIndexOf(Se.COMMIT_START_TAG, a);
      if (u !== -1) {
        const c = r.substring(0, u), d = r.substring(a + Se.COMMIT_END_TAG.length), m = /\s$/.test(c), h = /^\s/.test(d);
        m && h ? r = c.replace(/\s$/, "") + d : r = c + d;
      }
    }
    const l = r.lastIndexOf(Se.COMMITTED_END_TAG);
    if (l !== -1) {
      const u = r.lastIndexOf(Se.COMMITTED_START_TAG, l);
      if (u !== -1) {
        const c = r.substring(0, u), d = r.substring(l + Se.COMMITTED_END_TAG.length);
        r = c + Se.COMMITTED_START_TAG + s + Se.COMMITTED_END_TAG + d;
      }
    } else
      r = r + Se.COMMITTED_START_TAG + s + Se.COMMITTED_END_TAG;
    o.mes = r, n?.saveChat();
  }
  static extractTagContent(e, s, n) {
    const i = e.lastIndexOf(n);
    if (i === -1) return null;
    const o = e.lastIndexOf(s, i);
    return o === -1 ? null : e.substring(o + s.length, i).trim() || null;
  }
}
class $r {
  static compressDml(e, s) {
    let n = e;
    const i = Object.entries(s);
    i.sort((o, r) => {
      const [, a] = o, [, l] = r;
      return l.tableName.length - a.tableName.length;
    });
    for (const [o, r] of i) {
      const a = parseInt(o), l = r.tableName, u = `$t${a}`, c = Object.entries(r.columnSchemas);
      c.sort((d, m) => {
        const [, h] = d, [, b] = m;
        return b.name.length - h.name.length;
      });
      for (const [d, m] of c) {
        const h = parseInt(d), b = m.name, E = `$t${a}c${h}`;
        n = n.replace(new RegExp(`\\b${b.replace(/\$/g, "\\$")}\\b`, "g"), E);
      }
      n = n.replace(new RegExp(`\\b${l.replace(/\$/g, "\\$")}\\b`, "g"), u);
    }
    return n;
  }
  static decompressDml(e, s) {
    let n = e;
    const i = Object.entries(s);
    i.sort((o, r) => {
      const [a] = o, [l] = r;
      return l.length - a.length;
    });
    for (const [o, r] of i) {
      const a = parseInt(o), l = r.tableName, u = `$t${a}`, c = Object.entries(r.columnSchemas);
      c.sort((d, m) => {
        const [h] = d, [b] = m;
        return b.length - h.length;
      });
      for (const [d, m] of c) {
        const h = parseInt(d), b = m.name, E = `$t${a}c${h}`;
        n = n.replace(new RegExp(E.replace(/\$/g, "\\$"), "g"), b);
      }
      n = n.replace(new RegExp(u.replace(/\$/g, "\\$"), "g"), l);
    }
    return n;
  }
}
class Ar {
  tableTemplate;
  constructor(e) {
    this.tableTemplate = e.clone();
  }
  getTables() {
    return this.tableTemplate.getTables();
  }
  clone() {
    return this.tableTemplate.clone();
  }
  compressDml(e) {
    const s = this.getTableSchemas();
    return $r.compressDml(e, s);
  }
  decompressDml(e) {
    const s = this.getTableSchemas();
    return $r.decompressDml(e, s);
  }
  getTableSchemas() {
    const e = this.getTables(), s = {};
    for (const n of e) {
      const i = this.getTableIdxByName(n.tableName);
      i !== void 0 && (s[i] = n);
    }
    return s;
  }
  execute(e, s) {
    const n = e.split(";").map((a) => a.trim()).filter((a) => a.length > 0);
    if (n.length === 0)
      return { success: !0, message: "SQL", data: 0, type: ee.DML };
    let i = 0, o = [], r = [];
    for (const a of n) {
      const l = this.detectSqlType(a);
      if (!s.includes(l))
        throw new Error(`SQL ${s.join("  ")} ${l}`);
      if (l === ee.DML)
        r.length > 0 && (this.tableTemplate.execute(r.join(`;
`), [ee.DDL]), r = []), o.push(a);
      else if (l === ee.DDL)
        o.length > 0 && (i += this.executeDml(o.join(`;
`)), o = []), r.push(a);
      else if (l === ee.DQL)
        return r.length > 0 && (this.tableTemplate.execute(r.join(`;
`), [ee.DDL]), r = []), o.length > 0 && (i += this.executeDml(o.join(`;
`)), o = []), this.storage.execute(a, [ee.DQL]);
    }
    return r.length > 0 && this.tableTemplate.execute(r.join(`;
`), [ee.DDL]), o.length > 0 && (i += this.executeDml(o.join(`;
`))), { success: !0, message: "", data: i, type: ee.DML };
  }
  detectSqlType(e) {
    const s = e.trim().toUpperCase();
    if (/^CREATE\s+TABLE|^ALTER\s+TABLE|^DROP\s+TABLE/i.test(s))
      return ee.DDL;
    if (/^SELECT/i.test(s))
      return ee.DQL;
    if (/^INSERT|^UPDATE|^DELETE|^APPEND/i.test(s))
      return ee.DML;
    throw new Error(`SQL: ${e}`);
  }
  executeDml(e) {
    const s = this.compressDml(e);
    return Se.processLastCommitted((n) => {
      const i = n || "";
      return `<committed>${i ? `${i};
${s}` : s}</committed>`;
    }), e.split(";").map((n) => n.trim()).filter((n) => n.length > 0).length;
  }
  export(e, s) {
    return this.storage.export(e, s);
  }
  get storage() {
    const e = Se.getCommitted(), s = this.tableTemplate.clone();
    if (e) {
      const n = this.decompressDml(e);
      s.execute(n, [ee.DML]);
    }
    return s;
  }
  getDataStorage() {
    return this.storage.getDataStorage();
  }
  getTableIdxByName(e) {
    return this.tableTemplate.getTableIdxByName(e);
  }
  getTableNameByIdx(e) {
    return this.tableTemplate.getTableNameByIdx(e);
  }
  setDataStorage(e) {
  }
  serialize() {
    return this.tableTemplate.serialize();
  }
  deserialize(e) {
    this.tableTemplate.deserialize(e);
  }
}
function qi(t, e) {
  return new Proxy(t, {
    get(s, n) {
      const i = s[n];
      return typeof i == "function" && n === "execute" ? function(...o) {
        const r = i.apply(s, o);
        return e(), r;
      } : i;
    }
  });
}
class xe {
  static MODULE_NAME = "ST_BETTER_DATABASE";
  static _instance = new xe();
  _tableTemplateCache = null;
  _tableTemplateProxy = null;
  _chatStatusBarSwitch = !1;
  _chatStatusBarCode = "";
  _extensionSwitch = !1;
  _systemSqlExecutorCache = null;
  _systemSqlExecutorProxy = null;
  _chatStatusBarChangeListeners = /* @__PURE__ */ new Set();
  constructor() {
    const { extensionSettings: e } = SillyTavern.getContext();
    e[xe.MODULE_NAME] || (e[xe.MODULE_NAME] = {
      tableTemplate: null,
      chatStatusBarSwitch: !1,
      chatStatusBarCode: "",
      extensionSwitch: !1,
      systemSqlExecutor: null
    }), this._loadFromSettings();
  }
  _loadFromSettings() {
    const { extensionSettings: e } = SillyTavern.getContext(), s = e[xe.MODULE_NAME];
    if (s) {
      if (s.tableTemplate)
        try {
          this._tableTemplateCache = fs.newExecutor(), this._tableTemplateCache.deserialize(s.tableTemplate);
        } catch {
          this._tableTemplateCache = null;
        }
      if (this._chatStatusBarSwitch = s.chatStatusBarSwitch ?? !1, this._chatStatusBarCode = s.chatStatusBarCode ?? "", this._extensionSwitch = s.extensionSwitch ?? !1, s.systemSqlExecutor)
        try {
          this._systemSqlExecutorCache = fs.newExecutor(), this._systemSqlExecutorCache.deserialize(s.systemSqlExecutor);
        } catch {
          this._systemSqlExecutorCache = null;
        }
    }
  }
  _saveToSettings() {
    const { extensionSettings: e } = SillyTavern.getContext();
    let s = e[xe.MODULE_NAME];
    s || (s = {
      tableTemplate: null,
      chatStatusBarSwitch: !1,
      chatStatusBarCode: "",
      extensionSwitch: !1,
      systemSqlExecutor: null
    }, e[xe.MODULE_NAME] = s), s.tableTemplate = this._tableTemplateCache?.serialize(), s.chatStatusBarSwitch = this._chatStatusBarSwitch, s.chatStatusBarCode = this._chatStatusBarCode, s.extensionSwitch = this._extensionSwitch, s.systemSqlExecutor = this._systemSqlExecutorCache?.serialize(), SillyTavern.getContext().saveSettingsDebounced();
  }
  get tableTemplate() {
    return this._tableTemplateCache || (this._tableTemplateCache = fs.newExecutor()), this._tableTemplateProxy || (this._tableTemplateProxy = qi(this._tableTemplateCache, () => this._saveToSettings())), this._tableTemplateProxy;
  }
  set tableTemplate(e) {
    if (typeof e == "object" && "serialize" in e) {
      const s = e.serialize();
      this._tableTemplateCache = fs.newExecutor(), this._tableTemplateCache.deserialize(s);
    } else
      this._tableTemplateCache = e;
    this._tableTemplateProxy = null, this._saveToSettings();
  }
  get chatStatusBarSwitch() {
    return this._chatStatusBarSwitch;
  }
  set chatStatusBarSwitch(e) {
    this._chatStatusBarSwitch !== e && (this._chatStatusBarSwitch = e, this._saveToSettings(), this._notifyChatStatusBarChange());
  }
  onChatStatusBarChange(e) {
    return this._chatStatusBarChangeListeners.add(e), () => this._chatStatusBarChangeListeners.delete(e);
  }
  _notifyChatStatusBarChange() {
    this._chatStatusBarChangeListeners.forEach((e) => e());
  }
  get chatStatusBarCode() {
    return this._chatStatusBarCode;
  }
  set chatStatusBarCode(e) {
    this._chatStatusBarCode = e, this._saveToSettings(), this._notifyChatStatusBarChange();
  }
  get extensionSwitch() {
    return this._extensionSwitch;
  }
  set extensionSwitch(e) {
    this._extensionSwitch = e, this._saveToSettings();
  }
  get systemSqlExecutor() {
    return this._systemSqlExecutorCache || (this._systemSqlExecutorCache = fs.newExecutor()), this._systemSqlExecutorProxy || (this._systemSqlExecutorProxy = qi(this._systemSqlExecutorCache, () => this._saveToSettings())), this._systemSqlExecutorProxy;
  }
  set systemSqlExecutor(e) {
    if (typeof e == "object" && "serialize" in e) {
      const s = e.serialize();
      this._systemSqlExecutorCache = fs.newExecutor(), this._systemSqlExecutorCache.deserialize(s);
    } else
      this._systemSqlExecutorCache = e;
    this._systemSqlExecutorProxy = null, this._saveToSettings();
  }
  static get instance() {
    return xe._instance;
  }
}
class Pe {
  static MODULE_NAME = "ST_BETTER_DATABASE";
  /**
   *  null 
   *
   * 
   * -  readonly _instance = new ChatMetaManager()
   * -  SillyTavern.getContext() 
   * -  chatMetadata 
   */
  static _instance = null;
  /**
   * 
   *  object  SimpleSqlExecutor.serialize() 
   * 
   */
  _serializedTemplateCache = null;
  /**
   * SqlExecutor 
   *  tableTemplate  _serializedTemplateCache 
   * 
   */
  _tableTemplateCache = null;
  /**
   * 
   *  execute  _saveToMetadata()
   */
  _tableTemplateProxy = null;
  constructor() {
    const { chatMetadata: e } = SillyTavern.getContext();
    e[Pe.MODULE_NAME] || (e[Pe.MODULE_NAME] = {
      tableTemplate: null
    }), this._loadFromMetadata();
  }
  /**
   *  chatMetadata 
   *
   *  SillyTavern.getContext().chatMetadata
   * chatMetadata 
   */
  _loadFromMetadata() {
    const { chatMetadata: e } = SillyTavern.getContext(), s = e[Pe.MODULE_NAME];
    if (!s || !s.tableTemplate) {
      const n = xe.instance.tableTemplate, i = new Ar(n);
      this._serializedTemplateCache = i.serialize();
    } else
      this._serializedTemplateCache = s.tableTemplate;
    this._tableTemplateCache = null, this._tableTemplateProxy = null;
  }
  /**
   *  chatMetadata
   *
   *  SillyTavern.getContext().chatMetadata
   * chatMetadata 
   */
  _saveToMetadata() {
    const { chatMetadata: e } = SillyTavern.getContext(), s = e[Pe.MODULE_NAME] || {};
    s.tableTemplate = this._serializedTemplateCache, e[Pe.MODULE_NAME] = s, SillyTavern.getContext().saveMetadata();
  }
  get tableTemplate() {
    if (!this._tableTemplateCache && this._serializedTemplateCache) {
      const e = xe.instance.tableTemplate;
      this._tableTemplateCache = new Ar(e), this._tableTemplateCache.deserialize(this._serializedTemplateCache);
    }
    return !this._tableTemplateProxy && this._tableTemplateCache && (this._tableTemplateProxy = qi(this._tableTemplateCache, () => {
      this._saveToMetadata();
    })), this._tableTemplateProxy || xe.instance.tableTemplate;
  }
  set tableTemplate(e) {
    typeof e == "object" && "serialize" in e ? this._serializedTemplateCache = e.serialize() : this._serializedTemplateCache = e, this._tableTemplateCache = null, this._tableTemplateProxy = null, this._saveToMetadata();
  }
  /**
   * 
   *
   * 
   *  SillyTavern.getContext() 
   */
  static get instance() {
    return Pe._instance || (Pe._instance = new Pe()), Pe._instance;
  }
  /**
   * 
   *
   *  chatMetadata 
   *
   * chatMetadata 
   * 
   */
  reload() {
    this._tableTemplateCache = null, this._tableTemplateProxy = null, this._loadFromMetadata();
  }
}
const Cn = "chatTemplateContainer", im = "chat";
class Rt {
  static _instance = null;
  constructor() {
  }
  static getInstance() {
    return Rt._instance || (Rt._instance = new Rt()), Rt._instance;
  }
  updateChatTemplateDisplay() {
    const e = xe.instance;
    if (!e.chatStatusBarSwitch) {
      this.removeTemplateContainer();
      return;
    }
    const s = e.chatStatusBarCode.trim();
    if (!s) {
      this.removeTemplateContainer();
      return;
    }
    this.renderTemplateToChat(s);
  }
  removeTemplateContainer() {
    const e = document.getElementById(Cn);
    e && e.remove();
  }
  renderTemplateToChat(e) {
    const s = this.escapeIframeContent(e), n = document.getElementById(im);
    if (!n) return;
    const i = document.getElementById(Cn);
    i && i.remove(), n.insertAdjacentHTML("beforeend", `<div class="wide100p" id="${Cn}">${s}</div>`);
    const o = document.getElementById(Cn);
    o && this.attachTouchEventHandlers(o);
  }
  attachTouchEventHandlers(e) {
    const s = (n) => n.stopPropagation();
    e.addEventListener("touchstart", s, { passive: !1 }), e.addEventListener("touchmove", s, { passive: !1 }), e.addEventListener("touchend", s, { passive: !1 });
  }
  escapeIframeContent(e) {
    return e.replace(/<iframe\b([^>]*)>([\s\S]*?)<\/iframe>/gi, (s, n, i) => {
      if (/\bsrcdoc=/i.test(n))
        return s;
      const o = i.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      return `<iframe${n} srcdoc="${o}"></iframe>`;
    });
  }
}
class Xs {
  static instance;
  constructor() {
  }
  static init() {
    if (xe.instance.extensionSwitch && !Xs.instance) {
      const e = new Xs();
      e.registerEventListeners(), Xs.instance = e;
    }
  }
  registerEventListeners() {
    const e = SillyTavern.getContext(), { eventSource: s, event_types: n } = e;
    s.on(n.MESSAGE_RECEIVED, (i) => this.onMessageReceived(i)), s.on(n.MESSAGE_EDITED, (i) => this.onMessageEdited(i)), s.on(n.MESSAGE_DELETED, (i) => this.onMessageDeleted()), s.on(n.CHAT_CHANGED, () => this.onChatChanged());
  }
  onMessageReceived(e) {
    this.processMessage(e), Rt.getInstance().updateChatTemplateDisplay();
  }
  onMessageEdited(e) {
    this.processMessage(e), Rt.getInstance().updateChatTemplateDisplay();
  }
  onMessageDeleted() {
    Rt.getInstance().updateChatTemplateDisplay();
  }
  onChatChanged() {
    Pe.instance.reload(), Rt.getInstance().updateChatTemplateDisplay();
  }
  processMessage(e) {
    const i = (SillyTavern.getContext().chat || [])[e];
    if (!i || !i.mes)
      return;
    const o = Se.extractCommit(i.mes);
    if (o)
      try {
        const a = Pe.instance.tableTemplate.compressDml(o), l = Se.extractCommitted(i.mes);
        let u = "";
        l && (u = l);
        const c = u ? `${u};
${a}` : a;
        Se.replaceCommitWithCommitted(e, c);
      } catch (r) {
        console.error("[ChatMessageHandler] Failed to compress commit:", r);
        return;
      }
  }
}
class As {
  root;
  currentCondition;
  static of() {
    return new As();
  }
  eq(e, s) {
    const n = `${e} = ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  ne(e, s) {
    const n = `${e} != ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  gt(e, s) {
    const n = `${e} > ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  lt(e, s) {
    const n = `${e} < ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  ge(e, s) {
    const n = `${e} >= ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  le(e, s) {
    const n = `${e} <= ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  between(e, s, n) {
    const i = `${e} BETWEEN ${this.formatValue(s)} AND ${this.formatValue(n)}`;
    return this.addCondition({ type: "condition", sql: i });
  }
  notBetween(e, s, n) {
    const i = `${e} NOT BETWEEN ${this.formatValue(s)} AND ${this.formatValue(n)}`;
    return this.addCondition({ type: "condition", sql: i });
  }
  in(e, s) {
    const n = s.map((o) => this.formatValue(o)).join(", "), i = `${e} IN (${n})`;
    return this.addCondition({ type: "condition", sql: i });
  }
  notIn(e, s) {
    const n = s.map((o) => this.formatValue(o)).join(", "), i = `${e} NOT IN (${n})`;
    return this.addCondition({ type: "condition", sql: i });
  }
  isNull(e) {
    const s = `${e} IS NULL`;
    return this.addCondition({ type: "condition", sql: s });
  }
  isNotNull(e) {
    const s = `${e} IS NOT NULL`;
    return this.addCondition({ type: "condition", sql: s });
  }
  and(e) {
    return this.combine("and", e);
  }
  or(e) {
    return this.combine("or", e);
  }
  addCondition(e) {
    return this.currentCondition ? this.currentCondition = { type: "and", left: this.currentCondition, right: e } : this.currentCondition = e, this.root = this.currentCondition, this;
  }
  combine(e, s) {
    const n = s.root || s.currentCondition;
    return n ? (this.currentCondition ? this.currentCondition = { type: e, left: this.currentCondition, right: n } : this.currentCondition = n, this.root = this.currentCondition, this) : this;
  }
  formatValue(e) {
    return e === null ? "NULL" : typeof e == "string" ? `"${e}"` : String(e);
  }
  build() {
    const e = this.root || this.currentCondition;
    return e ? this.buildNode(e) : "";
  }
  buildNode(e) {
    if (e.type === "condition")
      return e.sql;
    const s = this.buildNode(e.left), n = this.buildNode(e.right), i = e.type.toUpperCase();
    return `(${s} ${i} ${n})`;
  }
}
class bn {
  whereCondition;
  orderByClauses = [];
  joins = [];
  where(e) {
    return this.whereCondition = e, this;
  }
  orderBy(e, s = !0) {
    return this.orderByClauses.push(`${e} ${s ? "ASC" : "DESC"}`), this;
  }
  formatValue(e) {
    return e === null ? "NULL" : typeof e == "string" ? `"${e}"` : String(e);
  }
  buildWhere() {
    if (!this.whereCondition) return "";
    const e = this.whereCondition.build();
    return e ? ` WHERE ${e}` : "";
  }
}
class om extends bn {
  tableName;
  columns = [];
  from(e) {
    return this.tableName = e, this;
  }
  select(...e) {
    return this.columns = e, this;
  }
  join(e, s, n, i) {
    return this.joins.push({ type: e.toString(), table: s, on: `${n} = ${i}` }), this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    let s = `SELECT ${this.columns.length > 0 ? this.columns.join(", ") : "*"} FROM ${this.tableName}`;
    return this.joins.length > 0 && (s += this.joins.map((n) => ` ${n.type} JOIN ${n.table} ON ${n.on}`).join("")), s += this.buildWhere(), this.orderByClauses.length > 0 && (s += ` ORDER BY ${this.orderByClauses.join(", ")}`), s;
  }
}
class rm extends bn {
  tableName;
  values = /* @__PURE__ */ new Map();
  batchValues = [];
  into(e) {
    return this.tableName = e, this;
  }
  set(e, s) {
    return this.values.set(e, s), this;
  }
  setValues(e) {
    return e.forEach((s, n) => this.values.set(n, s)), this;
  }
  batch(e) {
    return this.batchValues = e, this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    const e = this.batchValues.length > 0 ? this.batchValues : [this.values], s = e[0];
    if (!s || s.size === 0)
      throw new Error("No data to insert");
    const n = Array.from(s.keys()).join(", "), i = e.map((o) => `(${Array.from(s.keys()).map((a) => {
      const l = o.get(a);
      return this.formatValue(l !== void 0 ? l : null);
    }).join(", ")})`).join(", ");
    return `INSERT INTO ${this.tableName} (${n}) VALUES ${i}`;
  }
}
class am extends bn {
  tableName;
  sets = /* @__PURE__ */ new Map();
  table(e) {
    return this.tableName = e, this;
  }
  set(e, s) {
    return this.sets.set(e, s), this;
  }
  setValues(e) {
    return e.forEach((s, n) => this.sets.set(n, s)), this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    if (this.sets.size === 0)
      throw new Error("At least one SET clause is required");
    const e = Array.from(this.sets.entries()).map(([s, n]) => `${s} = ${this.formatValue(n)}`).join(", ");
    return `UPDATE ${this.tableName} SET ${e}${this.buildWhere()}`;
  }
}
class lm extends bn {
  tableName;
  from(e) {
    return this.tableName = e, this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    return `DELETE FROM ${this.tableName}${this.buildWhere()}`;
  }
}
class cm extends bn {
  tableName;
  columnName;
  appendValue;
  into(e) {
    return this.tableName = e, this;
  }
  column(e) {
    return this.columnName = e, this;
  }
  value(e) {
    return this.appendValue = e, this;
  }
  build() {
    if (!this.tableName || !this.columnName || this.appendValue === void 0)
      throw new Error("Table name, column, and value are required");
    const e = this.formatValue(this.appendValue);
    return `APPEND INTO ${this.tableName} (${this.columnName}) VALUES (${e})${this.buildWhere()}`;
  }
}
class um {
  static createTable(e, s, n, i) {
    const o = Array.from(s.entries()).map(([a, l]) => {
      let u = `    ${a} ${l}`;
      return i && i.has(a) && (u += ` COMMENT ${this.formatValue(i.get(a))}`), u;
    }).join(`,
`);
    let r = `CREATE TABLE ${e} (
${o}
)`;
    return n && (r += ` COMMENT ${this.formatValue(n)}`), r;
  }
  static alterTableAddColumn(e, s, n, i) {
    let o = `ALTER TABLE ${e} ADD COLUMN ${s} ${n}`;
    return i && (o += ` COMMENT ${this.formatValue(i)}`), o;
  }
  static alterTableDropColumn(e, s) {
    return `ALTER TABLE ${e} DROP COLUMN ${s}`;
  }
  static alterTableRename(e, s) {
    return `ALTER TABLE ${e} RENAME TO ${s}`;
  }
  static alterTableModifyColumnComment(e, s, n, i) {
    return `ALTER TABLE ${e} MODIFY COLUMN ${s} ${n} COMMENT ${this.formatValue(i)}`;
  }
  static alterTableRenameColumn(e, s, n) {
    return `ALTER TABLE ${e} RENAME COLUMN ${s} TO ${n}`;
  }
  static alterTableComment(e, s) {
    return `ALTER TABLE ${e} COMMENT ${this.formatValue(s)}`;
  }
  static dropTable(e) {
    return `DROP TABLE ${e}`;
  }
  static formatValue(e) {
    return `"${e}"`;
  }
}
class ot {
  static select() {
    return new om();
  }
  static insert() {
    return new rm();
  }
  static update() {
    return new am();
  }
  static delete() {
    return new lm();
  }
  static append() {
    return new cm();
  }
  static ddl() {
    return um;
  }
}
class cl {
  queryData(e, s) {
    const n = ot.select().from(e).where(s || As.of()).build();
    return this.executor.execute(n, [ee.DQL]);
  }
  insertData(e, s) {
    const n = ot.insert().into(e);
    Array.isArray(s) ? n.batch(s) : n.setValues(s);
    const i = n.build();
    return this.executor.execute(i, [ee.DML]);
  }
  deleteData(e, s) {
    const n = ot.delete().from(e).where(s).build();
    return this.executor.execute(n, [ee.DML]);
  }
  updateData(e, s, n) {
    const i = ot.update().table(e).setValues(s).where(n).build();
    return this.executor.execute(i, [ee.DML]);
  }
  export(e) {
    return this.executor.export(rt.INSERT_SQL, e);
  }
}
class dm extends cl {
  get executor() {
    return Pe.instance.tableTemplate;
  }
}
class No {
  createTable(e, s, n) {
    const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    s.forEach((a) => {
      const l = a.type + (a.primitiveKey ? " PRIMARY KEY" : "");
      i.set(a.name, l), a.comment && o.set(a.name, a.comment);
    });
    const r = ot.ddl().createTable(e, i, n, o);
    return this.executor.execute(r, [ee.DDL]);
  }
  dropTable(e) {
    const s = ot.ddl().dropTable(e);
    return this.executor.execute(s, [ee.DDL]);
  }
  addColumn(e, s, n) {
    const i = n.type + (n.primitiveKey ? " PRIMARY KEY" : ""), o = ot.ddl().alterTableAddColumn(e, s, i, n.comment);
    return this.executor.execute(o, [ee.DDL]);
  }
  dropColumn(e, s) {
    const n = ot.ddl().alterTableDropColumn(e, s);
    return this.executor.execute(n, [ee.DDL]);
  }
  alterTableName(e, s) {
    const n = ot.ddl().alterTableRename(e, s);
    return this.executor.execute(n, [ee.DDL]);
  }
  alterTableComment(e, s) {
    const n = ot.ddl().alterTableComment(e, s);
    return this.executor.execute(n, [ee.DDL]);
  }
  alterColumnComment(e, s, n) {
    if (this.executor.getTableIdxByName(e) === void 0)
      return {
        success: !1,
        message: `Table ${e} not found`,
        data: 0,
        type: ee.DDL
      };
    const o = ot.ddl().alterTableModifyColumnComment(e, s, "STRING", n);
    return this.executor.execute(o, [ee.DDL]);
  }
  alterColumnName(e, s, n) {
    const i = ot.ddl().alterTableRenameColumn(e, s, n);
    return this.executor.execute(i, [ee.DDL]);
  }
  exportData(e) {
    return this.executor.export(rt.INSERT_SQL, e);
  }
  exportDDL(e) {
    return this.executor.export(rt.DDL, e);
  }
  getTables() {
    return this.executor.getTables();
  }
}
class fm extends No {
  get executor() {
    return Pe.instance.tableTemplate;
  }
}
class pm extends No {
  get executor() {
    return xe.instance.tableTemplate;
  }
}
class hm extends cl {
  get executor() {
    return xe.instance.systemSqlExecutor;
  }
}
class mm extends No {
  get executor() {
    return xe.instance.systemSqlExecutor;
  }
}
class vm {
  execute(e) {
    return xe.instance.systemSqlExecutor.execute(e, [ee.DDL, ee.DML]);
  }
}
class bm {
  syncTableFromTemplate() {
    xe.instance.systemSqlExecutor = xe.instance.tableTemplate.clone();
  }
  pushTableToTemplate() {
    const e = xe.instance.systemSqlExecutor, s = xe.instance.tableTemplate, n = e.serialize();
    s.deserialize({ structure: n.tableTemplate.structure });
  }
}
class gm {
  execute(e) {
    return Pe.instance.tableTemplate.execute(e, [ee.DDL]);
  }
}
class Em {
  execute(e) {
    return xe.instance.tableTemplate.execute(e, [ee.DDL]);
  }
}
class ym {
  /**
   * 
   */
  pushTableToTemplate() {
    const e = Pe.instance.tableTemplate, s = xe.instance.tableTemplate, n = e.serialize();
    s.deserialize({ structure: n.tableTemplate.structure });
  }
  /**
   * 
   */
  syncTableFromTemplate() {
    Pe.instance.tableTemplate = xe.instance.tableTemplate.clone();
  }
}
class ke {
  static _chatDataManagementService = new dm();
  static _chatTableManagementService = new fm();
  static _chatSqlExecutorService = new gm();
  static _templateSqlExecutorService = new Em();
  static _templateTableManagementService = new pm();
  static _chatDatabaseSyncService = new ym();
  static _systemDataManagementService = new hm();
  static _systemTableManagementService = new mm();
  static _systemSqlExecutorService = new vm();
  static _systemDatabaseSyncService = new bm();
  static get chatDataManagementService() {
    return ke._chatDataManagementService;
  }
  static get chatTableManagementService() {
    return ke._chatTableManagementService;
  }
  static get chatSqlExecutorService() {
    return ke._chatSqlExecutorService;
  }
  static get templateSqlExecutorService() {
    return ke._templateSqlExecutorService;
  }
  static get templateTableManagementService() {
    return ke._templateTableManagementService;
  }
  static get chatDatabaseSyncService() {
    return ke._chatDatabaseSyncService;
  }
  static get systemDataManagementService() {
    return ke._systemDataManagementService;
  }
  static get systemTableManagementService() {
    return ke._systemTableManagementService;
  }
  static get systemSqlExecutorService() {
    return ke._systemSqlExecutorService;
  }
  static get systemDatabaseSyncService() {
    return ke._systemDatabaseSyncService;
  }
}
function _m() {
  const t = se(() => ke.chatDataManagementService), e = se(() => ke.chatTableManagementService), s = se(() => ke.chatSqlExecutorService), n = se(() => ke.chatDatabaseSyncService);
  return {
    dataManagementService: t,
    tableManagementService: e,
    sqlExecutorService: s,
    databaseSyncService: n
  };
}
function Tm() {
  const t = se(() => ke.templateTableManagementService), e = se(() => ke.templateSqlExecutorService);
  return {
    tableManagementService: t,
    sqlExecutorService: e
  };
}
function Nm() {
  const t = se(() => ke.systemDataManagementService), e = se(() => ke.systemTableManagementService), s = se(() => ke.systemSqlExecutorService), n = se(() => ke.systemDatabaseSyncService);
  return {
    dataManagementService: t,
    tableManagementService: e,
    sqlExecutorService: s,
    databaseSyncService: n
  };
}
const xm = /* @__PURE__ */ _e({
  __name: "TemplateManagementPanel",
  props: /* @__PURE__ */ no({
    defaultTabOnTableSelect: { default: "template" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { tableManagementService: n, sqlExecutorService: i } = Tm(), o = io(t, "visible"), r = /* @__PURE__ */ q(!1), a = /* @__PURE__ */ q("template"), l = /* @__PURE__ */ q(""), u = /* @__PURE__ */ q([]), c = /* @__PURE__ */ q(null), d = [
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], m = () => {
      u.value = n.value.getTables();
    }, h = (_) => {
      l.value = _, a.value = s.defaultTabOnTableSelect;
    }, b = () => {
      r.value = !r.value;
    }, E = async () => {
      a.value = "template", await Lt(), c.value?.openCreateTableModal();
    }, y = () => {
      o.value = !1;
    };
    return lt(o, (_) => {
      _ && m();
    }), e({
      open: () => {
        o.value = !0;
      }
    }), (_, S) => (x(), L("div", null, [
      vt(_.$slots, "default"),
      C(Ge, {
        visible: o.value,
        "onUpdate:visible": S[2] || (S[2] = (T) => o.value = T),
        title: "",
        closable: !0,
        height: "650px",
        onClose: y
      }, {
        titlePrefix: P(() => [
          C(mo, {
            expanded: r.value,
            onToggle: b
          }, null, 8, ["expanded"])
        ]),
        default: P(() => [
          C(po, {
            "drawer-expanded": r.value,
            "onUpdate:drawerExpanded": S[1] || (S[1] = (T) => r.value = T),
            tables: u.value,
            "selected-table": l.value,
            onSelectTable: h,
            onCreateTable: E
          }, {
            default: P(() => [
              C(ho, {
                "active-tab": a.value,
                "onUpdate:activeTab": S[0] || (S[0] = (T) => a.value = T),
                tabs: d
              }, {
                template: P(() => [
                  C(vo, {
                    ref_key: "tableTabRef",
                    ref: c,
                    "table-service": Y(n),
                    tables: u.value,
                    "selected-table": l.value,
                    onRefresh: m,
                    "onUpdate:selectedTable": h
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: P(() => [
                  C(bo, {
                    "sql-executor-service": Y(i),
                    onRefresh: m
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), Sm = { class: "data-form" }, Cm = { class: "form-content" }, wm = { class: "form-label" }, Dm = {
  key: 0,
  class: "required-mark"
}, Om = ["onUpdate:modelValue", "type"], $m = { class: "form-actions" }, Am = /* @__PURE__ */ _e({
  __name: "DataForm",
  props: {
    columns: {},
    initialData: {},
    title: { default: "" },
    modalWidth: { default: "50vw" },
    modalHeight: { default: "auto" }
  },
  emits: ["submit", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1), o = () => {
      i.value = window.innerWidth <= 768;
    };
    it(() => {
      o(), window.addEventListener("resize", o);
    }), Ft(() => {
      window.removeEventListener("resize", o);
    });
    const r = se(() => i.value ? "100%" : s.modalWidth), a = se(() => {
      const b = {};
      return s.modalWidth && (b["--form-modal-width"] = i.value ? "100%" : s.modalWidth), s.modalHeight && (b["--form-modal-height"] = s.modalHeight), b;
    }), l = /* @__PURE__ */ _s({}), u = () => {
      s.columns.forEach((b) => {
        s.initialData && s.initialData[b.name] !== void 0 ? l[b.name] = s.initialData[b.name] : b.defaultValue !== void 0 ? l[b.name] = b.defaultValue : l[b.name] = "";
      });
    }, c = (b) => {
      const E = b.toUpperCase();
      return E.includes("STRING") || E.includes("TEXT");
    }, d = (b) => b.toUpperCase().includes("INT") || b.toUpperCase().includes("REAL") || b.toUpperCase().includes("FLOA") || b.toUpperCase().includes("DOUB") ? "number" : "text", m = () => {
      const b = /* @__PURE__ */ new Map();
      s.columns.forEach((E) => {
        let y = l[E.name], _;
        y === "" || y === void 0 ? E.primitiveKey && E.defaultValue !== void 0 ? _ = E.defaultValue : _ = null : _ = y;
        const S = E.type.toUpperCase();
        S.includes("INT") && _ !== null ? _ = parseInt(String(_)) : (S.includes("REAL") || S.includes("FLOA") || S.includes("DOUB")) && _ !== null && (_ = parseFloat(String(_))), b.set(E.name, _);
      }), n("submit", b);
    }, h = () => {
      n("cancel");
    };
    return lt(() => s.initialData, () => {
      u();
    }, { immediate: !0 }), (b, E) => (x(), L("div", {
      class: "data-form-wrapper",
      style: Ke(a.value)
    }, [
      C(Ge, {
        visible: !0,
        title: t.title,
        width: r.value,
        height: t.modalHeight,
        closable: !1,
        onClose: h
      }, {
        default: P(() => [
          f("div", Sm, [
            f("div", Cm, [
              (x(!0), L(Ae, null, Gt(t.columns, (y) => (x(), L("div", {
                key: y.name,
                class: "form-item"
              }, [
                f("label", wm, [
                  ne(ue(y.name) + " ", 1),
                  y.primitiveKey ? (x(), L("span", Dm, "*")) : te("", !0)
                ]),
                c(y.type) ? (x(), Ie(Is, {
                  key: 1,
                  "model-value": String(l[y.name] || ""),
                  "onUpdate:modelValue": (_) => l[y.name] = _,
                  "min-rows": 1,
                  "max-rows": 10
                }, null, 8, ["model-value", "onUpdate:modelValue"])) : nt((x(), L("input", {
                  key: 0,
                  "onUpdate:modelValue": (_) => l[y.name] = _,
                  type: d(y.type),
                  class: "form-input"
                }, null, 8, Om)), [
                  [yd, l[y.name]]
                ])
              ]))), 128))
            ]),
            f("div", $m, [
              C(ae, { onClick: h }, {
                default: P(() => [...E[0] || (E[0] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                onClick: m
              }, {
                default: P(() => [...E[1] || (E[1] = [
                  ne("", -1)
                ])]),
                _: 1
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["title", "width", "height"])
    ], 4));
  }
}), Vr = /* @__PURE__ */ De(Am, [["__scopeId", "data-v-dd6bd7a8"]]), Vm = { class: "confirm-container" }, Mm = { class: "form-actions" }, Im = /* @__PURE__ */ _e({
  __name: "DeleteDataConfirm",
  props: {
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = se(() => {
      const a = {};
      return s.modalWidth && (a["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (a["--confirm-modal-height"] = s.modalHeight), a;
    }), o = () => {
      n("confirm");
    }, r = () => {
      n("cancel");
    };
    return (a, l) => (x(), L("div", {
      class: "delete-data-confirm-wrapper",
      style: Ke(i.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: r
      }, {
        default: P(() => [
          f("div", Vm, [
            l[2] || (l[2] = f("div", { class: "confirm-content" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" }),
              f("p", { class: "confirm-message" }, "")
            ], -1)),
            f("div", Mm, [
              C(ae, { onClick: r }, {
                default: P(() => [...l[0] || (l[0] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "danger",
                onClick: o
              }, {
                default: P(() => [...l[1] || (l[1] = [
                  ne("", -1)
                ])]),
                _: 1
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), Rm = /* @__PURE__ */ De(Im, [["__scopeId", "data-v-b672c047"]]), Lm = { class: "export-container" }, km = { class: "export-header" }, Pm = { class: "export-content" }, Bm = { class: "export-code" }, Fm = { class: "form-actions" }, Um = /* @__PURE__ */ _e({
  __name: "ExportDisplay",
  props: {
    sql: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1);
    let o = null;
    const r = async () => {
      try {
        await navigator.clipboard.writeText(s.sql), i.value = !0, o && clearTimeout(o), o = setTimeout(() => {
          i.value = !1;
        }, 2e3);
      } catch (l) {
        console.error(":", l);
      }
    }, a = () => {
      n("close");
    };
    return (l, u) => (x(), L("div", Lm, [
      f("div", km, [
        u[0] || (u[0] = f("span", { class: "export-title" }, "SQL", -1)),
        f("button", {
          class: "copy-btn",
          onClick: r
        }, [
          f("i", {
            class: Re(i.value ? "fa-solid fa-check" : "fa-solid fa-copy")
          }, null, 2),
          ne(" " + ue(i.value ? "" : ""), 1)
        ])
      ]),
      f("div", Pm, [
        f("pre", Bm, ue(t.sql), 1)
      ]),
      f("div", Fm, [
        C(ae, { onClick: a }, {
          default: P(() => [...u[1] || (u[1] = [
            ne("", -1)
          ])]),
          _: 1
        })
      ])
    ]));
  }
}), jm = /* @__PURE__ */ De(Um, [["__scopeId", "data-v-affef56e"]]), qm = { class: "chat-data-management-tab" }, Hm = {
  key: 1,
  class: "data-detail"
}, Wm = { class: "data-toolbar" }, Km = { class: "data-title" }, zm = { class: "table-name" }, Gm = {
  key: 0,
  class: "table-comment"
}, Ym = { class: "data-actions" }, Jm = { class: "data-list" }, Qm = {
  key: 1,
  class: "table-container"
}, Xm = { class: "data-table" }, Zm = {
  key: 0,
  class: "checkbox-header sticky-col",
  style: { left: "0" }
}, ev = { class: "checkbox-wrapper" }, tv = ["checked"], sv = {
  key: 0,
  class: "checkbox-cell sticky-col",
  style: { left: "0" }
}, nv = { class: "checkbox-wrapper" }, iv = ["checked", "onChange"], ov = { class: "row-actions" }, rv = { class: "cell-value" }, av = /* @__PURE__ */ _e({
  __name: "ChatDataManagementTab",
  props: {
    dataService: {},
    tables: {},
    selectedTable: {}
  },
  setup(t) {
    const e = t, s = se(() => e.tables.find((w) => w.tableName === e.selectedTable) || {}), n = se(() => s.value.columnSchemas ? Object.values(s.value.columnSchemas) : []), i = se(() => l.value === "none" ? "" : l.value === "selecting" ? "" : l.value === "confirming" ? "" : ""), o = /* @__PURE__ */ q([]), r = /* @__PURE__ */ q(/* @__PURE__ */ new Set()), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q("none"), { toast: u, showToast: c } = al(), d = /* @__PURE__ */ q(!1), m = /* @__PURE__ */ q(!1), h = /* @__PURE__ */ q(!1), b = /* @__PURE__ */ q(!1), E = /* @__PURE__ */ q(null), y = /* @__PURE__ */ q(""), _ = (w) => w === null ? "NULL" : w === void 0 ? "" : String(w).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "\\n").replace(/<br>/gi, "&lt;br&gt;"), S = () => {
      if (s.value.tableName) {
        const w = e.dataService.queryData(s.value.tableName);
        w.success && Array.isArray(w.data) ? o.value = w.data : o.value = [];
      }
    }, T = (w) => {
      if (s.value.tableName) {
        const W = e.dataService.insertData(s.value.tableName, w);
        W.success ? (d.value = !1, S(), c("")) : c(W.message || "", "error");
      }
    }, I = (w, W) => {
      E.value = { index: w, row: W }, m.value = !0;
    }, B = (w) => {
      if (s.value.tableName && E.value) {
        const W = n.value.find((le) => le.primitiveKey), oe = o.value[E.value.index];
        let be = As.of();
        if (W) {
          const le = oe[W.name];
          be = be.eq(W.name, le);
        }
        const fe = e.dataService.updateData(s.value.tableName, w, be);
        fe.success ? (m.value = !1, E.value = null, S(), c("")) : c(fe.message || "", "error");
      }
    }, K = (w) => {
      E.value = { index: w, row: o.value[w] }, h.value = !0;
    }, pe = () => {
      if (s.value.tableName && E.value) {
        const w = n.value.find((fe) => fe.primitiveKey), W = o.value[E.value.index];
        let oe = As.of();
        if (w) {
          const fe = W[w.name];
          oe = oe.eq(w.name, fe);
        }
        const be = e.dataService.deleteData(s.value.tableName, oe);
        be.success ? (h.value = !1, E.value = null, S(), c("")) : c(be.message || "", "error");
      }
    }, he = (w) => {
      r.value.has(w) ? r.value.delete(w) : r.value.add(w), r.value.size > 0 ? l.value = "confirming" : l.value = "selecting";
    }, H = (w) => {
      w.target.checked ? o.value.forEach((oe, be) => r.value.add(be)) : r.value.clear(), r.value.size > 0 ? l.value = "confirming" : l.value = "selecting";
    }, re = () => {
      if (l.value === "none")
        l.value = "selecting", a.value = !0, r.value.clear();
      else if (l.value === "selecting")
        l.value = "none", a.value = !1, r.value.clear();
      else if (l.value === "confirming") {
        if (r.value.size === 0) {
          c("", "error");
          return;
        }
        if (s.value.tableName) {
          let w = 0;
          const W = n.value.find((oe) => oe.primitiveKey);
          r.value.forEach((oe) => {
            const be = o.value[oe];
            let fe = As.of();
            if (W) {
              const de = be[W.name];
              fe = fe.eq(W.name, de);
            }
            e.dataService.deleteData(s.value.tableName, fe).success && w++;
          }), r.value.clear(), S(), c(` ${w} `), l.value = "none", a.value = !1;
        }
      }
    }, me = () => {
      s.value.tableName && (y.value = e.dataService.export(s.value.tableName), b.value = !0);
    };
    return lt(() => e.selectedTable, () => {
      S();
    }), it(() => {
      S();
    }), (w, W) => (x(), L("div", qm, [
      t.selectedTable ? (x(), L("div", Hm, [
        f("div", Wm, [
          f("div", Km, [
            f("span", zm, ue(s.value.tableName), 1),
            s.value.comment ? (x(), L("span", Gm, ue(s.value.comment), 1)) : te("", !0)
          ]),
          f("div", Ym, [
            C(ae, {
              onClick: W[0] || (W[0] = (oe) => d.value = !0)
            }, {
              default: P(() => [...W[6] || (W[6] = [
                f("i", {
                  class: "fa-solid fa-plus",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            }),
            C(ae, {
              type: "danger",
              onClick: re
            }, {
              default: P(() => [
                W[7] || (W[7] = f("i", {
                  class: "fa-solid fa-trash",
                  style: { "margin-right": "6px" }
                }, null, -1)),
                ne(" " + ue(i.value), 1)
              ]),
              _: 1
            }),
            C(ae, { onClick: me }, {
              default: P(() => [...W[8] || (W[8] = [
                f("i", {
                  class: "fa-solid fa-download",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            })
          ])
        ]),
        f("div", Jm, [
          o.value.length === 0 ? (x(), Ie(Yn, {
            key: 0,
            icon: "fa-solid fa-database",
            text: ""
          })) : (x(), L("div", Qm, [
            f("table", Xm, [
              f("thead", null, [
                f("tr", null, [
                  a.value ? (x(), L("th", Zm, [
                    f("label", ev, [
                      f("input", {
                        type: "checkbox",
                        checked: r.value.size === o.value.length && o.value.length > 0,
                        onChange: H
                      }, null, 40, tv)
                    ])
                  ])) : te("", !0),
                  f("th", {
                    class: "actions-header sticky-col",
                    style: Ke({ left: a.value ? "50px" : "0" })
                  }, "  ", 4),
                  (x(!0), L(Ae, null, Gt(n.value, (oe) => (x(), L("th", {
                    key: oe.name,
                    class: Re(["column-header", oe.primitiveKey ? "primary-key" : ""])
                  }, ue(oe.name), 3))), 128))
                ])
              ]),
              f("tbody", null, [
                (x(!0), L(Ae, null, Gt(o.value, (oe, be) => (x(), L("tr", {
                  key: be,
                  class: "table-row"
                }, [
                  a.value ? (x(), L("td", sv, [
                    f("label", nv, [
                      f("input", {
                        type: "checkbox",
                        checked: r.value.has(be),
                        onChange: (fe) => he(be)
                      }, null, 40, iv)
                    ])
                  ])) : te("", !0),
                  f("td", {
                    class: "actions-cell sticky-col",
                    style: Ke({ left: a.value ? "50px" : "0" })
                  }, [
                    f("div", ov, [
                      C(ae, {
                        size: "small",
                        onClick: (fe) => I(be, oe)
                      }, {
                        default: P(() => [...W[9] || (W[9] = [
                          f("i", { class: "fa-solid fa-pen" }, null, -1)
                        ])]),
                        _: 1
                      }, 8, ["onClick"]),
                      C(ae, {
                        type: "danger",
                        size: "small",
                        onClick: (fe) => K(be)
                      }, {
                        default: P(() => [...W[10] || (W[10] = [
                          f("i", { class: "fa-solid fa-trash" }, null, -1)
                        ])]),
                        _: 1
                      }, 8, ["onClick"])
                    ])
                  ], 4),
                  (x(!0), L(Ae, null, Gt(n.value, (fe) => (x(), L("td", {
                    key: fe.name,
                    class: Re(["table-cell", fe.primitiveKey ? "primary-key" : ""])
                  }, [
                    f("span", rv, ue(_(oe[fe.name])), 1)
                  ], 2))), 128))
                ]))), 128))
              ])
            ])
          ]))
        ])
      ])) : (x(), Ie(Yn, {
        key: 0,
        icon: "fa-solid fa-table",
        text: ""
      })),
      C(rl, {
        visible: Y(u).visible,
        message: Y(u).message,
        type: Y(u).type,
        icon: Y(u).icon
      }, null, 8, ["visible", "message", "type", "icon"]),
      d.value ? (x(), Ie(Vr, {
        key: 2,
        title: "",
        columns: n.value,
        "modal-width": "50vw",
        onSubmit: T,
        onCancel: W[1] || (W[1] = (oe) => d.value = !1)
      }, null, 8, ["columns"])) : te("", !0),
      m.value && E.value ? (x(), Ie(Vr, {
        key: 3,
        title: "",
        columns: n.value,
        "initial-data": E.value.row,
        "modal-width": "50vw",
        onSubmit: B,
        onCancel: W[2] || (W[2] = (oe) => m.value = !1)
      }, null, 8, ["columns", "initial-data"])) : te("", !0),
      h.value ? (x(), Ie(Rm, {
        key: 4,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: pe,
        onCancel: W[3] || (W[3] = (oe) => h.value = !1)
      })) : te("", !0),
      b.value ? (x(), Ie(Ge, {
        key: 5,
        visible: "",
        title: "",
        onClose: W[5] || (W[5] = (oe) => b.value = !1)
      }, {
        default: P(() => [
          C(jm, {
            sql: y.value,
            onClose: W[4] || (W[4] = (oe) => b.value = !1)
          }, null, 8, ["sql"])
        ]),
        _: 1
      })) : te("", !0)
    ]));
  }
}), ul = /* @__PURE__ */ De(av, [["__scopeId", "data-v-c1523f72"]]), lv = /* @__PURE__ */ _e({
  __name: "SystemDataManagementPanel",
  props: /* @__PURE__ */ no({
    defaultTabOnTableSelect: { default: "data" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { dataManagementService: n, tableManagementService: i, sqlExecutorService: o } = Nm(), r = io(t, "visible"), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q("data"), u = /* @__PURE__ */ q(""), c = /* @__PURE__ */ q([]), d = /* @__PURE__ */ q(null), m = [
      { key: "data", label: "", icon: "fa-solid fa-database" },
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], h = () => {
      c.value = i.value.getTables();
    }, b = (S) => {
      u.value = S, l.value = s.defaultTabOnTableSelect;
    }, E = () => {
      a.value = !a.value;
    }, y = async () => {
      l.value = "template", await Lt(), d.value?.openCreateTableModal();
    }, _ = () => {
      r.value = !1;
    };
    return lt(r, (S) => {
      S && h();
    }), e({
      open: () => {
        r.value = !0;
      }
    }), (S, T) => (x(), L("div", null, [
      vt(S.$slots, "default"),
      C(Ge, {
        visible: r.value,
        "onUpdate:visible": T[2] || (T[2] = (I) => r.value = I),
        title: "",
        closable: !0,
        height: "650px",
        onClose: _
      }, {
        titlePrefix: P(() => [
          C(mo, {
            expanded: a.value,
            onToggle: E
          }, null, 8, ["expanded"])
        ]),
        default: P(() => [
          C(po, {
            "drawer-expanded": a.value,
            "onUpdate:drawerExpanded": T[1] || (T[1] = (I) => a.value = I),
            tables: c.value,
            "selected-table": u.value,
            "show-sync-buttons": !1,
            onSelectTable: b,
            onCreateTable: y
          }, {
            default: P(() => [
              C(ho, {
                "active-tab": l.value,
                "onUpdate:activeTab": T[0] || (T[0] = (I) => l.value = I),
                tabs: m
              }, {
                data: P(() => [
                  C(ul, {
                    "data-service": Y(n),
                    tables: c.value,
                    "selected-table": u.value,
                    onRefresh: h
                  }, null, 8, ["data-service", "tables", "selected-table"])
                ]),
                template: P(() => [
                  C(vo, {
                    ref_key: "tableTabRef",
                    ref: d,
                    "table-service": Y(i),
                    tables: c.value,
                    "selected-table": u.value,
                    onRefresh: h,
                    "onUpdate:selectedTable": b
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: P(() => [
                  C(bo, {
                    "sql-executor-service": Y(o),
                    onRefresh: h
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), cv = { class: "category_container" }, uv = { style: { display: "flex", "align-items": "center", gap: "10px" } }, dv = { class: "category_container" }, fv = { class: "category_container" }, pv = { style: { display: "flex", "flex-direction": "column", gap: "12px" } }, hv = /* @__PURE__ */ _e({
  __name: "SettingsPanel",
  setup(t) {
    const e = xe.instance, s = se({
      get: () => e.extensionSwitch,
      set: (E) => e.extensionSwitch = E
    }), n = se({
      get: () => e.chatStatusBarSwitch,
      set: (E) => e.chatStatusBarSwitch = E
    }), i = /* @__PURE__ */ q(!1), o = /* @__PURE__ */ q(""), r = /* @__PURE__ */ q(), a = /* @__PURE__ */ q(0);
    lt(i, async (E) => {
      if (E) {
        a.value++, await Lt();
        const y = e.chatStatusBarCode;
        o.value = y, await Lt(), r.value && (r.value.value = y);
      }
    });
    const l = () => {
      i.value = !0;
    }, u = () => {
      i.value = !1;
    }, c = () => {
      e.chatStatusBarCode = o.value, i.value = !1;
    }, d = /* @__PURE__ */ q(), m = /* @__PURE__ */ q(), h = () => {
      d.value?.open();
    }, b = () => {
      m.value?.open();
    };
    return (E, y) => (x(), L(Ae, null, [
      f("div", cv, [
        C(xn, null, {
          left: P(() => [...y[4] || (y[4] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-sliders",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: P(() => [
            C(Sr, {
              checked: s.value,
              onChange: y[0] || (y[0] = (_) => s.value = _)
            }, null, 8, ["checked"])
          ]),
          _: 1
        }),
        C(xn, null, {
          left: P(() => [...y[5] || (y[5] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-paper-plane",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: P(() => [
            f("div", uv, [
              C(Sr, {
                checked: n.value,
                onChange: y[1] || (y[1] = (_) => n.value = _)
              }, null, 8, ["checked"]),
              C(ae, { onClick: l }, {
                default: P(() => [...y[6] || (y[6] = [
                  f("i", {
                    class: "fa-solid fa-pen-to-square",
                    style: { "margin-right": "6px" }
                  }, null, -1),
                  ne("  ", -1)
                ])]),
                _: 1
              })
            ])
          ]),
          _: 1
        })
      ]),
      f("div", dv, [
        C(xn, null, {
          left: P(() => [...y[7] || (y[7] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-file-code",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: P(() => [
            C(ae, { onClick: h }, {
              default: P(() => [...y[8] || (y[8] = [
                f("i", {
                  class: "fa-solid fa-gear",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      f("div", fv, [
        C(xn, null, {
          left: P(() => [...y[9] || (y[9] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-database",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: P(() => [
            C(ae, { onClick: b }, {
              default: P(() => [...y[10] || (y[10] = [
                f("i", {
                  class: "fa-solid fa-gear",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      C(xm, {
        ref_key: "templateManagementPanelRef",
        ref: d
      }, {
        default: P(() => [...y[11] || (y[11] = [])]),
        _: 1
      }, 512),
      C(lv, {
        ref_key: "systemDataManagementPanelRef",
        ref: m
      }, {
        default: P(() => [...y[12] || (y[12] = [])]),
        _: 1
      }, 512),
      C(Ge, {
        visible: i.value,
        "onUpdate:visible": y[3] || (y[3] = (_) => i.value = _),
        title: "",
        closable: !0,
        onClose: u
      }, {
        footer: P(() => [
          C(ae, { onClick: u }, {
            default: P(() => [...y[13] || (y[13] = [
              ne("", -1)
            ])]),
            _: 1
          }),
          C(ae, { onClick: c }, {
            default: P(() => [...y[14] || (y[14] = [
              ne("", -1)
            ])]),
            _: 1
          })
        ]),
        default: P(() => [
          f("div", pv, [
            nt(f("textarea", {
              ref_key: "textareaRef",
              ref: r,
              "onUpdate:modelValue": y[2] || (y[2] = (_) => o.value = _),
              rows: "10",
              style: { width: "100%", padding: "12px", border: "1px solid var(--SmartThemeBorderColor)", "border-radius": "6px", background: "var(--black30a)", color: "var(--SmartThemeBodyColor)", "font-family": "monospace", resize: "vertical" },
              placeholder: "..."
            }, null, 512), [
              [bt, o.value]
            ])
          ])
        ]),
        _: 1
      }, 8, ["visible"])
    ], 64));
  }
}), mv = /* @__PURE__ */ _e({
  __name: "ExtraMesButtons",
  emits: ["click"],
  setup(t, { emit: e }) {
    const s = e;
    function n() {
      s("click");
    }
    return it(() => {
      $(document).on("click", ".open_database_table", n);
    }), pn(() => {
      $(document).off("click", ".open_database_table", n);
    }), (i, o) => (x(), Ie(_a, { to: ".extraMesButtons" }, [
      o[0] || (o[0] = f("div", {
        class: "mes_button open_database_table",
        title: ""
      }, [
        f("i", { class: "fa-solid fa-table" })
      ], -1))
    ]));
  }
}), vv = /* @__PURE__ */ _e({
  __name: "ChatManagementPanel",
  props: /* @__PURE__ */ no({
    defaultTabOnTableSelect: { default: "data" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { dataManagementService: n, tableManagementService: i, sqlExecutorService: o, databaseSyncService: r } = _m(), a = io(t, "visible"), l = /* @__PURE__ */ q(!1), u = /* @__PURE__ */ q("data"), c = /* @__PURE__ */ q(""), d = /* @__PURE__ */ q([]), m = /* @__PURE__ */ q(null), h = [
      { key: "data", label: "", icon: "fa-solid fa-database" },
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], b = () => {
      d.value = i.value.getTables();
    }, E = (B) => {
      c.value = B, u.value = s.defaultTabOnTableSelect;
    }, y = () => {
      l.value = !l.value;
    }, _ = async () => {
      u.value = "template", await Lt(), m.value?.openCreateTableModal();
    }, S = () => {
      r.value.syncTableFromTemplate(), b();
    }, T = () => {
      r.value.pushTableToTemplate(), b();
    }, I = () => {
      a.value = !1;
    };
    return lt(a, (B) => {
      B && b();
    }), e({
      open: () => {
        a.value = !0;
      }
    }), (B, K) => (x(), L("div", null, [
      vt(B.$slots, "default"),
      C(Ge, {
        visible: a.value,
        "onUpdate:visible": K[2] || (K[2] = (pe) => a.value = pe),
        title: "",
        closable: !0,
        height: "650px",
        onClose: I
      }, {
        titlePrefix: P(() => [
          C(mo, {
            expanded: l.value,
            onToggle: y
          }, null, 8, ["expanded"])
        ]),
        default: P(() => [
          C(po, {
            "drawer-expanded": l.value,
            "onUpdate:drawerExpanded": K[1] || (K[1] = (pe) => l.value = pe),
            tables: d.value,
            "selected-table": c.value,
            "show-sync-buttons": !0,
            onSelectTable: E,
            onCreateTable: _,
            onSync: S,
            onPush: T
          }, {
            default: P(() => [
              C(ho, {
                "active-tab": u.value,
                "onUpdate:activeTab": K[0] || (K[0] = (pe) => u.value = pe),
                tabs: h
              }, {
                data: P(() => [
                  C(ul, {
                    "data-service": Y(n),
                    tables: d.value,
                    "selected-table": c.value,
                    onRefresh: b
                  }, null, 8, ["data-service", "tables", "selected-table"])
                ]),
                template: P(() => [
                  C(vo, {
                    ref_key: "tableTabRef",
                    ref: m,
                    "table-service": Y(i),
                    tables: d.value,
                    "selected-table": c.value,
                    onRefresh: b,
                    "onUpdate:selectedTable": E
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: P(() => [
                  C(bo, {
                    "sql-executor-service": Y(o),
                    onRefresh: b
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), bv = { class: "translation_settings" }, gv = { class: "inline-drawer" }, Ev = { class: "inline-drawer-content" }, yv = { style: { padding: "10px" } }, _v = /* @__PURE__ */ _e({
  __name: "MainView",
  setup(t) {
    const e = /* @__PURE__ */ q(!1), s = () => {
      e.value = !0;
    };
    return (n, i) => (x(), L("div", bv, [
      f("div", gv, [
        i[1] || (i[1] = f("div", { class: "inline-drawer-toggle inline-drawer-header" }, [
          f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
            f("b", null, "")
          ]),
          f("div", { class: "inline-drawer-icon fa-solid fa-circle-chevron-down down" })
        ], -1)),
        f("div", Ev, [
          f("div", yv, [
            C(hv)
          ])
        ])
      ]),
      C(mv, { onClick: s }),
      C(vv, {
        visible: e.value,
        "onUpdate:visible": i[0] || (i[0] = (o) => e.value = o)
      }, null, 8, ["visible"])
    ]));
  }
}), Tv = /* @__PURE__ */ De(_v, [["__scopeId", "data-v-d18c04a2"]]);
class Nv {
  static init() {
    if (xe.instance.extensionSwitch) {
      const e = SillyTavern.getContext(), { registerMacro: s, eventSource: n } = e;
      if (typeof window > "u")
        return;
      window.getTemplateSqlExecutor = () => xe.instance.tableTemplate, window.getChatSqlExecutor = () => Pe.instance.tableTemplate, window.chatDatabaseData = () => JSON.parse(Pe.instance.tableTemplate.export(rt.STANDARD_DATA)), n.on("prompt_template_prepare", (i) => {
        i.getTemplateSqlExecutor = () => xe.instance.tableTemplate, i.getChatSqlExecutor = () => Pe.instance.tableTemplate;
      }), this.registerMacros(s);
    }
  }
  static registerMacros(e) {
    const s = ke.chatTableManagementService;
    e("GET_ALL_TABLE_NAMES", () => s.getTables().map((n) => n.tableName)), e("GET_ALL_TABLE_SCHEMAS", () => Pe.instance.tableTemplate.export(rt.DDL)), e("GET_ALL_TABLE_DATA", () => Pe.instance.tableTemplate.export(rt.MARKDOWN));
  }
}
class xv {
  static init() {
    Xs.init(), Nv.init();
    const e = Rt.getInstance();
    e.updateChatTemplateDisplay(), xe.instance.onChatStatusBarChange(() => {
      e.updateChatTemplateDisplay();
    });
  }
}
xv.init();
const Mr = document.createElement("div"), Ir = document.querySelector("#extensions_settings");
Ir && (Ir.appendChild(Mr), wd(Tv).mount(Mr));
//# sourceMappingURL=index.js.map
