(function(){"use strict";try{if(typeof document<"u"){var a=document.createElement("style");a.appendChild(document.createTextNode('.st-card-unified[data-v-5b66fbc1]{min-height:48px;display:flex;align-items:center;transition:background-color var(--animation-duration, 125ms)}.st-card-unified>div[data-v-5b66fbc1]{width:100%}.st-toggle-switch[data-v-f73e4a93]{position:relative;display:inline-block;width:40px;height:22px;transform:scale(.9)}.st-toggle-switch input[data-v-f73e4a93]{opacity:0;width:0;height:0}.st-toggle-slider[data-v-f73e4a93]{position:absolute;cursor:pointer;inset:0;background-color:var(--SmartThemeEmColor);transition:var(--animation-duration, 125ms);border-radius:22px}.st-toggle-slider[data-v-f73e4a93]:before{position:absolute;content:"";height:16px;width:16px;left:3px;bottom:3px;background-color:var(--SmartThemeBodyColor);transition:var(--animation-duration, 125ms);border-radius:50%;box-shadow:0 2px 4px var(--SmartThemeShadowColor)}input:checked+.st-toggle-slider[data-v-f73e4a93]{background-color:var(--SmartThemeBodyColor)}input:checked+.st-toggle-slider[data-v-f73e4a93]:before{transform:translate(18px);background-color:var(--SmartThemeBlurTintColor)}.button-wrapper[data-v-8b9ccff3]{display:inline-flex;align-items:center;justify-content:center;flex-direction:row}.button-content[data-v-8b9ccff3]{display:flex;align-items:center;gap:6px;flex-direction:row;white-space:nowrap}.popup-modal-overlay[data-v-546209e7]{position:fixed;inset:0;background:#00000080;display:flex;align-items:center;justify-content:center;z-index:9999;padding:20px}.popup-modal[data-v-546209e7]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:8px;box-shadow:0 4px 20px var(--SmartThemeShadowColor);max-width:1200px;width:100%;max-height:90vh;display:flex;flex-direction:column}.popup-modal-header[data-v-546209e7]{display:flex;justify-content:space-between;align-items:center;padding:16px 20px;border-bottom:1px solid var(--SmartThemeBorderColor)}.popup-modal-title[data-v-546209e7]{font-size:18px;font-weight:600;color:var(--SmartThemeBodyColor);display:flex;align-items:center;gap:8px}.popup-modal-close[data-v-546209e7]{width:32px;height:32px;display:flex;align-items:center;justify-content:center;cursor:pointer;border-radius:4px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);transition:all .2s}.popup-modal-close[data-v-546209e7]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.popup-modal-close i[data-v-546209e7]{font-size:18px}.popup-modal-body[data-v-546209e7]{flex:1;overflow:auto;padding:20px}.popup-modal-footer[data-v-546209e7]{padding:16px 20px;border-top:1px solid var(--SmartThemeBorderColor);display:flex;justify-content:flex-end;gap:10px}.modal-enter-active[data-v-546209e7],.modal-leave-active[data-v-546209e7]{transition:opacity .3s ease}.modal-enter-from[data-v-546209e7],.modal-leave-to[data-v-546209e7]{opacity:0}.modal-enter-active .popup-modal[data-v-546209e7],.modal-leave-active .popup-modal[data-v-546209e7]{transition:transform .3s ease,opacity .3s ease}.modal-enter-from .popup-modal[data-v-546209e7],.modal-leave-to .popup-modal[data-v-546209e7]{transform:scale(.9);opacity:0}@media(max-width:768px){.popup-modal-overlay[data-v-546209e7]{padding:10px}.popup-modal[data-v-546209e7]{height:90vh;border-radius:8px 8px 0 0;margin-top:auto}.popup-modal-header[data-v-546209e7]{padding:12px 16px}.popup-modal-title[data-v-546209e7]{font-size:16px}.popup-modal-body[data-v-546209e7]{padding:16px}.popup-modal-footer[data-v-546209e7]{padding:12px 16px}}.table-list-drawer[data-v-85bfbdca]{display:flex;flex-direction:column;height:100%;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);border-right:1px solid var(--SmartThemeBorderColor)}.drawer-header[data-v-85bfbdca]{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor)}.drawer-title[data-v-85bfbdca]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.header-actions[data-v-85bfbdca]{display:flex;align-items:center;gap:6px}.sync-btn[data-v-85bfbdca],.push-btn[data-v-85bfbdca]{display:flex;align-items:center;justify-content:center;width:28px;height:28px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);cursor:pointer;transition:all .2s}.sync-btn[data-v-85bfbdca]:hover,.push-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.sync-btn i[data-v-85bfbdca],.push-btn i[data-v-85bfbdca]{font-size:13px}.create-table-btn[data-v-85bfbdca]{display:flex;align-items:center;justify-content:center;width:28px;height:28px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);cursor:pointer;transition:all .2s}.create-table-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.create-table-btn i[data-v-85bfbdca]{font-size:13px}.drawer-body[data-v-85bfbdca]{flex:1;overflow-y:auto;padding:8px}.empty-state[data-v-85bfbdca]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:200px;gap:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.empty-state i[data-v-85bfbdca]{font-size:32px}.empty-state span[data-v-85bfbdca]{font-size:14px}.empty-create-btn[data-v-85bfbdca]{display:flex;align-items:center;gap:6px;padding:8px 16px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s;margin-top:8px}.empty-create-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.empty-create-btn i[data-v-85bfbdca]{font-size:12px}.table-list[data-v-85bfbdca]{display:flex;flex-direction:column;gap:4px}.table-item[data-v-85bfbdca]{padding:12px;border-radius:6px;cursor:pointer;transition:all .2s;border:1px solid transparent}.table-item[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.table-item.active[data-v-85bfbdca]{background:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent);border-color:var(--SmartThemeBorderColor)}.table-item-main[data-v-85bfbdca]{display:flex;align-items:center;gap:8px;margin-bottom:4px}.table-icon[data-v-85bfbdca]{font-size:14px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.table-name[data-v-85bfbdca]{font-size:14px;font-weight:500;color:var(--SmartThemeBodyColor);flex:1;word-break:break-all}.table-comment[data-v-85bfbdca]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);margin-left:22px;word-break:break-all}@media(max-width:768px){.drawer-header[data-v-85bfbdca],.drawer-body[data-v-85bfbdca]{padding:12px}.empty-state[data-v-85bfbdca]{height:auto;min-height:150px;padding:20px}.table-list[data-v-85bfbdca]{gap:8px}.table-item[data-v-85bfbdca]{padding:14px 12px}.table-name[data-v-85bfbdca]{font-size:15px}.table-comment[data-v-85bfbdca]{font-size:13px;margin-top:4px;margin-left:0}}.table-drawer-layout[data-v-3e0df31e]{display:flex;flex-direction:column;height:100%;min-height:500px}.layout-content[data-v-3e0df31e]{flex:1;display:flex;overflow:hidden;position:relative}.layout-drawer[data-v-3e0df31e]{width:240px;flex-shrink:0;border-right:1px solid var(--SmartThemeBorderColor)}.layout-main[data-v-3e0df31e]{flex:1;overflow:hidden}.drawer-slide-enter-active[data-v-3e0df31e],.drawer-slide-leave-active[data-v-3e0df31e]{transition:all .3s ease}.drawer-slide-enter-from[data-v-3e0df31e],.drawer-slide-leave-to[data-v-3e0df31e]{width:0;opacity:0}@media(max-width:768px){.table-drawer-layout[data-v-3e0df31e]{min-height:400px}.layout-drawer[data-v-3e0df31e]{width:100%}}.tab-container[data-v-9d94b988]{display:flex;flex-direction:column;height:100%}.tab-header[data-v-9d94b988]{display:flex;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);overflow-x:auto;scrollbar-width:none}.tab-header[data-v-9d94b988]::-webkit-scrollbar{display:none}.tab-item[data-v-9d94b988]{padding:12px 24px;cursor:pointer;border-bottom:2px solid transparent;transition:all .2s;display:flex;align-items:center;gap:8px;font-size:14px;color:var(--SmartThemeEmColor)}.tab-item[data-v-9d94b988]:hover{color:var(--SmartThemeBodyColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.tab-item.active[data-v-9d94b988]{color:var(--SmartThemeBodyColor);border-bottom-color:var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.tab-item i[data-v-9d94b988]{font-size:14px}.tab-body[data-v-9d94b988]{flex:1;overflow:hidden}@media(max-width:768px){.tab-header .tab-item[data-v-9d94b988]{width:40vw;flex-shrink:0;justify-content:center;padding:14px 16px;font-size:13px;white-space:nowrap}.tab-item[data-v-9d94b988]{gap:6px}}.drawer-toggle[data-v-04d4da93]{background:none;border:none;cursor:pointer;padding:7.2px;display:flex;align-items:center;justify-content:center;color:var(--SmartThemeBodyColor);transition:all .2s;border-radius:3.6px;transform:scale(.9)}.drawer-toggle[data-v-04d4da93]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.drawer-toggle[data-v-04d4da93]:active{transform:scale(.855)}.drawer-toggle.fab[data-v-04d4da93]{position:fixed;bottom:80px;right:20px;width:56px;height:56px;border-radius:50%;background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);box-shadow:0 4px 12px var(--SmartThemeShadowColor);z-index:1001}.drawer-toggle.fab[data-v-04d4da93]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.drawer-toggle.fab .hamburger-icon[data-v-04d4da93]{width:24px;height:24px}@media(min-width:769px){.drawer-toggle.fab[data-v-04d4da93]{display:none}}.hamburger-icon[data-v-04d4da93]{width:21.6px;height:16.2px;display:flex;flex-direction:column;justify-content:space-between;position:relative}.line[data-v-04d4da93]{width:100%;height:1.8px;background:var(--SmartThemeBodyColor);border-radius:1.8px;transition:all .3s ease}.toast-notification[data-v-76c92735]{position:fixed;top:20px;left:50%;transform:translate(-50%);display:flex;align-items:center;gap:10px;padding:12px 20px;border-radius:6px;font-size:14px;font-weight:500;z-index:10000;box-shadow:0 4px 12px #00000026}.toast-notification.success[data-v-76c92735]{background:#10b981;color:#fff}.toast-notification.error[data-v-76c92735]{background:#ef4444;color:#fff}.toast-notification i[data-v-76c92735]{font-size:16px}.toast-enter-active[data-v-76c92735],.toast-leave-active[data-v-76c92735]{transition:all .3s ease}.toast-enter-from[data-v-76c92735],.toast-leave-to[data-v-76c92735]{opacity:0;transform:translate(-50%) translateY(-20px)}@media(max-width:768px){.toast-notification[data-v-76c92735]{left:16px;right:16px;transform:none;justify-content:center}.toast-enter-from[data-v-76c92735],.toast-leave-to[data-v-76c92735]{transform:translateY(-20px)}}.empty-state[data-v-5ddb0dfd]{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.empty-state span[data-v-5ddb0dfd]{font-size:14px}.empty-state.compact[data-v-5ddb0dfd]{gap:12px;padding:40px 20px}.empty-state.compact span[data-v-5ddb0dfd]{font-size:14px}.auto-resize-wrapper[data-v-fd129974]{position:relative;width:100%;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);transition:all .25s cubic-bezier(.4,0,.2,1)}.auto-resize-wrapper[data-v-fd129974]:hover:not(.disabled){border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.auto-resize-wrapper.focused[data-v-fd129974]{border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.auto-resize-wrapper.disabled[data-v-fd129974]{opacity:.6;cursor:not-allowed}.textarea-mirror[data-v-fd129974]{position:absolute;top:0;left:0;visibility:hidden;pointer-events:none;height:auto;overflow:hidden;z-index:-1}.auto-resize-textarea[data-v-fd129974]{display:block;width:100%;padding:12px 16px;border:none;outline:none;background:transparent;font-family:inherit;font-size:14px;line-height:1.5;color:var(--SmartThemeBodyColor);resize:none;overflow:hidden;box-sizing:border-box;transition:height .15s ease}.auto-resize-textarea[data-v-fd129974]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.auto-resize-textarea[data-v-fd129974]:disabled{cursor:not-allowed}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar{width:8px}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-track{background:transparent}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-thumb{background:color-mix(in srgb,var(--SmartThemeBorderColor) 60%,transparent);border-radius:4px}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-thumb:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 80%,transparent)}.textarea-footer[data-v-fd129974]{display:flex;justify-content:flex-end;padding:2px 14px 8px;margin-top:-4px}.char-count[data-v-fd129974]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);transition:color .2s}.char-count.warning[data-v-fd129974]{color:#ef4444;font-weight:600}@media(max-width:768px){.auto-resize-textarea[data-v-fd129974]{padding:14px 16px;font-size:16px}}.form-wrapper[data-v-08eccbfb]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-08eccbfb]{display:flex;flex-direction:column;gap:24px;max-height:65vh;overflow-y:auto}.form-section[data-v-08eccbfb]{display:flex;flex-direction:column;gap:16px}.form-item[data-v-08eccbfb]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-08eccbfb]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);display:flex;align-items:center;gap:4px;letter-spacing:.3px}.required[data-v-08eccbfb]{color:#ef4444;margin-left:4px}.form-input[data-v-08eccbfb],.form-select[data-v-08eccbfb]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-08eccbfb]:hover,.form-select[data-v-08eccbfb]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-08eccbfb]:focus,.form-select[data-v-08eccbfb]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-08eccbfb]::placeholder,.form-select[data-v-08eccbfb]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input.has-error[data-v-08eccbfb],.form-select.has-error[data-v-08eccbfb]{border-color:#ef4444}.form-input.has-error[data-v-08eccbfb]:focus,.form-select.has-error[data-v-08eccbfb]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-08eccbfb]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-08eccbfb]{font-size:14px}.section-error[data-v-08eccbfb]{padding:10px 12px;background:#ef44441a;border-radius:6px;margin-bottom:8px}.field-hint[data-v-08eccbfb]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.columns-section[data-v-08eccbfb]{border-top:1.5px solid var(--SmartThemeBorderColor);padding-top:20px}.section-header[data-v-08eccbfb]{display:flex;justify-content:space-between;align-items:center}.column-count[data-v-08eccbfb]{font-size:13px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);padding:4px 10px;border-radius:12px}.columns-list[data-v-08eccbfb]{display:flex;flex-direction:column;gap:12px}.column-card[data-v-08eccbfb]{background:var(--SmartThemeBlurTintColor);border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;overflow:hidden}.column-card.has-error[data-v-08eccbfb]{border-color:#ef4444}.column-card-header[data-v-08eccbfb]{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:color-mix(in srgb,var(--SmartThemeBorderColor) 20%,transparent);border-bottom:1.5px solid var(--SmartThemeBorderColor)}.column-number[data-v-08eccbfb]{font-size:12px;font-weight:600;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.remove-btn[data-v-08eccbfb]{background:none;border:none;cursor:pointer;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);padding:6px;border-radius:4px;transition:all .2s}.remove-btn[data-v-08eccbfb]:hover{color:#ef4444;background:#ef44441a}.remove-btn i[data-v-08eccbfb]{font-size:14px}.column-card-body[data-v-08eccbfb]{padding:16px;display:flex;flex-direction:column;gap:12px}.form-row[data-v-08eccbfb]{display:flex;gap:12px}.form-col[data-v-08eccbfb]{display:flex;flex-direction:column;gap:6px}.form-col.form-col-name[data-v-08eccbfb]{flex:2}.form-col.form-col-type[data-v-08eccbfb],.form-col.form-col-default[data-v-08eccbfb],.form-col.form-col-comment[data-v-08eccbfb]{flex:1}.field-label[data-v-08eccbfb]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 70%,transparent)}.field-label .required[data-v-08eccbfb]{font-size:12px;margin-left:4px}.checkbox-label[data-v-08eccbfb]{display:flex;align-items:center;gap:8px;color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;width:fit-content}.checkbox-label input[data-v-08eccbfb]{cursor:pointer;width:16px;height:16px}.add-column-btn[data-v-08eccbfb]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px;border:2px dashed var(--SmartThemeBorderColor);border-radius:8px;background:transparent;color:color-mix(in srgb,var(--SmartThemeBodyColor) 70%,transparent);font-size:14px;cursor:pointer;transition:all .2s}.add-column-btn[data-v-08eccbfb]:hover{border-color:var(--SmartThemeBorderColor);color:var(--SmartThemeBodyColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 10%,transparent)}.add-column-btn i[data-v-08eccbfb]{font-size:14px}.form-actions[data-v-08eccbfb]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-08eccbfb]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-08eccbfb]{--form-modal-width: 100%}.form-container[data-v-08eccbfb]{gap:20px}.form-row[data-v-08eccbfb]{flex-direction:column;gap:12px}.form-col.form-col-name[data-v-08eccbfb],.form-col.form-col-type[data-v-08eccbfb],.form-col.form-col-default[data-v-08eccbfb],.form-col.form-col-comment[data-v-08eccbfb]{flex:1}.column-card-body[data-v-08eccbfb]{padding:12px}.form-actions[data-v-08eccbfb]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-08eccbfb]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-58e374f4]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-58e374f4]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-58e374f4]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-58e374f4]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-58e374f4]{color:#ef4444;margin-left:4px}.form-input[data-v-58e374f4]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-58e374f4]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-58e374f4]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-58e374f4]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-58e374f4]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-input.has-error[data-v-58e374f4]{border-color:#ef4444}.form-input.has-error[data-v-58e374f4]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-58e374f4]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-58e374f4]{font-size:14px}.field-hint[data-v-58e374f4]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.form-actions[data-v-58e374f4]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-58e374f4]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-58e374f4]{--form-modal-width: 100%}.form-container[data-v-58e374f4]{gap:16px}.form-item[data-v-58e374f4]{gap:8px}.form-label[data-v-58e374f4]{font-size:15px}.form-input[data-v-58e374f4]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-58e374f4]::placeholder{font-size:15px}.field-hint[data-v-58e374f4]{font-size:13px}.form-actions[data-v-58e374f4]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-58e374f4]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-03532044]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-03532044]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-03532044]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-03532044]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.form-actions[data-v-03532044]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-03532044]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-03532044]{--form-modal-width: 100%}.form-container[data-v-03532044]{gap:16px}.form-item[data-v-03532044]{gap:8px}.form-label[data-v-03532044]{font-size:15px}.form-actions[data-v-03532044]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-03532044]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.drop-table-confirm-wrapper[data-v-4629727b]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-4629727b]{padding:24px 20px;text-align:center}.confirm-icon-wrapper[data-v-4629727b]{margin-bottom:16px}.warning-icon[data-v-4629727b]{font-size:48px;color:#f59e0b}.confirm-content[data-v-4629727b]{margin-bottom:24px}.confirm-message[data-v-4629727b]{font-size:16px;color:var(--SmartThemeBodyColor);margin-bottom:12px;line-height:1.5}.confirm-message strong[data-v-4629727b]{color:#ef4444;font-weight:600}.confirm-warning[data-v-4629727b]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#ef44441a;border-radius:6px;font-size:13px;color:#ef4444;text-align:left}.confirm-warning i[data-v-4629727b]{font-size:14px;flex-shrink:0}.form-actions[data-v-4629727b]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.drop-table-confirm-wrapper[data-v-4629727b]{--confirm-modal-width: 90vw}.confirm-container[data-v-4629727b]{padding:20px 16px}.warning-icon[data-v-4629727b]{font-size:40px}.confirm-message[data-v-4629727b]{font-size:15px}.form-actions[data-v-4629727b]{flex-direction:column-reverse}.form-actions[data-v-4629727b]>*{width:100%}}.form-wrapper[data-v-019138f2]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-019138f2]{display:flex;flex-direction:column;gap:20px;max-height:70vh;overflow-y:auto}.form-item[data-v-019138f2]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-019138f2]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-019138f2]{color:#ef4444;margin-left:4px}.form-input[data-v-019138f2],.form-select[data-v-019138f2]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-019138f2]:hover,.form-select[data-v-019138f2]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-019138f2]:focus,.form-select[data-v-019138f2]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-019138f2]::placeholder,.form-select[data-v-019138f2]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input.has-error[data-v-019138f2],.form-select.has-error[data-v-019138f2]{border-color:#ef4444}.form-input.has-error[data-v-019138f2]:focus,.form-select.has-error[data-v-019138f2]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-019138f2]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-019138f2]{font-size:14px}.field-hint[data-v-019138f2]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.checkbox-label[data-v-019138f2]{display:flex;align-items:center;gap:8px;color:var(--SmartThemeEmColor);font-size:14px;cursor:pointer;width:fit-content}.checkbox-label input[data-v-019138f2]{cursor:pointer;width:18px;height:18px}.checkbox-label span[data-v-019138f2]{cursor:pointer}.form-actions[data-v-019138f2]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-019138f2]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-019138f2]{--form-modal-width: 100%}.form-container[data-v-019138f2]{gap:16px}.form-item[data-v-019138f2]{gap:8px}.form-label[data-v-019138f2]{font-size:15px}.form-input[data-v-019138f2],.form-select[data-v-019138f2]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-019138f2]::placeholder,.form-select[data-v-019138f2]::placeholder{font-size:15px}.field-hint[data-v-019138f2]{font-size:13px}.form-actions[data-v-019138f2]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-019138f2]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-36708f97]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-36708f97]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-36708f97]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-36708f97]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-36708f97]{color:#ef4444;margin-left:4px}.form-input[data-v-36708f97]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-36708f97]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-36708f97]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-36708f97]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-36708f97]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-input.has-error[data-v-36708f97]{border-color:#ef4444}.form-input.has-error[data-v-36708f97]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-36708f97]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-36708f97]{font-size:14px}.field-hint[data-v-36708f97]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.form-actions[data-v-36708f97]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-36708f97]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-36708f97]{--form-modal-width: 100%}.form-container[data-v-36708f97]{gap:16px}.form-item[data-v-36708f97]{gap:8px}.form-label[data-v-36708f97]{font-size:15px}.form-input[data-v-36708f97]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-36708f97]::placeholder{font-size:15px}.field-hint[data-v-36708f97]{font-size:13px}.form-actions[data-v-36708f97]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-36708f97]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-1f79f493]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-1f79f493]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-1f79f493]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-1f79f493]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.form-input[data-v-1f79f493]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-1f79f493]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-1f79f493]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-1f79f493]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-1f79f493]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-actions[data-v-1f79f493]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-1f79f493]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-1f79f493]{--form-modal-width: 100%}.form-container[data-v-1f79f493]{gap:16px}.form-item[data-v-1f79f493]{gap:8px}.form-label[data-v-1f79f493]{font-size:15px}.form-input[data-v-1f79f493]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-1f79f493]::placeholder{font-size:15px}.form-actions[data-v-1f79f493]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-1f79f493]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.drop-column-confirm-wrapper[data-v-7565defa]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-7565defa]{padding:24px 20px;text-align:center}.confirm-icon-wrapper[data-v-7565defa]{margin-bottom:16px}.warning-icon[data-v-7565defa]{font-size:48px;color:#f59e0b}.confirm-content[data-v-7565defa]{margin-bottom:24px}.confirm-message[data-v-7565defa]{font-size:16px;color:var(--SmartThemeBodyColor);margin-bottom:12px;line-height:1.5}.confirm-message strong[data-v-7565defa]{color:#ef4444;font-weight:600}.confirm-warning[data-v-7565defa]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#ef44441a;border-radius:6px;font-size:13px;color:#ef4444;text-align:left}.confirm-warning i[data-v-7565defa]{font-size:14px;flex-shrink:0}.form-actions[data-v-7565defa]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.drop-column-confirm-wrapper[data-v-7565defa]{--confirm-modal-width: 90vw}.confirm-container[data-v-7565defa]{padding:20px 16px}.warning-icon[data-v-7565defa]{font-size:40px}.confirm-message[data-v-7565defa]{font-size:15px}.form-actions[data-v-7565defa]{flex-direction:column-reverse}.form-actions[data-v-7565defa]>*{width:100%}}.ddl-container[data-v-da039aee]{padding:20px}.ddl-header[data-v-da039aee]{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.ddl-title[data-v-da039aee]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.copy-btn[data-v-da039aee]{display:flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--SmartThemeBorderColor);border-radius:4px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s}.copy-btn[data-v-da039aee]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.copy-btn i[data-v-da039aee]{font-size:12px}.ddl-content[data-v-da039aee]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:6px;padding:16px;margin-bottom:20px;max-height:400px;overflow:auto}.ddl-code[data-v-da039aee]{margin:0;font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;color:var(--SmartThemeBodyColor);white-space:pre-wrap;word-wrap:break-word}.form-actions[data-v-da039aee]{display:flex;gap:12px;justify-content:flex-end}@media(max-width:768px){.ddl-container[data-v-da039aee]{padding:16px}.ddl-content[data-v-da039aee]{padding:12px;max-height:300px}.ddl-code[data-v-da039aee]{font-size:12px}.form-actions[data-v-da039aee]>*{width:100%}}.table-management-tab[data-v-f00e195b]{display:flex;flex-direction:column;height:100%;overflow:hidden}.table-detail[data-v-f00e195b]{flex:1;display:flex;flex-direction:column;overflow:hidden}.table-header[data-v-f00e195b]{padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.table-title-section[data-v-f00e195b]{margin-bottom:12px}.table-name-row[data-v-f00e195b],.table-comment-row[data-v-f00e195b]{display:flex;align-items:center;gap:8px;margin-bottom:8px}.table-name-row[data-v-f00e195b]:last-child,.table-comment-row[data-v-f00e195b]:last-child{margin-bottom:0}.table-label[data-v-f00e195b]{font-size:13px;color:var(--SmartThemeEmColor);min-width:50px;flex-shrink:0}.table-name[data-v-f00e195b]{font-size:15px;font-weight:600;color:var(--SmartThemeBodyColor);flex:1;word-break:break-all}.table-comment[data-v-f00e195b]{font-size:14px;color:var(--SmartThemeEmColor);flex:1;word-break:break-all}.table-comment.placeholder[data-v-f00e195b]{color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent);font-style:italic}.table-actions[data-v-f00e195b]{display:flex;gap:8px}.columns-section[data-v-f00e195b]{flex:1;display:flex;flex-direction:column;overflow:hidden}.section-header[data-v-f00e195b]{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.section-title[data-v-f00e195b]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.columns-list[data-v-f00e195b]{flex:1;overflow-y:auto;padding:12px}.column-item[data-v-f00e195b]{display:flex;justify-content:space-between;align-items:flex-start;padding:12px;border-radius:6px;background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);margin-bottom:8px;transition:all .2s}.column-item[data-v-f00e195b]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent)}.column-main[data-v-f00e195b]{flex:1;min-width:0;margin-right:12px}.column-first-row[data-v-f00e195b]{display:flex;align-items:center;gap:24px;margin-bottom:6px}.column-name-wrapper[data-v-f00e195b]{display:flex;align-items:center;gap:6px;min-width:0}.column-icon[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);flex-shrink:0}.column-name[data-v-f00e195b]{font-size:14px;font-weight:500;color:var(--SmartThemeBodyColor);word-break:break-all;min-width:0}.type-badge[data-v-f00e195b]{display:inline-block;padding:2px 8px;border-radius:4px;font-size:12px;font-weight:500;background:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent);color:var(--SmartThemeEmColor);flex-shrink:0}.primary-key-badge[data-v-f00e195b]{display:inline-flex;align-items:center;justify-content:center;width:24px;height:24px;border-radius:4px;background:#f59e0b26;border:1px solid rgba(245,158,11,.3);flex-shrink:0}.primary-key-badge i[data-v-f00e195b]{font-size:12px;color:#f59e0b}.column-comment[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);word-break:break-all;line-height:1.4;max-height:2.8em;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical}.default-value[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);margin-top:4px}.column-actions[data-v-f00e195b]{display:flex;gap:4px;flex-shrink:0}@media(max-width:768px){.tab-toolbar[data-v-f00e195b]{flex-wrap:wrap;padding:10px 12px}.table-header[data-v-f00e195b]{padding:12px}.table-name-row[data-v-f00e195b],.table-comment-row[data-v-f00e195b]{flex-wrap:wrap}.table-actions[data-v-f00e195b]{width:100%;justify-content:stretch;margin-top:12px}.table-actions>button[data-v-f00e195b]{flex:1}.section-header[data-v-f00e195b]{padding:10px 12px}.columns-list[data-v-f00e195b]{padding:8px}.column-item[data-v-f00e195b]{flex-direction:column;gap:10px;padding:10px}.column-main[data-v-f00e195b]{margin-right:0}.column-first-row[data-v-f00e195b]{flex-wrap:wrap;gap:6px}.column-name-wrapper[data-v-f00e195b]{flex:1;min-width:0}.column-actions[data-v-f00e195b]{gap:2px;width:100%;justify-content:flex-end;border-top:1px solid var(--SmartThemeBorderColor);padding-top:8px;margin-top:4px}}.sql-panel-tab[data-v-34ac73ac]{display:flex;flex-direction:column;height:100%;gap:16px;overflow:hidden}.sql-editor-container[data-v-34ac73ac]{display:flex;flex-direction:column;height:100%;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.sql-toolbar[data-v-34ac73ac]{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-bottom:1px solid var(--SmartThemeBorderColor)}.toolbar-title[data-v-34ac73ac]{font-size:13px;font-weight:500;color:var(--SmartThemeEmColor)}.sql-editor[data-v-34ac73ac]{min-height:200px;max-height:400px;padding:16px;background:var(--SmartThemeBlurTintColor);border:none;outline:none;color:var(--SmartThemeBodyColor);font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;resize:vertical;overflow-y:auto;height:100%}.sql-editor[data-v-34ac73ac]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.sql-footer[data-v-34ac73ac]{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-top:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.result-status[data-v-34ac73ac]{font-size:12px;font-weight:500;color:var(--SmartThemeBodyColor)}.editor-stats[data-v-34ac73ac]{display:flex;gap:16px}.stat-item[data-v-34ac73ac]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.result-message[data-v-34ac73ac]{padding:10px 16px;font-size:12px;border-top:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.result-message.error[data-v-34ac73ac]{background:color-mix(in srgb,#e74c3c 20%,transparent);color:#e74c3c}@media(max-width:768px){.sql-panel-tab[data-v-34ac73ac]{gap:12px}.sql-editor[data-v-34ac73ac]{font-size:12px;min-height:150px;height:100%}.sql-footer[data-v-34ac73ac]{gap:8px}}.data-form-wrapper[data-v-daf1bd0f]{--form-modal-width: 50vw;--form-modal-height: auto}.data-form[data-v-daf1bd0f]{display:flex;flex-direction:column;gap:24px;max-height:65vh}.form-content[data-v-daf1bd0f]{display:flex;flex-direction:column;gap:20px;overflow-y:auto;padding:8px 4px}.form-item[data-v-daf1bd0f]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-daf1bd0f]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required-mark[data-v-daf1bd0f]{color:#ef4444;margin-left:4px;font-size:14px}.form-input[data-v-daf1bd0f]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-daf1bd0f]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-daf1bd0f]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-daf1bd0f]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-daf1bd0f]:disabled{opacity:.6;cursor:not-allowed}.form-hint[data-v-daf1bd0f]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);margin-top:-4px;line-height:1.5;padding-left:2px}.form-actions[data-v-daf1bd0f]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-daf1bd0f]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.data-form-wrapper[data-v-daf1bd0f]{--form-modal-width: 100%}.data-form[data-v-daf1bd0f]{gap:20px;max-height:70vh}.form-content[data-v-daf1bd0f]{gap:16px;padding:4px}.form-item[data-v-daf1bd0f]{gap:8px}.form-label[data-v-daf1bd0f]{font-size:15px}.form-input[data-v-daf1bd0f]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-daf1bd0f]::placeholder{font-size:15px}.form-hint[data-v-daf1bd0f]{font-size:13px}.form-actions[data-v-daf1bd0f]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-daf1bd0f]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.delete-data-confirm-wrapper[data-v-b672c047]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-b672c047]{padding:20px}.confirm-content[data-v-b672c047]{display:flex;flex-direction:column;align-items:center;gap:16px;padding:20px 0}.warning-icon[data-v-b672c047]{font-size:48px;color:#f59e0b}.confirm-message[data-v-b672c047]{font-size:14px;color:var(--SmartThemeBodyColor);text-align:center;line-height:1.6;margin:0}.form-actions[data-v-b672c047]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.delete-data-confirm-wrapper[data-v-b672c047]{--confirm-modal-width: 90vw}.confirm-container[data-v-b672c047]{padding:16px}.form-actions[data-v-b672c047]{flex-direction:column-reverse}.form-actions>button[data-v-b672c047]{width:100%}}.export-container[data-v-affef56e]{padding:20px}.export-header[data-v-affef56e]{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.export-title[data-v-affef56e]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.copy-btn[data-v-affef56e]{display:flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--SmartThemeBorderColor);border-radius:4px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s}.copy-btn[data-v-affef56e]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.copy-btn i[data-v-affef56e]{font-size:12px}.export-content[data-v-affef56e]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:6px;padding:16px;margin-bottom:20px;max-height:400px;overflow:auto}.export-code[data-v-affef56e]{margin:0;font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;color:var(--SmartThemeBodyColor);white-space:pre-wrap;word-wrap:break-word}.form-actions[data-v-affef56e]{display:flex;gap:12px;justify-content:flex-end}@media(max-width:768px){.export-container[data-v-affef56e]{padding:16px}.export-content[data-v-affef56e]{padding:12px;max-height:300px}.export-code[data-v-affef56e]{font-size:12px}.form-actions[data-v-affef56e]>*{width:100%}}.chat-data-management-tab[data-v-0cce85f5]{display:flex;flex-direction:column;height:100%;overflow:hidden}.data-detail[data-v-0cce85f5]{flex:1;display:flex;flex-direction:column;overflow:hidden}.data-toolbar[data-v-0cce85f5]{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.data-title[data-v-0cce85f5]{display:flex;flex-direction:column;gap:4px}.table-name[data-v-0cce85f5]{font-size:15px;font-weight:600;color:var(--SmartThemeBodyColor)}.table-comment[data-v-0cce85f5]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.data-actions[data-v-0cce85f5]{display:flex;gap:8px}.data-list[data-v-0cce85f5]{flex:1;overflow:hidden;display:flex;flex-direction:column}.table-container[data-v-0cce85f5]{flex:1;overflow:auto}.data-table[data-v-0cce85f5]{width:100%;border-collapse:collapse;font-size:13px}thead[data-v-0cce85f5]{position:sticky;top:0;z-index:30;background:var(--SmartThemeBlurTintColor)}thead th[data-v-0cce85f5]{padding:12px 16px;border-bottom:2px solid var(--SmartThemeBorderColor);font-weight:600;color:var(--SmartThemeBodyColor);white-space:nowrap;background:var(--SmartThemeBlurTintColor)}tbody th[data-v-0cce85f5]{text-align:left;padding:12px 16px;font-weight:600;color:var(--SmartThemeBodyColor);white-space:nowrap}.checkbox-header[data-v-0cce85f5]{width:50px;text-align:center;padding:12px 8px}.column-header[data-v-0cce85f5]{min-width:120px}.actions-header[data-v-0cce85f5]{width:100px;text-align:center;padding:12px 8px}.sticky-col[data-v-0cce85f5]{position:sticky;background:var(--SmartThemeBlurTintColor);z-index:20;left:0}thead th.sticky-col[data-v-0cce85f5]{z-index:32;left:0}.primary-key[data-v-0cce85f5]{background:color-mix(in srgb,rgba(218,165,32,.15) 50%,var(--SmartThemeBlurTintColor));border-right:2px solid color-mix(in srgb,rgba(218,165,32,.3) 50%,var(--SmartThemeBorderColor))}thead th.primary-key[data-v-0cce85f5]{background:color-mix(in srgb,rgba(218,165,32,.2) 50%,var(--SmartThemeBlurTintColor))}thead th.actions-header.sticky-col[data-v-0cce85f5]{z-index:31}thead th.checkbox-header.sticky-col[data-v-0cce85f5]{z-index:32}.table-row[data-v-0cce85f5]{border-bottom:1px solid var(--SmartThemeBorderColor);transition:background-color .2s}.table-row[data-v-0cce85f5]:hover{background-color:color-mix(in srgb,var(--SmartThemeBorderColor) 20%,transparent)}.table-row[data-v-0cce85f5]:last-child{border-bottom:none}.table-cell[data-v-0cce85f5]{padding:10px 16px;border-right:1px solid var(--SmartThemeBorderColor);max-width:300px;min-width:120px;background:var(--SmartThemeBlurTintColor);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.table-cell[data-v-0cce85f5]:last-child{border-right:none}.table-cell.primary-key[data-v-0cce85f5]{background:color-mix(in srgb,rgba(59,130,246,.1) 50%,var(--SmartThemeBlurTintColor));border-right:2px solid color-mix(in srgb,rgba(59,130,246,.3) 50%,var(--SmartThemeBorderColor))}.cell-value[data-v-0cce85f5]{color:var(--SmartThemeBodyColor);text-align:center;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;line-height:1.5}.checkbox-cell[data-v-0cce85f5]{width:50px;text-align:center;padding:10px 8px;border-right:1px solid var(--SmartThemeBorderColor)}.actions-cell[data-v-0cce85f5]{width:100px;padding:10px 8px;text-align:center;border-right:1px solid var(--SmartThemeBorderColor)}.actions-cell.sticky-col[data-v-0cce85f5]{box-shadow:3px 0 10px -3px #00000040}.checkbox-cell.sticky-col[data-v-0cce85f5]{box-shadow:2px 0 10px -3px #00000026}.checkbox-wrapper[data-v-0cce85f5]{display:flex;align-items:center;justify-content:center;cursor:pointer}.checkbox-wrapper input[type=checkbox][data-v-0cce85f5]{width:16px;height:16px;cursor:pointer}.row-actions[data-v-0cce85f5]{display:flex;gap:4px;justify-content:center}@media(max-width:768px){.data-toolbar[data-v-0cce85f5]{flex-direction:column;align-items:stretch;gap:12px;padding:12px}.data-title[data-v-0cce85f5]{align-items:flex-start}.data-actions[data-v-0cce85f5]{width:100%}.data-actions>button[data-v-0cce85f5]{flex:1}thead th[data-v-0cce85f5],.table-cell[data-v-0cce85f5]{padding:8px 10px}.column-header[data-v-0cce85f5]{min-width:80px}.table-cell[data-v-0cce85f5]{max-width:150px;min-width:80px}.actions-header[data-v-0cce85f5],.actions-cell[data-v-0cce85f5]{width:70px}}.translation_settings[data-v-d18c04a2],.inline-drawer[data-v-d18c04a2]{width:100%}.inline-drawer-toggle[data-v-d18c04a2]{cursor:pointer}.inline-drawer-icon[data-v-d18c04a2]{transition:transform .2s}.inline-drawer-icon.down[data-v-d18c04a2]{transform:rotate(0)}.inline-drawer-icon.up[data-v-d18c04a2]{transform:rotate(180deg)}')),document.head.appendChild(a)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
var Ir = {};
// @__NO_SIDE_EFFECTS__
function Yt(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const s of t.split(",")) e[s] = 1;
  return (s) => s in e;
}
const ye = Ir.NODE_ENV !== "production" ? Object.freeze({}) : {}, Ss = Ir.NODE_ENV !== "production" ? Object.freeze([]) : [], qe = () => {
}, Rr = () => !1, ln = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter
(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), Rn = (t) => t.startsWith("onUpdate:"), Ve = Object.assign, Ki = (t, e) => {
  const s = t.indexOf(e);
  s > -1 && t.splice(s, 1);
}, ml = Object.prototype.hasOwnProperty, Ee = (t, e) => ml.call(t, e), z = Array.isArray, ps = (t) => cn(t) === "[object Map]", Ms = (t) => cn(t) === "[object Set]", wo = (t) => cn(t) === "[object Date]", Z = (t) => typeof t == "function", Me = (t) => typeof t == "string", vt = (t) => typeof t == "symbol", ve = (t) => t !== null && typeof t == "object", zi = (t) => (ve(t) || Z(t)) && Z(t.then) && Z(t.catch), Lr = Object.prototype.toString, cn = (t) => Lr.call(t), Gi = (t) => cn(t).slice(8, -1), kr = (t) => cn(t) === "[object Object]", Yi = (t) => Me(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Ks = /* @__PURE__ */ Yt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), vl = /* @__PURE__ */ Yt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), Jn = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return ((s) => e[s] || (e[s] = t(s)));
}, bl = /-\w/g, ut = Jn(
  (t) => t.replace(bl, (e) => e.slice(1).toUpperCase())
), gl = /\B([A-Z])/g, Gt = Jn(
  (t) => t.replace(gl, "-$1").toLowerCase()
), Xn = Jn((t) => t.charAt(0).toUpperCase() + t.slice(1)), cs = Jn(
  (t) => t ? `on${Xn(t)}` : ""
), nt = (t, e) => !Object.is(t, e), Ns = (t, ...e) => {
  for (let s = 0; s < t.length; s++)
    t[s](...e);
}, Ln = (t, e, s, n = !1) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    writable: n,
    value: s
  });
}, Zn = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, El = (t) => {
  const e = Me(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let Do;
const un = () => Do || (Do = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {});
function Ke(t) {
  if (z(t)) {
    const e = {};
    for (let s = 0; s < t.length; s++) {
      const n = t[s], i = Me(n) ? Nl(n) : Ke(n);
      if (i)
        for (const o in i)
          e[o] = i[o];
    }
    return e;
  } else if (Me(t) || ve(t))
    return t;
}
const yl = /;(?![^(]*\))/g, _l = /:([^]+)/, Tl = /\/\*[^]*?\*\//g;
function Nl(t) {
  const e = {};
  return t.replace(Tl, "").split(yl).forEach((s) => {
    if (s) {
      const n = s.split(_l);
      n.length > 1 && (e[n[0].trim()] = n[1].trim());
    }
  }), e;
}
function Ie(t) {
  let e = "";
  if (Me(t))
    e = t;
  else if (z(t))
    for (let s = 0; s < t.length; s++) {
      const n = Ie(t[s]);
      n && (e += n + " ");
    }
  else if (ve(t))
    for (const s in t)
      t[s] && (e += s + " ");
  return e.trim();
}
const xl = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Sl = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", Cl = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", wl = /* @__PURE__ */ Yt(xl), Dl = /* @__PURE__ */ Yt(Sl), Ol = /* @__PURE__ */ Yt(Cl), $l = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Al = /* @__PURE__ */ Yt($l);
function Pr(t) {
  return !!t || t === "";
}
function Vl(t, e) {
  if (t.length !== e.length) return !1;
  let s = !0;
  for (let n = 0; s && n < t.length; n++)
    s = Is(t[n], e[n]);
  return s;
}
function Is(t, e) {
  if (t === e) return !0;
  let s = wo(t), n = wo(e);
  if (s || n)
    return s && n ? t.getTime() === e.getTime() : !1;
  if (s = vt(t), n = vt(e), s || n)
    return t === e;
  if (s = z(t), n = z(e), s || n)
    return s && n ? Vl(t, e) : !1;
  if (s = ve(t), n = ve(e), s || n) {
    if (!s || !n)
      return !1;
    const i = Object.keys(t).length, o = Object.keys(e).length;
    if (i !== o)
      return !1;
    for (const r in t) {
      const a = t.hasOwnProperty(r), l = e.hasOwnProperty(r);
      if (a && !l || !a && l || !Is(t[r], e[r]))
        return !1;
    }
  }
  return String(t) === String(e);
}
function Qi(t, e) {
  return t.findIndex((s) => Is(s, e));
}
const Br = (t) => !!(t && t.__v_isRef === !0), ue = (t) => Me(t) ? t : t == null ? "" : z(t) || ve(t) && (t.toString === Lr || !Z(t.toString)) ? Br(t) ? ue(t.value) : JSON.stringify(t, Fr, 2) : String(t), Fr = (t, e) => Br(e) ? Fr(t, e.value) : ps(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (s, [n, i], o) => (s[hi(n, o) + " =>"] = i, s),
    {}
  )
} : Ms(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((s) => hi(s))
} : vt(e) ? hi(e) : ve(e) && !z(e) && !kr(e) ? String(e) : e, hi = (t, e = "") => {
  var s;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    vt(t) ? `Symbol(${(s = t.description) != null ? s : e})` : t
  );
};
var Ce = {};
function bt(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
let st;
class Ml {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.__v_skip = !0, this.parent = st, !e && st && (this.index = (st.scopes || (st.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, s;
      if (this.scopes)
        for (e = 0, s = this.scopes.length; e < s; e++)
          this.scopes[e].pause();
      for (e = 0, s = this.effects.length; e < s; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, s;
      if (this.scopes)
        for (e = 0, s = this.scopes.length; e < s; e++)
          this.scopes[e].resume();
      for (e = 0, s = this.effects.length; e < s; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const s = st;
      try {
        return st = this, e();
      } finally {
        st = s;
      }
    } else Ce.NODE_ENV !== "production" && bt("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = st, st = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (st = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let s, n;
      for (s = 0, n = this.effects.length; s < n; s++)
        this.effects[s].stop();
      for (this.effects.length = 0, s = 0, n = this.cleanups.length; s < n; s++)
        this.cleanups[s]();
      if (this.cleanups.length = 0, this.scopes) {
        for (s = 0, n = this.scopes.length; s < n; s++)
          this.scopes[s].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Il() {
  return st;
}
let Ne;
const mi = /* @__PURE__ */ new WeakSet();
class Ur {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, st && st.active && st.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, mi.has(this) && (mi.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || qr(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Oo(this), Hr(this);
    const e = Ne, s = ht;
    Ne = this, ht = !0;
    try {
      return this.fn();
    } finally {
      Ce.NODE_ENV !== "production" && Ne !== this && bt(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), Wr(this), Ne = e, ht = s, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        Zi(e);
      this.deps = this.depsTail = void 0, Oo(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? mi.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Ci(this) && this.run();
  }
  get dirty() {
    return Ci(this);
  }
}
let jr = 0, zs, Gs;
function qr(t, e = !1) {
  if (t.flags |= 8, e) {
    t.next = Gs, Gs = t;
    return;
  }
  t.next = zs, zs = t;
}
function Ji() {
  jr++;
}
function Xi() {
  if (--jr > 0)
    return;
  if (Gs) {
    let e = Gs;
    for (Gs = void 0; e; ) {
      const s = e.next;
      e.next = void 0, e.flags &= -9, e = s;
    }
  }
  let t;
  for (; zs; ) {
    let e = zs;
    for (zs = void 0; e; ) {
      const s = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (n) {
          t || (t = n);
        }
      e = s;
    }
  }
  if (t) throw t;
}
function Hr(t) {
  for (let e = t.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function Wr(t) {
  let e, s = t.depsTail, n = s;
  for (; n; ) {
    const i = n.prevDep;
    n.version === -1 ? (n === s && (s = i), Zi(n), Rl(n)) : e = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = i;
  }
  t.deps = e, t.depsTail = s;
}
function Ci(t) {
  for (let e = t.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (Kr(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!t._dirty;
}
function Kr(t) {
  if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17, t.globalVersion === Zs) || (t.globalVersion = Zs, !t.isSSR && t.flags & 128 && (!t.deps && !t._dirty || !Ci(t))))
    return;
  t.flags |= 2;
  const e = t.dep, s = Ne, n = ht;
  Ne = t, ht = !0;
  try {
    Hr(t);
    const i = t.fn(t._value);
    (e.version === 0 || nt(i, t._value)) && (t.flags |= 128, t._value = i, e.version++);
  } catch (i) {
    throw e.version++, i;
  } finally {
    Ne = s, ht = n, Wr(t), t.flags &= -3;
  }
}
function Zi(t, e = !1) {
  const { dep: s, prevSub: n, nextSub: i } = t;
  if (n && (n.nextSub = i, t.prevSub = void 0), i && (i.prevSub = n, t.nextSub = void 0), Ce.NODE_ENV !== "production" && s.subsHead === t && (s.subsHead = i), s.subs === t && (s.subs = n, !n && s.computed)) {
    s.computed.flags &= -5;
    for (let o = s.computed.deps; o; o = o.nextDep)
      Zi(o, !0);
  }
  !e && !--s.sc && s.map && s.map.delete(s.key);
}
function Rl(t) {
  const { prevDep: e, nextDep: s } = t;
  e && (e.nextDep = s, t.prevDep = void 0), s && (s.prevDep = e, t.nextDep = void 0);
}
let ht = !0;
const zr = [];
function gt() {
  zr.push(ht), ht = !1;
}
function Et() {
  const t = zr.pop();
  ht = t === void 0 ? !0 : t;
}
function Oo(t) {
  const { cleanup: e } = t;
  if (t.cleanup = void 0, e) {
    const s = Ne;
    Ne = void 0;
    try {
      e();
    } finally {
      Ne = s;
    }
  }
}
let Zs = 0;
class Ll {
  constructor(e, s) {
    this.sub = e, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class ei {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0, Ce.NODE_ENV !== "production" && (this.subsHead = void 0);
  }
  track(e) {
    if (!Ne || !ht || Ne === this.computed)
      return;
    let s = this.activeLink;
    if (s === void 0 || s.sub !== Ne)
      s = this.activeLink = new Ll(Ne, this), Ne.deps ? (s.prevDep = Ne.depsTail, Ne.depsTail.nextDep = s, Ne.depsTail = s) : Ne.deps = Ne.depsTail = s, Gr(s);
    else if (s.version === -1 && (s.version = this.version, s.nextDep)) {
      const n = s.nextDep;
      n.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = n), s.prevDep = Ne.depsTail, s.nextDep = void 0, Ne.depsTail.nextDep = s, Ne.depsTail = s, Ne.deps === s && (Ne.deps = n);
    }
    return Ce.NODE_ENV !== "production" && Ne.onTrack && Ne.onTrack(
      Ve(
        {
          effect: Ne
        },
        e
      )
    ), s;
  }
  trigger(e) {
    this.version++, Zs++, this.notify(e);
  }
  notify(e) {
    Ji();
    try {
      if (Ce.NODE_ENV !== "production")
        for (let s = this.subsHead; s; s = s.nextSub)
          s.sub.onTrigger && !(s.sub.flags & 8) && s.sub.onTrigger(
            Ve(
              {
                effect: s.sub
              },
              e
            )
          );
      for (let s = this.subs; s; s = s.prevSub)
        s.sub.notify() && s.sub.dep.notify();
    } finally {
      Xi();
    }
  }
}
function Gr(t) {
  if (t.dep.sc++, t.sub.flags & 4) {
    const e = t.dep.computed;
    if (e && !t.dep.subs) {
      e.flags |= 20;
      for (let n = e.deps; n; n = n.nextDep)
        Gr(n);
    }
    const s = t.dep.subs;
    s !== t && (t.prevSub = s, s && (s.nextSub = t)), Ce.NODE_ENV !== "production" && t.dep.subsHead === void 0 && (t.dep.subsHead = t), t.dep.subs = t;
  }
}
const wi = /* @__PURE__ */ new WeakMap(), hs = /* @__PURE__ */ Symbol(
  Ce.NODE_ENV !== "production" ? "Object iterate" : ""
), Di = /* @__PURE__ */ Symbol(
  Ce.NODE_ENV !== "production" ? "Map keys iterate" : ""
), en = /* @__PURE__ */ Symbol(
  Ce.NODE_ENV !== "production" ? "Array iterate" : ""
);
function je(t, e, s) {
  if (ht && Ne) {
    let n = wi.get(t);
    n || wi.set(t, n = /* @__PURE__ */ new Map());
    let i = n.get(s);
    i || (n.set(s, i = new ei()), i.map = n, i.key = s), Ce.NODE_ENV !== "production" ? i.track({
      target: t,
      type: e,
      key: s
    }) : i.track();
  }
}
function $t(t, e, s, n, i, o) {
  const r = wi.get(t);
  if (!r) {
    Zs++;
    return;
  }
  const a = (l) => {
    l && (Ce.NODE_ENV !== "production" ? l.trigger({
      target: t,
      type: e,
      key: s,
      newValue: n,
      oldValue: i,
      oldTarget: o
    }) : l.trigger());
  };
  if (Ji(), e === "clear")
    r.forEach(a);
  else {
    const l = z(t), u = l && Yi(s);
    if (l && s === "length") {
      const c = Number(n);
      r.forEach((d, m) => {
        (m === "length" || m === en || !vt(m) && m >= c) && a(d);
      });
    } else
      switch ((s !== void 0 || r.has(void 0)) && a(r.get(s)), u && a(r.get(en)), e) {
        case "add":
          l ? u && a(r.get("length")) : (a(r.get(hs)), ps(t) && a(r.get(Di)));
          break;
        case "delete":
          l || (a(r.get(hs)), ps(t) && a(r.get(Di)));
          break;
        case "set":
          ps(t) && a(r.get(hs));
          break;
      }
  }
  Xi();
}
function ys(t) {
  const e = /* @__PURE__ */ ce(t);
  return e === t ? e : (je(e, "iterate", en), /* @__PURE__ */ Ze(t) ? e : e.map(_t));
}
function ti(t) {
  return je(t = /* @__PURE__ */ ce(t), "iterate", en), t;
}
function Zt(t, e) {
  return /* @__PURE__ */ yt(t) ? $s(/* @__PURE__ */ ns(t) ? _t(e) : e) : _t(e);
}
const kl = {
  __proto__: null,
  [Symbol.iterator]() {
    return vi(this, Symbol.iterator, (t) => Zt(this, t));
  },
  concat(...t) {
    return ys(this).concat(
      ...t.map((e) => z(e) ? ys(e) : e)
    );
  },
  entries() {
    return vi(this, "entries", (t) => (t[1] = Zt(this, t[1]), t));
  },
  every(t, e) {
    return Bt(this, "every", t, e, void 0, arguments);
  },
  filter(t, e) {
    return Bt(
      this,
      "filter",
      t,
      e,
      (s) => s.map((n) => Zt(this, n)),
      arguments
    );
  },
  find(t, e) {
    return Bt(
      this,
      "find",
      t,
      e,
      (s) => Zt(this, s),
      arguments
    );
  },
  findIndex(t, e) {
    return Bt(this, "findIndex", t, e, void 0, arguments);
  },
  findLast(t, e) {
    return Bt(
      this,
      "findLast",
      t,
      e,
      (s) => Zt(this, s),
      arguments
    );
  },
  findLastIndex(t, e) {
    return Bt(this, "findLastIndex", t, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(t, e) {
    return Bt(this, "forEach", t, e, void 0, arguments);
  },
  includes(...t) {
    return bi(this, "includes", t);
  },
  indexOf(...t) {
    return bi(this, "indexOf", t);
  },
  join(t) {
    return ys(this).join(t);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...t) {
    return bi(this, "lastIndexOf", t);
  },
  map(t, e) {
    return Bt(this, "map", t, e, void 0, arguments);
  },
  pop() {
    return Bs(this, "pop");
  },
  push(...t) {
    return Bs(this, "push", t);
  },
  reduce(t, ...e) {
    return $o(this, "reduce", t, e);
  },
  reduceRight(t, ...e) {
    return $o(this, "reduceRight", t, e);
  },
  shift() {
    return Bs(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(t, e) {
    return Bt(this, "some", t, e, void 0, arguments);
  },
  splice(...t) {
    return Bs(this, "splice", t);
  },
  toReversed() {
    return ys(this).toReversed();
  },
  toSorted(t) {
    return ys(this).toSorted(t);
  },
  toSpliced(...t) {
    return ys(this).toSpliced(...t);
  },
  unshift(...t) {
    return Bs(this, "unshift", t);
  },
  values() {
    return vi(this, "values", (t) => Zt(this, t));
  }
};
function vi(t, e, s) {
  const n = ti(t), i = n[e]();
  return n !== t && !/* @__PURE__ */ Ze(t) && (i._next = i.next, i.next = () => {
    const o = i._next();
    return o.done || (o.value = s(o.value)), o;
  }), i;
}
const Pl = Array.prototype;
function Bt(t, e, s, n, i, o) {
  const r = ti(t), a = r !== t && !/* @__PURE__ */ Ze(t), l = r[e];
  if (l !== Pl[e]) {
    const d = l.apply(t, o);
    return a ? _t(d) : d;
  }
  let u = s;
  r !== t && (a ? u = function(d, m) {
    return s.call(this, Zt(t, d), m, t);
  } : s.length > 2 && (u = function(d, m) {
    return s.call(this, d, m, t);
  }));
  const c = l.call(r, u, n);
  return a && i ? i(c) : c;
}
function $o(t, e, s, n) {
  const i = ti(t);
  let o = s;
  return i !== t && (/* @__PURE__ */ Ze(t) ? s.length > 3 && (o = function(r, a, l) {
    return s.call(this, r, a, l, t);
  }) : o = function(r, a, l) {
    return s.call(this, r, Zt(t, a), l, t);
  }), i[e](o, ...n);
}
function bi(t, e, s) {
  const n = /* @__PURE__ */ ce(t);
  je(n, "iterate", en);
  const i = n[e](...s);
  return (i === -1 || i === !1) && /* @__PURE__ */ kn(s[0]) ? (s[0] = /* @__PURE__ */ ce(s[0]), n[e](...s)) : i;
}
function Bs(t, e, s = []) {
  gt(), Ji();
  const n = (/* @__PURE__ */ ce(t))[e].apply(t, s);
  return Xi(), Et(), n;
}
const Bl = /* @__PURE__ */ Yt("__proto__,__v_isRef,__isVue"), Yr = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(vt)
);
function Fl(t) {
  vt(t) || (t = String(t));
  const e = /* @__PURE__ */ ce(this);
  return je(e, "has", t), e.hasOwnProperty(t);
}
class Qr {
  constructor(e = !1, s = !1) {
    this._isReadonly = e, this._isShallow = s;
  }
  get(e, s, n) {
    if (s === "__v_skip") return e.__v_skip;
    const i = this._isReadonly, o = this._isShallow;
    if (s === "__v_isReactive")
      return !i;
    if (s === "__v_isReadonly")
      return i;
    if (s === "__v_isShallow")
      return o;
    if (s === "__v_raw")
      return n === (i ? o ? sa : ta : o ? ea : Zr).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
    const r = z(e);
    if (!i) {
      let l;
      if (r && (l = kl[s]))
        return l;
      if (s === "hasOwnProperty")
        return Fl;
    }
    const a = Reflect.get(
      e,
      s,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      /* @__PURE__ */ Fe(e) ? e : n
    );
    if ((vt(s) ? Yr.has(s) : Bl(s)) || (i || je(e, "get", s), o))
      return a;
    if (/* @__PURE__ */ Fe(a)) {
      const l = r && Yi(s) ? a : a.value;
      return i && ve(l) ? /* @__PURE__ */ $i(l) : l;
    }
    return ve(a) ? i ? /* @__PURE__ */ $i(a) : /* @__PURE__ */ is(a) : a;
  }
}
class Jr extends Qr {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, s, n, i) {
    let o = e[s];
    const r = z(e) && Yi(s);
    if (!this._isShallow) {
      const u = /* @__PURE__ */ yt(o);
      if (!/* @__PURE__ */ Ze(n) && !/* @__PURE__ */ yt(n) && (o = /* @__PURE__ */ ce(o), n = /* @__PURE__ */ ce(n)), !r && /* @__PURE__ */ Fe(o) && !/* @__PURE__ */ Fe(n))
        return u ? (Ce.NODE_ENV !== "production" && bt(
          `Set operation on key "${String(s)}" failed: target is readonly.`,
          e[s]
        ), !0) : (o.value = n, !0);
    }
    const a = r ? Number(s) < e.length : Ee(e, s), l = Reflect.set(
      e,
      s,
      n,
      /* @__PURE__ */ Fe(e) ? e : i
    );
    return e === /* @__PURE__ */ ce(i) && (a ? nt(n, o) && $t(e, "set", s, n, o) : $t(e, "add", s, n)), l;
  }
  deleteProperty(e, s) {
    const n = Ee(e, s), i = e[s], o = Reflect.deleteProperty(e, s);
    return o && n && $t(e, "delete", s, void 0, i), o;
  }
  has(e, s) {
    const n = Reflect.has(e, s);
    return (!vt(s) || !Yr.has(s)) && je(e, "has", s), n;
  }
  ownKeys(e) {
    return je(
      e,
      "iterate",
      z(e) ? "length" : hs
    ), Reflect.ownKeys(e);
  }
}
class Xr extends Qr {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, s) {
    return Ce.NODE_ENV !== "production" && bt(
      `Set operation on key "${String(s)}" failed: target is readonly.`,
      e
    ), !0;
  }
  deleteProperty(e, s) {
    return Ce.NODE_ENV !== "production" && bt(
      `Delete operation on key "${String(s)}" failed: target is readonly.`,
      e
    ), !0;
  }
}
const Ul = /* @__PURE__ */ new Jr(), jl = /* @__PURE__ */ new Xr(), ql = /* @__PURE__ */ new Jr(!0), Hl = /* @__PURE__ */ new Xr(!0), Oi = (t) => t, yn = (t) => Reflect.getPrototypeOf(t);
function Wl(t, e, s) {
  return function(...n) {
    const i = this.__v_raw, o = /* @__PURE__ */ ce(i), r = ps(o), a = t === "entries" || t === Symbol.iterator && r, l = t === "keys" && r, u = i[t](...n), c = s ? Oi : e ? $s : _t;
    return !e && je(
      o,
      "iterate",
      l ? Di : hs
    ), Ve(
      // inheriting all iterator properties
      Object.create(u),
      {
        // iterator protocol
        next() {
          const { value: d, done: m } = u.next();
          return m ? { value: d, done: m } : {
            value: a ? [c(d[0]), c(d[1])] : c(d),
            done: m
          };
        }
      }
    );
  };
}
function _n(t) {
  return function(...e) {
    if (Ce.NODE_ENV !== "production") {
      const s = e[0] ? `on key "${e[0]}" ` : "";
      bt(
        `${Xn(t)} operation ${s}failed: target is readonly.`,
        /* @__PURE__ */ ce(this)
      );
    }
    return t === "delete" ? !1 : t === "clear" ? void 0 : this;
  };
}
function Kl(t, e) {
  const s = {
    get(i) {
      const o = this.__v_raw, r = /* @__PURE__ */ ce(o), a = /* @__PURE__ */ ce(i);
      t || (nt(i, a) && je(r, "get", i), je(r, "get", a));
      const { has: l } = yn(r), u = e ? Oi : t ? $s : _t;
      if (l.call(r, i))
        return u(o.get(i));
      if (l.call(r, a))
        return u(o.get(a));
      o !== r && o.get(i);
    },
    get size() {
      const i = this.__v_raw;
      return !t && je(/* @__PURE__ */ ce(i), "iterate", hs), i.size;
    },
    has(i) {
      const o = this.__v_raw, r = /* @__PURE__ */ ce(o), a = /* @__PURE__ */ ce(i);
      return t || (nt(i, a) && je(r, "has", i), je(r, "has", a)), i === a ? o.has(i) : o.has(i) || o.has(a);
    },
    forEach(i, o) {
      const r = this, a = r.__v_raw, l = /* @__PURE__ */ ce(a), u = e ? Oi : t ? $s : _t;
      return !t && je(l, "iterate", hs), a.forEach((c, d) => i.call(o, u(c), u(d), r));
    }
  };
  return Ve(
    s,
    t ? {
      add: _n("add"),
      set: _n("set"),
      delete: _n("delete"),
      clear: _n("clear")
    } : {
      add(i) {
        !e && !/* @__PURE__ */ Ze(i) && !/* @__PURE__ */ yt(i) && (i = /* @__PURE__ */ ce(i));
        const o = /* @__PURE__ */ ce(this);
        return yn(o).has.call(o, i) || (o.add(i), $t(o, "add", i, i)), this;
      },
      set(i, o) {
        !e && !/* @__PURE__ */ Ze(o) && !/* @__PURE__ */ yt(o) && (o = /* @__PURE__ */ ce(o));
        const r = /* @__PURE__ */ ce(this), { has: a, get: l } = yn(r);
        let u = a.call(r, i);
        u ? Ce.NODE_ENV !== "production" && Ao(r, a, i) : (i = /* @__PURE__ */ ce(i), u = a.call(r, i));
        const c = l.call(r, i);
        return r.set(i, o), u ? nt(o, c) && $t(r, "set", i, o, c) : $t(r, "add", i, o), this;
      },
      delete(i) {
        const o = /* @__PURE__ */ ce(this), { has: r, get: a } = yn(o);
        let l = r.call(o, i);
        l ? Ce.NODE_ENV !== "production" && Ao(o, r, i) : (i = /* @__PURE__ */ ce(i), l = r.call(o, i));
        const u = a ? a.call(o, i) : void 0, c = o.delete(i);
        return l && $t(o, "delete", i, void 0, u), c;
      },
      clear() {
        const i = /* @__PURE__ */ ce(this), o = i.size !== 0, r = Ce.NODE_ENV !== "production" ? ps(i) ? new Map(i) : new Set(i) : void 0, a = i.clear();
        return o && $t(
          i,
          "clear",
          void 0,
          void 0,
          r
        ), a;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((i) => {
    s[i] = Wl(i, t, e);
  }), s;
}
function si(t, e) {
  const s = Kl(t, e);
  return (n, i, o) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? n : Reflect.get(
    Ee(s, i) && i in n ? s : n,
    i,
    o
  );
}
const zl = {
  get: /* @__PURE__ */ si(!1, !1)
}, Gl = {
  get: /* @__PURE__ */ si(!1, !0)
}, Yl = {
  get: /* @__PURE__ */ si(!0, !1)
}, Ql = {
  get: /* @__PURE__ */ si(!0, !0)
};
function Ao(t, e, s) {
  const n = /* @__PURE__ */ ce(s);
  if (n !== s && e.call(t, n)) {
    const i = Gi(t);
    bt(
      `Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const Zr = /* @__PURE__ */ new WeakMap(), ea = /* @__PURE__ */ new WeakMap(), ta = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap();
function Jl(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Xl(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : Jl(Gi(t));
}
// @__NO_SIDE_EFFECTS__
function is(t) {
  return /* @__PURE__ */ yt(t) ? t : ni(
    t,
    !1,
    Ul,
    zl,
    Zr
  );
}
// @__NO_SIDE_EFFECTS__
function Zl(t) {
  return ni(
    t,
    !1,
    ql,
    Gl,
    ea
  );
}
// @__NO_SIDE_EFFECTS__
function $i(t) {
  return ni(
    t,
    !0,
    jl,
    Yl,
    ta
  );
}
// @__NO_SIDE_EFFECTS__
function Vt(t) {
  return ni(
    t,
    !0,
    Hl,
    Ql,
    sa
  );
}
function ni(t, e, s, n, i) {
  if (!ve(t))
    return Ce.NODE_ENV !== "production" && bt(
      `value cannot be made ${e ? "readonly" : "reactive"}: ${String(
        t
      )}`
    ), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const o = Xl(t);
  if (o === 0)
    return t;
  const r = i.get(t);
  if (r)
    return r;
  const a = new Proxy(
    t,
    o === 2 ? n : s
  );
  return i.set(t, a), a;
}
// @__NO_SIDE_EFFECTS__
function ns(t) {
  return /* @__PURE__ */ yt(t) ? /* @__PURE__ */ ns(t.__v_raw) : !!(t && t.__v_isReactive);
}
// @__NO_SIDE_EFFECTS__
function yt(t) {
  return !!(t && t.__v_isReadonly);
}
// @__NO_SIDE_EFFECTS__
function Ze(t) {
  return !!(t && t.__v_isShallow);
}
// @__NO_SIDE_EFFECTS__
function kn(t) {
  return t ? !!t.__v_raw : !1;
}
// @__NO_SIDE_EFFECTS__
function ce(t) {
  const e = t && t.__v_raw;
  return e ? /* @__PURE__ */ ce(e) : t;
}
function ec(t) {
  return !Ee(t, "__v_skip") && Object.isExtensible(t) && Ln(t, "__v_skip", !0), t;
}
const _t = (t) => ve(t) ? /* @__PURE__ */ is(t) : t, $s = (t) => ve(t) ? /* @__PURE__ */ $i(t) : t;
// @__NO_SIDE_EFFECTS__
function Fe(t) {
  return t ? t.__v_isRef === !0 : !1;
}
// @__NO_SIDE_EFFECTS__
function q(t) {
  return tc(t, !1);
}
function tc(t, e) {
  return /* @__PURE__ */ Fe(t) ? t : new sc(t, e);
}
class sc {
  constructor(e, s) {
    this.dep = new ei(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? e : /* @__PURE__ */ ce(e), this._value = s ? e : _t(e), this.__v_isShallow = s;
  }
  get value() {
    return Ce.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track(), this._value;
  }
  set value(e) {
    const s = this._rawValue, n = this.__v_isShallow || /* @__PURE__ */ Ze(e) || /* @__PURE__ */ yt(e);
    e = n ? e : /* @__PURE__ */ ce(e), nt(e, s) && (this._rawValue = e, this._value = n ? e : _t(e), Ce.NODE_ENV !== "production" ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: e,
      oldValue: s
    }) : this.dep.trigger());
  }
}
function Q(t) {
  return /* @__PURE__ */ Fe(t) ? t.value : t;
}
const nc = {
  get: (t, e, s) => e === "__v_raw" ? t : Q(Reflect.get(t, e, s)),
  set: (t, e, s, n) => {
    const i = t[e];
    return /* @__PURE__ */ Fe(i) && !/* @__PURE__ */ Fe(s) ? (i.value = s, !0) : Reflect.set(t, e, s, n);
  }
};
function na(t) {
  return /* @__PURE__ */ ns(t) ? t : new Proxy(t, nc);
}
class ic {
  constructor(e) {
    this.__v_isRef = !0, this._value = void 0;
    const s = this.dep = new ei(), { get: n, set: i } = e(s.track.bind(s), s.trigger.bind(s));
    this._get = n, this._set = i;
  }
  get value() {
    return this._value = this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function oc(t) {
  return new ic(t);
}
class rc {
  constructor(e, s, n) {
    this.fn = e, this.setter = s, this._value = void 0, this.dep = new ei(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Zs - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !s, this.isSSR = n;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Ne !== this)
      return qr(this, !0), !0;
  }
  get value() {
    const e = Ce.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    return Kr(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter ? this.setter(e) : Ce.NODE_ENV !== "production" && bt("Write operation failed: computed value is readonly");
  }
}
// @__NO_SIDE_EFFECTS__
function ac(t, e, s = !1) {
  let n, i;
  return Z(t) ? n = t : (n = t.get, i = t.set), new rc(n, i, s);
}
const Tn = {}, Pn = /* @__PURE__ */ new WeakMap();
let us;
function lc(t, e = !1, s = us) {
  if (s) {
    let n = Pn.get(s);
    n || Pn.set(s, n = []), n.push(t);
  } else Ce.NODE_ENV !== "production" && !e && bt(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function cc(t, e, s = ye) {
  const { immediate: n, deep: i, once: o, scheduler: r, augmentJob: a, call: l } = s, u = (M) => {
    (s.onWarn || bt)(
      "Invalid watch source: ",
      M,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, c = (M) => i ? M : /* @__PURE__ */ Ze(M) || i === !1 || i === 0 ? Ht(M, 1) : Ht(M);
  let d, m, h, g, y = !1, _ = !1;
  if (/* @__PURE__ */ Fe(t) ? (m = () => t.value, y = /* @__PURE__ */ Ze(t)) : /* @__PURE__ */ ns(t) ? (m = () => c(t), y = !0) : z(t) ? (_ = !0, y = t.some((M) => /* @__PURE__ */ ns(M) || /* @__PURE__ */ Ze(M)), m = () => t.map((M) => {
    if (/* @__PURE__ */ Fe(M))
      return M.value;
    if (/* @__PURE__ */ ns(M))
      return c(M);
    if (Z(M))
      return l ? l(M, 2) : M();
    Ce.NODE_ENV !== "production" && u(M);
  })) : Z(t) ? e ? m = l ? () => l(t, 2) : t : m = () => {
    if (h) {
      gt();
      try {
        h();
      } finally {
        Et();
      }
    }
    const M = us;
    us = d;
    try {
      return l ? l(t, 3, [g]) : t(g);
    } finally {
      us = M;
    }
  } : (m = qe, Ce.NODE_ENV !== "production" && u(t)), e && i) {
    const M = m, K = i === !0 ? 1 / 0 : i;
    m = () => Ht(M(), K);
  }
  const E = Il(), x = () => {
    d.stop(), E && E.active && Ki(E.effects, d);
  };
  if (o && e) {
    const M = e;
    e = (...K) => {
      M(...K), x();
    };
  }
  let T = _ ? new Array(t.length).fill(Tn) : Tn;
  const O = (M) => {
    if (!(!(d.flags & 1) || !d.dirty && !M))
      if (e) {
        const K = d.run();
        if (i || y || (_ ? K.some((pe, he) => nt(pe, T[he])) : nt(K, T))) {
          h && h();
          const pe = us;
          us = d;
          try {
            const he = [
              K,
              // pass undefined as the old value when it's changed for the first time
              T === Tn ? void 0 : _ && T[0] === Tn ? [] : T,
              g
            ];
            T = K, l ? l(e, 3, he) : (
              // @ts-expect-error
              e(...he)
            );
          } finally {
            us = pe;
          }
        }
      } else
        d.run();
  };
  return a && a(O), d = new Ur(m), d.scheduler = r ? () => r(O, !1) : O, g = (M) => lc(M, !1, d), h = d.onStop = () => {
    const M = Pn.get(d);
    if (M) {
      if (l)
        l(M, 4);
      else
        for (const K of M) K();
      Pn.delete(d);
    }
  }, Ce.NODE_ENV !== "production" && (d.onTrack = s.onTrack, d.onTrigger = s.onTrigger), e ? n ? O(!0) : T = d.run() : r ? r(O.bind(null, !0), !0) : d.run(), x.pause = d.pause.bind(d), x.resume = d.resume.bind(d), x.stop = x, x;
}
function Ht(t, e = 1 / 0, s) {
  if (e <= 0 || !ve(t) || t.__v_skip || (s = s || /* @__PURE__ */ new Map(), (s.get(t) || 0) >= e))
    return t;
  if (s.set(t, e), e--, /* @__PURE__ */ Fe(t))
    Ht(t.value, e, s);
  else if (z(t))
    for (let n = 0; n < t.length; n++)
      Ht(t[n], e, s);
  else if (Ms(t) || ps(t))
    t.forEach((n) => {
      Ht(n, e, s);
    });
  else if (kr(t)) {
    for (const n in t)
      Ht(t[n], e, s);
    for (const n of Object.getOwnPropertySymbols(t))
      Object.prototype.propertyIsEnumerable.call(t, n) && Ht(t[n], e, s);
  }
  return t;
}
var b = {};
const ms = [];
function wn(t) {
  ms.push(t);
}
function Dn() {
  ms.pop();
}
let gi = !1;
function R(t, ...e) {
  if (gi) return;
  gi = !0, gt();
  const s = ms.length ? ms[ms.length - 1].component : null, n = s && s.appContext.config.warnHandler, i = uc();
  if (n)
    Rs(
      n,
      s,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        t + e.map((o) => {
          var r, a;
          return (a = (r = o.toString) == null ? void 0 : r.call(o)) != null ? a : JSON.stringify(o);
        }).join(""),
        s && s.proxy,
        i.map(
          ({ vnode: o }) => `at <${bn(s, o.type)}>`
        ).join(`
`),
        i
      ]
    );
  else {
    const o = [`[Vue warn]: ${t}`, ...e];
    i.length && o.push(`
`, ...dc(i)), console.warn(...o);
  }
  Et(), gi = !1;
}
function uc() {
  let t = ms[ms.length - 1];
  if (!t)
    return [];
  const e = [];
  for (; t; ) {
    const s = e[0];
    s && s.vnode === t ? s.recurseCount++ : e.push({
      vnode: t,
      recurseCount: 0
    });
    const n = t.component && t.component.parent;
    t = n && n.vnode;
  }
  return e;
}
function dc(t) {
  const e = [];
  return t.forEach((s, n) => {
    e.push(...n === 0 ? [] : [`
`], ...fc(s));
  }), e;
}
function fc({ vnode: t, recurseCount: e }) {
  const s = e > 0 ? `... (${e} recursive calls)` : "", n = t.component ? t.component.parent == null : !1, i = ` at <${bn(
    t.component,
    t.type,
    n
  )}`, o = ">" + s;
  return t.props ? [i, ...pc(t.props), o] : [i + o];
}
function pc(t) {
  const e = [], s = Object.keys(t);
  return s.slice(0, 3).forEach((n) => {
    e.push(...ia(n, t[n]));
  }), s.length > 3 && e.push(" ..."), e;
}
function ia(t, e, s) {
  return Me(e) ? (e = JSON.stringify(e), s ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? s ? e : [`${t}=${e}`] : /* @__PURE__ */ Fe(e) ? (e = ia(t, /* @__PURE__ */ ce(e.value), !0), s ? e : [`${t}=Ref<`, e, ">"]) : Z(e) ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`] : (e = /* @__PURE__ */ ce(e), s ? e : [`${t}=`, e]);
}
function hc(t, e) {
  b.NODE_ENV !== "production" && t !== void 0 && (typeof t != "number" ? R(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && R(`${e} is NaN - the duration expression might be incorrect.`));
}
const eo = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function Rs(t, e, s, n) {
  try {
    return n ? t(...n) : t();
  } catch (i) {
    dn(i, e, s);
  }
}
function Tt(t, e, s, n) {
  if (Z(t)) {
    const i = Rs(t, e, s, n);
    return i && zi(i) && i.catch((o) => {
      dn(o, e, s);
    }), i;
  }
  if (z(t)) {
    const i = [];
    for (let o = 0; o < t.length; o++)
      i.push(Tt(t[o], e, s, n));
    return i;
  } else b.NODE_ENV !== "production" && R(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof t}`
  );
}
function dn(t, e, s, n = !0) {
  const i = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: r } = e && e.appContext.config || ye;
  if (e) {
    let a = e.parent;
    const l = e.proxy, u = b.NODE_ENV !== "production" ? eo[s] : `https://vuejs.org/error-reference/#runtime-${s}`;
    for (; a; ) {
      const c = a.ec;
      if (c) {
        for (let d = 0; d < c.length; d++)
          if (c[d](t, l, u) === !1)
            return;
      }
      a = a.parent;
    }
    if (o) {
      gt(), Rs(o, null, 10, [
        t,
        l,
        u
      ]), Et();
      return;
    }
  }
  mc(t, s, i, n, r);
}
function mc(t, e, s, n = !0, i = !1) {
  if (b.NODE_ENV !== "production") {
    const o = eo[e];
    if (s && wn(s), R(`Unhandled error${o ? ` during execution of ${o}` : ""}`), s && Dn(), n)
      throw t;
    console.error(t);
  } else {
    if (i)
      throw t;
    console.error(t);
  }
}
const Je = [];
let Dt = -1;
const Cs = [];
let es = null, xs = 0;
const oa = /* @__PURE__ */ Promise.resolve();
let Bn = null;
const vc = 100;
function It(t) {
  const e = Bn || oa;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function bc(t) {
  let e = Dt + 1, s = Je.length;
  for (; e < s; ) {
    const n = e + s >>> 1, i = Je[n], o = tn(i);
    o < t || o === t && i.flags & 2 ? e = n + 1 : s = n;
  }
  return e;
}
function ii(t) {
  if (!(t.flags & 1)) {
    const e = tn(t), s = Je[Je.length - 1];
    !s || // fast path when the job id is larger than the tail
    !(t.flags & 2) && e >= tn(s) ? Je.push(t) : Je.splice(bc(e), 0, t), t.flags |= 1, ra();
  }
}
function ra() {
  Bn || (Bn = oa.then(ca));
}
function aa(t) {
  z(t) ? Cs.push(...t) : es && t.id === -1 ? es.splice(xs + 1, 0, t) : t.flags & 1 || (Cs.push(t), t.flags |= 1), ra();
}
function Vo(t, e, s = Dt + 1) {
  for (b.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()); s < Je.length; s++) {
    const n = Je[s];
    if (n && n.flags & 2) {
      if (t && n.id !== t.uid || b.NODE_ENV !== "production" && to(e, n))
        continue;
      Je.splice(s, 1), s--, n.flags & 4 && (n.flags &= -2), n(), n.flags & 4 || (n.flags &= -2);
    }
  }
}
function la(t) {
  if (Cs.length) {
    const e = [...new Set(Cs)].sort(
      (s, n) => tn(s) - tn(n)
    );
    if (Cs.length = 0, es) {
      es.push(...e);
      return;
    }
    for (es = e, b.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), xs = 0; xs < es.length; xs++) {
      const s = es[xs];
      b.NODE_ENV !== "production" && to(t, s) || (s.flags & 4 && (s.flags &= -2), s.flags & 8 || s(), s.flags &= -2);
    }
    es = null, xs = 0;
  }
}
const tn = (t) => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id;
function ca(t) {
  b.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map());
  const e = b.NODE_ENV !== "production" ? (s) => to(t, s) : qe;
  try {
    for (Dt = 0; Dt < Je.length; Dt++) {
      const s = Je[Dt];
      if (s && !(s.flags & 8)) {
        if (b.NODE_ENV !== "production" && e(s))
          continue;
        s.flags & 4 && (s.flags &= -2), Rs(
          s,
          s.i,
          s.i ? 15 : 14
        ), s.flags & 4 || (s.flags &= -2);
      }
    }
  } finally {
    for (; Dt < Je.length; Dt++) {
      const s = Je[Dt];
      s && (s.flags &= -2);
    }
    Dt = -1, Je.length = 0, la(t), Bn = null, (Je.length || Cs.length) && ca(t);
  }
}
function to(t, e) {
  const s = t.get(e) || 0;
  if (s > vc) {
    const n = e.i, i = n && el(n.type);
    return dn(
      `Maximum recursive updates exceeded${i ? ` in component <${i}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), !0;
  }
  return t.set(e, s + 1), !1;
}
let pt = !1;
const On = /* @__PURE__ */ new Map();
b.NODE_ENV !== "production" && (un().__VUE_HMR_RUNTIME__ = {
  createRecord: Ei(ua),
  rerender: Ei(yc),
  reload: Ei(_c)
});
const gs = /* @__PURE__ */ new Map();
function gc(t) {
  const e = t.type.__hmrId;
  let s = gs.get(e);
  s || (ua(e, t.type), s = gs.get(e)), s.instances.add(t);
}
function Ec(t) {
  gs.get(t.type.__hmrId).instances.delete(t);
}
function ua(t, e) {
  return gs.has(t) ? !1 : (gs.set(t, {
    initialDef: Fn(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Fn(t) {
  return tl(t) ? t.__vccOpts : t;
}
function yc(t, e) {
  const s = gs.get(t);
  s && (s.initialDef.render = e, [...s.instances].forEach((n) => {
    e && (n.render = e, Fn(n.type).render = e), n.renderCache = [], pt = !0, n.job.flags & 8 || n.update(), pt = !1;
  }));
}
function _c(t, e) {
  const s = gs.get(t);
  if (!s) return;
  e = Fn(e), Mo(s.initialDef, e);
  const n = [...s.instances];
  for (let i = 0; i < n.length; i++) {
    const o = n[i], r = Fn(o.type);
    let a = On.get(r);
    a || (r !== s.initialDef && Mo(r, e), On.set(r, a = /* @__PURE__ */ new Set())), a.add(o), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (a.add(o), o.ceReload(e.styles), a.delete(o)) : o.parent ? ii(() => {
      o.job.flags & 8 || (pt = !0, o.parent.update(), pt = !1, a.delete(o));
    }) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), o.root.ce && o !== o.root && o.root.ce._removeChildStyle(r);
  }
  aa(() => {
    On.clear();
  });
}
function Mo(t, e) {
  Ve(t, e);
  for (const s in t)
    s !== "__file" && !(s in e) && delete t[s];
}
function Ei(t) {
  return (e, s) => {
    try {
      return t(e, s);
    } catch (n) {
      console.error(n), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let At, Hs = [], Ai = !1;
function fn(t, ...e) {
  At ? At.emit(t, ...e) : Ai || Hs.push({ event: t, args: e });
}
function da(t, e) {
  var s, n;
  At = t, At ? (At.enabled = !0, Hs.forEach(({ event: i, args: o }) => At.emit(i, ...o)), Hs = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((n = (s = window.navigator) == null ? void 0 : s.userAgent) != null && n.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((o) => {
    da(o, e);
  }), setTimeout(() => {
    At || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Ai = !0, Hs = []);
  }, 3e3)) : (Ai = !0, Hs = []);
}
function Tc(t, e) {
  fn("app:init", t, e, {
    Fragment: Ae,
    Text: mn,
    Comment: Be,
    Static: Vn
  });
}
function Nc(t) {
  fn("app:unmount", t);
}
const xc = /* @__PURE__ */ so(
  "component:added"
  /* COMPONENT_ADDED */
), fa = /* @__PURE__ */ so(
  "component:updated"
  /* COMPONENT_UPDATED */
), Sc = /* @__PURE__ */ so(
  "component:removed"
  /* COMPONENT_REMOVED */
), Cc = (t) => {
  At && typeof At.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !At.cleanupBuffer(t) && Sc(t);
};
// @__NO_SIDE_EFFECTS__
function so(t) {
  return (e) => {
    fn(
      t,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const wc = /* @__PURE__ */ pa(
  "perf:start"
  /* PERFORMANCE_START */
), Dc = /* @__PURE__ */ pa(
  "perf:end"
  /* PERFORMANCE_END */
);
function pa(t) {
  return (e, s, n) => {
    fn(t, e.appContext.app, e.uid, e, s, n);
  };
}
function Oc(t, e, s) {
  fn(
    "component:emit",
    t.appContext.app,
    t,
    e,
    s
  );
}
let He = null, ha = null;
function Un(t) {
  const e = He;
  return He = t, ha = t && t.type.__scopeId || null, e;
}
function B(t, e = He, s) {
  if (!e || t._n)
    return t;
  const n = (...i) => {
    n._d && zn(-1);
    const o = Un(e);
    let r;
    try {
      r = t(...i);
    } finally {
      Un(o), n._d && zn(1);
    }
    return b.NODE_ENV !== "production" && fa(e), r;
  };
  return n._n = !0, n._c = !0, n._d = !0, n;
}
function ma(t) {
  vl(t) && R("Do not use built-in directive ids as custom directive id: " + t);
}
function Xe(t, e) {
  if (He === null)
    return b.NODE_ENV !== "production" && R("withDirectives can only be used inside render functions."), t;
  const s = li(He), n = t.dirs || (t.dirs = []);
  for (let i = 0; i < e.length; i++) {
    let [o, r, a, l = ye] = e[i];
    o && (Z(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Ht(r), n.push({
      dir: o,
      instance: s,
      value: r,
      oldValue: void 0,
      arg: a,
      modifiers: l
    }));
  }
  return t;
}
function os(t, e, s, n) {
  const i = t.dirs, o = e && e.dirs;
  for (let r = 0; r < i.length; r++) {
    const a = i[r];
    o && (a.oldValue = o[r].value);
    let l = a.dir[n];
    l && (gt(), Tt(l, s, 8, [
      t.el,
      a,
      t,
      e
    ]), Et());
  }
}
function $c(t, e) {
  if (b.NODE_ENV !== "production" && (!Ue || Ue.isMounted) && R("provide() can only be used inside setup()."), Ue) {
    let s = Ue.provides;
    const n = Ue.parent && Ue.parent.provides;
    n === s && (s = Ue.provides = Object.create(n)), s[t] = e;
  }
}
function $n(t, e, s = !1) {
  const n = ai();
  if (n || Ds) {
    let i = Ds ? Ds._context.provides : n ? n.parent == null || n.ce ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0;
    if (i && t in i)
      return i[t];
    if (arguments.length > 1)
      return s && Z(e) ? e.call(n && n.proxy) : e;
    b.NODE_ENV !== "production" && R(`injection "${String(t)}" not found.`);
  } else b.NODE_ENV !== "production" && R("inject() can only be used inside setup() or functional components.");
}
const Ac = /* @__PURE__ */ Symbol.for("v-scx"), Vc = () => {
  {
    const t = $n(Ac);
    return t || b.NODE_ENV !== "production" && R(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), t;
  }
};
function Mc(t, e) {
  return no(
    t,
    null,
    b.NODE_ENV !== "production" ? Ve({}, e, { flush: "sync" }) : { flush: "sync" }
  );
}
function it(t, e, s) {
  return b.NODE_ENV !== "production" && !Z(e) && R(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), no(t, e, s);
}
function no(t, e, s = ye) {
  const { immediate: n, deep: i, flush: o, once: r } = s;
  b.NODE_ENV !== "production" && !e && (n !== void 0 && R(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), i !== void 0 && R(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), r !== void 0 && R(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const a = Ve({}, s);
  b.NODE_ENV !== "production" && (a.onWarn = R);
  const l = e && n || !e && o !== "post";
  let u;
  if (on) {
    if (o === "sync") {
      const h = Vc();
      u = h.__watcherHandles || (h.__watcherHandles = []);
    } else if (!l) {
      const h = () => {
      };
      return h.stop = qe, h.resume = qe, h.pause = qe, h;
    }
  }
  const c = Ue;
  a.call = (h, g, y) => Tt(h, c, g, y);
  let d = !1;
  o === "post" ? a.scheduler = (h) => {
    ze(h, c && c.suspense);
  } : o !== "sync" && (d = !0, a.scheduler = (h, g) => {
    g ? h() : ii(h);
  }), a.augmentJob = (h) => {
    e && (h.flags |= 4), d && (h.flags |= 2, c && (h.id = c.uid, h.i = c));
  };
  const m = cc(t, e, a);
  return on && (u ? u.push(m) : l && m()), m;
}
function Ic(t, e, s) {
  const n = this.proxy, i = Me(t) ? t.includes(".") ? va(n, t) : () => n[t] : t.bind(n, n);
  let o;
  Z(e) ? o = e : (o = e.handler, s = e);
  const r = vn(this), a = no(i, o.bind(n), s);
  return r(), a;
}
function va(t, e) {
  const s = e.split(".");
  return () => {
    let n = t;
    for (let i = 0; i < s.length && n; i++)
      n = n[s[i]];
    return n;
  };
}
const ba = /* @__PURE__ */ Symbol("_vte"), ga = (t) => t.__isTeleport, vs = (t) => t && (t.disabled || t.disabled === ""), Io = (t) => t && (t.defer || t.defer === ""), Ro = (t) => typeof SVGElement < "u" && t instanceof SVGElement, Lo = (t) => typeof MathMLElement == "function" && t instanceof MathMLElement, Vi = (t, e) => {
  const s = t && t.to;
  if (Me(s))
    if (e) {
      const n = e(s);
      return b.NODE_ENV !== "production" && !n && !vs(t) && R(
        `Failed to locate Teleport target with selector "${s}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), n;
    } else
      return b.NODE_ENV !== "production" && R(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return b.NODE_ENV !== "production" && !s && !vs(t) && R(`Invalid Teleport target: ${s}`), s;
}, Ea = {
  name: "Teleport",
  __isTeleport: !0,
  process(t, e, s, n, i, o, r, a, l, u) {
    const {
      mc: c,
      pc: d,
      pbc: m,
      o: { insert: h, querySelector: g, createText: y, createComment: _ }
    } = u, E = vs(e.props);
    let { shapeFlag: x, children: T, dynamicChildren: O } = e;
    if (b.NODE_ENV !== "production" && pt && (l = !1, O = null), t == null) {
      const M = e.el = b.NODE_ENV !== "production" ? _("teleport start") : y(""), K = e.anchor = b.NODE_ENV !== "production" ? _("teleport end") : y("");
      h(M, s, n), h(K, s, n);
      const pe = (H, re) => {
        x & 16 && c(
          T,
          H,
          re,
          i,
          o,
          r,
          a,
          l
        );
      }, he = () => {
        const H = e.target = Vi(e.props, g), re = Mi(H, e, y, h);
        H ? (r !== "svg" && Ro(H) ? r = "svg" : r !== "mathml" && Lo(H) && (r = "mathml"), i && i.isCE && (i.ce._teleportTargets || (i.ce._teleportTargets = /* @__PURE__ */ new Set())).add(H), E || (pe(H, re), An(e, !1))) : b.NODE_ENV !== "production" && !E && R(
          "Invalid Teleport target on mount:",
          H,
          `(${typeof H})`
        );
      };
      E && (pe(s, K), An(e, !0)), Io(e.props) ? (e.el.__isMounted = !1, ze(() => {
        he(), delete e.el.__isMounted;
      }, o)) : he();
    } else {
      if (Io(e.props) && t.el.__isMounted === !1) {
        ze(() => {
          Ea.process(
            t,
            e,
            s,
            n,
            i,
            o,
            r,
            a,
            l,
            u
          );
        }, o);
        return;
      }
      e.el = t.el, e.targetStart = t.targetStart;
      const M = e.anchor = t.anchor, K = e.target = t.target, pe = e.targetAnchor = t.targetAnchor, he = vs(t.props), H = he ? s : K, re = he ? M : pe;
      if (r === "svg" || Ro(K) ? r = "svg" : (r === "mathml" || Lo(K)) && (r = "mathml"), O ? (m(
        t.dynamicChildren,
        O,
        H,
        i,
        o,
        r,
        a
      ), Qs(t, e, b.NODE_ENV === "production")) : l || d(
        t,
        e,
        H,
        re,
        i,
        o,
        r,
        a,
        !1
      ), E)
        he ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : Nn(
          e,
          s,
          M,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
        const me = e.target = Vi(
          e.props,
          g
        );
        me ? Nn(
          e,
          me,
          null,
          u,
          0
        ) : b.NODE_ENV !== "production" && R(
          "Invalid Teleport target on update:",
          K,
          `(${typeof K})`
        );
      } else he && Nn(
        e,
        K,
        pe,
        u,
        1
      );
      An(e, E);
    }
  },
  remove(t, e, s, { um: n, o: { remove: i } }, o) {
    const {
      shapeFlag: r,
      children: a,
      anchor: l,
      targetStart: u,
      targetAnchor: c,
      target: d,
      props: m
    } = t;
    if (d && (i(u), i(c)), o && i(l), r & 16) {
      const h = o || !vs(m);
      for (let g = 0; g < a.length; g++) {
        const y = a[g];
        n(
          y,
          e,
          s,
          h,
          !!y.dynamicChildren
        );
      }
    }
  },
  move: Nn,
  hydrate: Rc
};
function Nn(t, e, s, { o: { insert: n }, m: i }, o = 2) {
  o === 0 && n(t.targetAnchor, e, s);
  const { el: r, anchor: a, shapeFlag: l, children: u, props: c } = t, d = o === 2;
  if (d && n(r, e, s), (!d || vs(c)) && l & 16)
    for (let m = 0; m < u.length; m++)
      i(
        u[m],
        e,
        s,
        2
      );
  d && n(a, e, s);
}
function Rc(t, e, s, n, i, o, {
  o: { nextSibling: r, parentNode: a, querySelector: l, insert: u, createText: c }
}, d) {
  function m(_, E) {
    let x = E;
    for (; x; ) {
      if (x && x.nodeType === 8) {
        if (x.data === "teleport start anchor")
          e.targetStart = x;
        else if (x.data === "teleport anchor") {
          e.targetAnchor = x, _._lpa = e.targetAnchor && r(e.targetAnchor);
          break;
        }
      }
      x = r(x);
    }
  }
  function h(_, E) {
    E.anchor = d(
      r(_),
      E,
      a(_),
      s,
      n,
      i,
      o
    );
  }
  const g = e.target = Vi(
    e.props,
    l
  ), y = vs(e.props);
  if (g) {
    const _ = g._lpa || g.firstChild;
    e.shapeFlag & 16 && (y ? (h(t, e), m(g, _), e.targetAnchor || Mi(
      g,
      e,
      c,
      u,
      // if target is the same as the main view, insert anchors before current node
      // to avoid hydrating mismatch
      a(t) === g ? t : null
    )) : (e.anchor = r(t), m(g, _), e.targetAnchor || Mi(g, e, c, u), d(
      _ && r(_),
      e,
      g,
      s,
      n,
      i,
      o
    ))), An(e, y);
  } else y && e.shapeFlag & 16 && (h(t, e), e.targetStart = t, e.targetAnchor = r(t));
  return e.anchor && r(e.anchor);
}
const ya = Ea;
function An(t, e) {
  const s = t.ctx;
  if (s && s.ut) {
    let n, i;
    for (e ? (n = t.el, i = t.anchor) : (n = t.targetStart, i = t.targetAnchor); n && n !== i; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", s.uid), n = n.nextSibling;
    s.ut();
  }
}
function Mi(t, e, s, n, i = null) {
  const o = e.targetStart = s(""), r = e.targetAnchor = s("");
  return o[ba] = r, t && (n(o, t, i), n(r, t, i)), r;
}
const Ot = /* @__PURE__ */ Symbol("_leaveCb"), Fs = /* @__PURE__ */ Symbol("_enterCb");
function Lc() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return ot(() => {
    t.isMounted = !0;
  }), Pt(() => {
    t.isUnmounting = !0;
  }), t;
}
const ct = [Function, Array], _a = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: ct,
  onEnter: ct,
  onAfterEnter: ct,
  onEnterCancelled: ct,
  // leave
  onBeforeLeave: ct,
  onLeave: ct,
  onAfterLeave: ct,
  onLeaveCancelled: ct,
  // appear
  onBeforeAppear: ct,
  onAppear: ct,
  onAfterAppear: ct,
  onAppearCancelled: ct
}, Ta = (t) => {
  const e = t.subTree;
  return e.component ? Ta(e.component) : e;
}, kc = {
  name: "BaseTransition",
  props: _a,
  setup(t, { slots: e }) {
    const s = ai(), n = Lc();
    return () => {
      const i = e.default && Sa(e.default(), !0);
      if (!i || !i.length)
        return;
      const o = Na(i), r = /* @__PURE__ */ ce(t), { mode: a } = r;
      if (b.NODE_ENV !== "production" && a && a !== "in-out" && a !== "out-in" && a !== "default" && R(`invalid <transition> mode: ${a}`), n.isLeaving)
        return yi(o);
      const l = ko(o);
      if (!l)
        return yi(o);
      let u = Ii(
        l,
        r,
        n,
        s,
        // #11061, ensure enterHooks is fresh after clone
        (d) => u = d
      );
      l.type !== Be && sn(l, u);
      let c = s.subTree && ko(s.subTree);
      if (c && c.type !== Be && !fs(c, l) && Ta(s).type !== Be) {
        let d = Ii(
          c,
          r,
          n,
          s
        );
        if (sn(c, d), a === "out-in" && l.type !== Be)
          return n.isLeaving = !0, d.afterLeave = () => {
            n.isLeaving = !1, s.job.flags & 8 || s.update(), delete d.afterLeave, c = void 0;
          }, yi(o);
        a === "in-out" && l.type !== Be ? d.delayLeave = (m, h, g) => {
          const y = xa(
            n,
            c
          );
          y[String(c.key)] = c, m[Ot] = () => {
            h(), m[Ot] = void 0, delete u.delayedLeave, c = void 0;
          }, u.delayedLeave = () => {
            g(), delete u.delayedLeave, c = void 0;
          };
        } : c = void 0;
      } else c && (c = void 0);
      return o;
    };
  }
};
function Na(t) {
  let e = t[0];
  if (t.length > 1) {
    let s = !1;
    for (const n of t)
      if (n.type !== Be) {
        if (b.NODE_ENV !== "production" && s) {
          R(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        if (e = n, s = !0, b.NODE_ENV === "production") break;
      }
  }
  return e;
}
const Pc = kc;
function xa(t, e) {
  const { leavingVNodes: s } = t;
  let n = s.get(e.type);
  return n || (n = /* @__PURE__ */ Object.create(null), s.set(e.type, n)), n;
}
function Ii(t, e, s, n, i) {
  const {
    appear: o,
    mode: r,
    persisted: a = !1,
    onBeforeEnter: l,
    onEnter: u,
    onAfterEnter: c,
    onEnterCancelled: d,
    onBeforeLeave: m,
    onLeave: h,
    onAfterLeave: g,
    onLeaveCancelled: y,
    onBeforeAppear: _,
    onAppear: E,
    onAfterAppear: x,
    onAppearCancelled: T
  } = e, O = String(t.key), M = xa(s, t), K = (H, re) => {
    H && Tt(
      H,
      n,
      9,
      re
    );
  }, pe = (H, re) => {
    const me = re[1];
    K(H, re), z(H) ? H.every((w) => w.length <= 1) && me() : H.length <= 1 && me();
  }, he = {
    mode: r,
    persisted: a,
    beforeEnter(H) {
      let re = l;
      if (!s.isMounted)
        if (o)
          re = _ || l;
        else
          return;
      H[Ot] && H[Ot](
        !0
        /* cancelled */
      );
      const me = M[O];
      me && fs(t, me) && me.el[Ot] && me.el[Ot](), K(re, [H]);
    },
    enter(H) {
      let re = u, me = c, w = d;
      if (!s.isMounted)
        if (o)
          re = E || u, me = x || c, w = T || d;
        else
          return;
      let W = !1;
      H[Fs] = (be) => {
        W || (W = !0, be ? K(w, [H]) : K(me, [H]), he.delayedLeave && he.delayedLeave(), H[Fs] = void 0);
      };
      const oe = H[Fs].bind(null, !1);
      re ? pe(re, [H, oe]) : oe();
    },
    leave(H, re) {
      const me = String(t.key);
      if (H[Fs] && H[Fs](
        !0
        /* cancelled */
      ), s.isUnmounting)
        return re();
      K(m, [H]);
      let w = !1;
      H[Ot] = (oe) => {
        w || (w = !0, re(), oe ? K(y, [H]) : K(g, [H]), H[Ot] = void 0, M[me] === t && delete M[me]);
      };
      const W = H[Ot].bind(null, !1);
      M[me] = t, h ? pe(h, [H, W]) : W();
    },
    clone(H) {
      const re = Ii(
        H,
        e,
        s,
        n,
        i
      );
      return i && i(re), re;
    }
  };
  return he;
}
function yi(t) {
  if (pn(t))
    return t = kt(t), t.children = null, t;
}
function ko(t) {
  if (!pn(t))
    return ga(t.type) && t.children ? Na(t.children) : t;
  if (t.component)
    return t.component.subTree;
  const { shapeFlag: e, children: s } = t;
  if (s) {
    if (e & 16)
      return s[0];
    if (e & 32 && Z(s.default))
      return s.default();
  }
}
function sn(t, e) {
  t.shapeFlag & 6 && t.component ? (t.transition = e, sn(t.component.subTree, e)) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function Sa(t, e = !1, s) {
  let n = [], i = 0;
  for (let o = 0; o < t.length; o++) {
    let r = t[o];
    const a = s == null ? r.key : String(s) + String(r.key != null ? r.key : o);
    r.type === Ae ? (r.patchFlag & 128 && i++, n = n.concat(
      Sa(r.children, e, a)
    )) : (e || r.type !== Be) && n.push(a != null ? kt(r, { key: a }) : r);
  }
  if (i > 1)
    for (let o = 0; o < n.length; o++)
      n[o].patchFlag = -2;
  return n;
}
// @__NO_SIDE_EFFECTS__
function Te(t, e) {
  return Z(t) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Ve({ name: t.name }, e, { setup: t })
  ) : t;
}
function Ca(t) {
  t.ids = [t.ids[0] + t.ids[2]++ + "-", 0, 0];
}
const Po = /* @__PURE__ */ new WeakSet();
function Bo(t, e) {
  let s;
  return !!((s = Object.getOwnPropertyDescriptor(t, e)) && !s.configurable);
}
const jn = /* @__PURE__ */ new WeakMap();
function Ys(t, e, s, n, i = !1) {
  if (z(t)) {
    t.forEach(
      (y, _) => Ys(
        y,
        e && (z(e) ? e[_] : e),
        s,
        n,
        i
      )
    );
    return;
  }
  if (ws(n) && !i) {
    n.shapeFlag & 512 && n.type.__asyncResolved && n.component.subTree.component && Ys(t, e, s, n.component.subTree);
    return;
  }
  const o = n.shapeFlag & 4 ? li(n.component) : n.el, r = i ? null : o, { i: a, r: l } = t;
  if (b.NODE_ENV !== "production" && !a) {
    R(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const u = e && e.r, c = a.refs === ye ? a.refs = {} : a.refs, d = a.setupState, m = /* @__PURE__ */ ce(d), h = d === ye ? Rr : (y) => b.NODE_ENV !== "production" && (Ee(m, y) && !/* @__PURE__ */ Fe(m[y]) && R(
    `Template ref "${y}" used on a non-ref value. It will not work in the production build.`
  ), Po.has(m[y])) || Bo(c, y) ? !1 : Ee(m, y), g = (y, _) => !(b.NODE_ENV !== "production" && Po.has(y) || _ && Bo(c, _));
  if (u != null && u !== l) {
    if (Fo(e), Me(u))
      c[u] = null, h(u) && (d[u] = null);
    else if (/* @__PURE__ */ Fe(u)) {
      const y = e;
      g(u, y.k) && (u.value = null), y.k && (c[y.k] = null);
    }
  }
  if (Z(l))
    Rs(l, a, 12, [r, c]);
  else {
    const y = Me(l), _ = /* @__PURE__ */ Fe(l);
    if (y || _) {
      const E = () => {
        if (t.f) {
          const x = y ? h(l) ? d[l] : c[l] : g(l) || !t.k ? l.value : c[t.k];
          if (i)
            z(x) && Ki(x, o);
          else if (z(x))
            x.includes(o) || x.push(o);
          else if (y)
            c[l] = [o], h(l) && (d[l] = c[l]);
          else {
            const T = [o];
            g(l, t.k) && (l.value = T), t.k && (c[t.k] = T);
          }
        } else y ? (c[l] = r, h(l) && (d[l] = r)) : _ ? (g(l, t.k) && (l.value = r), t.k && (c[t.k] = r)) : b.NODE_ENV !== "production" && R("Invalid template ref type:", l, `(${typeof l})`);
      };
      if (r) {
        const x = () => {
          E(), jn.delete(t);
        };
        x.id = -1, jn.set(t, x), ze(x, s);
      } else
        Fo(t), E();
    } else b.NODE_ENV !== "production" && R("Invalid template ref type:", l, `(${typeof l})`);
  }
}
function Fo(t) {
  const e = jn.get(t);
  e && (e.flags |= 8, jn.delete(t));
}
un().requestIdleCallback;
un().cancelIdleCallback;
const ws = (t) => !!t.type.__asyncLoader, pn = (t) => t.type.__isKeepAlive;
function Bc(t, e) {
  wa(t, "a", e);
}
function Fc(t, e) {
  wa(t, "da", e);
}
function wa(t, e, s = Ue) {
  const n = t.__wdc || (t.__wdc = () => {
    let i = s;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return t();
  });
  if (oi(e, n, s), s) {
    let i = s.parent;
    for (; i && i.parent; )
      pn(i.parent.vnode) && Uc(n, e, s, i), i = i.parent;
  }
}
function Uc(t, e, s, n) {
  const i = oi(
    e,
    t,
    n,
    !0
    /* prepend */
  );
  hn(() => {
    Ki(n[e], i);
  }, s);
}
function oi(t, e, s = Ue, n = !1) {
  if (s) {
    const i = s[t] || (s[t] = []), o = e.__weh || (e.__weh = (...r) => {
      gt();
      const a = vn(s), l = Tt(e, s, t, r);
      return a(), Et(), l;
    });
    return n ? i.unshift(o) : i.push(o), o;
  } else if (b.NODE_ENV !== "production") {
    const i = cs(eo[t].replace(/ hook$/, ""));
    R(
      `${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const Qt = (t) => (e, s = Ue) => {
  (!on || t === "sp") && oi(t, (...n) => e(...n), s);
}, jc = Qt("bm"), ot = Qt("m"), qc = Qt(
  "bu"
), Hc = Qt("u"), Pt = Qt(
  "bum"
), hn = Qt("um"), Wc = Qt(
  "sp"
), Kc = Qt("rtg"), zc = Qt("rtc");
function Gc(t, e = Ue) {
  oi("ec", t, e);
}
const Yc = /* @__PURE__ */ Symbol.for("v-ndc");
function Wt(t, e, s, n) {
  let i;
  const o = s, r = z(t);
  if (r || Me(t)) {
    const a = r && /* @__PURE__ */ ns(t);
    let l = !1, u = !1;
    a && (l = !/* @__PURE__ */ Ze(t), u = /* @__PURE__ */ yt(t), t = ti(t)), i = new Array(t.length);
    for (let c = 0, d = t.length; c < d; c++)
      i[c] = e(
        l ? u ? $s(_t(t[c])) : _t(t[c]) : t[c],
        c,
        void 0,
        o
      );
  } else if (typeof t == "number") {
    b.NODE_ENV !== "production" && !Number.isInteger(t) && R(`The v-for range expect an integer value but got ${t}.`), i = new Array(t);
    for (let a = 0; a < t; a++)
      i[a] = e(a + 1, a, void 0, o);
  } else if (ve(t))
    if (t[Symbol.iterator])
      i = Array.from(
        t,
        (a, l) => e(a, l, void 0, o)
      );
    else {
      const a = Object.keys(t);
      i = new Array(a.length);
      for (let l = 0, u = a.length; l < u; l++) {
        const c = a[l];
        i[l] = e(t[c], c, l, o);
      }
    }
  else
    i = [];
  return i;
}
function mt(t, e, s = {}, n, i) {
  if (He.ce || He.parent && ws(He.parent) && He.parent.ce) {
    const u = Object.keys(s).length > 0;
    return e !== "default" && (s.name = e), S(), Le(
      Ae,
      null,
      [C("slot", s, n)],
      u ? -2 : 64
    );
  }
  let o = t[e];
  b.NODE_ENV !== "production" && o && o.length > 1 && (R(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), o = () => []), o && o._c && (o._d = !1), S();
  const r = o && Da(o(s)), a = s.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  r && r.key, l = Le(
    Ae,
    {
      key: (a && !vt(a) ? a : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!r && n ? "_fb" : "")
    },
    r || [],
    r && t._ === 1 ? 64 : -2
  );
  return !i && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), o && o._c && (o._d = !0), l;
}
function Da(t) {
  return t.some((e) => Es(e) ? !(e.type === Be || e.type === Ae && !Da(e.children)) : !0) ? t : null;
}
const Ri = (t) => t ? Xa(t) ? li(t) : Ri(t.parent) : null, bs = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Ve(/* @__PURE__ */ Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(t.props) : t.props,
    $attrs: (t) => b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(t.attrs) : t.attrs,
    $slots: (t) => b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(t.slots) : t.slots,
    $refs: (t) => b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(t.refs) : t.refs,
    $parent: (t) => Ri(t.parent),
    $root: (t) => Ri(t.root),
    $host: (t) => t.ce,
    $emit: (t) => t.emit,
    $options: (t) => Aa(t),
    $forceUpdate: (t) => t.f || (t.f = () => {
      ii(t.update);
    }),
    $nextTick: (t) => t.n || (t.n = It.bind(t.proxy)),
    $watch: (t) => Ic.bind(t)
  })
), io = (t) => t === "_" || t === "$", _i = (t, e) => t !== ye && !t.__isScriptSetup && Ee(t, e), Oa = {
  get({ _: t }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: s, setupState: n, data: i, props: o, accessCache: r, type: a, appContext: l } = t;
    if (b.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    if (e[0] !== "$") {
      const m = r[e];
      if (m !== void 0)
        switch (m) {
          case 1:
            return n[e];
          case 2:
            return i[e];
          case 4:
            return s[e];
          case 3:
            return o[e];
        }
      else {
        if (_i(n, e))
          return r[e] = 1, n[e];
        if (i !== ye && Ee(i, e))
          return r[e] = 2, i[e];
        if (Ee(o, e))
          return r[e] = 3, o[e];
        if (s !== ye && Ee(s, e))
          return r[e] = 4, s[e];
        Li && (r[e] = 0);
      }
    }
    const u = bs[e];
    let c, d;
    if (u)
      return e === "$attrs" ? (je(t.attrs, "get", ""), b.NODE_ENV !== "production" && Wn()) : b.NODE_ENV !== "production" && e === "$slots" && je(t, "get", e), u(t);
    if (
      // css module (injected by vue-loader)
      (c = a.__cssModules) && (c = c[e])
    )
      return c;
    if (s !== ye && Ee(s, e))
      return r[e] = 4, s[e];
    if (
      // global properties
      d = l.config.globalProperties, Ee(d, e)
    )
      return d[e];
    b.NODE_ENV !== "production" && He && (!Me(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (i !== ye && io(e[0]) && Ee(i, e) ? R(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : t === He && R(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: t }, e, s) {
    const { data: n, setupState: i, ctx: o } = t;
    return _i(i, e) ? (i[e] = s, !0) : b.NODE_ENV !== "production" && i.__isScriptSetup && Ee(i, e) ? (R(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : n !== ye && Ee(n, e) ? (n[e] = s, !0) : Ee(t.props, e) ? (b.NODE_ENV !== "production" && R(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (b.NODE_ENV !== "production" && R(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : (b.NODE_ENV !== "production" && e in t.appContext.config.globalProperties ? Object.defineProperty(o, e, {
      enumerable: !0,
      configurable: !0,
      value: s
    }) : o[e] = s, !0);
  },
  has({
    _: { data: t, setupState: e, accessCache: s, ctx: n, appContext: i, props: o, type: r }
  }, a) {
    let l;
    return !!(s[a] || t !== ye && a[0] !== "$" && Ee(t, a) || _i(e, a) || Ee(o, a) || Ee(n, a) || Ee(bs, a) || Ee(i.config.globalProperties, a) || (l = r.__cssModules) && l[a]);
  },
  defineProperty(t, e, s) {
    return s.get != null ? t._.accessCache[e] = 0 : Ee(s, "value") && this.set(t, e, s.value, null), Reflect.defineProperty(t, e, s);
  }
};
b.NODE_ENV !== "production" && (Oa.ownKeys = (t) => (R(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(t)));
function Qc(t) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => t
  }), Object.keys(bs).forEach((s) => {
    Object.defineProperty(e, s, {
      configurable: !0,
      enumerable: !1,
      get: () => bs[s](t),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: qe
    });
  }), e;
}
function Jc(t) {
  const {
    ctx: e,
    propsOptions: [s]
  } = t;
  s && Object.keys(s).forEach((n) => {
    Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[n],
      set: qe
    });
  });
}
function Xc(t) {
  const { ctx: e, setupState: s } = t;
  Object.keys(/* @__PURE__ */ ce(s)).forEach((n) => {
    if (!s.__isScriptSetup) {
      if (io(n[0])) {
        R(
          `setup() return property ${JSON.stringify(
            n
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, n, {
        enumerable: !0,
        configurable: !0,
        get: () => s[n],
        set: qe
      });
    }
  });
}
function qn(t) {
  return z(t) ? t.reduce(
    (e, s) => (e[s] = null, e),
    {}
  ) : t;
}
function oo(t, e) {
  return !t || !e ? t || e : z(t) && z(e) ? t.concat(e) : Ve({}, qn(t), qn(e));
}
function Zc() {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, s) => {
    t[s] ? R(`${e} property "${s}" is already defined in ${t[s]}.`) : t[s] = e;
  };
}
let Li = !0;
function eu(t) {
  const e = Aa(t), s = t.proxy, n = t.ctx;
  Li = !1, e.beforeCreate && Uo(e.beforeCreate, t, "bc");
  const {
    // state
    data: i,
    computed: o,
    methods: r,
    watch: a,
    provide: l,
    inject: u,
    // lifecycle
    created: c,
    beforeMount: d,
    mounted: m,
    beforeUpdate: h,
    updated: g,
    activated: y,
    deactivated: _,
    beforeDestroy: E,
    beforeUnmount: x,
    destroyed: T,
    unmounted: O,
    render: M,
    renderTracked: K,
    renderTriggered: pe,
    errorCaptured: he,
    serverPrefetch: H,
    // public API
    expose: re,
    inheritAttrs: me,
    // assets
    components: w,
    directives: W,
    filters: oe
  } = e, be = b.NODE_ENV !== "production" ? Zc() : null;
  if (b.NODE_ENV !== "production") {
    const [le] = t.propsOptions;
    if (le)
      for (const de in le)
        be("Props", de);
  }
  if (u && tu(u, n, be), r)
    for (const le in r) {
      const de = r[le];
      Z(de) ? (b.NODE_ENV !== "production" ? Object.defineProperty(n, le, {
        value: de.bind(s),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : n[le] = de.bind(s), b.NODE_ENV !== "production" && be("Methods", le)) : b.NODE_ENV !== "production" && R(
        `Method "${le}" has type "${typeof de}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (i) {
    b.NODE_ENV !== "production" && !Z(i) && R(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const le = i.call(s, s);
    if (b.NODE_ENV !== "production" && zi(le) && R(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !ve(le))
      b.NODE_ENV !== "production" && R("data() should return an object.");
    else if (t.data = /* @__PURE__ */ is(le), b.NODE_ENV !== "production")
      for (const de in le)
        be("Data", de), io(de[0]) || Object.defineProperty(n, de, {
          configurable: !0,
          enumerable: !0,
          get: () => le[de],
          set: qe
        });
  }
  if (Li = !0, o)
    for (const le in o) {
      const de = o[le], J = Z(de) ? de.bind(s, s) : Z(de.get) ? de.get.bind(s, s) : qe;
      b.NODE_ENV !== "production" && J === qe && R(`Computed property "${le}" has no getter.`);
      const L = !Z(de) && Z(de.set) ? de.set.bind(s) : b.NODE_ENV !== "production" ? () => {
        R(
          `Write operation failed: computed property "${le}" is readonly.`
        );
      } : qe, Oe = te({
        get: J,
        set: L
      });
      Object.defineProperty(n, le, {
        enumerable: !0,
        configurable: !0,
        get: () => Oe.value,
        set: (We) => Oe.value = We
      }), b.NODE_ENV !== "production" && be("Computed", le);
    }
  if (a)
    for (const le in a)
      $a(a[le], n, s, le);
  if (l) {
    const le = Z(l) ? l.call(s) : l;
    Reflect.ownKeys(le).forEach((de) => {
      $c(de, le[de]);
    });
  }
  c && Uo(c, t, "c");
  function fe(le, de) {
    z(de) ? de.forEach((J) => le(J.bind(s))) : de && le(de.bind(s));
  }
  if (fe(jc, d), fe(ot, m), fe(qc, h), fe(Hc, g), fe(Bc, y), fe(Fc, _), fe(Gc, he), fe(zc, K), fe(Kc, pe), fe(Pt, x), fe(hn, O), fe(Wc, H), z(re))
    if (re.length) {
      const le = t.exposed || (t.exposed = {});
      re.forEach((de) => {
        Object.defineProperty(le, de, {
          get: () => s[de],
          set: (J) => s[de] = J,
          enumerable: !0
        });
      });
    } else t.exposed || (t.exposed = {});
  M && t.render === qe && (t.render = M), me != null && (t.inheritAttrs = me), w && (t.components = w), W && (t.directives = W), H && Ca(t);
}
function tu(t, e, s = qe) {
  z(t) && (t = ki(t));
  for (const n in t) {
    const i = t[n];
    let o;
    ve(i) ? "default" in i ? o = $n(
      i.from || n,
      i.default,
      !0
    ) : o = $n(i.from || n) : o = $n(i), /* @__PURE__ */ Fe(o) ? Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (r) => o.value = r
    }) : e[n] = o, b.NODE_ENV !== "production" && s("Inject", n);
  }
}
function Uo(t, e, s) {
  Tt(
    z(t) ? t.map((n) => n.bind(e.proxy)) : t.bind(e.proxy),
    e,
    s
  );
}
function $a(t, e, s, n) {
  let i = n.includes(".") ? va(s, n) : () => s[n];
  if (Me(t)) {
    const o = e[t];
    Z(o) ? it(i, o) : b.NODE_ENV !== "production" && R(`Invalid watch handler specified by key "${t}"`, o);
  } else if (Z(t))
    it(i, t.bind(s));
  else if (ve(t))
    if (z(t))
      t.forEach((o) => $a(o, e, s, n));
    else {
      const o = Z(t.handler) ? t.handler.bind(s) : e[t.handler];
      Z(o) ? it(i, o, t) : b.NODE_ENV !== "production" && R(`Invalid watch handler specified by key "${t.handler}"`, o);
    }
  else b.NODE_ENV !== "production" && R(`Invalid watch option: "${n}"`, t);
}
function Aa(t) {
  const e = t.type, { mixins: s, extends: n } = e, {
    mixins: i,
    optionsCache: o,
    config: { optionMergeStrategies: r }
  } = t.appContext, a = o.get(e);
  let l;
  return a ? l = a : !i.length && !s && !n ? l = e : (l = {}, i.length && i.forEach(
    (u) => Hn(l, u, r, !0)
  ), Hn(l, e, r)), ve(e) && o.set(e, l), l;
}
function Hn(t, e, s, n = !1) {
  const { mixins: i, extends: o } = e;
  o && Hn(t, o, s, !0), i && i.forEach(
    (r) => Hn(t, r, s, !0)
  );
  for (const r in e)
    if (n && r === "expose")
      b.NODE_ENV !== "production" && R(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const a = su[r] || s && s[r];
      t[r] = a ? a(t[r], e[r]) : e[r];
    }
  return t;
}
const su = {
  data: jo,
  props: qo,
  emits: qo,
  // objects
  methods: Ws,
  computed: Ws,
  // lifecycle
  beforeCreate: Qe,
  created: Qe,
  beforeMount: Qe,
  mounted: Qe,
  beforeUpdate: Qe,
  updated: Qe,
  beforeDestroy: Qe,
  beforeUnmount: Qe,
  destroyed: Qe,
  unmounted: Qe,
  activated: Qe,
  deactivated: Qe,
  errorCaptured: Qe,
  serverPrefetch: Qe,
  // assets
  components: Ws,
  directives: Ws,
  // watch
  watch: iu,
  // provide / inject
  provide: jo,
  inject: nu
};
function jo(t, e) {
  return e ? t ? function() {
    return Ve(
      Z(t) ? t.call(this, this) : t,
      Z(e) ? e.call(this, this) : e
    );
  } : e : t;
}
function nu(t, e) {
  return Ws(ki(t), ki(e));
}
function ki(t) {
  if (z(t)) {
    const e = {};
    for (let s = 0; s < t.length; s++)
      e[t[s]] = t[s];
    return e;
  }
  return t;
}
function Qe(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function Ws(t, e) {
  return t ? Ve(/* @__PURE__ */ Object.create(null), t, e) : e;
}
function qo(t, e) {
  return t ? z(t) && z(e) ? [.../* @__PURE__ */ new Set([...t, ...e])] : Ve(
    /* @__PURE__ */ Object.create(null),
    qn(t),
    qn(e ?? {})
  ) : e;
}
function iu(t, e) {
  if (!t) return e;
  if (!e) return t;
  const s = Ve(/* @__PURE__ */ Object.create(null), t);
  for (const n in e)
    s[n] = Qe(t[n], e[n]);
  return s;
}
function Va() {
  return {
    app: null,
    config: {
      isNativeTag: Rr,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let ou = 0;
function ru(t, e) {
  return function(n, i = null) {
    Z(n) || (n = Ve({}, n)), i != null && !ve(i) && (b.NODE_ENV !== "production" && R("root props passed to app.mount() must be an object."), i = null);
    const o = Va(), r = /* @__PURE__ */ new WeakSet(), a = [];
    let l = !1;
    const u = o.app = {
      _uid: ou++,
      _component: n,
      _props: i,
      _container: null,
      _context: o,
      _instance: null,
      version: er,
      get config() {
        return o.config;
      },
      set config(c) {
        b.NODE_ENV !== "production" && R(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(c, ...d) {
        return r.has(c) ? b.NODE_ENV !== "production" && R("Plugin has already been applied to target app.") : c && Z(c.install) ? (r.add(c), c.install(u, ...d)) : Z(c) ? (r.add(c), c(u, ...d)) : b.NODE_ENV !== "production" && R(
          'A plugin must either be a function or an object with an "install" function.'
        ), u;
      },
      mixin(c) {
        return o.mixins.includes(c) ? b.NODE_ENV !== "production" && R(
          "Mixin has already been applied to target app" + (c.name ? `: ${c.name}` : "")
        ) : o.mixins.push(c), u;
      },
      component(c, d) {
        return b.NODE_ENV !== "production" && ji(c, o.config), d ? (b.NODE_ENV !== "production" && o.components[c] && R(`Component "${c}" has already been registered in target app.`), o.components[c] = d, u) : o.components[c];
      },
      directive(c, d) {
        return b.NODE_ENV !== "production" && ma(c), d ? (b.NODE_ENV !== "production" && o.directives[c] && R(`Directive "${c}" has already been registered in target app.`), o.directives[c] = d, u) : o.directives[c];
      },
      mount(c, d, m) {
        if (l)
          b.NODE_ENV !== "production" && R(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          b.NODE_ENV !== "production" && c.__vue_app__ && R(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const h = u._ceVNode || C(n, i);
          return h.appContext = o, m === !0 ? m = "svg" : m === !1 && (m = void 0), b.NODE_ENV !== "production" && (o.reload = () => {
            const g = kt(h);
            g.el = null, t(g, c, m);
          }), t(h, c, m), l = !0, u._container = c, c.__vue_app__ = u, b.NODE_ENV !== "production" && (u._instance = h.component, Tc(u, er)), li(h.component);
        }
      },
      onUnmount(c) {
        b.NODE_ENV !== "production" && typeof c != "function" && R(
          `Expected function as first argument to app.onUnmount(), but got ${typeof c}`
        ), a.push(c);
      },
      unmount() {
        l ? (Tt(
          a,
          u._instance,
          16
        ), t(null, u._container), b.NODE_ENV !== "production" && (u._instance = null, Nc(u)), delete u._container.__vue_app__) : b.NODE_ENV !== "production" && R("Cannot unmount an app that is not mounted.");
      },
      provide(c, d) {
        return b.NODE_ENV !== "production" && c in o.provides && (Ee(o.provides, c) ? R(
          `App already provides property with key "${String(c)}". It will be overwritten with the new value.`
        ) : R(
          `App already provides property with key "${String(c)}" inherited from its parent element. It will be overwritten with the new value.`
        )), o.provides[c] = d, u;
      },
      runWithContext(c) {
        const d = Ds;
        Ds = u;
        try {
          return c();
        } finally {
          Ds = d;
        }
      }
    };
    return u;
  };
}
let Ds = null;
function ro(t, e, s = ye) {
  const n = ai();
  if (b.NODE_ENV !== "production" && !n)
    return R("useModel() called without active instance."), /* @__PURE__ */ q();
  const i = ut(e);
  if (b.NODE_ENV !== "production" && !n.propsOptions[0][i])
    return R(`useModel() called with prop "${e}" which is not declared.`), /* @__PURE__ */ q();
  const o = Gt(e), r = Ma(t, i), a = oc((l, u) => {
    let c, d = ye, m;
    return Mc(() => {
      const h = t[i];
      nt(c, h) && (c = h, u());
    }), {
      get() {
        return l(), s.get ? s.get(c) : c;
      },
      set(h) {
        const g = s.set ? s.set(h) : h;
        if (!nt(g, c) && !(d !== ye && nt(h, d)))
          return;
        const y = n.vnode.props;
        y && // check if parent has passed v-model
        (e in y || i in y || o in y) && (`onUpdate:${e}` in y || `onUpdate:${i}` in y || `onUpdate:${o}` in y) || (c = h, u()), n.emit(`update:${e}`, g), nt(h, g) && nt(h, d) && !nt(g, m) && u(), d = h, m = g;
      }
    };
  });
  return a[Symbol.iterator] = () => {
    let l = 0;
    return {
      next() {
        return l < 2 ? { value: l++ ? r || ye : a, done: !1 } : { done: !0 };
      }
    };
  }, a;
}
const Ma = (t, e) => e === "modelValue" || e === "model-value" ? t.modelModifiers : t[`${e}Modifiers`] || t[`${ut(e)}Modifiers`] || t[`${Gt(e)}Modifiers`];
function au(t, e, ...s) {
  if (t.isUnmounted) return;
  const n = t.vnode.props || ye;
  if (b.NODE_ENV !== "production") {
    const {
      emitsOptions: c,
      propsOptions: [d]
    } = t;
    if (c)
      if (!(e in c))
        (!d || !(cs(ut(e)) in d)) && R(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${cs(ut(e))}" prop.`
        );
      else {
        const m = c[e];
        Z(m) && (m(...s) || R(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let i = s;
  const o = e.startsWith("update:"), r = o && Ma(n, e.slice(7));
  if (r && (r.trim && (i = s.map((c) => Me(c) ? c.trim() : c)), r.number && (i = s.map(Zn))), b.NODE_ENV !== "production" && Oc(t, e, i), b.NODE_ENV !== "production") {
    const c = e.toLowerCase();
    c !== e && n[cs(c)] && R(
      `Event "${c}" is emitted in component ${bn(
        t,
        t.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Gt(
        e
      )}" instead of "${e}".`
    );
  }
  let a, l = n[a = cs(e)] || // also try camelCase event handler (#2249)
  n[a = cs(ut(e))];
  !l && o && (l = n[a = cs(Gt(e))]), l && Tt(
    l,
    t,
    6,
    i
  );
  const u = n[a + "Once"];
  if (u) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[a])
      return;
    t.emitted[a] = !0, Tt(
      u,
      t,
      6,
      i
    );
  }
}
const lu = /* @__PURE__ */ new WeakMap();
function Ia(t, e, s = !1) {
  const n = s ? lu : e.emitsCache, i = n.get(t);
  if (i !== void 0)
    return i;
  const o = t.emits;
  let r = {}, a = !1;
  if (!Z(t)) {
    const l = (u) => {
      const c = Ia(u, e, !0);
      c && (a = !0, Ve(r, c));
    };
    !s && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l);
  }
  return !o && !a ? (ve(t) && n.set(t, null), null) : (z(o) ? o.forEach((l) => r[l] = null) : Ve(r, o), ve(t) && n.set(t, r), r);
}
function ri(t, e) {
  return !t || !ln(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Ee(t, e[0].toLowerCase() + e.slice(1)) || Ee(t, Gt(e)) || Ee(t, e));
}
let Pi = !1;
function Wn() {
  Pi = !0;
}
function Ho(t) {
  const {
    type: e,
    vnode: s,
    proxy: n,
    withProxy: i,
    propsOptions: [o],
    slots: r,
    attrs: a,
    emit: l,
    render: u,
    renderCache: c,
    props: d,
    data: m,
    setupState: h,
    ctx: g,
    inheritAttrs: y
  } = t, _ = Un(t);
  let E, x;
  b.NODE_ENV !== "production" && (Pi = !1);
  try {
    if (s.shapeFlag & 4) {
      const M = i || n, K = b.NODE_ENV !== "production" && h.__isScriptSetup ? new Proxy(M, {
        get(pe, he, H) {
          return R(
            `Property '${String(
              he
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(pe, he, H);
        }
      }) : M;
      E = ft(
        u.call(
          K,
          M,
          c,
          b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(d) : d,
          h,
          m,
          g
        )
      ), x = a;
    } else {
      const M = e;
      b.NODE_ENV !== "production" && a === d && Wn(), E = ft(
        M.length > 1 ? M(
          b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(d) : d,
          b.NODE_ENV !== "production" ? {
            get attrs() {
              return Wn(), /* @__PURE__ */ Vt(a);
            },
            slots: r,
            emit: l
          } : { attrs: a, slots: r, emit: l }
        ) : M(
          b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(d) : d,
          null
        )
      ), x = e.props ? a : cu(a);
    }
  } catch (M) {
    Js.length = 0, dn(M, t, 1), E = C(Be);
  }
  let T = E, O;
  if (b.NODE_ENV !== "production" && E.patchFlag > 0 && E.patchFlag & 2048 && ([T, O] = Ra(E)), x && y !== !1) {
    const M = Object.keys(x), { shapeFlag: K } = T;
    if (M.length) {
      if (K & 7)
        o && M.some(Rn) && (x = uu(
          x,
          o
        )), T = kt(T, x, !1, !0);
      else if (b.NODE_ENV !== "production" && !Pi && T.type !== Be) {
        const pe = Object.keys(a), he = [], H = [];
        for (let re = 0, me = pe.length; re < me; re++) {
          const w = pe[re];
          ln(w) ? Rn(w) || he.push(w[2].toLowerCase() + w.slice(3)) : H.push(w);
        }
        H.length && R(
          `Extraneous non-props attributes (${H.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
        ), he.length && R(
          `Extraneous non-emits event listeners (${he.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return s.dirs && (b.NODE_ENV !== "production" && !Wo(T) && R(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), T = kt(T, null, !1, !0), T.dirs = T.dirs ? T.dirs.concat(s.dirs) : s.dirs), s.transition && (b.NODE_ENV !== "production" && !Wo(T) && R(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), sn(T, s.transition)), b.NODE_ENV !== "production" && O ? O(T) : E = T, Un(_), E;
}
const Ra = (t) => {
  const e = t.children, s = t.dynamicChildren, n = ao(e, !1);
  if (n) {
    if (b.NODE_ENV !== "production" && n.patchFlag > 0 && n.patchFlag & 2048)
      return Ra(n);
  } else return [t, void 0];
  const i = e.indexOf(n), o = s ? s.indexOf(n) : -1, r = (a) => {
    e[i] = a, s && (o > -1 ? s[o] = a : a.patchFlag > 0 && (t.dynamicChildren = [...s, a]));
  };
  return [ft(n), r];
};
function ao(t, e = !0) {
  let s;
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    if (Es(i)) {
      if (i.type !== Be || i.children === "v-if") {
        if (s)
          return;
        if (s = i, b.NODE_ENV !== "production" && e && s.patchFlag > 0 && s.patchFlag & 2048)
          return ao(s.children);
      }
    } else
      return;
  }
  return s;
}
const cu = (t) => {
  let e;
  for (const s in t)
    (s === "class" || s === "style" || ln(s)) && ((e || (e = {}))[s] = t[s]);
  return e;
}, uu = (t, e) => {
  const s = {};
  for (const n in t)
    (!Rn(n) || !(n.slice(9) in e)) && (s[n] = t[n]);
  return s;
}, Wo = (t) => t.shapeFlag & 7 || t.type === Be;
function du(t, e, s) {
  const { props: n, children: i, component: o } = t, { props: r, children: a, patchFlag: l } = e, u = o.emitsOptions;
  if (b.NODE_ENV !== "production" && (i || a) && pt || e.dirs || e.transition)
    return !0;
  if (s && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return n ? Ko(n, r, u) : !!r;
    if (l & 8) {
      const c = e.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        const m = c[d];
        if (La(r, n, m) && !ri(u, m))
          return !0;
      }
    }
  } else
    return (i || a) && (!a || !a.$stable) ? !0 : n === r ? !1 : n ? r ? Ko(n, r, u) : !0 : !!r;
  return !1;
}
function Ko(t, e, s) {
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !0;
  for (let i = 0; i < n.length; i++) {
    const o = n[i];
    if (La(e, t, o) && !ri(s, o))
      return !0;
  }
  return !1;
}
function La(t, e, s) {
  const n = t[s], i = e[s];
  return s === "style" && ve(n) && ve(i) ? !Is(n, i) : n !== i;
}
function fu({ vnode: t, parent: e }, s) {
  for (; e; ) {
    const n = e.subTree;
    if (n.suspense && n.suspense.activeBranch === t && (n.el = t.el), n === t)
      (t = e.vnode).el = s, e = e.parent;
    else
      break;
  }
}
const ka = {}, Pa = () => Object.create(ka), Ba = (t) => Object.getPrototypeOf(t) === ka;
function pu(t, e, s, n = !1) {
  const i = {}, o = Pa();
  t.propsDefaults = /* @__PURE__ */ Object.create(null), Fa(t, e, i, o);
  for (const r in t.propsOptions[0])
    r in i || (i[r] = void 0);
  b.NODE_ENV !== "production" && ja(e || {}, i, t), s ? t.props = n ? i : /* @__PURE__ */ Zl(i) : t.type.props ? t.props = i : t.props = o, t.attrs = o;
}
function hu(t) {
  for (; t; ) {
    if (t.type.__hmrId) return !0;
    t = t.parent;
  }
}
function mu(t, e, s, n) {
  const {
    props: i,
    attrs: o,
    vnode: { patchFlag: r }
  } = t, a = /* @__PURE__ */ ce(i), [l] = t.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(b.NODE_ENV !== "production" && hu(t)) && (n || r > 0) && !(r & 16)
  ) {
    if (r & 8) {
      const c = t.vnode.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        let m = c[d];
        if (ri(t.emitsOptions, m))
          continue;
        const h = e[m];
        if (l)
          if (Ee(o, m))
            h !== o[m] && (o[m] = h, u = !0);
          else {
            const g = ut(m);
            i[g] = Bi(
              l,
              a,
              g,
              h,
              t,
              !1
            );
          }
        else
          h !== o[m] && (o[m] = h, u = !0);
      }
    }
  } else {
    Fa(t, e, i, o) && (u = !0);
    let c;
    for (const d in a)
      (!e || // for camelCase
      !Ee(e, d) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((c = Gt(d)) === d || !Ee(e, c))) && (l ? s && // for camelCase
      (s[d] !== void 0 || // for kebab-case
      s[c] !== void 0) && (i[d] = Bi(
        l,
        a,
        d,
        void 0,
        t,
        !0
      )) : delete i[d]);
    if (o !== a)
      for (const d in o)
        (!e || !Ee(e, d)) && (delete o[d], u = !0);
  }
  u && $t(t.attrs, "set", ""), b.NODE_ENV !== "production" && ja(e || {}, i, t);
}
function Fa(t, e, s, n) {
  const [i, o] = t.propsOptions;
  let r = !1, a;
  if (e)
    for (let l in e) {
      if (Ks(l))
        continue;
      const u = e[l];
      let c;
      i && Ee(i, c = ut(l)) ? !o || !o.includes(c) ? s[c] = u : (a || (a = {}))[c] = u : ri(t.emitsOptions, l) || (!(l in n) || u !== n[l]) && (n[l] = u, r = !0);
    }
  if (o) {
    const l = /* @__PURE__ */ ce(s), u = a || ye;
    for (let c = 0; c < o.length; c++) {
      const d = o[c];
      s[d] = Bi(
        i,
        l,
        d,
        u[d],
        t,
        !Ee(u, d)
      );
    }
  }
  return r;
}
function Bi(t, e, s, n, i, o) {
  const r = t[s];
  if (r != null) {
    const a = Ee(r, "default");
    if (a && n === void 0) {
      const l = r.default;
      if (r.type !== Function && !r.skipFactory && Z(l)) {
        const { propsDefaults: u } = i;
        if (s in u)
          n = u[s];
        else {
          const c = vn(i);
          n = u[s] = l.call(
            null,
            e
          ), c();
        }
      } else
        n = l;
      i.ce && i.ce._setProp(s, n);
    }
    r[
      0
      /* shouldCast */
    ] && (o && !a ? n = !1 : r[
      1
      /* shouldCastTrue */
    ] && (n === "" || n === Gt(s)) && (n = !0));
  }
  return n;
}
const vu = /* @__PURE__ */ new WeakMap();
function Ua(t, e, s = !1) {
  const n = s ? vu : e.propsCache, i = n.get(t);
  if (i)
    return i;
  const o = t.props, r = {}, a = [];
  let l = !1;
  if (!Z(t)) {
    const c = (d) => {
      l = !0;
      const [m, h] = Ua(d, e, !0);
      Ve(r, m), h && a.push(...h);
    };
    !s && e.mixins.length && e.mixins.forEach(c), t.extends && c(t.extends), t.mixins && t.mixins.forEach(c);
  }
  if (!o && !l)
    return ve(t) && n.set(t, Ss), Ss;
  if (z(o))
    for (let c = 0; c < o.length; c++) {
      b.NODE_ENV !== "production" && !Me(o[c]) && R("props must be strings when using array syntax.", o[c]);
      const d = ut(o[c]);
      zo(d) && (r[d] = ye);
    }
  else if (o) {
    b.NODE_ENV !== "production" && !ve(o) && R("invalid props options", o);
    for (const c in o) {
      const d = ut(c);
      if (zo(d)) {
        const m = o[c], h = r[d] = z(m) || Z(m) ? { type: m } : Ve({}, m), g = h.type;
        let y = !1, _ = !0;
        if (z(g))
          for (let E = 0; E < g.length; ++E) {
            const x = g[E], T = Z(x) && x.name;
            if (T === "Boolean") {
              y = !0;
              break;
            } else T === "String" && (_ = !1);
          }
        else
          y = Z(g) && g.name === "Boolean";
        h[
          0
          /* shouldCast */
        ] = y, h[
          1
          /* shouldCastTrue */
        ] = _, (y || Ee(h, "default")) && a.push(d);
      }
    }
  }
  const u = [r, a];
  return ve(t) && n.set(t, u), u;
}
function zo(t) {
  return t[0] !== "$" && !Ks(t) ? !0 : (b.NODE_ENV !== "production" && R(`Invalid prop name: "${t}" is a reserved property.`), !1);
}
function bu(t) {
  return t === null ? "null" : typeof t == "function" ? t.name || "" : typeof t == "object" && t.constructor && t.constructor.name || "";
}
function ja(t, e, s) {
  const n = /* @__PURE__ */ ce(e), i = s.propsOptions[0], o = Object.keys(t).map((r) => ut(r));
  for (const r in i) {
    let a = i[r];
    a != null && gu(
      r,
      n[r],
      a,
      b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(n) : n,
      !o.includes(r)
    );
  }
}
function gu(t, e, s, n, i) {
  const { type: o, required: r, validator: a, skipCheck: l } = s;
  if (r && i) {
    R('Missing required prop: "' + t + '"');
    return;
  }
  if (!(e == null && !r)) {
    if (o != null && o !== !0 && !l) {
      let u = !1;
      const c = z(o) ? o : [o], d = [];
      for (let m = 0; m < c.length && !u; m++) {
        const { valid: h, expectedType: g } = yu(e, c[m]);
        d.push(g || ""), u = h;
      }
      if (!u) {
        R(_u(t, e, d));
        return;
      }
    }
    a && !a(e, n) && R('Invalid prop: custom validator check failed for prop "' + t + '".');
  }
}
const Eu = /* @__PURE__ */ Yt(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function yu(t, e) {
  let s;
  const n = bu(e);
  if (n === "null")
    s = t === null;
  else if (Eu(n)) {
    const i = typeof t;
    s = i === n.toLowerCase(), !s && i === "object" && (s = t instanceof e);
  } else n === "Object" ? s = ve(t) : n === "Array" ? s = z(t) : s = t instanceof e;
  return {
    valid: s,
    expectedType: n
  };
}
function _u(t, e, s) {
  if (s.length === 0)
    return `Prop type [] for prop "${t}" won't match anything. Did you mean to use type Array instead?`;
  let n = `Invalid prop: type check failed for prop "${t}". Expected ${s.map(Xn).join(" | ")}`;
  const i = s[0], o = Gi(e), r = Go(e, i), a = Go(e, o);
  return s.length === 1 && Yo(i) && !Tu(i, o) && (n += ` with value ${r}`), n += `, got ${o} `, Yo(o) && (n += `with value ${a}.`), n;
}
function Go(t, e) {
  return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`;
}
function Yo(t) {
  return ["string", "number", "boolean"].some((s) => t.toLowerCase() === s);
}
function Tu(...t) {
  return t.some((e) => e.toLowerCase() === "boolean");
}
const lo = (t) => t === "_" || t === "_ctx" || t === "$stable", co = (t) => z(t) ? t.map(ft) : [ft(t)], Nu = (t, e, s) => {
  if (e._n)
    return e;
  const n = B((...i) => (b.NODE_ENV !== "production" && Ue && !(s === null && He) && !(s && s.root !== Ue.root) && R(
    `Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), co(e(...i))), s);
  return n._c = !1, n;
}, qa = (t, e, s) => {
  const n = t._ctx;
  for (const i in t) {
    if (lo(i)) continue;
    const o = t[i];
    if (Z(o))
      e[i] = Nu(i, o, n);
    else if (o != null) {
      b.NODE_ENV !== "production" && R(
        `Non-function value encountered for slot "${i}". Prefer function slots for better performance.`
      );
      const r = co(o);
      e[i] = () => r;
    }
  }
}, Ha = (t, e) => {
  b.NODE_ENV !== "production" && !pn(t.vnode) && R(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const s = co(e);
  t.slots.default = () => s;
}, Fi = (t, e, s) => {
  for (const n in e)
    (s || !lo(n)) && (t[n] = e[n]);
}, xu = (t, e, s) => {
  const n = t.slots = Pa();
  if (t.vnode.shapeFlag & 32) {
    const i = e._;
    i ? (Fi(n, e, s), s && Ln(n, "_", i, !0)) : qa(e, n);
  } else e && Ha(t, e);
}, Su = (t, e, s) => {
  const { vnode: n, slots: i } = t;
  let o = !0, r = ye;
  if (n.shapeFlag & 32) {
    const a = e._;
    a ? b.NODE_ENV !== "production" && pt ? (Fi(i, e, s), $t(t, "set", "$slots")) : s && a === 1 ? o = !1 : Fi(i, e, s) : (o = !e.$stable, qa(e, i)), r = e;
  } else e && (Ha(t, e), r = { default: 1 });
  if (o)
    for (const a in i)
      !lo(a) && r[a] == null && delete i[a];
};
let Us, jt;
function _s(t, e) {
  t.appContext.config.performance && Kn() && jt.mark(`vue-${e}-${t.uid}`), b.NODE_ENV !== "production" && wc(t, e, Kn() ? jt.now() : Date.now());
}
function Ts(t, e) {
  if (t.appContext.config.performance && Kn()) {
    const s = `vue-${e}-${t.uid}`, n = s + ":end", i = `<${bn(t, t.type)}> ${e}`;
    jt.mark(n), jt.measure(i, s, n), jt.clearMeasures(i), jt.clearMarks(s), jt.clearMarks(n);
  }
  b.NODE_ENV !== "production" && Dc(t, e, Kn() ? jt.now() : Date.now());
}
function Kn() {
  return Us !== void 0 || (typeof window < "u" && window.performance ? (Us = !0, jt = window.performance) : Us = !1), Us;
}
function Cu() {
  const t = [];
  if (b.NODE_ENV !== "production" && t.length) {
    const e = t.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${t.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const ze = Au;
function wu(t) {
  return Du(t);
}
function Du(t, e) {
  Cu();
  const s = un();
  s.__VUE__ = !0, b.NODE_ENV !== "production" && da(s.__VUE_DEVTOOLS_GLOBAL_HOOK__, s);
  const {
    insert: n,
    remove: i,
    patchProp: o,
    createElement: r,
    createText: a,
    createComment: l,
    setText: u,
    setElementText: c,
    parentNode: d,
    nextSibling: m,
    setScopeId: h = qe,
    insertStaticContent: g
  } = t, y = (p, v, N, I = null, D = null, A = null, U = void 0, F = null, P = b.NODE_ENV !== "production" && pt ? !1 : !!v.dynamicChildren) => {
    if (p === v)
      return;
    p && !fs(p, v) && (I = En(p), dt(p, D, A, !0), p = null), v.patchFlag === -2 && (P = !1, v.dynamicChildren = null);
    const { type: V, ref: X, shapeFlag: j } = v;
    switch (V) {
      case mn:
        _(p, v, N, I);
        break;
      case Be:
        E(p, v, N, I);
        break;
      case Vn:
        p == null ? x(v, N, I, U) : b.NODE_ENV !== "production" && T(p, v, N, U);
        break;
      case Ae:
        W(
          p,
          v,
          N,
          I,
          D,
          A,
          U,
          F,
          P
        );
        break;
      default:
        j & 1 ? K(
          p,
          v,
          N,
          I,
          D,
          A,
          U,
          F,
          P
        ) : j & 6 ? oe(
          p,
          v,
          N,
          I,
          D,
          A,
          U,
          F,
          P
        ) : j & 64 || j & 128 ? V.process(
          p,
          v,
          N,
          I,
          D,
          A,
          U,
          F,
          P,
          ks
        ) : b.NODE_ENV !== "production" && R("Invalid VNode type:", V, `(${typeof V})`);
    }
    X != null && D ? Ys(X, p && p.ref, A, v || p, !v) : X == null && p && p.ref != null && Ys(p.ref, null, A, p, !0);
  }, _ = (p, v, N, I) => {
    if (p == null)
      n(
        v.el = a(v.children),
        N,
        I
      );
    else {
      const D = v.el = p.el;
      v.children !== p.children && u(D, v.children);
    }
  }, E = (p, v, N, I) => {
    p == null ? n(
      v.el = l(v.children || ""),
      N,
      I
    ) : v.el = p.el;
  }, x = (p, v, N, I) => {
    [p.el, p.anchor] = g(
      p.children,
      v,
      N,
      I,
      p.el,
      p.anchor
    );
  }, T = (p, v, N, I) => {
    if (v.children !== p.children) {
      const D = m(p.anchor);
      M(p), [v.el, v.anchor] = g(
        v.children,
        N,
        D,
        I
      );
    } else
      v.el = p.el, v.anchor = p.anchor;
  }, O = ({ el: p, anchor: v }, N, I) => {
    let D;
    for (; p && p !== v; )
      D = m(p), n(p, N, I), p = D;
    n(v, N, I);
  }, M = ({ el: p, anchor: v }) => {
    let N;
    for (; p && p !== v; )
      N = m(p), i(p), p = N;
    i(v);
  }, K = (p, v, N, I, D, A, U, F, P) => {
    if (v.type === "svg" ? U = "svg" : v.type === "math" && (U = "mathml"), p == null)
      pe(
        v,
        N,
        I,
        D,
        A,
        U,
        F,
        P
      );
    else {
      const V = p.el && p.el._isVueCE ? p.el : null;
      try {
        V && V._beginPatch(), re(
          p,
          v,
          D,
          A,
          U,
          F,
          P
        );
      } finally {
        V && V._endPatch();
      }
    }
  }, pe = (p, v, N, I, D, A, U, F) => {
    let P, V;
    const { props: X, shapeFlag: j, transition: G, dirs: ie } = p;
    if (P = p.el = r(
      p.type,
      A,
      X && X.is,
      X
    ), j & 8 ? c(P, p.children) : j & 16 && H(
      p.children,
      P,
      null,
      I,
      D,
      Ti(p, A),
      U,
      F
    ), ie && os(p, null, I, "created"), he(P, p, p.scopeId, U, I), X) {
      for (const we in X)
        we !== "value" && !Ks(we) && o(P, we, null, X[we], A, I);
      "value" in X && o(P, "value", null, X.value, A), (V = X.onVnodeBeforeMount) && wt(V, I, p);
    }
    b.NODE_ENV !== "production" && (Ln(P, "__vnode", p, !0), Ln(P, "__vueParentComponent", I, !0)), ie && os(p, null, I, "beforeMount");
    const ge = Ou(D, G);
    ge && G.beforeEnter(P), n(P, v, N), ((V = X && X.onVnodeMounted) || ge || ie) && ze(() => {
      V && wt(V, I, p), ge && G.enter(P), ie && os(p, null, I, "mounted");
    }, D);
  }, he = (p, v, N, I, D) => {
    if (N && h(p, N), I)
      for (let A = 0; A < I.length; A++)
        h(p, I[A]);
    if (D) {
      let A = D.subTree;
      if (b.NODE_ENV !== "production" && A.patchFlag > 0 && A.patchFlag & 2048 && (A = ao(A.children) || A), v === A || za(A.type) && (A.ssContent === v || A.ssFallback === v)) {
        const U = D.vnode;
        he(
          p,
          U,
          U.scopeId,
          U.slotScopeIds,
          D.parent
        );
      }
    }
  }, H = (p, v, N, I, D, A, U, F, P = 0) => {
    for (let V = P; V < p.length; V++) {
      const X = p[V] = F ? qt(p[V]) : ft(p[V]);
      y(
        null,
        X,
        v,
        N,
        I,
        D,
        A,
        U,
        F
      );
    }
  }, re = (p, v, N, I, D, A, U) => {
    const F = v.el = p.el;
    b.NODE_ENV !== "production" && (F.__vnode = v);
    let { patchFlag: P, dynamicChildren: V, dirs: X } = v;
    P |= p.patchFlag & 16;
    const j = p.props || ye, G = v.props || ye;
    let ie;
    if (N && rs(N, !1), (ie = G.onVnodeBeforeUpdate) && wt(ie, N, v, p), X && os(v, p, N, "beforeUpdate"), N && rs(N, !0), b.NODE_ENV !== "production" && pt && (P = 0, U = !1, V = null), (j.innerHTML && G.innerHTML == null || j.textContent && G.textContent == null) && c(F, ""), V ? (me(
      p.dynamicChildren,
      V,
      F,
      N,
      I,
      Ti(v, D),
      A
    ), b.NODE_ENV !== "production" && Qs(p, v)) : U || J(
      p,
      v,
      F,
      null,
      N,
      I,
      Ti(v, D),
      A,
      !1
    ), P > 0) {
      if (P & 16)
        w(F, j, G, N, D);
      else if (P & 2 && j.class !== G.class && o(F, "class", null, G.class, D), P & 4 && o(F, "style", j.style, G.style, D), P & 8) {
        const ge = v.dynamicProps;
        for (let we = 0; we < ge.length; we++) {
          const xe = ge[we], et = j[xe], tt = G[xe];
          (tt !== et || xe === "value") && o(F, xe, et, tt, D, N);
        }
      }
      P & 1 && p.children !== v.children && c(F, v.children);
    } else !U && V == null && w(F, j, G, N, D);
    ((ie = G.onVnodeUpdated) || X) && ze(() => {
      ie && wt(ie, N, v, p), X && os(v, p, N, "updated");
    }, I);
  }, me = (p, v, N, I, D, A, U) => {
    for (let F = 0; F < v.length; F++) {
      const P = p[F], V = v[F], X = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        P.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (P.type === Ae || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !fs(P, V) || // - In the case of a component, it could contain anything.
        P.shapeFlag & 198) ? d(P.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          N
        )
      );
      y(
        P,
        V,
        X,
        null,
        I,
        D,
        A,
        U,
        !0
      );
    }
  }, w = (p, v, N, I, D) => {
    if (v !== N) {
      if (v !== ye)
        for (const A in v)
          !Ks(A) && !(A in N) && o(
            p,
            A,
            v[A],
            null,
            D,
            I
          );
      for (const A in N) {
        if (Ks(A)) continue;
        const U = N[A], F = v[A];
        U !== F && A !== "value" && o(p, A, F, U, D, I);
      }
      "value" in N && o(p, "value", v.value, N.value, D);
    }
  }, W = (p, v, N, I, D, A, U, F, P) => {
    const V = v.el = p ? p.el : a(""), X = v.anchor = p ? p.anchor : a("");
    let { patchFlag: j, dynamicChildren: G, slotScopeIds: ie } = v;
    b.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (pt || j & 2048) && (j = 0, P = !1, G = null), ie && (F = F ? F.concat(ie) : ie), p == null ? (n(V, N, I), n(X, N, I), H(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      v.children || [],
      N,
      X,
      D,
      A,
      U,
      F,
      P
    )) : j > 0 && j & 64 && G && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    p.dynamicChildren && p.dynamicChildren.length === G.length ? (me(
      p.dynamicChildren,
      G,
      N,
      D,
      A,
      U,
      F
    ), b.NODE_ENV !== "production" ? Qs(p, v) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (v.key != null || D && v === D.subTree) && Qs(
        p,
        v,
        !0
        /* shallow */
      )
    )) : J(
      p,
      v,
      N,
      X,
      D,
      A,
      U,
      F,
      P
    );
  }, oe = (p, v, N, I, D, A, U, F, P) => {
    v.slotScopeIds = F, p == null ? v.shapeFlag & 512 ? D.ctx.activate(
      v,
      N,
      I,
      U,
      P
    ) : be(
      v,
      N,
      I,
      D,
      A,
      U,
      P
    ) : fe(p, v, P);
  }, be = (p, v, N, I, D, A, U) => {
    const F = p.component = Pu(
      p,
      I,
      D
    );
    if (b.NODE_ENV !== "production" && F.type.__hmrId && gc(F), b.NODE_ENV !== "production" && (wn(p), _s(F, "mount")), pn(p) && (F.ctx.renderer = ks), b.NODE_ENV !== "production" && _s(F, "init"), Fu(F, !1, U), b.NODE_ENV !== "production" && Ts(F, "init"), b.NODE_ENV !== "production" && pt && (p.el = null), F.asyncDep) {
      if (D && D.registerDep(F, le, U), !p.el) {
        const P = F.subTree = C(Be);
        E(null, P, v, N), p.placeholder = P.el;
      }
    } else
      le(
        F,
        p,
        v,
        N,
        D,
        A,
        U
      );
    b.NODE_ENV !== "production" && (Dn(), Ts(F, "mount"));
  }, fe = (p, v, N) => {
    const I = v.component = p.component;
    if (du(p, v, N))
      if (I.asyncDep && !I.asyncResolved) {
        b.NODE_ENV !== "production" && wn(v), de(I, v, N), b.NODE_ENV !== "production" && Dn();
        return;
      } else
        I.next = v, I.update();
    else
      v.el = p.el, I.vnode = v;
  }, le = (p, v, N, I, D, A, U) => {
    const F = () => {
      if (p.isMounted) {
        let { next: j, bu: G, u: ie, parent: ge, vnode: we } = p;
        {
          const St = Wa(p);
          if (St) {
            j && (j.el = we.el, de(p, j, U)), St.asyncDep.then(() => {
              ze(() => {
                p.isUnmounted || V();
              }, D);
            });
            return;
          }
        }
        let xe = j, et;
        b.NODE_ENV !== "production" && wn(j || p.vnode), rs(p, !1), j ? (j.el = we.el, de(p, j, U)) : j = we, G && Ns(G), (et = j.props && j.props.onVnodeBeforeUpdate) && wt(et, ge, j, we), rs(p, !0), b.NODE_ENV !== "production" && _s(p, "render");
        const tt = Ho(p);
        b.NODE_ENV !== "production" && Ts(p, "render");
        const xt = p.subTree;
        p.subTree = tt, b.NODE_ENV !== "production" && _s(p, "patch"), y(
          xt,
          tt,
          // parent may have changed if it's in a teleport
          d(xt.el),
          // anchor may have changed if it's in a fragment
          En(xt),
          p,
          D,
          A
        ), b.NODE_ENV !== "production" && Ts(p, "patch"), j.el = tt.el, xe === null && fu(p, tt.el), ie && ze(ie, D), (et = j.props && j.props.onVnodeUpdated) && ze(
          () => wt(et, ge, j, we),
          D
        ), b.NODE_ENV !== "production" && fa(p), b.NODE_ENV !== "production" && Dn();
      } else {
        let j;
        const { el: G, props: ie } = v, { bm: ge, m: we, parent: xe, root: et, type: tt } = p, xt = ws(v);
        rs(p, !1), ge && Ns(ge), !xt && (j = ie && ie.onVnodeBeforeMount) && wt(j, xe, v), rs(p, !0);
        {
          et.ce && et.ce._hasShadowRoot() && et.ce._injectChildStyle(tt), b.NODE_ENV !== "production" && _s(p, "render");
          const St = p.subTree = Ho(p);
          b.NODE_ENV !== "production" && Ts(p, "render"), b.NODE_ENV !== "production" && _s(p, "patch"), y(
            null,
            St,
            N,
            I,
            p,
            D,
            A
          ), b.NODE_ENV !== "production" && Ts(p, "patch"), v.el = St.el;
        }
        if (we && ze(we, D), !xt && (j = ie && ie.onVnodeMounted)) {
          const St = v;
          ze(
            () => wt(j, xe, St),
            D
          );
        }
        (v.shapeFlag & 256 || xe && ws(xe.vnode) && xe.vnode.shapeFlag & 256) && p.a && ze(p.a, D), p.isMounted = !0, b.NODE_ENV !== "production" && xc(p), v = N = I = null;
      }
    };
    p.scope.on();
    const P = p.effect = new Ur(F);
    p.scope.off();
    const V = p.update = P.run.bind(P), X = p.job = P.runIfDirty.bind(P);
    X.i = p, X.id = p.uid, P.scheduler = () => ii(X), rs(p, !0), b.NODE_ENV !== "production" && (P.onTrack = p.rtc ? (j) => Ns(p.rtc, j) : void 0, P.onTrigger = p.rtg ? (j) => Ns(p.rtg, j) : void 0), V();
  }, de = (p, v, N) => {
    v.component = p;
    const I = p.vnode.props;
    p.vnode = v, p.next = null, mu(p, v.props, I, N), Su(p, v.children, N), gt(), Vo(p), Et();
  }, J = (p, v, N, I, D, A, U, F, P = !1) => {
    const V = p && p.children, X = p ? p.shapeFlag : 0, j = v.children, { patchFlag: G, shapeFlag: ie } = v;
    if (G > 0) {
      if (G & 128) {
        Oe(
          V,
          j,
          N,
          I,
          D,
          A,
          U,
          F,
          P
        );
        return;
      } else if (G & 256) {
        L(
          V,
          j,
          N,
          I,
          D,
          A,
          U,
          F,
          P
        );
        return;
      }
    }
    ie & 8 ? (X & 16 && Ls(V, D, A), j !== V && c(N, j)) : X & 16 ? ie & 16 ? Oe(
      V,
      j,
      N,
      I,
      D,
      A,
      U,
      F,
      P
    ) : Ls(V, D, A, !0) : (X & 8 && c(N, ""), ie & 16 && H(
      j,
      N,
      I,
      D,
      A,
      U,
      F,
      P
    ));
  }, L = (p, v, N, I, D, A, U, F, P) => {
    p = p || Ss, v = v || Ss;
    const V = p.length, X = v.length, j = Math.min(V, X);
    let G;
    for (G = 0; G < j; G++) {
      const ie = v[G] = P ? qt(v[G]) : ft(v[G]);
      y(
        p[G],
        ie,
        N,
        null,
        D,
        A,
        U,
        F,
        P
      );
    }
    V > X ? Ls(
      p,
      D,
      A,
      !0,
      !1,
      j
    ) : H(
      v,
      N,
      I,
      D,
      A,
      U,
      F,
      P,
      j
    );
  }, Oe = (p, v, N, I, D, A, U, F, P) => {
    let V = 0;
    const X = v.length;
    let j = p.length - 1, G = X - 1;
    for (; V <= j && V <= G; ) {
      const ie = p[V], ge = v[V] = P ? qt(v[V]) : ft(v[V]);
      if (fs(ie, ge))
        y(
          ie,
          ge,
          N,
          null,
          D,
          A,
          U,
          F,
          P
        );
      else
        break;
      V++;
    }
    for (; V <= j && V <= G; ) {
      const ie = p[j], ge = v[G] = P ? qt(v[G]) : ft(v[G]);
      if (fs(ie, ge))
        y(
          ie,
          ge,
          N,
          null,
          D,
          A,
          U,
          F,
          P
        );
      else
        break;
      j--, G--;
    }
    if (V > j) {
      if (V <= G) {
        const ie = G + 1, ge = ie < X ? v[ie].el : I;
        for (; V <= G; )
          y(
            null,
            v[V] = P ? qt(v[V]) : ft(v[V]),
            N,
            ge,
            D,
            A,
            U,
            F,
            P
          ), V++;
      }
    } else if (V > G)
      for (; V <= j; )
        dt(p[V], D, A, !0), V++;
    else {
      const ie = V, ge = V, we = /* @__PURE__ */ new Map();
      for (V = ge; V <= G; V++) {
        const Ye = v[V] = P ? qt(v[V]) : ft(v[V]);
        Ye.key != null && (b.NODE_ENV !== "production" && we.has(Ye.key) && R(
          "Duplicate keys found during update:",
          JSON.stringify(Ye.key),
          "Make sure keys are unique."
        ), we.set(Ye.key, V));
      }
      let xe, et = 0;
      const tt = G - ge + 1;
      let xt = !1, St = 0;
      const Ps = new Array(tt);
      for (V = 0; V < tt; V++) Ps[V] = 0;
      for (V = ie; V <= j; V++) {
        const Ye = p[V];
        if (et >= tt) {
          dt(Ye, D, A, !0);
          continue;
        }
        let Ct;
        if (Ye.key != null)
          Ct = we.get(Ye.key);
        else
          for (xe = ge; xe <= G; xe++)
            if (Ps[xe - ge] === 0 && fs(Ye, v[xe])) {
              Ct = xe;
              break;
            }
        Ct === void 0 ? dt(Ye, D, A, !0) : (Ps[Ct - ge] = V + 1, Ct >= St ? St = Ct : xt = !0, y(
          Ye,
          v[Ct],
          N,
          null,
          D,
          A,
          U,
          F,
          P
        ), et++);
      }
      const xo = xt ? $u(Ps) : Ss;
      for (xe = xo.length - 1, V = tt - 1; V >= 0; V--) {
        const Ye = ge + V, Ct = v[Ye], So = v[Ye + 1], Co = Ye + 1 < X ? (
          // #13559, #14173 fallback to el placeholder for unresolved async component
          So.el || Ka(So)
        ) : I;
        Ps[V] === 0 ? y(
          null,
          Ct,
          N,
          Co,
          D,
          A,
          U,
          F,
          P
        ) : xt && (xe < 0 || V !== xo[xe] ? We(Ct, N, Co, 2) : xe--);
      }
    }
  }, We = (p, v, N, I, D = null) => {
    const { el: A, type: U, transition: F, children: P, shapeFlag: V } = p;
    if (V & 6) {
      We(p.component.subTree, v, N, I);
      return;
    }
    if (V & 128) {
      p.suspense.move(v, N, I);
      return;
    }
    if (V & 64) {
      U.move(p, v, N, ks);
      return;
    }
    if (U === Ae) {
      n(A, v, N);
      for (let j = 0; j < P.length; j++)
        We(P[j], v, N, I);
      n(p.anchor, v, N);
      return;
    }
    if (U === Vn) {
      O(p, v, N);
      return;
    }
    if (I !== 2 && V & 1 && F)
      if (I === 0)
        F.beforeEnter(A), n(A, v, N), ze(() => F.enter(A), D);
      else {
        const { leave: j, delayLeave: G, afterLeave: ie } = F, ge = () => {
          p.ctx.isUnmounted ? i(A) : n(A, v, N);
        }, we = () => {
          A._isLeaving && A[Ot](
            !0
            /* cancelled */
          ), j(A, () => {
            ge(), ie && ie();
          });
        };
        G ? G(A, ge, we) : we();
      }
    else
      n(A, v, N);
  }, dt = (p, v, N, I = !1, D = !1) => {
    const {
      type: A,
      props: U,
      ref: F,
      children: P,
      dynamicChildren: V,
      shapeFlag: X,
      patchFlag: j,
      dirs: G,
      cacheIndex: ie
    } = p;
    if (j === -2 && (D = !1), F != null && (gt(), Ys(F, null, N, p, !0), Et()), ie != null && (v.renderCache[ie] = void 0), X & 256) {
      v.ctx.deactivate(p);
      return;
    }
    const ge = X & 1 && G, we = !ws(p);
    let xe;
    if (we && (xe = U && U.onVnodeBeforeUnmount) && wt(xe, v, p), X & 6)
      hl(p.component, N, I);
    else {
      if (X & 128) {
        p.suspense.unmount(N, I);
        return;
      }
      ge && os(p, null, v, "beforeUnmount"), X & 64 ? p.type.remove(
        p,
        v,
        N,
        ks,
        I
      ) : V && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !V.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (A !== Ae || j > 0 && j & 64) ? Ls(
        V,
        v,
        N,
        !1,
        !0
      ) : (A === Ae && j & 384 || !D && X & 16) && Ls(P, v, N), I && fi(p);
    }
    (we && (xe = U && U.onVnodeUnmounted) || ge) && ze(() => {
      xe && wt(xe, v, p), ge && os(p, null, v, "unmounted");
    }, N);
  }, fi = (p) => {
    const { type: v, el: N, anchor: I, transition: D } = p;
    if (v === Ae) {
      b.NODE_ENV !== "production" && p.patchFlag > 0 && p.patchFlag & 2048 && D && !D.persisted ? p.children.forEach((U) => {
        U.type === Be ? i(U.el) : fi(U);
      }) : pl(N, I);
      return;
    }
    if (v === Vn) {
      M(p);
      return;
    }
    const A = () => {
      i(N), D && !D.persisted && D.afterLeave && D.afterLeave();
    };
    if (p.shapeFlag & 1 && D && !D.persisted) {
      const { leave: U, delayLeave: F } = D, P = () => U(N, A);
      F ? F(p.el, A, P) : P();
    } else
      A();
  }, pl = (p, v) => {
    let N;
    for (; p !== v; )
      N = m(p), i(p), p = N;
    i(v);
  }, hl = (p, v, N) => {
    b.NODE_ENV !== "production" && p.type.__hmrId && Ec(p);
    const { bum: I, scope: D, job: A, subTree: U, um: F, m: P, a: V } = p;
    Qo(P), Qo(V), I && Ns(I), D.stop(), A && (A.flags |= 8, dt(U, p, v, N)), F && ze(F, v), ze(() => {
      p.isUnmounted = !0;
    }, v), b.NODE_ENV !== "production" && Cc(p);
  }, Ls = (p, v, N, I = !1, D = !1, A = 0) => {
    for (let U = A; U < p.length; U++)
      dt(p[U], v, N, I, D);
  }, En = (p) => {
    if (p.shapeFlag & 6)
      return En(p.component.subTree);
    if (p.shapeFlag & 128)
      return p.suspense.next();
    const v = m(p.anchor || p.el), N = v && v[ba];
    return N ? m(N) : v;
  };
  let pi = !1;
  const No = (p, v, N) => {
    let I;
    p == null ? v._vnode && (dt(v._vnode, null, null, !0), I = v._vnode.component) : y(
      v._vnode || null,
      p,
      v,
      null,
      null,
      null,
      N
    ), v._vnode = p, pi || (pi = !0, Vo(I), la(), pi = !1);
  }, ks = {
    p: y,
    um: dt,
    m: We,
    r: fi,
    mt: be,
    mc: H,
    pc: J,
    pbc: me,
    n: En,
    o: t
  };
  return {
    render: No,
    hydrate: void 0,
    createApp: ru(No)
  };
}
function Ti({ type: t, props: e }, s) {
  return s === "svg" && t === "foreignObject" || s === "mathml" && t === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : s;
}
function rs({ effect: t, job: e }, s) {
  s ? (t.flags |= 32, e.flags |= 4) : (t.flags &= -33, e.flags &= -5);
}
function Ou(t, e) {
  return (!t || t && !t.pendingBranch) && e && !e.persisted;
}
function Qs(t, e, s = !1) {
  const n = t.children, i = e.children;
  if (z(n) && z(i))
    for (let o = 0; o < n.length; o++) {
      const r = n[o];
      let a = i[o];
      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[o] = qt(i[o]), a.el = r.el), !s && a.patchFlag !== -2 && Qs(r, a)), a.type === mn && (a.patchFlag === -1 && (a = i[o] = qt(a)), a.el = r.el), a.type === Be && !a.el && (a.el = r.el), b.NODE_ENV !== "production" && a.el && (a.el.__vnode = a);
    }
}
function $u(t) {
  const e = t.slice(), s = [0];
  let n, i, o, r, a;
  const l = t.length;
  for (n = 0; n < l; n++) {
    const u = t[n];
    if (u !== 0) {
      if (i = s[s.length - 1], t[i] < u) {
        e[n] = i, s.push(n);
        continue;
      }
      for (o = 0, r = s.length - 1; o < r; )
        a = o + r >> 1, t[s[a]] < u ? o = a + 1 : r = a;
      u < t[s[o]] && (o > 0 && (e[n] = s[o - 1]), s[o] = n);
    }
  }
  for (o = s.length, r = s[o - 1]; o-- > 0; )
    s[o] = r, r = e[r];
  return s;
}
function Wa(t) {
  const e = t.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : Wa(e);
}
function Qo(t) {
  if (t)
    for (let e = 0; e < t.length; e++)
      t[e].flags |= 8;
}
function Ka(t) {
  if (t.placeholder)
    return t.placeholder;
  const e = t.component;
  return e ? Ka(e.subTree) : null;
}
const za = (t) => t.__isSuspense;
function Au(t, e) {
  e && e.pendingBranch ? z(t) ? e.effects.push(...t) : e.effects.push(t) : aa(t);
}
const Ae = /* @__PURE__ */ Symbol.for("v-fgt"), mn = /* @__PURE__ */ Symbol.for("v-txt"), Be = /* @__PURE__ */ Symbol.for("v-cmt"), Vn = /* @__PURE__ */ Symbol.for("v-stc"), Js = [];
let lt = null;
function S(t = !1) {
  Js.push(lt = t ? null : []);
}
function Vu() {
  Js.pop(), lt = Js[Js.length - 1] || null;
}
let nn = 1;
function zn(t, e = !1) {
  nn += t, t < 0 && lt && e && (lt.hasOnce = !0);
}
function Ga(t) {
  return t.dynamicChildren = nn > 0 ? lt || Ss : null, Vu(), nn > 0 && lt && lt.push(t), t;
}
function k(t, e, s, n, i, o) {
  return Ga(
    f(
      t,
      e,
      s,
      n,
      i,
      o,
      !0
    )
  );
}
function Le(t, e, s, n, i) {
  return Ga(
    C(
      t,
      e,
      s,
      n,
      i,
      !0
    )
  );
}
function Es(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function fs(t, e) {
  if (b.NODE_ENV !== "production" && e.shapeFlag & 6 && t.component) {
    const s = On.get(e.type);
    if (s && s.has(t.component))
      return t.shapeFlag &= -257, e.shapeFlag &= -513, !1;
  }
  return t.type === e.type && t.key === e.key;
}
const Mu = (...t) => Qa(
  ...t
), Ya = ({ key: t }) => t ?? null, Mn = ({
  ref: t,
  ref_key: e,
  ref_for: s
}) => (typeof t == "number" && (t = "" + t), t != null ? Me(t) || /* @__PURE__ */ Fe(t) || Z(t) ? { i: He, r: t, k: e, f: !!s } : t : null);
function f(t, e = null, s = null, n = 0, i = null, o = t === Ae ? 0 : 1, r = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && Ya(e),
    ref: e && Mn(e),
    scopeId: ha,
    slotScopeIds: null,
    children: s,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: n,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: He
  };
  return a ? (uo(l, s), o & 128 && t.normalize(l)) : s && (l.shapeFlag |= Me(s) ? 8 : 16), b.NODE_ENV !== "production" && l.key !== l.key && R("VNode created with invalid key (NaN). VNode type:", l.type), nn > 0 && // avoid a block node from tracking itself
  !r && // has current parent block
  lt && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && lt.push(l), l;
}
const C = b.NODE_ENV !== "production" ? Mu : Qa;
function Qa(t, e = null, s = null, n = 0, i = null, o = !1) {
  if ((!t || t === Yc) && (b.NODE_ENV !== "production" && !t && R(`Invalid vnode type when creating vnode: ${t}.`), t = Be), Es(t)) {
    const a = kt(
      t,
      e,
      !0
      /* mergeRef: true */
    );
    return s && uo(a, s), nn > 0 && !o && lt && (a.shapeFlag & 6 ? lt[lt.indexOf(t)] = a : lt.push(a)), a.patchFlag = -2, a;
  }
  if (tl(t) && (t = t.__vccOpts), e) {
    e = Iu(e);
    let { class: a, style: l } = e;
    a && !Me(a) && (e.class = Ie(a)), ve(l) && (/* @__PURE__ */ kn(l) && !z(l) && (l = Ve({}, l)), e.style = Ke(l));
  }
  const r = Me(t) ? 1 : za(t) ? 128 : ga(t) ? 64 : ve(t) ? 4 : Z(t) ? 2 : 0;
  return b.NODE_ENV !== "production" && r & 4 && /* @__PURE__ */ kn(t) && (t = /* @__PURE__ */ ce(t), R(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    t
  )), f(
    t,
    e,
    s,
    n,
    i,
    r,
    o,
    !0
  );
}
function Iu(t) {
  return t ? /* @__PURE__ */ kn(t) || Ba(t) ? Ve({}, t) : t : null;
}
function kt(t, e, s = !1, n = !1) {
  const { props: i, ref: o, patchFlag: r, children: a, transition: l } = t, u = e ? Ru(i || {}, e) : i, c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: u,
    key: u && Ya(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      s && o ? z(o) ? o.concat(Mn(e)) : [o, Mn(e)] : Mn(e)
    ) : o,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: b.NODE_ENV !== "production" && r === -1 && z(a) ? a.map(Ja) : a,
    target: t.target,
    targetStart: t.targetStart,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && t.type !== Ae ? r === -1 ? 16 : r | 16 : r,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: l,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && kt(t.ssContent),
    ssFallback: t.ssFallback && kt(t.ssFallback),
    placeholder: t.placeholder,
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
  return l && n && sn(
    c,
    l.clone(c)
  ), c;
}
function Ja(t) {
  const e = kt(t);
  return z(t.children) && (e.children = t.children.map(Ja)), e;
}
function se(t = " ", e = 0) {
  return C(mn, null, t, e);
}
function ne(t = "", e = !1) {
  return e ? (S(), Le(Be, null, t)) : C(Be, null, t);
}
function ft(t) {
  return t == null || typeof t == "boolean" ? C(Be) : z(t) ? C(
    Ae,
    null,
    // #3666, avoid reference pollution when reusing vnode
    t.slice()
  ) : Es(t) ? qt(t) : C(mn, null, String(t));
}
function qt(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : kt(t);
}
function uo(t, e) {
  let s = 0;
  const { shapeFlag: n } = t;
  if (e == null)
    e = null;
  else if (z(e))
    s = 16;
  else if (typeof e == "object")
    if (n & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), uo(t, i()), i._c && (i._d = !0));
      return;
    } else {
      s = 32;
      const i = e._;
      !i && !Ba(e) ? e._ctx = He : i === 3 && He && (He.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else Z(e) ? (e = { default: e, _ctx: He }, s = 32) : (e = String(e), n & 64 ? (s = 16, e = [se(e)]) : s = 8);
  t.children = e, t.shapeFlag |= s;
}
function Ru(...t) {
  const e = {};
  for (let s = 0; s < t.length; s++) {
    const n = t[s];
    for (const i in n)
      if (i === "class")
        e.class !== n.class && (e.class = Ie([e.class, n.class]));
      else if (i === "style")
        e.style = Ke([e.style, n.style]);
      else if (ln(i)) {
        const o = e[i], r = n[i];
        r && o !== r && !(z(o) && o.includes(r)) && (e[i] = o ? [].concat(o, r) : r);
      } else i !== "" && (e[i] = n[i]);
  }
  return e;
}
function wt(t, e, s, n = null) {
  Tt(t, e, 7, [
    s,
    n
  ]);
}
const Lu = Va();
let ku = 0;
function Pu(t, e, s) {
  const n = t.type, i = (e ? e.appContext : t.appContext) || Lu, o = {
    uid: ku++,
    vnode: t,
    type: n,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Ml(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Ua(n, i),
    emitsOptions: Ia(n, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: ye,
    // inheritAttrs
    inheritAttrs: n.inheritAttrs,
    // state
    ctx: ye,
    data: ye,
    props: ye,
    attrs: ye,
    slots: ye,
    refs: ye,
    setupState: ye,
    setupContext: null,
    // suspense related
    suspense: s,
    suspenseId: s ? s.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return b.NODE_ENV !== "production" ? o.ctx = Qc(o) : o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = au.bind(null, o), t.ce && t.ce(o), o;
}
let Ue = null;
const ai = () => Ue || He;
let Gn, Ui;
{
  const t = un(), e = (s, n) => {
    let i;
    return (i = t[s]) || (i = t[s] = []), i.push(n), (o) => {
      i.length > 1 ? i.forEach((r) => r(o)) : i[0](o);
    };
  };
  Gn = e(
    "__VUE_INSTANCE_SETTERS__",
    (s) => Ue = s
  ), Ui = e(
    "__VUE_SSR_SETTERS__",
    (s) => on = s
  );
}
const vn = (t) => {
  const e = Ue;
  return Gn(t), t.scope.on(), () => {
    t.scope.off(), Gn(e);
  };
}, Jo = () => {
  Ue && Ue.scope.off(), Gn(null);
}, Bu = /* @__PURE__ */ Yt("slot,component");
function ji(t, { isNativeTag: e }) {
  (Bu(t) || e(t)) && R(
    "Do not use built-in or reserved HTML elements as component id: " + t
  );
}
function Xa(t) {
  return t.vnode.shapeFlag & 4;
}
let on = !1;
function Fu(t, e = !1, s = !1) {
  e && Ui(e);
  const { props: n, children: i } = t.vnode, o = Xa(t);
  pu(t, n, o, e), xu(t, i, s || e);
  const r = o ? Uu(t, e) : void 0;
  return e && Ui(!1), r;
}
function Uu(t, e) {
  const s = t.type;
  if (b.NODE_ENV !== "production") {
    if (s.name && ji(s.name, t.appContext.config), s.components) {
      const i = Object.keys(s.components);
      for (let o = 0; o < i.length; o++)
        ji(i[o], t.appContext.config);
    }
    if (s.directives) {
      const i = Object.keys(s.directives);
      for (let o = 0; o < i.length; o++)
        ma(i[o]);
    }
    s.compilerOptions && ju() && R(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = new Proxy(t.ctx, Oa), b.NODE_ENV !== "production" && Jc(t);
  const { setup: n } = s;
  if (n) {
    gt();
    const i = t.setupContext = n.length > 1 ? Hu(t) : null, o = vn(t), r = Rs(
      n,
      t,
      0,
      [
        b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(t.props) : t.props,
        i
      ]
    ), a = zi(r);
    if (Et(), o(), (a || t.sp) && !ws(t) && Ca(t), a) {
      if (r.then(Jo, Jo), e)
        return r.then((l) => {
          Xo(t, l, e);
        }).catch((l) => {
          dn(l, t, 0);
        });
      if (t.asyncDep = r, b.NODE_ENV !== "production" && !t.suspense) {
        const l = bn(t, s);
        R(
          `Component <${l}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      Xo(t, r, e);
  } else
    Za(t, e);
}
function Xo(t, e, s) {
  Z(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : ve(e) ? (b.NODE_ENV !== "production" && Es(e) && R(
    "setup() should not return VNodes directly - return a render function instead."
  ), b.NODE_ENV !== "production" && (t.devtoolsRawSetupState = e), t.setupState = na(e), b.NODE_ENV !== "production" && Xc(t)) : b.NODE_ENV !== "production" && e !== void 0 && R(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), Za(t, s);
}
const ju = () => !0;
function Za(t, e, s) {
  const n = t.type;
  t.render || (t.render = n.render || qe);
  {
    const i = vn(t);
    gt();
    try {
      eu(t);
    } finally {
      Et(), i();
    }
  }
  b.NODE_ENV !== "production" && !n.render && t.render === qe && !e && (n.template ? R(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : R("Component is missing template or render function: ", n));
}
const Zo = b.NODE_ENV !== "production" ? {
  get(t, e) {
    return Wn(), je(t, "get", ""), t[e];
  },
  set() {
    return R("setupContext.attrs is readonly."), !1;
  },
  deleteProperty() {
    return R("setupContext.attrs is readonly."), !1;
  }
} : {
  get(t, e) {
    return je(t, "get", ""), t[e];
  }
};
function qu(t) {
  return new Proxy(t.slots, {
    get(e, s) {
      return je(t, "get", "$slots"), e[s];
    }
  });
}
function Hu(t) {
  const e = (s) => {
    if (b.NODE_ENV !== "production" && (t.exposed && R("expose() should be called only once per setup()."), s != null)) {
      let n = typeof s;
      n === "object" && (z(s) ? n = "array" : /* @__PURE__ */ Fe(s) && (n = "ref")), n !== "object" && R(
        `expose() should be passed a plain object, received ${n}.`
      );
    }
    t.exposed = s || {};
  };
  if (b.NODE_ENV !== "production") {
    let s, n;
    return Object.freeze({
      get attrs() {
        return s || (s = new Proxy(t.attrs, Zo));
      },
      get slots() {
        return n || (n = qu(t));
      },
      get emit() {
        return (i, ...o) => t.emit(i, ...o);
      },
      expose: e
    });
  } else
    return {
      attrs: new Proxy(t.attrs, Zo),
      slots: t.slots,
      emit: t.emit,
      expose: e
    };
}
function li(t) {
  return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(na(ec(t.exposed)), {
    get(e, s) {
      if (s in e)
        return e[s];
      if (s in bs)
        return bs[s](t);
    },
    has(e, s) {
      return s in e || s in bs;
    }
  })) : t.proxy;
}
const Wu = /(?:^|[-_])\w/g, Ku = (t) => t.replace(Wu, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function el(t, e = !0) {
  return Z(t) ? t.displayName || t.name : t.name || e && t.__name;
}
function bn(t, e, s = !1) {
  let n = el(e);
  if (!n && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (n = i[1]);
  }
  if (!n && t) {
    const i = (o) => {
      for (const r in o)
        if (o[r] === e)
          return r;
    };
    n = i(t.components) || t.parent && i(
      t.parent.type.components
    ) || i(t.appContext.components);
  }
  return n ? Ku(n) : s ? "App" : "Anonymous";
}
function tl(t) {
  return Z(t) && "__vccOpts" in t;
}
const te = (t, e) => {
  const s = /* @__PURE__ */ ac(t, e, on);
  if (b.NODE_ENV !== "production") {
    const n = ai();
    n && n.appContext.config.warnRecursiveComputed && (s._warnRecursive = !0);
  }
  return s;
};
function zu(t, e, s) {
  try {
    zn(-1);
    const n = arguments.length;
    return n === 2 ? ve(e) && !z(e) ? Es(e) ? C(t, null, [e]) : C(t, e) : C(t, null, e) : (n > 3 ? s = Array.prototype.slice.call(arguments, 2) : n === 3 && Es(s) && (s = [s]), C(t, e, s));
  } finally {
    zn(1);
  }
}
function Gu() {
  if (b.NODE_ENV === "production" || typeof window > "u")
    return;
  const t = { style: "color:#3ba776" }, e = { style: "color:#1677ff" }, s = { style: "color:#f5222d" }, n = { style: "color:#eb2f96" }, i = {
    __vue_custom_formatter: !0,
    header(d) {
      if (!ve(d))
        return null;
      if (d.__isVue)
        return ["div", t, "VueInstance"];
      if (/* @__PURE__ */ Fe(d)) {
        gt();
        const m = d.value;
        return Et(), [
          "div",
          {},
          ["span", t, c(d)],
          "<",
          a(m),
          ">"
        ];
      } else {
        if (/* @__PURE__ */ ns(d))
          return [
            "div",
            {},
            ["span", t, /* @__PURE__ */ Ze(d) ? "ShallowReactive" : "Reactive"],
            "<",
            a(d),
            `>${/* @__PURE__ */ yt(d) ? " (readonly)" : ""}`
          ];
        if (/* @__PURE__ */ yt(d))
          return [
            "div",
            {},
            ["span", t, /* @__PURE__ */ Ze(d) ? "ShallowReadonly" : "Readonly"],
            "<",
            a(d),
            ">"
          ];
      }
      return null;
    },
    hasBody(d) {
      return d && d.__isVue;
    },
    body(d) {
      if (d && d.__isVue)
        return [
          "div",
          {},
          ...o(d.$)
        ];
    }
  };
  function o(d) {
    const m = [];
    d.type.props && d.props && m.push(r("props", /* @__PURE__ */ ce(d.props))), d.setupState !== ye && m.push(r("setup", d.setupState)), d.data !== ye && m.push(r("data", /* @__PURE__ */ ce(d.data)));
    const h = l(d, "computed");
    h && m.push(r("computed", h));
    const g = l(d, "inject");
    return g && m.push(r("injected", g)), m.push([
      "div",
      {},
      [
        "span",
        {
          style: n.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: d }]
    ]), m;
  }
  function r(d, m) {
    return m = Ve({}, m), Object.keys(m).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        d
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(m).map((h) => [
          "div",
          {},
          ["span", n, h + ": "],
          a(m[h], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function a(d, m = !0) {
    return typeof d == "number" ? ["span", e, d] : typeof d == "string" ? ["span", s, JSON.stringify(d)] : typeof d == "boolean" ? ["span", n, d] : ve(d) ? ["object", { object: m ? /* @__PURE__ */ ce(d) : d }] : ["span", s, String(d)];
  }
  function l(d, m) {
    const h = d.type;
    if (Z(h))
      return;
    const g = {};
    for (const y in d.ctx)
      u(h, y, m) && (g[y] = d.ctx[y]);
    return g;
  }
  function u(d, m, h) {
    const g = d[h];
    if (z(g) && g.includes(m) || ve(g) && m in g || d.extends && u(d.extends, m, h) || d.mixins && d.mixins.some((y) => u(y, m, h)))
      return !0;
  }
  function c(d) {
    return /* @__PURE__ */ Ze(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];
}
const er = "3.5.28", Rt = b.NODE_ENV !== "production" ? R : qe;
var Nt = {};
let qi;
const tr = typeof window < "u" && window.trustedTypes;
if (tr)
  try {
    qi = /* @__PURE__ */ tr.createPolicy("vue", {
      createHTML: (t) => t
    });
  } catch (t) {
    Nt.NODE_ENV !== "production" && Rt(`Error creating trusted types policy: ${t}`);
  }
const sl = qi ? (t) => qi.createHTML(t) : (t) => t, Yu = "http://www.w3.org/2000/svg", Qu = "http://www.w3.org/1998/Math/MathML", Ut = typeof document < "u" ? document : null, sr = Ut && /* @__PURE__ */ Ut.createElement("template"), Ju = {
  insert: (t, e, s) => {
    e.insertBefore(t, s || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, s, n) => {
    const i = e === "svg" ? Ut.createElementNS(Yu, t) : e === "mathml" ? Ut.createElementNS(Qu, t) : s ? Ut.createElement(t, { is: s }) : Ut.createElement(t);
    return t === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple), i;
  },
  createText: (t) => Ut.createTextNode(t),
  createComment: (t) => Ut.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Ut.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(t, e, s, n, i, o) {
    const r = s ? s.previousSibling : e.lastChild;
    if (i && (i === o || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), s), !(i === o || !(i = i.nextSibling)); )
        ;
    else {
      sr.innerHTML = sl(
        n === "svg" ? `<svg>${t}</svg>` : n === "mathml" ? `<math>${t}</math>` : t
      );
      const a = sr.content;
      if (n === "svg" || n === "mathml") {
        const l = a.firstChild;
        for (; l.firstChild; )
          a.appendChild(l.firstChild);
        a.removeChild(l);
      }
      e.insertBefore(a, s);
    }
    return [
      // first
      r ? r.nextSibling : e.firstChild,
      // last
      s ? s.previousSibling : e.lastChild
    ];
  }
}, Jt = "transition", js = "animation", rn = /* @__PURE__ */ Symbol("_vtc"), nl = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, Xu = /* @__PURE__ */ Ve(
  {},
  _a,
  nl
), Zu = (t) => (t.displayName = "Transition", t.props = Xu, t), fo = /* @__PURE__ */ Zu(
  (t, { slots: e }) => zu(Pc, ed(t), e)
), as = (t, e = []) => {
  z(t) ? t.forEach((s) => s(...e)) : t && t(...e);
}, nr = (t) => t ? z(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function ed(t) {
  const e = {};
  for (const w in t)
    w in nl || (e[w] = t[w]);
  if (t.css === !1)
    return e;
  const {
    name: s = "v",
    type: n,
    duration: i,
    enterFromClass: o = `${s}-enter-from`,
    enterActiveClass: r = `${s}-enter-active`,
    enterToClass: a = `${s}-enter-to`,
    appearFromClass: l = o,
    appearActiveClass: u = r,
    appearToClass: c = a,
    leaveFromClass: d = `${s}-leave-from`,
    leaveActiveClass: m = `${s}-leave-active`,
    leaveToClass: h = `${s}-leave-to`
  } = t, g = td(i), y = g && g[0], _ = g && g[1], {
    onBeforeEnter: E,
    onEnter: x,
    onEnterCancelled: T,
    onLeave: O,
    onLeaveCancelled: M,
    onBeforeAppear: K = E,
    onAppear: pe = x,
    onAppearCancelled: he = T
  } = e, H = (w, W, oe, be) => {
    w._enterCancelled = be, ls(w, W ? c : a), ls(w, W ? u : r), oe && oe();
  }, re = (w, W) => {
    w._isLeaving = !1, ls(w, d), ls(w, h), ls(w, m), W && W();
  }, me = (w) => (W, oe) => {
    const be = w ? pe : x, fe = () => H(W, w, oe);
    as(be, [W, fe]), ir(() => {
      ls(W, w ? l : o), Ft(W, w ? c : a), nr(be) || or(W, n, y, fe);
    });
  };
  return Ve(e, {
    onBeforeEnter(w) {
      as(E, [w]), Ft(w, o), Ft(w, r);
    },
    onBeforeAppear(w) {
      as(K, [w]), Ft(w, l), Ft(w, u);
    },
    onEnter: me(!1),
    onAppear: me(!0),
    onLeave(w, W) {
      w._isLeaving = !0;
      const oe = () => re(w, W);
      Ft(w, d), w._enterCancelled ? (Ft(w, m), lr(w)) : (lr(w), Ft(w, m)), ir(() => {
        w._isLeaving && (ls(w, d), Ft(w, h), nr(O) || or(w, n, _, oe));
      }), as(O, [w, oe]);
    },
    onEnterCancelled(w) {
      H(w, !1, void 0, !0), as(T, [w]);
    },
    onAppearCancelled(w) {
      H(w, !0, void 0, !0), as(he, [w]);
    },
    onLeaveCancelled(w) {
      re(w), as(M, [w]);
    }
  });
}
function td(t) {
  if (t == null)
    return null;
  if (ve(t))
    return [Ni(t.enter), Ni(t.leave)];
  {
    const e = Ni(t);
    return [e, e];
  }
}
function Ni(t) {
  const e = El(t);
  return Nt.NODE_ENV !== "production" && hc(e, "<transition> explicit duration"), e;
}
function Ft(t, e) {
  e.split(/\s+/).forEach((s) => s && t.classList.add(s)), (t[rn] || (t[rn] = /* @__PURE__ */ new Set())).add(e);
}
function ls(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.remove(n));
  const s = t[rn];
  s && (s.delete(e), s.size || (t[rn] = void 0));
}
function ir(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let sd = 0;
function or(t, e, s, n) {
  const i = t._endId = ++sd, o = () => {
    i === t._endId && n();
  };
  if (s != null)
    return setTimeout(o, s);
  const { type: r, timeout: a, propCount: l } = nd(t, e);
  if (!r)
    return n();
  const u = r + "end";
  let c = 0;
  const d = () => {
    t.removeEventListener(u, m), o();
  }, m = (h) => {
    h.target === t && ++c >= l && d();
  };
  setTimeout(() => {
    c < l && d();
  }, a + 1), t.addEventListener(u, m);
}
function nd(t, e) {
  const s = window.getComputedStyle(t), n = (g) => (s[g] || "").split(", "), i = n(`${Jt}Delay`), o = n(`${Jt}Duration`), r = rr(i, o), a = n(`${js}Delay`), l = n(`${js}Duration`), u = rr(a, l);
  let c = null, d = 0, m = 0;
  e === Jt ? r > 0 && (c = Jt, d = r, m = o.length) : e === js ? u > 0 && (c = js, d = u, m = l.length) : (d = Math.max(r, u), c = d > 0 ? r > u ? Jt : js : null, m = c ? c === Jt ? o.length : l.length : 0);
  const h = c === Jt && /\b(?:transform|all)(?:,|$)/.test(
    n(`${Jt}Property`).toString()
  );
  return {
    type: c,
    timeout: d,
    propCount: m,
    hasTransform: h
  };
}
function rr(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((s, n) => ar(s) + ar(t[n])));
}
function ar(t) {
  return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function lr(t) {
  return (t ? t.ownerDocument : document).body.offsetHeight;
}
function id(t, e, s) {
  const n = t[rn];
  n && (e = (e ? [e, ...n] : [...n]).join(" ")), e == null ? t.removeAttribute("class") : s ? t.setAttribute("class", e) : t.className = e;
}
const Yn = /* @__PURE__ */ Symbol("_vod"), il = /* @__PURE__ */ Symbol("_vsh"), cr = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(t, { value: e }, { transition: s }) {
    t[Yn] = t.style.display === "none" ? "" : t.style.display, s && e ? s.beforeEnter(t) : qs(t, e);
  },
  mounted(t, { value: e }, { transition: s }) {
    s && e && s.enter(t);
  },
  updated(t, { value: e, oldValue: s }, { transition: n }) {
    !e != !s && (n ? e ? (n.beforeEnter(t), qs(t, !0), n.enter(t)) : n.leave(t, () => {
      qs(t, !1);
    }) : qs(t, e));
  },
  beforeUnmount(t, { value: e }) {
    qs(t, e);
  }
};
function qs(t, e) {
  t.style.display = e ? t[Yn] : "none", t[il] = !e;
}
const od = /* @__PURE__ */ Symbol(Nt.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""), rd = /(?:^|;)\s*display\s*:/;
function ad(t, e, s) {
  const n = t.style, i = Me(s);
  let o = !1;
  if (s && !i) {
    if (e)
      if (Me(e))
        for (const r of e.split(";")) {
          const a = r.slice(0, r.indexOf(":")).trim();
          s[a] == null && In(n, a, "");
        }
      else
        for (const r in e)
          s[r] == null && In(n, r, "");
    for (const r in s)
      r === "display" && (o = !0), In(n, r, s[r]);
  } else if (i) {
    if (e !== s) {
      const r = n[od];
      r && (s += ";" + r), n.cssText = s, o = rd.test(s);
    }
  } else e && t.removeAttribute("style");
  Yn in t && (t[Yn] = o ? n.display : "", t[il] && (n.display = "none"));
}
const ld = /[^\\];\s*$/, ur = /\s*!important$/;
function In(t, e, s) {
  if (z(s))
    s.forEach((n) => In(t, e, n));
  else if (s == null && (s = ""), Nt.NODE_ENV !== "production" && ld.test(s) && Rt(
    `Unexpected semicolon at the end of '${e}' style value: '${s}'`
  ), e.startsWith("--"))
    t.setProperty(e, s);
  else {
    const n = cd(t, e);
    ur.test(s) ? t.setProperty(
      Gt(n),
      s.replace(ur, ""),
      "important"
    ) : t[n] = s;
  }
}
const dr = ["Webkit", "Moz", "ms"], xi = {};
function cd(t, e) {
  const s = xi[e];
  if (s)
    return s;
  let n = ut(e);
  if (n !== "filter" && n in t)
    return xi[e] = n;
  n = Xn(n);
  for (let i = 0; i < dr.length; i++) {
    const o = dr[i] + n;
    if (o in t)
      return xi[e] = o;
  }
  return e;
}
const fr = "http://www.w3.org/1999/xlink";
function pr(t, e, s, n, i, o = Al(e)) {
  n && e.startsWith("xlink:") ? s == null ? t.removeAttributeNS(fr, e.slice(6, e.length)) : t.setAttributeNS(fr, e, s) : s == null || o && !Pr(s) ? t.removeAttribute(e) : t.setAttribute(
    e,
    o ? "" : vt(s) ? String(s) : s
  );
}
function hr(t, e, s, n, i) {
  if (e === "innerHTML" || e === "textContent") {
    s != null && (t[e] = e === "innerHTML" ? sl(s) : s);
    return;
  }
  const o = t.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const a = o === "OPTION" ? t.getAttribute("value") || "" : t.value, l = s == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      t.type === "checkbox" ? "on" : ""
    ) : String(s);
    (a !== l || !("_value" in t)) && (t.value = l), s == null && t.removeAttribute(e), t._value = s;
    return;
  }
  let r = !1;
  if (s === "" || s == null) {
    const a = typeof t[e];
    a === "boolean" ? s = Pr(s) : s == null && a === "string" ? (s = "", r = !0) : a === "number" && (s = 0, r = !0);
  }
  try {
    t[e] = s;
  } catch (a) {
    Nt.NODE_ENV !== "production" && !r && Rt(
      `Failed setting prop "${e}" on <${o.toLowerCase()}>: value ${s} is invalid.`,
      a
    );
  }
  r && t.removeAttribute(i || e);
}
function ts(t, e, s, n) {
  t.addEventListener(e, s, n);
}
function ud(t, e, s, n) {
  t.removeEventListener(e, s, n);
}
const mr = /* @__PURE__ */ Symbol("_vei");
function dd(t, e, s, n, i = null) {
  const o = t[mr] || (t[mr] = {}), r = o[e];
  if (n && r)
    r.value = Nt.NODE_ENV !== "production" ? br(n, e) : n;
  else {
    const [a, l] = fd(e);
    if (n) {
      const u = o[e] = md(
        Nt.NODE_ENV !== "production" ? br(n, e) : n,
        i
      );
      ts(t, a, u, l);
    } else r && (ud(t, a, r, l), o[e] = void 0);
  }
}
const vr = /(?:Once|Passive|Capture)$/;
function fd(t) {
  let e;
  if (vr.test(t)) {
    e = {};
    let n;
    for (; n = t.match(vr); )
      t = t.slice(0, t.length - n[0].length), e[n[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : Gt(t.slice(2)), e];
}
let Si = 0;
const pd = /* @__PURE__ */ Promise.resolve(), hd = () => Si || (pd.then(() => Si = 0), Si = Date.now());
function md(t, e) {
  const s = (n) => {
    if (!n._vts)
      n._vts = Date.now();
    else if (n._vts <= s.attached)
      return;
    Tt(
      vd(n, s.value),
      e,
      5,
      [n]
    );
  };
  return s.value = t, s.attached = hd(), s;
}
function br(t, e) {
  return Z(t) || z(t) ? t : (Rt(
    `Wrong type passed as event handler to ${e} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof t}.`
  ), qe);
}
function vd(t, e) {
  if (z(e)) {
    const s = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      s.call(t), t._stopped = !0;
    }, e.map(
      (n) => (i) => !i._stopped && n && n(i)
    );
  } else
    return e;
}
const gr = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // lowercase letter
t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, bd = (t, e, s, n, i, o) => {
  const r = i === "svg";
  e === "class" ? id(t, n, r) : e === "style" ? ad(t, s, n) : ln(e) ? Rn(e) || dd(t, e, s, n, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : gd(t, e, n, r)) ? (hr(t, e, n), !t.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && pr(t, e, n, r, o, e !== "value")) : /* #11081 force set props for possible async custom element */ t._isVueCE && (/[A-Z]/.test(e) || !Me(n)) ? hr(t, ut(e), n, o, e) : (e === "true-value" ? t._trueValue = n : e === "false-value" && (t._falseValue = n), pr(t, e, n, r));
};
function gd(t, e, s, n) {
  if (n)
    return !!(e === "innerHTML" || e === "textContent" || e in t && gr(e) && Z(s));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && t.tagName === "IFRAME" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = t.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return gr(e) && Me(s) ? !1 : e in t;
}
const As = (t) => {
  const e = t.props["onUpdate:modelValue"] || !1;
  return z(e) ? (s) => Ns(e, s) : e;
};
function Ed(t) {
  t.target.composing = !0;
}
function Er(t) {
  const e = t.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const Kt = /* @__PURE__ */ Symbol("_assign");
function yr(t, e, s) {
  return e && (t = t.trim()), s && (t = Zn(t)), t;
}
const zt = {
  created(t, { modifiers: { lazy: e, trim: s, number: n } }, i) {
    t[Kt] = As(i);
    const o = n || i.props && i.props.type === "number";
    ts(t, e ? "change" : "input", (r) => {
      r.target.composing || t[Kt](yr(t.value, s, o));
    }), (s || o) && ts(t, "change", () => {
      t.value = yr(t.value, s, o);
    }), e || (ts(t, "compositionstart", Ed), ts(t, "compositionend", Er), ts(t, "change", Er));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(t, { value: e }) {
    t.value = e ?? "";
  },
  beforeUpdate(t, { value: e, oldValue: s, modifiers: { lazy: n, trim: i, number: o } }, r) {
    if (t[Kt] = As(r), t.composing) return;
    const a = (o || t.type === "number") && !/^0\d/.test(t.value) ? Zn(t.value) : t.value, l = e ?? "";
    a !== l && (document.activeElement === t && t.type !== "range" && (n && e === s || i && t.value.trim() === l) || (t.value = l));
  }
}, ol = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(t, e, s) {
    t[Kt] = As(s), ts(t, "change", () => {
      const n = t._modelValue, i = an(t), o = t.checked, r = t[Kt];
      if (z(n)) {
        const a = Qi(n, i), l = a !== -1;
        if (o && !l)
          r(n.concat(i));
        else if (!o && l) {
          const u = [...n];
          u.splice(a, 1), r(u);
        }
      } else if (Ms(n)) {
        const a = new Set(n);
        o ? a.add(i) : a.delete(i), r(a);
      } else
        r(al(t, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: _r,
  beforeUpdate(t, e, s) {
    t[Kt] = As(s), _r(t, e, s);
  }
};
function _r(t, { value: e, oldValue: s }, n) {
  t._modelValue = e;
  let i;
  if (z(e))
    i = Qi(e, n.props.value) > -1;
  else if (Ms(e))
    i = e.has(n.props.value);
  else {
    if (e === s) return;
    i = Is(e, al(t, !0));
  }
  t.checked !== i && (t.checked = i);
}
const rl = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(t, { value: e, modifiers: { number: s } }, n) {
    const i = Ms(e);
    ts(t, "change", () => {
      const o = Array.prototype.filter.call(t.options, (r) => r.selected).map(
        (r) => s ? Zn(an(r)) : an(r)
      );
      t[Kt](
        t.multiple ? i ? new Set(o) : o : o[0]
      ), t._assigning = !0, It(() => {
        t._assigning = !1;
      });
    }), t[Kt] = As(n);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(t, { value: e }) {
    Tr(t, e);
  },
  beforeUpdate(t, e, s) {
    t[Kt] = As(s);
  },
  updated(t, { value: e }) {
    t._assigning || Tr(t, e);
  }
};
function Tr(t, e) {
  const s = t.multiple, n = z(e);
  if (s && !n && !Ms(e)) {
    Nt.NODE_ENV !== "production" && Rt(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let i = 0, o = t.options.length; i < o; i++) {
    const r = t.options[i], a = an(r);
    if (s)
      if (n) {
        const l = typeof a;
        l === "string" || l === "number" ? r.selected = e.some((u) => String(u) === String(a)) : r.selected = Qi(e, a) > -1;
      } else
        r.selected = e.has(a);
    else if (Is(an(r), e)) {
      t.selectedIndex !== i && (t.selectedIndex = i);
      return;
    }
  }
  !s && t.selectedIndex !== -1 && (t.selectedIndex = -1);
}
function an(t) {
  return "_value" in t ? t._value : t.value;
}
function al(t, e) {
  const s = e ? "_trueValue" : "_falseValue";
  return s in t ? t[s] : e;
}
const yd = ["ctrl", "shift", "alt", "meta"], _d = {
  stop: (t) => t.stopPropagation(),
  prevent: (t) => t.preventDefault(),
  self: (t) => t.target !== t.currentTarget,
  ctrl: (t) => !t.ctrlKey,
  shift: (t) => !t.shiftKey,
  alt: (t) => !t.altKey,
  meta: (t) => !t.metaKey,
  left: (t) => "button" in t && t.button !== 0,
  middle: (t) => "button" in t && t.button !== 1,
  right: (t) => "button" in t && t.button !== 2,
  exact: (t, e) => yd.some((s) => t[`${s}Key`] && !e.includes(s))
}, Td = (t, e) => {
  if (!t) return t;
  const s = t._withMods || (t._withMods = {}), n = e.join(".");
  return s[n] || (s[n] = ((i, ...o) => {
    for (let r = 0; r < e.length; r++) {
      const a = _d[e[r]];
      if (a && a(i, e)) return;
    }
    return t(i, ...o);
  }));
}, Nd = /* @__PURE__ */ Ve({ patchProp: bd }, Ju);
let Nr;
function xd() {
  return Nr || (Nr = wu(Nd));
}
const Sd = ((...t) => {
  const e = xd().createApp(...t);
  Nt.NODE_ENV !== "production" && (wd(e), Dd(e));
  const { mount: s } = e;
  return e.mount = (n) => {
    const i = Od(n);
    if (!i) return;
    const o = e._component;
    !Z(o) && !o.render && !o.template && (o.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
    const r = s(i, !1, Cd(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), r;
  }, e;
});
function Cd(t) {
  if (t instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && t instanceof MathMLElement)
    return "mathml";
}
function wd(t) {
  Object.defineProperty(t.config, "isNativeTag", {
    value: (e) => wl(e) || Dl(e) || Ol(e),
    writable: !1
  });
}
function Dd(t) {
  {
    const e = t.config.isCustomElement;
    Object.defineProperty(t.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        Rt(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const s = t.config.compilerOptions, n = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(t.config, "compilerOptions", {
      get() {
        return Rt(n), s;
      },
      set() {
        Rt(n);
      }
    });
  }
}
function Od(t) {
  if (Me(t)) {
    const e = document.querySelector(t);
    return Nt.NODE_ENV !== "production" && !e && Rt(
      `Failed to mount app: mount target selector "${t}" returned null.`
    ), e;
  }
  return Nt.NODE_ENV !== "production" && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && Rt(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), t;
}
var $d = {};
function Ad() {
  Gu();
}
$d.NODE_ENV !== "production" && Ad();
const De = (t, e) => {
  const s = t.__vccOpts || t;
  for (const [n, i] of e)
    s[n] = i;
  return s;
}, Vd = {}, Md = { class: "card st-card-unified" }, Id = { style: { display: "flex", "align-items": "center", "justify-content": "space-between" } };
function Rd(t, e) {
  return S(), k("div", Md, [
    f("div", Id, [
      mt(t.$slots, "left", {}, void 0, !0),
      mt(t.$slots, "right", {}, void 0, !0)
    ])
  ]);
}
const xn = /* @__PURE__ */ De(Vd, [["render", Rd], ["__scopeId", "data-v-5b66fbc1"]]), Ld = { class: "st-toggle-switch" }, kd = ["checked"], Pd = /* @__PURE__ */ Te({
  __name: "ToggleSwitch",
  props: {
    checked: { type: Boolean }
  },
  emits: ["change"],
  setup(t) {
    return (e, s) => (S(), k("label", Ld, [
      f("input", {
        type: "checkbox",
        checked: t.checked,
        onChange: s[0] || (s[0] = (n) => e.$emit("change", n.target.checked))
      }, null, 40, kd),
      s[1] || (s[1] = f("span", { class: "st-toggle-slider" }, null, -1))
    ]));
  }
}), xr = /* @__PURE__ */ De(Pd, [["__scopeId", "data-v-f73e4a93"]]), Bd = { class: "button-content" }, Fd = /* @__PURE__ */ Te({
  __name: "Button",
  emits: ["click"],
  setup(t) {
    return (e, s) => (S(), k("button", {
      class: "menu_button button-wrapper",
      onClick: s[0] || (s[0] = (n) => e.$emit("click"))
    }, [
      f("span", Bd, [
        mt(e.$slots, "default", {}, void 0, !0)
      ])
    ]));
  }
}), ae = /* @__PURE__ */ De(Fd, [["__scopeId", "data-v-8b9ccff3"]]), Ud = {
  key: 0,
  class: "popup-modal-header"
}, jd = { class: "popup-modal-title" }, qd = { class: "popup-modal-body" }, Hd = {
  key: 1,
  class: "popup-modal-footer"
}, Wd = /* @__PURE__ */ Te({
  __name: "PopupModal",
  props: {
    visible: { type: Boolean },
    title: {},
    closable: { type: Boolean, default: !0 },
    maskClosable: { type: Boolean, default: !0 },
    height: {},
    width: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = te(() => {
      const a = {};
      return s.height && (a.height = s.height, a["max-height"] = s.height), s.width && (a.width = s.width, a["max-width"] = s.width), a;
    }), i = e, o = () => {
      i("close");
    }, r = () => {
      s.maskClosable && o();
    };
    return (a, l) => (S(), Le(ya, { to: "body" }, [
      C(fo, { name: "modal" }, {
        default: B(() => [
          t.visible ? (S(), k("div", {
            key: 0,
            class: "popup-modal-overlay",
            onClick: Td(r, ["self"])
          }, [
            f("div", {
              class: "popup-modal",
              style: Ke(n.value)
            }, [
              t.title || t.closable || a.$slots.titlePrefix ? (S(), k("div", Ud, [
                f("div", jd, [
                  mt(a.$slots, "titlePrefix", {}, void 0, !0),
                  f("span", null, ue(t.title), 1)
                ]),
                t.closable ? (S(), k("div", {
                  key: 0,
                  class: "popup-modal-close",
                  onClick: o
                }, [...l[0] || (l[0] = [
                  f("i", { class: "fa-solid fa-xmark" }, null, -1)
                ])])) : ne("", !0)
              ])) : ne("", !0),
              f("div", qd, [
                mt(a.$slots, "default", {}, void 0, !0)
              ]),
              a.$slots.footer ? (S(), k("div", Hd, [
                mt(a.$slots, "footer", {}, void 0, !0)
              ])) : ne("", !0)
            ], 4)
          ])) : ne("", !0)
        ]),
        _: 3
      })
    ]));
  }
}), Ge = /* @__PURE__ */ De(Wd, [["__scopeId", "data-v-546209e7"]]), Kd = { class: "drawer-header" }, zd = { class: "header-actions" }, Gd = { class: "drawer-body" }, Yd = {
  key: 0,
  class: "empty-state"
}, Qd = {
  key: 1,
  class: "table-list"
}, Jd = ["onClick"], Xd = { class: "table-item-main" }, Zd = { class: "table-name" }, ef = {
  key: 0,
  class: "table-comment"
}, tf = /* @__PURE__ */ Te({
  __name: "TableListDrawer",
  props: {
    tables: {},
    selectedTable: {},
    isDrawer: { type: Boolean, default: !0 },
    showSyncButtons: { type: Boolean, default: !1 }
  },
  emits: ["select", "create", "closeDrawer", "sync", "push"],
  setup(t, { emit: e }) {
    const s = e, n = /* @__PURE__ */ q(window.innerWidth), i = () => {
      n.value = window.innerWidth;
    };
    ot(() => {
      window.addEventListener("resize", i);
    }), hn(() => {
      window.removeEventListener("resize", i);
    });
    const o = () => n.value <= 768, r = (c) => {
      s("select", c), o() && s("closeDrawer");
    }, a = () => {
      s("create");
    }, l = () => {
      s("sync");
    }, u = () => {
      s("push");
    };
    return (c, d) => (S(), k("div", {
      class: Ie(["table-list-drawer", { "is-drawer": t.isDrawer }])
    }, [
      f("div", Kd, [
        d[3] || (d[3] = f("span", { class: "drawer-title" }, "", -1)),
        f("div", zd, [
          t.showSyncButtons ? (S(), k("button", {
            key: 0,
            class: "sync-btn",
            title: "",
            onClick: l
          }, [...d[0] || (d[0] = [
            f("i", { class: "fa-solid fa-rotate" }, null, -1)
          ])])) : ne("", !0),
          t.showSyncButtons ? (S(), k("button", {
            key: 1,
            class: "push-btn",
            title: "",
            onClick: u
          }, [...d[1] || (d[1] = [
            f("i", { class: "fa-solid fa-share-from-square" }, null, -1)
          ])])) : ne("", !0),
          f("button", {
            class: "create-table-btn",
            title: "",
            onClick: a
          }, [...d[2] || (d[2] = [
            f("i", { class: "fa-solid fa-plus" }, null, -1)
          ])])
        ])
      ]),
      f("div", Gd, [
        t.tables.length === 0 ? (S(), k("div", Yd, [
          d[5] || (d[5] = f("i", { class: "fa-solid fa-table" }, null, -1)),
          d[6] || (d[6] = f("span", null, "", -1)),
          f("button", {
            class: "empty-create-btn",
            onClick: a
          }, [...d[4] || (d[4] = [
            f("i", { class: "fa-solid fa-plus" }, null, -1),
            se("  ", -1)
          ])])
        ])) : (S(), k("div", Qd, [
          (S(!0), k(Ae, null, Wt(t.tables, (m) => (S(), k("div", {
            key: m.tableName,
            class: Ie(["table-item", { active: t.selectedTable === m.tableName }]),
            onClick: (h) => r(m.tableName)
          }, [
            f("div", Xd, [
              d[7] || (d[7] = f("i", { class: "fa-solid fa-table table-icon" }, null, -1)),
              f("span", Zd, ue(m.tableName), 1)
            ]),
            m.comment ? (S(), k("div", ef, ue(m.comment), 1)) : ne("", !0)
          ], 10, Jd))), 128))
        ]))
      ])
    ], 2));
  }
}), sf = /* @__PURE__ */ De(tf, [["__scopeId", "data-v-85bfbdca"]]), nf = { class: "table-drawer-layout" }, of = { class: "layout-content" }, rf = {
  key: 0,
  class: "layout-drawer"
}, af = { class: "layout-main" }, lf = /* @__PURE__ */ Te({
  __name: "TableDrawerLayout",
  props: {
    drawerExpanded: { type: Boolean },
    tables: {},
    selectedTable: {},
    showSyncButtons: { type: Boolean, default: !1 }
  },
  emits: ["update:drawerExpanded", "selectTable", "createTable", "sync", "push"],
  setup(t, { emit: e }) {
    const s = e, n = (l) => {
      s("selectTable", l);
    }, i = () => {
      s("createTable");
    }, o = () => {
      s("update:drawerExpanded", !1);
    }, r = () => {
      s("sync");
    }, a = () => {
      s("push");
    };
    return (l, u) => (S(), k("div", nf, [
      f("div", of, [
        C(fo, { name: "drawer-slide" }, {
          default: B(() => [
            t.drawerExpanded ? (S(), k("div", rf, [
              C(sf, {
                tables: t.tables,
                "selected-table": t.selectedTable,
                "show-sync-buttons": t.showSyncButtons,
                onSelect: n,
                onCreate: i,
                onCloseDrawer: o,
                onSync: r,
                onPush: a
              }, null, 8, ["tables", "selected-table", "show-sync-buttons"])
            ])) : ne("", !0)
          ]),
          _: 1
        }),
        f("div", af, [
          mt(l.$slots, "default", {}, void 0, !0)
        ])
      ])
    ]));
  }
}), po = /* @__PURE__ */ De(lf, [["__scopeId", "data-v-3e0df31e"]]), cf = { class: "tab-container" }, uf = { class: "tab-header" }, df = ["onClick"], ff = { class: "tab-body" }, pf = /* @__PURE__ */ Te({
  __name: "TabContainer",
  props: {
    tabs: {},
    activeTab: {}
  },
  emits: ["update:activeTab"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(window.innerWidth), o = () => {
      i.value = window.innerWidth;
    };
    ot(() => {
      window.addEventListener("resize", o);
    }), hn(() => {
      window.removeEventListener("resize", o);
    });
    const r = te(() => {
      const l = i.value <= 768;
      return s.tabs.filter((u) => !(u.mobileOnly && !l || u.desktopOnly && l));
    }), a = (l) => {
      n("update:activeTab", l);
    };
    return (l, u) => (S(), k("div", cf, [
      f("div", uf, [
        (S(!0), k(Ae, null, Wt(r.value, (c) => (S(), k("div", {
          key: c.key,
          class: Ie(["tab-item", { active: t.activeTab === c.key }]),
          onClick: (d) => a(c.key)
        }, [
          c.icon ? (S(), k("i", {
            key: 0,
            class: Ie(c.icon)
          }, null, 2)) : ne("", !0),
          f("span", null, ue(c.label), 1)
        ], 10, df))), 128))
      ]),
      f("div", ff, [
        (S(!0), k(Ae, null, Wt(t.tabs, (c) => (S(), k(Ae, {
          key: c.key
        }, [
          t.activeTab === c.key ? mt(l.$slots, c.key, { key: 0 }, void 0, !0) : ne("", !0)
        ], 64))), 128))
      ])
    ]));
  }
}), ho = /* @__PURE__ */ De(pf, [["__scopeId", "data-v-9d94b988"]]), hf = /* @__PURE__ */ Te({
  __name: "DrawerToggle",
  props: {
    expanded: { type: Boolean },
    fab: { type: Boolean, default: !1 }
  },
  emits: ["toggle"],
  setup(t, { emit: e }) {
    const s = e, n = () => {
      s("toggle");
    };
    return (i, o) => (S(), k("button", {
      class: Ie(["drawer-toggle", { fab: t.fab }]),
      onClick: n
    }, [...o[0] || (o[0] = [
      f("div", { class: "hamburger-icon" }, [
        f("span", { class: "line" }),
        f("span", { class: "line" }),
        f("span", { class: "line" })
      ], -1)
    ])], 2));
  }
}), mo = /* @__PURE__ */ De(hf, [["__scopeId", "data-v-04d4da93"]]), mf = /* @__PURE__ */ Te({
  __name: "ToastNotification",
  props: {
    visible: { type: Boolean },
    message: {},
    type: {},
    icon: {}
  },
  setup(t) {
    return (e, s) => (S(), Le(fo, { name: "toast" }, {
      default: B(() => [
        t.visible ? (S(), k("div", {
          key: 0,
          class: Ie(["toast-notification", t.type])
        }, [
          f("i", {
            class: Ie(t.icon)
          }, null, 2),
          f("span", null, ue(t.message), 1)
        ], 2)) : ne("", !0)
      ]),
      _: 1
    }));
  }
}), ll = /* @__PURE__ */ De(mf, [["__scopeId", "data-v-76c92735"]]), vf = /* @__PURE__ */ Te({
  __name: "EmptyState",
  props: {
    icon: {},
    text: {},
    iconSize: { default: 48 },
    variant: { default: "default" }
  },
  setup(t) {
    return (e, s) => (S(), k("div", {
      class: Ie([t.variant, "empty-state"])
    }, [
      f("i", {
        class: Ie(t.icon),
        style: Ke({ fontSize: `${t.iconSize}px` })
      }, null, 6),
      f("span", null, ue(t.text), 1)
    ], 2));
  }
}), Qn = /* @__PURE__ */ De(vf, [["__scopeId", "data-v-5ddb0dfd"]]);
function cl() {
  const t = /* @__PURE__ */ is({
    visible: !1,
    message: "",
    type: "success",
    icon: "fa-solid fa-check-circle"
  });
  let e = null;
  return {
    toast: t,
    showToast: (n, i = "success") => {
      e && clearTimeout(e), t.message = n, t.type = i, t.icon = i === "success" ? "fa-solid fa-check-circle" : "fa-solid fa-circle-xmark", t.visible = !0, e = setTimeout(() => {
        t.visible = !1;
      }, 3e3);
    }
  };
}
function bf() {
  return {
    showCreateTableModal: /* @__PURE__ */ q(!1),
    showEditTableNameModal: /* @__PURE__ */ q(!1),
    showEditTableCommentModal: /* @__PURE__ */ q(!1),
    showDropTableModal: /* @__PURE__ */ q(!1),
    showAddColumnModal: /* @__PURE__ */ q(!1),
    showEditColumnNameModal: /* @__PURE__ */ q(!1),
    showEditColumnCommentModal: /* @__PURE__ */ q(!1),
    showDropColumnModal: /* @__PURE__ */ q(!1),
    showDDLModal: /* @__PURE__ */ q(!1),
    editingColumn: /* @__PURE__ */ q(null),
    exportedDDL: /* @__PURE__ */ q("")
  };
}
const gf = ["value", "placeholder", "disabled", "readonly", "maxlength"], Ef = {
  key: 0,
  class: "textarea-footer"
}, yf = /* @__PURE__ */ Te({
  __name: "AutoResizeTextarea",
  props: {
    modelValue: { default: "" },
    placeholder: { default: "..." },
    minRows: { default: 1 },
    maxRows: { default: 15 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    maxlength: { default: void 0 },
    showCount: { type: Boolean, default: !1 },
    submitOnEnter: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "focus", "blur", "submit"],
  setup(t, { expose: e, emit: s }) {
    const n = t, i = s, o = /* @__PURE__ */ q(null), r = /* @__PURE__ */ q(null), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q(24), u = te(() => (n.modelValue || "").length);
    function c() {
      const x = o.value, T = r.value;
      if (!x || !T) return;
      const O = window.getComputedStyle(x), M = parseFloat(O.lineHeight) || 24;
      l.value = M;
      const K = parseFloat(O.paddingTop) || 0, pe = parseFloat(O.paddingBottom) || 0, he = parseFloat(O.borderTopWidth) || 0, H = parseFloat(O.borderBottomWidth) || 0;
      T.style.width = `${x.clientWidth}px`, T.style.fontSize = O.fontSize, T.style.fontFamily = O.fontFamily, T.style.fontWeight = O.fontWeight, T.style.letterSpacing = O.letterSpacing, T.style.wordSpacing = O.wordSpacing, T.style.lineHeight = O.lineHeight, T.style.paddingTop = O.paddingTop, T.style.paddingBottom = O.paddingBottom, T.style.paddingLeft = O.paddingLeft, T.style.paddingRight = O.paddingRight, T.style.wordBreak = O.wordBreak, T.style.whiteSpace = "pre-wrap", T.style.overflowWrap = "break-word", T.style.boxSizing = "border-box";
      const re = n.modelValue || "";
      T.textContent = re + `
`;
      const me = T.scrollHeight, w = M * n.minRows + K + pe, W = M * n.maxRows + K + pe, oe = Math.min(Math.max(me, w), W);
      x.style.height = `${oe + he + H}px`, x.style.overflowY = me > W ? "auto" : "hidden";
    }
    function d(x) {
      const T = x.target;
      i("update:modelValue", T.value), c(), It(c);
    }
    function m(x) {
      a.value = !0, i("focus", x);
    }
    function h(x) {
      a.value = !1, i("blur", x);
    }
    function g(x) {
      n.submitOnEnter && x.key === "Enter" && !x.shiftKey && (x.preventDefault(), i("submit", n.modelValue || ""));
    }
    function y() {
      o.value?.focus();
    }
    function _() {
      o.value?.blur();
    }
    e({ focus: y, blur: _, adjustHeight: c }), it(() => n.modelValue, () => {
      It(c);
    }), it([() => n.minRows, () => n.maxRows], () => {
      It(c);
    });
    let E = null;
    return ot(() => {
      c(), window.ResizeObserver && o.value && (E = new ResizeObserver(() => c()), E.observe(o.value.parentElement));
    }), Pt(() => {
      E?.disconnect();
    }), (x, T) => (S(), k("div", {
      class: Ie(["auto-resize-wrapper", { focused: a.value, disabled: t.disabled }])
    }, [
      f("div", {
        ref_key: "mirrorRef",
        ref: r,
        class: "textarea-mirror",
        "aria-hidden": "true"
      }, null, 512),
      f("textarea", {
        ref_key: "textareaRef",
        ref: o,
        class: "auto-resize-textarea",
        value: t.modelValue,
        placeholder: t.placeholder,
        disabled: t.disabled,
        readonly: t.readonly,
        maxlength: t.maxlength,
        rows: 1,
        onInput: d,
        onFocus: m,
        onBlur: h,
        onKeydown: g
      }, null, 40, gf),
      t.showCount && t.maxlength ? (S(), k("div", Ef, [
        f("span", {
          class: Ie(["char-count", { warning: u.value > t.maxlength * 0.9 }])
        }, ue(u.value) + " / " + ue(t.maxlength), 3)
      ])) : ne("", !0)
    ], 2));
  }
}), Vs = /* @__PURE__ */ De(yf, [["__scopeId", "data-v-fd129974"]]);
var Lt = /* @__PURE__ */ ((t) => (t.NUMBER = "NUMBER", t.STRING = "STRING", t))(Lt || {});
function ci() {
  const t = /* @__PURE__ */ q([]), e = te(() => t.value.length > 0), s = (h) => t.value.find((g) => g.field === h)?.message, n = () => {
    t.value = [];
  }, i = (h, g) => {
    t.value.push({ field: h, message: g });
  }, o = (h, g) => {
    const y = h.trim();
    return y ? y.length > 64 ? (i("tableName", "64"), !1) : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(y) ? g?.checkTableNameExists && g.checkTableNameExists(y) ? g.excludeName && y === g.excludeName ? !0 : (i("tableName", ` "${y}" `), !1) : !0 : (i("tableName", ""), !1) : (i("tableName", ""), !1);
  }, r = (h, g) => {
    const y = h.trim();
    return y ? y.length > 64 ? (i("columnName", "64"), !1) : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(y) ? g?.checkColumnNameExists && g.checkColumnNameExists(y) ? g.excludeName && y === g.excludeName ? !0 : (i("columnName", ` "${y}" `), !1) : !0 : (i("columnName", ""), !1) : (i("columnName", ""), !1);
  }, a = (h) => {
    const g = h.map((E) => E.name.trim()).filter((E) => E), y = [], _ = /* @__PURE__ */ new Set();
    for (const E of g)
      _.has(E) && (y.includes(E) || y.push(E)), _.add(E);
    return y.length > 0 ? (i("columns", `: ${y.join(", ")}`), !1) : !0;
  };
  return {
    errors: t,
    hasErrors: e,
    getFieldError: s,
    clearErrors: n,
    addError: i,
    validateTableName: o,
    validateColumnName: r,
    validateDuplicateColumnNames: a,
    validateCreateTableForm: (h, g, y) => {
      n();
      const _ = y.map((E) => E.tableName);
      return o(h, {
        checkTableNameExists: (E) => _.includes(E)
      }), g.length === 0 && i("columns", ""), g.forEach((E, x) => {
        const T = E.name.trim();
        T ? /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(T) || i(`column_${x}`, ` "${T}" `) : i(`column_${x}`, ` ${x + 1} `);
      }), a(g), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateAddColumnForm: (h, g) => {
      n();
      const y = g.map((_) => _.name);
      return r(h, {
        checkColumnNameExists: (_) => y.includes(_)
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateEditTableNameForm: (h, g, y) => {
      n();
      const _ = y.map((E) => E.tableName);
      return o(h, {
        checkTableNameExists: (E) => _.includes(E),
        excludeName: g
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateEditColumnNameForm: (h, g, y) => {
      n();
      const _ = y.map((E) => E.name);
      return r(h, {
        checkColumnNameExists: (E) => _.includes(E),
        excludeName: g
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateComment: (h, g = 500) => h && h.length > g ? (i("comment", ` ${g} `), !1) : !0
  };
}
const _f = { class: "form-container" }, Tf = { class: "form-section" }, Nf = { class: "form-item" }, xf = {
  key: 0,
  class: "field-error"
}, Sf = { class: "form-item" }, Cf = { class: "form-section columns-section" }, wf = { class: "section-header" }, Df = { class: "column-count" }, Of = {
  key: 0,
  class: "field-error section-error"
}, $f = { class: "columns-list" }, Af = { class: "column-card-header" }, Vf = { class: "column-number" }, Mf = ["onClick"], If = { class: "column-card-body" }, Rf = { class: "form-row" }, Lf = { class: "form-col form-col-name" }, kf = ["onUpdate:modelValue"], Pf = { class: "form-col form-col-type" }, Bf = ["onUpdate:modelValue"], Ff = ["value"], Uf = ["value"], jf = {
  key: 0,
  class: "field-error"
}, qf = { class: "form-row" }, Hf = { class: "form-col form-col-default" }, Wf = ["onUpdate:modelValue"], Kf = { class: "form-col form-col-comment" }, zf = { class: "checkbox-label" }, Gf = ["onUpdate:modelValue"], Yf = { class: "form-actions" }, Qf = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Jf = "auto", Xf = /* @__PURE__ */ Te({
  __name: "CreateTableForm",
  props: {
    existingTables: { default: () => [] }
  },
  emits: ["create", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateCreateTableForm: o, clearErrors: r } = ci(), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q(!1), u = () => {
      l.value = window.innerWidth <= 768;
    };
    ot(() => {
      u(), window.addEventListener("resize", u);
    }), Pt(() => {
      window.removeEventListener("resize", u);
    });
    const c = te(() => l.value ? "100%" : "50vw"), d = te(() => {
      const x = {};
      return x["--form-modal-width"] = l.value ? "100%" : "50vw", x;
    });
    let m = 0;
    const h = /* @__PURE__ */ is({
      tableName: "",
      comment: "",
      columns: []
    }), g = () => {
      h.columns.push({
        id: ++m,
        name: "",
        type: Lt.STRING,
        primitiveKey: !1,
        comment: ""
      });
    }, y = (x) => {
      h.columns.splice(x, 1);
    }, _ = () => {
      if (r(), a.value = !0, !o(
        h.tableName,
        h.columns,
        s.existingTables
      ).valid) {
        a.value = !1;
        return;
      }
      const T = h.columns.map((O) => ({
        name: O.name.trim(),
        type: O.type,
        primitiveKey: O.primitiveKey,
        defaultValue: O.defaultValue || void 0,
        comment: O.comment || void 0
      }));
      n("create", {
        tableName: h.tableName.trim(),
        columns: T,
        comment: h.comment.trim() || void 0
      }), a.value = !1;
    }, E = () => {
      r(), n("cancel");
    };
    return h.columns.length === 0 && g(), (x, T) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(d.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: c.value,
        height: Jf,
        closable: !1,
        onClose: E
      }, {
        default: B(() => [
          f("div", _f, [
            f("div", Tf, [
              f("div", Nf, [
                T[3] || (T[3] = f("label", { class: "form-label" }, [
                  se("  "),
                  f("span", { class: "required" }, "*")
                ], -1)),
                Xe(f("input", {
                  "onUpdate:modelValue": T[0] || (T[0] = (O) => h.tableName = O),
                  class: Ie(["form-input", { "has-error": Q(i)("tableName") }]),
                  type: "text",
                  placeholder: "user_info"
                }, null, 2), [
                  [zt, h.tableName]
                ]),
                Q(i)("tableName") ? (S(), k("div", xf, [
                  T[2] || (T[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                  se(" " + ue(Q(i)("tableName")), 1)
                ])) : ne("", !0),
                T[4] || (T[4] = f("div", { class: "field-hint" }, "", -1))
              ]),
              f("div", Sf, [
                T[5] || (T[5] = f("label", { class: "form-label" }, "", -1)),
                C(Vs, {
                  modelValue: h.comment,
                  "onUpdate:modelValue": T[1] || (T[1] = (O) => h.comment = O),
                  placeholder: "",
                  "min-rows": 2,
                  "max-rows": 6
                }, null, 8, ["modelValue"]),
                T[6] || (T[6] = f("div", { class: "field-hint" }, "", -1))
              ])
            ]),
            f("div", Cf, [
              f("div", wf, [
                T[7] || (T[7] = f("label", { class: "form-label" }, [
                  se("  "),
                  f("span", { class: "required" }, "*")
                ], -1)),
                f("span", Df, ue(h.columns.length) + " ", 1)
              ]),
              Q(i)("columns") ? (S(), k("div", Of, [
                T[8] || (T[8] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                se(" " + ue(Q(i)("columns")), 1)
              ])) : ne("", !0),
              f("div", $f, [
                (S(!0), k(Ae, null, Wt(h.columns, (O, M) => (S(), k("div", {
                  key: O.id,
                  class: Ie(["column-card", { "has-error": Q(i)(`column_${M}`) }])
                }, [
                  f("div", Af, [
                    f("span", Vf, "#" + ue(M + 1), 1),
                    f("button", {
                      class: "remove-btn",
                      onClick: (K) => y(M),
                      title: ""
                    }, [...T[9] || (T[9] = [
                      f("i", { class: "fa-solid fa-trash" }, null, -1)
                    ])], 8, Mf)
                  ]),
                  f("div", If, [
                    f("div", Rf, [
                      f("div", Lf, [
                        T[10] || (T[10] = f("label", { class: "field-label" }, [
                          se(" "),
                          f("span", { class: "required" }, "*")
                        ], -1)),
                        Xe(f("input", {
                          "onUpdate:modelValue": (K) => O.name = K,
                          class: "form-input",
                          type: "text",
                          placeholder: ""
                        }, null, 8, kf), [
                          [zt, O.name]
                        ])
                      ]),
                      f("div", Pf, [
                        T[11] || (T[11] = f("label", { class: "field-label" }, "", -1)),
                        Xe(f("select", {
                          "onUpdate:modelValue": (K) => O.type = K,
                          class: "form-select"
                        }, [
                          f("option", {
                            value: Q(Lt).STRING
                          }, "STRING", 8, Ff),
                          f("option", {
                            value: Q(Lt).NUMBER
                          }, "NUMBER", 8, Uf)
                        ], 8, Bf), [
                          [rl, O.type]
                        ])
                      ])
                    ]),
                    Q(i)(`column_${M}`) ? (S(), k("div", jf, [
                      T[12] || (T[12] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                      se(" " + ue(Q(i)(`column_${M}`)), 1)
                    ])) : ne("", !0),
                    f("div", qf, [
                      f("div", Hf, [
                        T[13] || (T[13] = f("label", { class: "field-label" }, "", -1)),
                        Xe(f("input", {
                          "onUpdate:modelValue": (K) => O.defaultValue = K,
                          class: "form-input",
                          type: "text",
                          placeholder: ""
                        }, null, 8, Wf), [
                          [zt, O.defaultValue]
                        ])
                      ]),
                      f("div", Kf, [
                        T[14] || (T[14] = f("label", { class: "field-label" }, "", -1)),
                        C(Vs, {
                          modelValue: O.comment,
                          "onUpdate:modelValue": (K) => O.comment = K,
                          placeholder: "",
                          "min-rows": 1,
                          "max-rows": 4
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ])
                    ]),
                    f("label", zf, [
                      Xe(f("input", {
                        "onUpdate:modelValue": (K) => O.primitiveKey = K,
                        type: "checkbox"
                      }, null, 8, Gf), [
                        [ol, O.primitiveKey]
                      ]),
                      T[15] || (T[15] = f("span", null, "", -1))
                    ])
                  ])
                ], 2))), 128)),
                f("button", {
                  class: "add-column-btn",
                  onClick: g
                }, [...T[16] || (T[16] = [
                  f("i", { class: "fa-solid fa-plus" }, null, -1),
                  f("span", null, "", -1)
                ])])
              ])
            ]),
            f("div", Yf, [
              C(ae, { onClick: E }, {
                default: B(() => [...T[17] || (T[17] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: a.value,
                onClick: _
              }, {
                default: B(() => [
                  a.value ? (S(), k("i", Qf)) : ne("", !0),
                  T[18] || (T[18] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Zf = /* @__PURE__ */ De(Xf, [["__scopeId", "data-v-08eccbfb"]]), ep = { class: "form-container" }, tp = { class: "form-item" }, sp = ["value"], np = { class: "form-item" }, ip = {
  key: 0,
  class: "field-error"
}, op = { class: "form-actions" }, rp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, ap = "auto", lp = /* @__PURE__ */ Te({
  __name: "EditTableNameForm",
  props: {
    tableName: {},
    existingTables: { default: () => [] }
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateEditTableNameForm: o, clearErrors: r } = ci(), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q(s.tableName), u = /* @__PURE__ */ q(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    ot(() => {
      c(), window.addEventListener("resize", c);
    }), Pt(() => {
      window.removeEventListener("resize", c);
    });
    const d = te(() => u.value ? "100%" : "50vw"), m = te(() => {
      const _ = {};
      return _["--form-modal-width"] = u.value ? "100%" : "50vw", _;
    }), h = te(() => l.value.trim() !== s.tableName);
    it(() => s.tableName, (_) => {
      l.value = _, r();
    });
    const g = () => {
      if (r(), a.value = !0, !o(
        l.value,
        s.tableName,
        s.existingTables
      ).valid) {
        a.value = !1;
        return;
      }
      n("save", l.value.trim()), a.value = !1;
    }, y = () => {
      l.value = s.tableName, r(), n("cancel");
    };
    return (_, E) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: ap,
        closable: !1,
        onClose: y
      }, {
        default: B(() => [
          f("div", ep, [
            f("div", tp, [
              E[1] || (E[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.tableName,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, sp)
            ]),
            f("div", np, [
              E[3] || (E[3] = f("label", { class: "form-label" }, [
                se("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              Xe(f("input", {
                "onUpdate:modelValue": E[0] || (E[0] = (x) => l.value = x),
                class: Ie(["form-input", { "has-error": Q(i)("tableName") }]),
                type: "text",
                placeholder: ""
              }, null, 2), [
                [zt, l.value]
              ]),
              Q(i)("tableName") ? (S(), k("div", ip, [
                E[2] || (E[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                se(" " + ue(Q(i)("tableName")), 1)
              ])) : ne("", !0),
              E[4] || (E[4] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", op, [
              C(ae, { onClick: y }, {
                default: B(() => [...E[5] || (E[5] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: a.value || !h.value,
                onClick: g
              }, {
                default: B(() => [
                  a.value ? (S(), k("i", rp)) : ne("", !0),
                  E[6] || (E[6] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), cp = /* @__PURE__ */ De(lp, [["__scopeId", "data-v-58e374f4"]]), up = { class: "form-container" }, dp = { class: "form-item" }, fp = { class: "form-actions" }, pp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, hp = "auto", mp = /* @__PURE__ */ Te({
  __name: "EditTableCommentForm",
  props: {
    comment: {}
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(s.comment || ""), o = /* @__PURE__ */ q(!1), r = /* @__PURE__ */ q(!1), a = () => {
      r.value = window.innerWidth <= 768;
    };
    ot(() => {
      a(), window.addEventListener("resize", a);
    }), Pt(() => {
      window.removeEventListener("resize", a);
    });
    const l = te(() => r.value ? "100%" : "50vw"), u = te(() => {
      const m = {};
      return m["--form-modal-width"] = r.value ? "100%" : "50vw", m;
    }), c = () => {
      o.value = !0, n("save", i.value), o.value = !1;
    }, d = () => {
      i.value = s.comment || "", n("cancel");
    };
    return (m, h) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(u.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: l.value,
        height: hp,
        closable: !1,
        onClose: d
      }, {
        default: B(() => [
          f("div", up, [
            f("div", dp, [
              h[1] || (h[1] = f("label", { class: "form-label" }, "", -1)),
              C(Vs, {
                modelValue: i.value,
                "onUpdate:modelValue": h[0] || (h[0] = (g) => i.value = g),
                placeholder: "",
                maxlength: 500,
                "show-count": !0,
                "min-rows": 3,
                "max-rows": 10
              }, null, 8, ["modelValue"])
            ]),
            f("div", fp, [
              C(ae, { onClick: d }, {
                default: B(() => [...h[2] || (h[2] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: o.value,
                onClick: c
              }, {
                default: B(() => [
                  o.value ? (S(), k("i", pp)) : ne("", !0),
                  h[3] || (h[3] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), vp = /* @__PURE__ */ De(mp, [["__scopeId", "data-v-03532044"]]), bp = { class: "confirm-container" }, gp = { class: "confirm-content" }, Ep = { class: "confirm-message" }, yp = { class: "form-actions" }, _p = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Tp = /* @__PURE__ */ Te({
  __name: "DropTableConfirm",
  props: {
    tableName: {},
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1), o = te(() => {
      const l = {};
      return s.modalWidth && (l["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (l["--confirm-modal-height"] = s.modalHeight), l;
    }), r = () => {
      i.value = !0, n("confirm");
    }, a = () => {
      n("cancel");
    };
    return (l, u) => (S(), k("div", {
      class: "drop-table-confirm-wrapper",
      style: Ke(o.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: a
      }, {
        default: B(() => [
          f("div", bp, [
            u[5] || (u[5] = f("div", { class: "confirm-icon-wrapper" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" })
            ], -1)),
            f("div", gp, [
              f("div", Ep, [
                u[0] || (u[0] = se("  ", -1)),
                f("strong", null, ue(t.tableName), 1),
                u[1] || (u[1] = se("  ", -1))
              ]),
              u[2] || (u[2] = f("div", { class: "confirm-warning" }, [
                f("i", { class: "fa-solid fa-circle-info" }),
                f("span", null, "")
              ], -1))
            ]),
            f("div", yp, [
              C(ae, { onClick: a }, {
                default: B(() => [...u[3] || (u[3] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "danger",
                disabled: i.value,
                onClick: r
              }, {
                default: B(() => [
                  i.value ? (S(), k("i", _p)) : ne("", !0),
                  u[4] || (u[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), Np = /* @__PURE__ */ De(Tp, [["__scopeId", "data-v-4629727b"]]), xp = { class: "form-container" }, Sp = { class: "form-item" }, Cp = {
  key: 0,
  class: "field-error"
}, wp = { class: "form-item" }, Dp = ["value"], Op = ["value"], $p = { class: "form-item" }, Ap = { class: "checkbox-label" }, Vp = { class: "form-item" }, Mp = { class: "form-item" }, Ip = { class: "form-actions" }, Rp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Lp = "auto", kp = /* @__PURE__ */ Te({
  __name: "AddColumnForm",
  props: {
    existingColumns: { default: () => [] }
  },
  emits: ["create", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateAddColumnForm: o, clearErrors: r } = ci(), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ is({
      name: "",
      type: Lt.STRING,
      primitiveKey: !1
    }), u = /* @__PURE__ */ q(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    ot(() => {
      c(), window.addEventListener("resize", c);
    }), Pt(() => {
      window.removeEventListener("resize", c);
    });
    const d = te(() => u.value ? "100%" : "50vw"), m = te(() => {
      const y = {};
      return y["--form-modal-width"] = u.value ? "100%" : "50vw", y;
    }), h = () => {
      if (r(), a.value = !0, !o(l.name, s.existingColumns).valid) {
        a.value = !1;
        return;
      }
      const _ = {
        name: l.name.trim(),
        type: l.type,
        primitiveKey: l.primitiveKey,
        defaultValue: l.defaultValue || void 0,
        comment: l.comment || void 0
      };
      n("create", _), a.value = !1;
    }, g = () => {
      r(), n("cancel");
    };
    return (y, _) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: Lp,
        closable: !1,
        onClose: g
      }, {
        default: B(() => [
          f("div", xp, [
            f("div", Sp, [
              _[6] || (_[6] = f("label", { class: "form-label" }, [
                se("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              Xe(f("input", {
                "onUpdate:modelValue": _[0] || (_[0] = (E) => l.name = E),
                class: Ie(["form-input", { "has-error": Q(i)("columnName") }]),
                type: "text",
                placeholder: "username"
              }, null, 2), [
                [zt, l.name]
              ]),
              Q(i)("columnName") ? (S(), k("div", Cp, [
                _[5] || (_[5] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                se(" " + ue(Q(i)("columnName")), 1)
              ])) : ne("", !0),
              _[7] || (_[7] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", wp, [
              _[8] || (_[8] = f("label", { class: "form-label" }, "", -1)),
              Xe(f("select", {
                "onUpdate:modelValue": _[1] || (_[1] = (E) => l.type = E),
                class: "form-select"
              }, [
                f("option", {
                  value: Q(Lt).STRING
                }, "STRING", 8, Dp),
                f("option", {
                  value: Q(Lt).NUMBER
                }, "NUMBER", 8, Op)
              ], 512), [
                [rl, l.type]
              ])
            ]),
            f("div", $p, [
              f("label", Ap, [
                Xe(f("input", {
                  "onUpdate:modelValue": _[2] || (_[2] = (E) => l.primitiveKey = E),
                  type: "checkbox"
                }, null, 512), [
                  [ol, l.primitiveKey]
                ]),
                _[9] || (_[9] = f("span", null, "", -1))
              ])
            ]),
            f("div", Vp, [
              _[10] || (_[10] = f("label", { class: "form-label" }, "", -1)),
              Xe(f("input", {
                "onUpdate:modelValue": _[3] || (_[3] = (E) => l.defaultValue = E),
                class: "form-input",
                type: "text",
                placeholder: ""
              }, null, 512), [
                [zt, l.defaultValue]
              ]),
              _[11] || (_[11] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Mp, [
              _[12] || (_[12] = f("label", { class: "form-label" }, "", -1)),
              C(Vs, {
                modelValue: l.comment,
                "onUpdate:modelValue": _[4] || (_[4] = (E) => l.comment = E),
                placeholder: "",
                "min-rows": 1,
                "max-rows": 4
              }, null, 8, ["modelValue"])
            ]),
            f("div", Ip, [
              C(ae, { onClick: g }, {
                default: B(() => [..._[13] || (_[13] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: a.value,
                onClick: h
              }, {
                default: B(() => [
                  a.value ? (S(), k("i", Rp)) : ne("", !0),
                  _[14] || (_[14] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Pp = /* @__PURE__ */ De(kp, [["__scopeId", "data-v-019138f2"]]), Bp = { class: "form-container" }, Fp = { class: "form-item" }, Up = ["value"], jp = { class: "form-item" }, qp = {
  key: 0,
  class: "field-error"
}, Hp = { class: "form-actions" }, Wp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Kp = "auto", zp = /* @__PURE__ */ Te({
  __name: "EditColumnNameForm",
  props: {
    column: {},
    existingColumns: { default: () => [] }
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateEditColumnNameForm: o, clearErrors: r } = ci(), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q(s.column.name), u = /* @__PURE__ */ q(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    ot(() => {
      c(), window.addEventListener("resize", c);
    }), Pt(() => {
      window.removeEventListener("resize", c);
    });
    const d = te(() => u.value ? "100%" : "50vw"), m = te(() => {
      const _ = {};
      return _["--form-modal-width"] = u.value ? "100%" : "50vw", _;
    }), h = te(() => l.value.trim() !== s.column.name);
    it(() => s.column, (_) => {
      l.value = _.name, r();
    }, { deep: !0 });
    const g = () => {
      if (r(), a.value = !0, !o(
        l.value,
        s.column.name,
        s.existingColumns
      ).valid) {
        a.value = !1;
        return;
      }
      n("save", l.value.trim()), a.value = !1;
    }, y = () => {
      l.value = s.column.name, r(), n("cancel");
    };
    return (_, E) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: Kp,
        closable: !1,
        onClose: y
      }, {
        default: B(() => [
          f("div", Bp, [
            f("div", Fp, [
              E[1] || (E[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.column.name,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, Up)
            ]),
            f("div", jp, [
              E[3] || (E[3] = f("label", { class: "form-label" }, [
                se("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              Xe(f("input", {
                "onUpdate:modelValue": E[0] || (E[0] = (x) => l.value = x),
                class: Ie(["form-input", { "has-error": Q(i)("columnName") }]),
                type: "text",
                placeholder: ""
              }, null, 2), [
                [zt, l.value]
              ]),
              Q(i)("columnName") ? (S(), k("div", qp, [
                E[2] || (E[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                se(" " + ue(Q(i)("columnName")), 1)
              ])) : ne("", !0),
              E[4] || (E[4] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Hp, [
              C(ae, { onClick: y }, {
                default: B(() => [...E[5] || (E[5] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: a.value || !h.value,
                onClick: g
              }, {
                default: B(() => [
                  a.value ? (S(), k("i", Wp)) : ne("", !0),
                  E[6] || (E[6] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Gp = /* @__PURE__ */ De(zp, [["__scopeId", "data-v-36708f97"]]), Yp = { class: "form-container" }, Qp = { class: "form-item" }, Jp = ["value"], Xp = { class: "form-item" }, Zp = { class: "form-actions" }, eh = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, th = "auto", sh = /* @__PURE__ */ Te({
  __name: "EditColumnCommentForm",
  props: {
    column: {}
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(s.column.comment || ""), o = /* @__PURE__ */ q(!1), r = /* @__PURE__ */ q(!1), a = () => {
      r.value = window.innerWidth <= 768;
    };
    ot(() => {
      a(), window.addEventListener("resize", a);
    }), Pt(() => {
      window.removeEventListener("resize", a);
    });
    const l = te(() => r.value ? "100%" : "50vw"), u = te(() => {
      const m = {};
      return m["--form-modal-width"] = r.value ? "100%" : "50vw", m;
    }), c = () => {
      o.value = !0, n("save", i.value), o.value = !1;
    }, d = () => {
      i.value = s.column.comment || "", n("cancel");
    };
    return (m, h) => (S(), k("div", {
      class: "form-wrapper",
      style: Ke(u.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: l.value,
        height: th,
        closable: !1,
        onClose: d
      }, {
        default: B(() => [
          f("div", Yp, [
            f("div", Qp, [
              h[1] || (h[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.column.name,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, Jp)
            ]),
            f("div", Xp, [
              h[2] || (h[2] = f("label", { class: "form-label" }, "", -1)),
              C(Vs, {
                modelValue: i.value,
                "onUpdate:modelValue": h[0] || (h[0] = (g) => i.value = g),
                placeholder: "",
                maxlength: 500,
                "show-count": !0,
                "min-rows": 3,
                "max-rows": 10
              }, null, 8, ["modelValue"])
            ]),
            f("div", Zp, [
              C(ae, { onClick: d }, {
                default: B(() => [...h[3] || (h[3] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                disabled: o.value,
                onClick: c
              }, {
                default: B(() => [
                  o.value ? (S(), k("i", eh)) : ne("", !0),
                  h[4] || (h[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), nh = /* @__PURE__ */ De(sh, [["__scopeId", "data-v-1f79f493"]]), ih = { class: "confirm-container" }, oh = { class: "confirm-content" }, rh = { class: "confirm-message" }, ah = { class: "form-actions" }, lh = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, ch = /* @__PURE__ */ Te({
  __name: "DropColumnConfirm",
  props: {
    column: {},
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1), o = te(() => {
      const l = {};
      return s.modalWidth && (l["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (l["--confirm-modal-height"] = s.modalHeight), l;
    }), r = () => {
      i.value = !0, n("confirm");
    }, a = () => {
      n("cancel");
    };
    return (l, u) => (S(), k("div", {
      class: "drop-column-confirm-wrapper",
      style: Ke(o.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: a
      }, {
        default: B(() => [
          f("div", ih, [
            u[5] || (u[5] = f("div", { class: "confirm-icon-wrapper" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" })
            ], -1)),
            f("div", oh, [
              f("div", rh, [
                u[0] || (u[0] = se("  ", -1)),
                f("strong", null, ue(t.column.name), 1),
                u[1] || (u[1] = se("  ", -1))
              ]),
              u[2] || (u[2] = f("div", { class: "confirm-warning" }, [
                f("i", { class: "fa-solid fa-circle-info" }),
                f("span", null, "")
              ], -1))
            ]),
            f("div", ah, [
              C(ae, { onClick: a }, {
                default: B(() => [...u[3] || (u[3] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "danger",
                disabled: i.value,
                onClick: r
              }, {
                default: B(() => [
                  i.value ? (S(), k("i", lh)) : ne("", !0),
                  u[4] || (u[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), uh = /* @__PURE__ */ De(ch, [["__scopeId", "data-v-7565defa"]]), dh = { class: "ddl-container" }, fh = { class: "ddl-header" }, ph = { class: "ddl-content" }, hh = { class: "ddl-code" }, mh = { class: "form-actions" }, vh = /* @__PURE__ */ Te({
  __name: "DDLDisplay",
  props: {
    ddl: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1);
    let o = null;
    const r = async () => {
      try {
        await navigator.clipboard.writeText(s.ddl), i.value = !0, o && clearTimeout(o), o = setTimeout(() => {
          i.value = !1;
        }, 2e3);
      } catch (l) {
        console.error(":", l);
      }
    }, a = () => {
      n("close");
    };
    return (l, u) => (S(), k("div", dh, [
      f("div", fh, [
        u[0] || (u[0] = f("span", { class: "ddl-title" }, "DDL ", -1)),
        f("button", {
          class: "copy-btn",
          onClick: r
        }, [
          f("i", {
            class: Ie(i.value ? "fa-solid fa-check" : "fa-solid fa-copy")
          }, null, 2),
          se(" " + ue(i.value ? "" : ""), 1)
        ])
      ]),
      f("div", ph, [
        f("pre", hh, ue(t.ddl), 1)
      ]),
      f("div", mh, [
        C(ae, { onClick: a }, {
          default: B(() => [...u[1] || (u[1] = [
            se("", -1)
          ])]),
          _: 1
        })
      ])
    ]));
  }
}), bh = /* @__PURE__ */ De(vh, [["__scopeId", "data-v-da039aee"]]), gh = { class: "table-management-tab" }, Eh = {
  key: 1,
  class: "table-detail"
}, yh = { class: "table-header" }, _h = { class: "table-title-section" }, Th = { class: "table-name-row" }, Nh = { class: "table-name" }, xh = {
  key: 0,
  class: "table-comment-row"
}, Sh = { class: "table-comment" }, Ch = {
  key: 1,
  class: "table-comment-row"
}, wh = { class: "table-actions" }, Dh = { class: "columns-section" }, Oh = { class: "section-header" }, $h = { class: "columns-list" }, Ah = { key: 1 }, Vh = { class: "column-main" }, Mh = { class: "column-first-row" }, Ih = { class: "column-name-wrapper" }, Rh = { class: "column-name" }, Lh = { class: "type-badge" }, kh = {
  key: 0,
  class: "primary-key-badge",
  title: ""
}, Ph = {
  key: 0,
  class: "column-comment"
}, Bh = {
  key: 1,
  class: "default-value"
}, Fh = { class: "column-actions" }, Uh = /* @__PURE__ */ Te({
  __name: "TableManagementTab",
  props: {
    tableService: {},
    tables: {},
    selectedTable: {}
  },
  emits: ["refresh", "update:selectedTable"],
  setup(t, { expose: e, emit: s }) {
    const n = t, i = s, o = te(() => n.tables.find((J) => J.tableName === n.selectedTable) || {}), r = te(() => o.value.columnSchemas ? Object.entries(o.value.columnSchemas).map(([J, L]) => [parseInt(J), L]) : []), a = te(() => o.value.columnSchemas ? Object.values(o.value.columnSchemas) : []), l = te(() => !o.value.columnSchemas || !O.value ? [] : Object.values(o.value.columnSchemas).filter((J) => J.name !== O.value?.column.name)), { toast: u, showToast: c } = cl(), {
      showCreateTableModal: d,
      showEditTableNameModal: m,
      showEditTableCommentModal: h,
      showDropTableModal: g,
      showAddColumnModal: y,
      showEditColumnNameModal: _,
      showEditColumnCommentModal: E,
      showDropColumnModal: x,
      showDDLModal: T,
      editingColumn: O,
      exportedDDL: M
    } = bf(), K = (J) => J === null ? "NULL" : J === void 0 ? "" : String(J), pe = (J) => {
      const L = n.tableService.createTable(J.tableName, J.columns, J.comment);
      L.success ? (d.value = !1, i("refresh"), c(` "${J.tableName}" `)) : c(L.message || "", "error");
    }, he = (J) => {
      if (o.value.tableName) {
        const L = n.tableService.alterTableName(o.value.tableName, J);
        L.success ? (m.value = !1, i("update:selectedTable", J), i("refresh"), c("")) : c(L.message || "", "error");
      }
    }, H = (J) => {
      if (o.value.tableName) {
        const L = n.tableService.alterTableComment(o.value.tableName, J);
        L.success ? (h.value = !1, i("refresh"), c("")) : c(L.message || "", "error");
      }
    }, re = () => {
      if (o.value.tableName) {
        const J = n.tableService.dropTable(o.value.tableName);
        J.success ? (g.value = !1, i("update:selectedTable", ""), i("refresh"), c("")) : c(J.message || "", "error");
      }
    }, me = (J) => {
      if (o.value.tableName) {
        const L = n.tableService.addColumn(o.value.tableName, J.name, J);
        L.success ? (y.value = !1, i("refresh"), c(` "${J.name}" `)) : c(L.message || "", "error");
      }
    }, w = (J, L) => {
      O.value = { fieldId: J, column: L }, _.value = !0;
    }, W = (J) => {
      if (o.value.tableName && O.value) {
        const L = n.tableService.alterColumnName(
          o.value.tableName,
          O.value.column.name,
          J
        );
        L.success ? (_.value = !1, O.value = null, i("refresh"), c("")) : c(L.message || "", "error");
      }
    }, oe = (J, L) => {
      O.value = { fieldId: J, column: L }, E.value = !0;
    }, be = (J) => {
      if (o.value.tableName && O.value) {
        const L = n.tableService.alterColumnComment(
          o.value.tableName,
          O.value.column.name,
          J
        );
        L.success ? (E.value = !1, O.value = null, i("refresh"), c("")) : c(L.message || "", "error");
      }
    }, fe = (J, L) => {
      O.value = { fieldId: J, column: L }, x.value = !0;
    }, le = () => {
      if (o.value.tableName && O.value) {
        const J = n.tableService.dropColumn(
          o.value.tableName,
          O.value.column.name
        );
        J.success ? (x.value = !1, O.value = null, i("refresh"), c("")) : c(J.message || "", "error");
      }
    }, de = () => {
      o.value.tableName && (M.value = n.tableService.exportDDL(o.value.tableName), T.value = !0);
    };
    return e({
      openCreateTableModal: () => {
        d.value = !0;
      }
    }), (J, L) => (S(), k("div", gh, [
      t.selectedTable ? (S(), k("div", Eh, [
        f("div", yh, [
          f("div", _h, [
            f("div", Th, [
              L[16] || (L[16] = f("span", { class: "table-label" }, "", -1)),
              f("span", Nh, ue(o.value.tableName), 1),
              C(ae, {
                size: "small",
                onClick: L[0] || (L[0] = (Oe) => m.value = !0)
              }, {
                default: B(() => [...L[15] || (L[15] = [
                  f("i", { class: "fa-solid fa-pen" }, null, -1)
                ])]),
                _: 1
              })
            ]),
            o.value.comment ? (S(), k("div", xh, [
              L[18] || (L[18] = f("span", { class: "table-label" }, "", -1)),
              f("span", Sh, ue(o.value.comment), 1),
              C(ae, {
                size: "small",
                onClick: L[1] || (L[1] = (Oe) => h.value = !0)
              }, {
                default: B(() => [...L[17] || (L[17] = [
                  f("i", { class: "fa-solid fa-pen" }, null, -1)
                ])]),
                _: 1
              })
            ])) : (S(), k("div", Ch, [
              L[20] || (L[20] = f("span", { class: "table-label" }, "", -1)),
              L[21] || (L[21] = f("span", { class: "table-comment placeholder" }, "", -1)),
              C(ae, {
                size: "small",
                onClick: L[2] || (L[2] = (Oe) => h.value = !0)
              }, {
                default: B(() => [...L[19] || (L[19] = [
                  f("i", { class: "fa-solid fa-plus" }, null, -1)
                ])]),
                _: 1
              })
            ]))
          ]),
          f("div", wh, [
            C(ae, { onClick: de }, {
              default: B(() => [...L[22] || (L[22] = [
                f("i", {
                  class: "fa-solid fa-download",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se(" DDL ", -1)
              ])]),
              _: 1
            }),
            C(ae, {
              type: "danger",
              onClick: L[3] || (L[3] = (Oe) => g.value = !0)
            }, {
              default: B(() => [...L[23] || (L[23] = [
                f("i", {
                  class: "fa-solid fa-trash",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            })
          ])
        ]),
        f("div", Dh, [
          f("div", Oh, [
            L[25] || (L[25] = f("span", { class: "section-title" }, "", -1)),
            C(ae, {
              size: "small",
              onClick: L[4] || (L[4] = (Oe) => y.value = !0)
            }, {
              default: B(() => [...L[24] || (L[24] = [
                f("i", {
                  class: "fa-solid fa-plus",
                  style: { "margin-right": "4px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            })
          ]),
          f("div", $h, [
            r.value.length === 0 ? (S(), Le(Qn, {
              key: 0,
              icon: "fa-solid fa-columns",
              text: "",
              variant: "compact"
            })) : (S(), k("div", Ah, [
              (S(!0), k(Ae, null, Wt(r.value, ([Oe, We]) => (S(), k("div", {
                key: Oe,
                class: "column-item"
              }, [
                f("div", Vh, [
                  f("div", Mh, [
                    f("div", Ih, [
                      L[26] || (L[26] = f("i", { class: "fa-solid fa-hashtag column-icon" }, null, -1)),
                      f("span", Rh, ue(We.name), 1)
                    ]),
                    f("span", Lh, ue(We.type), 1),
                    We.primitiveKey ? (S(), k("span", kh, [...L[27] || (L[27] = [
                      f("i", { class: "fa-solid fa-key" }, null, -1)
                    ])])) : ne("", !0)
                  ]),
                  We.comment ? (S(), k("div", Ph, ue(We.comment), 1)) : ne("", !0),
                  We.defaultValue !== void 0 ? (S(), k("div", Bh, " : " + ue(K(We.defaultValue)), 1)) : ne("", !0)
                ]),
                f("div", Fh, [
                  C(ae, {
                    size: "small",
                    title: "",
                    onClick: (dt) => w(Oe, We)
                  }, {
                    default: B(() => [...L[28] || (L[28] = [
                      f("i", { class: "fa-solid fa-pen" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"]),
                  C(ae, {
                    size: "small",
                    title: "",
                    onClick: (dt) => oe(Oe, We)
                  }, {
                    default: B(() => [...L[29] || (L[29] = [
                      f("i", { class: "fa-solid fa-comment" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"]),
                  C(ae, {
                    type: "danger",
                    size: "small",
                    title: "",
                    onClick: (dt) => fe(Oe, We)
                  }, {
                    default: B(() => [...L[30] || (L[30] = [
                      f("i", { class: "fa-solid fa-trash" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"])
                ])
              ]))), 128))
            ]))
          ])
        ])
      ])) : (S(), Le(Qn, {
        key: 0,
        icon: "fa-solid fa-table",
        text: ""
      })),
      C(ll, {
        visible: Q(u).visible,
        message: Q(u).message,
        type: Q(u).type,
        icon: Q(u).icon
      }, null, 8, ["visible", "message", "type", "icon"]),
      Q(d) ? (S(), Le(Zf, {
        key: 2,
        "existing-tables": t.tables,
        onCreate: pe,
        onCancel: L[5] || (L[5] = (Oe) => d.value = !1)
      }, null, 8, ["existing-tables"])) : ne("", !0),
      Q(m) ? (S(), Le(cp, {
        key: 3,
        "table-name": o.value.tableName,
        "existing-tables": t.tables,
        onSave: he,
        onCancel: L[6] || (L[6] = (Oe) => m.value = !1)
      }, null, 8, ["table-name", "existing-tables"])) : ne("", !0),
      Q(h) ? (S(), Le(vp, {
        key: 4,
        comment: o.value.comment,
        onSave: H,
        onCancel: L[7] || (L[7] = (Oe) => h.value = !1)
      }, null, 8, ["comment"])) : ne("", !0),
      Q(g) ? (S(), Le(Np, {
        key: 5,
        "table-name": o.value.tableName,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: re,
        onCancel: L[8] || (L[8] = (Oe) => g.value = !1)
      }, null, 8, ["table-name"])) : ne("", !0),
      Q(y) ? (S(), Le(Pp, {
        key: 6,
        "existing-columns": a.value,
        onCreate: me,
        onCancel: L[9] || (L[9] = (Oe) => y.value = !1)
      }, null, 8, ["existing-columns"])) : ne("", !0),
      Q(_) && Q(O) ? (S(), Le(Gp, {
        key: 7,
        column: Q(O).column,
        "existing-columns": l.value,
        onSave: W,
        onCancel: L[10] || (L[10] = (Oe) => _.value = !1)
      }, null, 8, ["column", "existing-columns"])) : ne("", !0),
      Q(E) && Q(O) ? (S(), Le(nh, {
        key: 8,
        column: Q(O).column,
        onSave: be,
        onCancel: L[11] || (L[11] = (Oe) => E.value = !1)
      }, null, 8, ["column"])) : ne("", !0),
      Q(x) && Q(O) ? (S(), Le(uh, {
        key: 9,
        column: Q(O).column,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: le,
        onCancel: L[12] || (L[12] = (Oe) => x.value = !1)
      }, null, 8, ["column"])) : ne("", !0),
      Q(T) ? (S(), Le(Ge, {
        key: 10,
        visible: "",
        title: "DDL",
        onClose: L[14] || (L[14] = (Oe) => T.value = !1)
      }, {
        default: B(() => [
          C(bh, {
            ddl: Q(M),
            onClose: L[13] || (L[13] = (Oe) => T.value = !1)
          }, null, 8, ["ddl"])
        ]),
        _: 1
      })) : ne("", !0)
    ]));
  }
}), vo = /* @__PURE__ */ De(Uh, [["__scopeId", "data-v-f00e195b"]]), jh = { class: "sql-panel-tab" }, qh = { class: "sql-editor-container" }, Hh = { class: "sql-toolbar" }, Wh = { class: "sql-footer" }, Kh = { class: "editor-stats" }, zh = { class: "stat-item" }, Gh = { class: "stat-item" }, Yh = {
  key: 0,
  class: "result-status"
}, Qh = { key: 0 }, Jh = { key: 1 }, Xh = /* @__PURE__ */ Te({
  __name: "SqlPanelTab",
  props: {
    sqlExecutorService: {}
  },
  emits: ["refresh"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(""), o = /* @__PURE__ */ q({ success: !1, message: "", data: 0, type: "DQL" }), r = te(() => i.value.split(`
`).length), a = te(() => i.value.length), l = te(() => u.value && Array.isArray(o.value.data) ? o.value.data : []), u = te(() => Array.isArray(o.value.data)), c = te(() => o.value.success || o.value.message !== ""), d = () => {
      if (!i.value.trim()) {
        o.value = { success: !1, message: "SQL", data: 0, type: "DQL" };
        return;
      }
      try {
        o.value = s.sqlExecutorService.execute(i.value), o.value.success && n("refresh");
      } catch (m) {
        o.value = {
          success: !1,
          message: m instanceof Error ? m.message : "",
          data: 0,
          type: "DQL"
        };
      }
    };
    return (m, h) => (S(), k("div", jh, [
      f("div", qh, [
        f("div", Hh, [
          h[2] || (h[2] = f("span", { class: "toolbar-title" }, "SQL", -1)),
          C(ae, { onClick: d }, {
            default: B(() => [...h[1] || (h[1] = [
              f("i", {
                class: "fa-solid fa-play",
                style: { "margin-right": "6px" }
              }, null, -1),
              se("  ", -1)
            ])]),
            _: 1
          })
        ]),
        Xe(f("textarea", {
          "onUpdate:modelValue": h[0] || (h[0] = (g) => i.value = g),
          class: "sql-editor",
          placeholder: "SQL...",
          spellcheck: "false"
        }, null, 512), [
          [zt, i.value]
        ]),
        f("div", Wh, [
          f("div", Kh, [
            f("span", zh, ": " + ue(r.value), 1),
            f("span", Gh, ": " + ue(a.value), 1)
          ]),
          c.value ? (S(), k("div", Yh, [
            u.value ? (S(), k("span", Qh, ": " + ue(l.value.length) + " ", 1)) : (S(), k("span", Jh, ": " + ue(o.value.data) + " ", 1))
          ])) : ne("", !0)
        ]),
        o.value.message ? (S(), k("div", {
          key: 0,
          class: Ie(["result-message", { error: !o.value.success }])
        }, ue(o.value.message), 3)) : ne("", !0)
      ])
    ]));
  }
}), bo = /* @__PURE__ */ De(Xh, [["__scopeId", "data-v-34ac73ac"]]);
var ee = /* @__PURE__ */ ((t) => (t.DDL = "DDL", t.DML = "DML", t.DQL = "DQL", t.ROW = "ROW", t))(ee || {}), at = /* @__PURE__ */ ((t) => (t.INSERT_SQL = "INSERT_SQL", t.TABLE_SCHEMA = "TABLE_SCHEMA", t.DDL = "DDL", t.MARKDOWN = "MARKDOWN", t.STANDARD_DATA = "STANDARD_DATA", t))(at || {}), Hi = /* @__PURE__ */ ((t) => (t.INNER = "INNER", t.LEFT = "LEFT", t))(Hi || {}), ui = /* @__PURE__ */ ((t) => (t.SYNTAX_ERROR = "SYNTAX_ERROR", t.VALIDATION_ERROR = "VALIDATION_ERROR", t.EXECUTION_ERROR = "EXECUTION_ERROR", t.TABLE_NOT_FOUND = "TABLE_NOT_FOUND", t.COLUMN_NOT_FOUND = "COLUMN_NOT_FOUND", t.TYPE_MISMATCH = "TYPE_MISMATCH", t))(ui || {});
class go extends Error {
  /**  */
  code;
  /** SQL */
  position;
  /** SQL */
  sql;
  constructor(e, s, n, i) {
    super(s), this.name = "SqlError", this.code = e, this.position = n, this.sql = i;
  }
}
class Sn extends go {
  constructor(e, s, n) {
    super(ui.SYNTAX_ERROR, e, s, n), this.name = "SqlSyntaxError";
  }
}
class Re extends go {
  constructor(e, s) {
    super(ui.VALIDATION_ERROR, e, void 0, s), this.name = "SqlValidationError";
  }
}
class ss extends go {
  constructor(e, s) {
    super(ui.EXECUTION_ERROR, e, void 0, s), this.name = "SqlExecutionError";
  }
}
var Y = /* @__PURE__ */ ((t) => (t.KEYWORD = "KEYWORD", t.IDENTIFIER = "IDENTIFIER", t.STRING = "STRING", t.NUMBER = "NUMBER", t.OPERATOR = "OPERATOR", t.COMMA = "COMMA", t.SEMICOLON = "SEMICOLON", t.LPAREN = "LPAREN", t.RPAREN = "RPAREN", t.DOT = "DOT", t.EOF = "EOF", t))(Y || {}), $e = /* @__PURE__ */ ((t) => (t.CREATE_TABLE = "CREATE_TABLE", t.ALTER_TABLE = "ALTER_TABLE", t.DROP_TABLE = "DROP_TABLE", t.INSERT = "INSERT", t.UPDATE = "UPDATE", t.DELETE = "DELETE", t.APPEND = "APPEND", t.SELECT = "SELECT", t.ROW = "ROW", t))($e || {}), Xt = /* @__PURE__ */ ((t) => (t.ADD_COLUMN = "ADD_COLUMN", t.DROP_COLUMN = "DROP_COLUMN", t.RENAME = "RENAME", t.RENAME_COLUMN = "RENAME_COLUMN", t.MODIFY_COLUMN_COMMENT = "MODIFY_COLUMN_COMMENT", t.MODIFY_COLUMN_PRIMITIVE_KEY = "MODIFY_COLUMN_PRIMITIVE_KEY", t.ALTER_TABLE_COMMENT = "ALTER_TABLE_COMMENT", t))(Xt || {});
const Zh = /* @__PURE__ */ new Set([
  "SELECT",
  "FROM",
  "WHERE",
  "INSERT",
  "INTO",
  "VALUES",
  "UPDATE",
  "SET",
  "DELETE",
  "CREATE",
  "TABLE",
  "ALTER",
  "DROP",
  "ADD",
  "COLUMN",
  "RENAME",
  "TO",
  "APPEND",
  "AND",
  "OR",
  "NOT",
  "NULL",
  "IS",
  "BETWEEN",
  "IN",
  "ORDER",
  "BY",
  "ASC",
  "DESC",
  "INNER",
  "LEFT",
  "JOIN",
  "ON",
  "DISTINCT",
  "STRING",
  "NUMBER",
  "PRIMARY",
  "KEY",
  "DEFAULT",
  "COMMENT",
  "MODIFY"
]), Sr = ["=", "!=", "<>", ">", "<", ">=", "<="];
class em {
  input;
  pos = 0;
  length;
  constructor(e) {
    this.input = e, this.length = e.length;
  }
  /**
   * 
   */
  peek(e = 0) {
    const s = this.pos + e;
    return this.input[s] ?? "";
  }
  /**
   * 
   */
  advance() {
    return this.pos >= this.length ? "" : this.input[this.pos++] ?? "";
  }
  /**
   * 
   */
  skipWhitespace() {
    for (; this.pos < this.length && /\s/.test(this.peek()); )
      this.pos++;
  }
  /**
   * 
   */
  skipComment() {
    for (; this.peek() === "-" && this.peek(1) === "-"; ) {
      for (this.pos += 2; this.pos < this.length && this.peek() !== `
`; )
        this.pos++;
      this.pos < this.length && this.peek() === `
` && this.pos++, this.skipWhitespace();
    }
  }
  /**
   * 
   */
  readIdentifier() {
    let e = "";
    for (; this.pos < this.length && /[\w]/.test(this.peek()); )
      e += this.advance();
    return e;
  }
  /**
   * 
   */
  readString(e) {
    let s = "";
    for (this.advance(); this.pos < this.length; ) {
      const n = this.peek();
      if (n === e)
        if (this.advance(), this.peek() === e)
          s += e, this.advance();
        else
          break;
      else n === "\\" ? (this.advance(), s += this.advance()) : s += this.advance();
    }
    return s;
  }
  /**
   * 
   */
  readNumber() {
    let e = "";
    for (; this.pos < this.length && /[\d.]/.test(this.peek()); )
      e += this.advance();
    return e;
  }
  /**
   * 
   */
  readOperator() {
    const e = this.peek() + this.peek(1);
    return Sr.includes(e) ? (this.advance(), this.advance(), e) : this.advance();
  }
  /**
   * Token
   */
  nextToken() {
    if (this.skipWhitespace(), this.skipComment(), this.pos >= this.length)
      return { type: Y.EOF, value: "", position: this.pos };
    const e = this.pos, s = this.peek();
    if (s === "(")
      return this.advance(), { type: Y.LPAREN, value: "(", position: e };
    if (s === ")")
      return this.advance(), { type: Y.RPAREN, value: ")", position: e };
    if (s === ",")
      return this.advance(), { type: Y.COMMA, value: ",", position: e };
    if (s === ";")
      return this.advance(), { type: Y.SEMICOLON, value: ";", position: e };
    if (s === ".")
      return this.advance(), { type: Y.DOT, value: ".", position: e };
    if (s === "'") {
      const n = this.readString(s);
      return { type: Y.STRING, value: n, position: e };
    }
    if (s === '"') {
      const n = this.readString(s);
      return { type: Y.STRING, value: n, position: e };
    }
    if (s === "*")
      return this.advance(), { type: Y.KEYWORD, value: "*", position: e };
    if (/[\d]/.test(s)) {
      const n = this.readNumber();
      return { type: Y.NUMBER, value: n, position: e };
    }
    if (/[a-zA-Z_]/.test(s)) {
      const n = this.readIdentifier(), i = n.toUpperCase();
      return Zh.has(i) ? { type: Y.KEYWORD, value: i, position: e } : { type: Y.IDENTIFIER, value: n, position: e };
    }
    if (Sr.some((n) => n.startsWith(s))) {
      const n = this.readOperator();
      return { type: Y.OPERATOR, value: n, position: e };
    }
    throw new Error(`Unexpected character: ${s} at position ${e}`);
  }
  /**
   * Token
   */
  tokenize() {
    const e = [];
    let s;
    do
      s = this.nextToken(), e.push(s);
    while (s.type !== Y.EOF);
    return e;
  }
}
class di {
  lexer;
  current;
  peekToken;
  errors = [];
  constructor(e) {
    this.lexer = e, this.current = this.lexer.nextToken(), this.peekToken = this.lexer.nextToken();
  }
  /**
   * Token
   */
  nextToken() {
    this.current = this.peekToken, this.peekToken = this.lexer.nextToken();
  }
  /**
   * Token
   */
  isCurrentType(e) {
    return this.current.type === e;
  }
  /**
   * Token
   */
  isCurrentValue(e) {
    return (this.current.type === Y.KEYWORD || this.current.type === Y.OPERATOR) && this.current.value === e;
  }
  /**
   * Token
   */
  expectType(e) {
    if (!this.isCurrentType(e))
      throw this.errors.push(`Expected ${e}, got ${this.current.type} at position ${this.current.position}`), new Error(`Parse error at position ${this.current.position}`);
    const s = this.current;
    return this.nextToken(), s;
  }
  /**
   * Token
   */
  expectValue(e) {
    if (!this.isCurrentValue(e))
      throw this.errors.push(`Expected ${e}, got ${this.current.value} at position ${this.current.position}`), new Error(`Parse error at position ${this.current.position}`);
    const s = this.current;
    return this.nextToken(), s;
  }
  /**
   * Token
   */
  matchValue(e) {
    return this.current.value === e && (this.current.type === Y.KEYWORD || this.current.type === Y.OPERATOR || this.current.type === Y.COMMA || this.current.type === Y.SEMICOLON) ? (this.nextToken(), !0) : !1;
  }
  /**
   * 
   */
  parseIdentifier() {
    if (this.isCurrentType(Y.IDENTIFIER) || this.isCurrentType(Y.KEYWORD)) {
      const e = this.current.value;
      return this.nextToken(), e;
    }
    throw new Error(`Expected identifier at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseFieldType() {
    if (this.isCurrentValue("STRING"))
      return this.nextToken(), Lt.STRING;
    if (this.isCurrentValue("NUMBER"))
      return this.nextToken(), Lt.NUMBER;
    throw new Error(`Expected field type at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseColumnDef() {
    const e = this.parseIdentifier(), s = this.parseFieldType(), n = { name: e, type: s };
    if (this.matchValue("PRIMARY") && (this.expectValue("KEY"), n.primitiveKey = !0), this.matchValue("DEFAULT"))
      if (this.isCurrentType(Y.STRING))
        n.defaultValue = this.current.value, this.nextToken();
      else if (this.isCurrentType(Y.NUMBER))
        n.defaultValue = Number(this.current.value), this.nextToken();
      else if (this.matchValue("NULL"))
        n.defaultValue = null;
      else
        throw new Error(`Expected default value at position ${this.current.position}`);
    if (this.matchValue("COMMENT"))
      if (this.isCurrentType(Y.STRING))
        n.comment = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    return n;
  }
  /**
   * 
   */
  parseExpression() {
    return this.parseLogicalOr();
  }
  /**
   * OR
   */
  parseLogicalOr() {
    let e = this.parseLogicalAnd();
    for (; this.matchValue("OR"); ) {
      const s = this.parseLogicalAnd();
      e = { type: "binary", operator: "OR", left: e, right: s };
    }
    return e;
  }
  /**
   * AND
   */
  parseLogicalAnd() {
    let e = this.parseNot();
    for (; this.matchValue("AND"); ) {
      const s = this.parseNot();
      e = { type: "binary", operator: "AND", left: e, right: s };
    }
    return e;
  }
  /**
   * NOT
   */
  parseNot() {
    if (this.matchValue("NOT")) {
      const e = this.parseNot();
      return e.type === "binary" ? { ...e, operator: `NOT ${e.operator}` } : e;
    }
    return this.parseComparison();
  }
  /**
   * 
   */
  parseComparison() {
    let e = this.parseIs();
    const s = ["=", "!=", "<>", ">", "<", ">=", "<="];
    for (; s.includes(this.current.value); ) {
      const n = this.current.value;
      this.nextToken();
      const i = this.parseIs();
      e = { type: "binary", operator: n, left: e, right: i };
    }
    if (this.matchValue("IN")) {
      this.expectType(Y.LPAREN);
      const n = [];
      for (n.push(this.parseExpression()); this.matchValue(","); )
        n.push(this.parseExpression());
      return this.expectType(Y.RPAREN), { type: "in", value: e, values: n };
    }
    if (this.matchValue("BETWEEN")) {
      const n = this.parseAdditive();
      this.expectValue("AND");
      const i = this.parseAdditive();
      return { type: "between", value: e, min: n, max: i };
    }
    return e;
  }
  /**
   * IS
   */
  parseIs() {
    const e = this.parseAdditive();
    if (this.matchValue("IS"))
      if (this.matchValue("NOT")) {
        const s = this.parseAdditive();
        return s.type === "null" ? { type: "null", value: e, not: !0 } : { type: "binary", operator: "IS NOT", left: e, right: s };
      } else {
        const s = this.parseAdditive();
        return s.type === "null" ? { type: "null", value: e } : { type: "binary", operator: "IS", left: e, right: s };
      }
    return e;
  }
  /**
   * 
   */
  parseAdditive() {
    let e = this.parseMultiplicative();
    for (; this.current.value === "+" || this.current.value === "-"; ) {
      const s = this.current.value;
      this.nextToken();
      const n = this.parseMultiplicative();
      e = { type: "binary", operator: s, left: e, right: n };
    }
    return e;
  }
  /**
   * 
   */
  parseMultiplicative() {
    let e = this.parsePrimary();
    for (; this.current.value === "*" || this.current.value === "/"; ) {
      const s = this.current.value;
      this.nextToken();
      const n = this.parsePrimary();
      e = { type: "binary", operator: s, left: e, right: n };
    }
    return e;
  }
  /**
   * 
   */
  parsePrimary() {
    if (this.isCurrentType(Y.NUMBER)) {
      const e = Number(this.current.value);
      return this.nextToken(), { type: "value", value: e };
    }
    if (this.isCurrentType(Y.STRING)) {
      const e = this.current.value;
      return this.nextToken(), { type: "value", value: e };
    }
    if (this.matchValue("NULL"))
      return { type: "null", value: { type: "value", value: null } };
    if (this.isCurrentType(Y.IDENTIFIER) || this.isCurrentType(Y.KEYWORD))
      return this.parseColumnExpression();
    if (this.isCurrentType(Y.LPAREN)) {
      this.nextToken();
      const e = this.parseExpression();
      return this.expectType(Y.RPAREN), e;
    }
    throw new Error(`Unexpected token at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseColumnExpression() {
    const e = this.parseIdentifier();
    if (this.matchValue(".")) {
      const s = e, n = this.parseIdentifier();
      return { type: "column", tableName: s, name: n };
    }
    return { type: "column", name: e };
  }
  /**
   * CREATE TABLE
   */
  parseCreateTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    this.expectType(Y.LPAREN);
    const s = [];
    for (s.push(this.parseColumnDef()); this.matchValue(","); )
      s.push(this.parseColumnDef());
    this.expectType(Y.RPAREN);
    const n = {
      type: $e.CREATE_TABLE,
      tableName: e,
      columns: s,
      position: this.current.position
    };
    if (this.matchValue("COMMENT"))
      if (this.isCurrentType(Y.STRING))
        n.comment = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    return n;
  }
  /**
   * ALTER TABLE
   */
  parseAlterTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    let s, n, i, o, r, a;
    if (this.matchValue("ADD"))
      this.expectValue("COLUMN"), s = Xt.ADD_COLUMN, i = this.parseColumnDef();
    else if (this.matchValue("DROP"))
      this.expectValue("COLUMN"), s = Xt.DROP_COLUMN, n = this.parseIdentifier();
    else if (this.matchValue("RENAME"))
      this.matchValue("COLUMN") ? (s = Xt.RENAME_COLUMN, n = this.parseIdentifier(), this.expectValue("TO"), r = this.parseIdentifier()) : (this.expectValue("TO"), s = Xt.RENAME, o = this.parseIdentifier());
    else if (this.matchValue("MODIFY")) {
      this.expectValue("COLUMN"), n = this.parseIdentifier();
      const l = this.parseFieldType();
      let u = !1;
      if (this.matchValue("PRIMARY") && (this.expectValue("KEY"), u = !0), this.matchValue("COMMENT"))
        if (this.isCurrentType(Y.STRING))
          a = this.current.value, this.nextToken();
        else
          throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
      if (u)
        s = Xt.MODIFY_COLUMN_PRIMITIVE_KEY, i = { name: n, type: l, primitiveKey: u, comment: a };
      else if (a !== void 0)
        s = Xt.MODIFY_COLUMN_COMMENT;
      else
        throw new Error(`Expected PRIMARY KEY or COMMENT after MODIFY COLUMN at position ${this.current.position}`);
    } else if (this.matchValue("COMMENT"))
      if (s = Xt.ALTER_TABLE_COMMENT, this.isCurrentType(Y.STRING))
        a = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    else
      throw new Error(`Expected ADD, DROP, RENAME, MODIFY COLUMN or COMMENT after ALTER TABLE at position ${this.current.position}`);
    return {
      type: $e.ALTER_TABLE,
      tableName: e,
      opType: s,
      columnName: n,
      columnDef: i,
      newTableName: o,
      newColumnName: r,
      comment: a,
      position: this.current.position
    };
  }
  /**
   * DROP TABLE
   */
  parseDropTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    return {
      type: $e.DROP_TABLE,
      tableName: e,
      position: this.current.position
    };
  }
  /**
   * INSERT
   */
  parseInsert() {
    this.expectValue("INTO");
    const e = this.parseIdentifier();
    let s;
    if (this.isCurrentType(Y.LPAREN)) {
      for (this.nextToken(), s = [], s.push(this.parseIdentifier()); this.matchValue(","); )
        s.push(this.parseIdentifier());
      this.expectType(Y.RPAREN);
    }
    this.expectValue("VALUES"), this.expectType(Y.LPAREN);
    const n = [], i = [];
    for (i.push(this.parseExpression()); this.matchValue(","); )
      i.push(this.parseExpression());
    for (n.push(i), this.expectType(Y.RPAREN); this.matchValue(","); ) {
      this.expectType(Y.LPAREN);
      const o = [];
      for (o.push(this.parseExpression()); this.matchValue(","); )
        o.push(this.parseExpression());
      n.push(o), this.expectType(Y.RPAREN);
    }
    return {
      type: $e.INSERT,
      tableName: e,
      columns: s,
      values: n,
      position: this.current.position
    };
  }
  /**
   * UPDATE
   */
  parseUpdate() {
    const e = this.parseIdentifier();
    this.expectValue("SET");
    const s = [], n = this.parseIdentifier();
    this.expectValue("=");
    const i = this.parseExpression();
    for (s.push({ column: n, value: i }); this.matchValue(","); ) {
      const r = this.parseIdentifier();
      this.expectValue("=");
      const a = this.parseExpression();
      s.push({ column: r, value: a });
    }
    let o;
    return this.matchValue("WHERE") && (o = this.parseExpression()), {
      type: $e.UPDATE,
      tableName: e,
      sets: s,
      where: o,
      position: this.current.position
    };
  }
  /**
   * DELETE
   */
  parseDelete() {
    this.expectValue("FROM");
    const e = this.parseIdentifier();
    let s;
    return this.matchValue("WHERE") && (s = this.parseExpression()), {
      type: $e.DELETE,
      tableName: e,
      where: s,
      position: this.current.position
    };
  }
  /**
   * APPEND
   */
  parseAppend() {
    this.expectValue("INTO");
    const e = this.parseIdentifier();
    this.expectType(Y.LPAREN);
    const s = [];
    for (s.push(this.parseIdentifier()); this.matchValue(","); )
      s.push(this.parseIdentifier());
    this.expectType(Y.RPAREN), this.expectValue("VALUES"), this.expectType(Y.LPAREN);
    const n = [];
    for (n.push(this.parseExpression()); this.matchValue(","); )
      n.push(this.parseExpression());
    this.expectType(Y.RPAREN);
    let i;
    return this.matchValue("WHERE") && (i = this.parseExpression()), {
      type: $e.APPEND,
      tableName: e,
      columns: s,
      values: n,
      where: i,
      position: this.current.position
    };
  }
  /**
   * SELECT
   */
  parseSelectList() {
    const e = [];
    if (this.matchValue("*"))
      e.push({ type: "star" });
    else
      for (e.push(this.parseSelectItem()); this.matchValue(","); )
        e.push(this.parseSelectItem());
    return e;
  }
  /**
   * SELECT
   */
  parseSelectItem() {
    return this.parseColumnExpression();
  }
  /**
   * JOIN
   */
  parseJoin() {
    if (this.matchValue("INNER")) {
      this.expectValue("JOIN");
      const e = this.parseIdentifier();
      this.expectValue("ON");
      const s = this.parseColumnExpression(), n = this.parseColumnExpression();
      return {
        type: Hi.INNER,
        tableName: e,
        on: { left: s, right: n }
      };
    }
    if (this.matchValue("LEFT")) {
      this.expectValue("JOIN");
      const e = this.parseIdentifier();
      this.expectValue("ON");
      const s = this.parseColumnExpression(), n = this.parseColumnExpression();
      return {
        type: Hi.LEFT,
        tableName: e,
        on: { left: s, right: n }
      };
    }
  }
  /**
   * ORDER BY
   */
  parseOrderBy() {
    if (!this.matchValue("ORDER")) return;
    this.expectValue("BY");
    const e = [];
    if (e.push({
      column: this.parseIdentifier(),
      ascending: !this.matchValue("DESC")
    }), this.matchValue("ASC")) {
      const s = e[e.length - 1];
      s && (s.ascending = !0);
    }
    for (; this.matchValue(","); )
      if (e.push({
        column: this.parseIdentifier(),
        ascending: !this.matchValue("DESC")
      }), this.matchValue("ASC")) {
        const s = e[e.length - 1];
        s && (s.ascending = !0);
      }
    return e;
  }
  /**
   * SELECT
   */
  parseSelect() {
    let e = !1;
    this.matchValue("DISTINCT") && (e = !0);
    const s = this.parseSelectList();
    this.expectValue("FROM");
    const n = this.parseIdentifier(), i = [];
    for (; ; ) {
      const a = this.parseJoin();
      if (!a) break;
      i.push(a);
    }
    let o;
    this.matchValue("WHERE") && (o = this.parseExpression());
    let r;
    return this.isCurrentValue("ORDER") && (r = this.parseOrderBy()), {
      type: $e.SELECT,
      distinct: e,
      columns: s,
      from: n,
      joins: i,
      where: o,
      orderBy: r,
      position: this.current.position
    };
  }
  /**
   * 
   */
  parseStatement() {
    return this.isCurrentValue("CREATE") ? (this.nextToken(), this.parseCreateTable()) : this.isCurrentValue("ALTER") ? (this.nextToken(), this.parseAlterTable()) : this.isCurrentValue("DROP") ? (this.nextToken(), this.parseDropTable()) : this.isCurrentValue("INSERT") ? (this.nextToken(), this.parseInsert()) : this.isCurrentValue("UPDATE") ? (this.nextToken(), this.parseUpdate()) : this.isCurrentValue("DELETE") ? (this.nextToken(), this.parseDelete()) : this.isCurrentValue("APPEND") ? (this.nextToken(), this.parseAppend()) : this.isCurrentValue("SELECT") ? (this.nextToken(), this.parseSelect()) : null;
  }
  /**
   * 
   */
  parse() {
    const e = [], s = [];
    for (; !this.isCurrentType(Y.EOF); )
      try {
        const n = this.parseStatement();
        n && e.push(n), this.matchValue(";") || this.isCurrentType(Y.EOF) || s.push(`Expected ';' at position ${this.current.position}`);
      } catch (n) {
        for (s.push(n.message); !this.isCurrentType(Y.EOF) && !this.isCurrentType(Y.SEMICOLON); )
          this.nextToken();
        this.isCurrentType(Y.SEMICOLON) && this.nextToken();
      }
    return { statements: e, errors: s };
  }
  /**
   * SQL
   */
  static parse(e) {
    const s = new em(e);
    return new di(s).parse();
  }
}
class ul {
  evaluateExpression(e, s, n, i) {
    if (e.type === "value")
      return e.value;
    if (e.type === "column") {
      if (i === null)
        throw new Error("Cannot evaluate column expression without row context");
      const o = e.name, r = s.fieldName2id[o];
      if (r === void 0)
        throw new Error(`Column '${o}' does not exist`);
      return i[r];
    }
    if (e.type === "binary") {
      const o = this.evaluateExpression(e.left, s, n, i), r = this.evaluateExpression(e.right, s, n, i);
      switch (e.operator) {
        case "+":
          return Number(o) + Number(r);
        case "-":
          return Number(o) - Number(r);
        case "*":
          return Number(o) * Number(r);
        case "/":
          return Number(o) / Number(r);
        case "=":
          return o === r;
        case "!=":
        case "<>":
          return o !== r;
        case ">":
          return Number(o) > Number(r);
        case "<":
          return Number(o) < Number(r);
        case ">=":
          return Number(o) >= Number(r);
        case "<=":
          return Number(o) <= Number(r);
        case "AND":
          return !!o && !!r;
        case "OR":
          return !!o || !!r;
        case "IS":
          return o === r;
        case "IS NOT":
          return o !== r;
        default:
          throw new Error(`Unknown operator: ${e.operator}`);
      }
    }
    if (e.type === "null") {
      if (e.value && e.value.type === "value" && e.value.value === null)
        return null;
      const o = this.evaluateExpression(e.value, s, n, i);
      return e.not ? o !== null : o === null;
    }
    if (e.type === "in") {
      const o = this.evaluateExpression(e.value, s, n, i);
      return e.values.map((a) => this.evaluateExpression(a, s, n, i)).some((a) => a === o);
    }
    if (e.type === "between") {
      const o = this.evaluateExpression(e.value, s, n, i), r = this.evaluateExpression(e.min, s, n, i), a = this.evaluateExpression(e.max, s, n, i);
      return o >= r && o <= a;
    }
    throw new Error(`Unknown expression type: ${e.type}`);
  }
  evaluateWhere(e, s, n, i) {
    return !!this.evaluateExpression(e, s, n, i);
  }
}
class Eo {
  static exportTable(e, s) {
    if (s.length === 0)
      return `**${e.tableName}**

*()*`;
    const n = Object.keys(e.id2fieldName).map((a) => parseInt(a)), i = n.map((a) => e.id2fieldName[a]), o = i.map(() => "---"), r = [];
    for (const a of s) {
      const l = [];
      for (const u of n) {
        const c = a[u];
        l.push(Eo.formatValue(c));
      }
      r.push(l.join(" | "));
    }
    return `**${e.tableName}**

| ${i.join(" | ")} |
| ${o.join(" | ")} |
${r.map((a) => `| ${a} |`).join(`
`)}`;
  }
  static formatValue(e) {
    return e === null ? "*NULL*" : typeof e == "string" ? e.replace(/\n/g, "<br>") : String(e);
  }
}
class tm {
  export(e, s, n, i, o) {
    if (i) {
      if (!o)
        throw new ss("getTableIdxByName function is required when exporting a specific table");
      const a = o(i);
      if (a === void 0)
        throw new ss(`Table '${i}' does not exist`);
      const l = s[a];
      if (!l)
        throw new ss(`Schema for table '${i}' not found`);
      const u = e.getTableData(a);
      return this.exportTable(l, u, n, a);
    }
    if (n === at.STANDARD_DATA) {
      const a = {};
      for (const [l, u] of Object.entries(s)) {
        const c = parseInt(l), d = e.getTableData(c), m = this.exportAsStandardData(u, d), h = JSON.parse(m);
        Object.assign(a, h);
      }
      return JSON.stringify(a, null, 2);
    }
    const r = [];
    for (const [a, l] of Object.entries(s)) {
      const u = parseInt(a), c = e.getTableData(u);
      r.push(this.exportTable(l, c, n, u));
    }
    return r.join(`

`);
  }
  exportTable(e, s, n, i) {
    switch (n) {
      case at.INSERT_SQL:
        return this.exportAsInsertSql(e, s);
      case at.TABLE_SCHEMA:
        return JSON.stringify(e, null, 2);
      case at.DDL:
        return this.exportAsDDL(e);
      case at.MARKDOWN:
        return this.exportAsMarkdown(e, s);
      case at.STANDARD_DATA:
        return this.exportAsStandardData(e, s);
      default:
        throw new ss(`Unknown export format: ${n}`);
    }
  }
  exportAsInsertSql(e, s) {
    const n = [];
    for (const i of s) {
      const o = [];
      for (const [a] of Object.entries(e.id2fieldName)) {
        const l = parseInt(a), u = i[l];
        if (u === null)
          o.push("NULL");
        else if (typeof u == "string") {
          const c = u.replace(/\\/g, "\\\\").replace(/'/g, "''").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
          o.push(`'${c}'`);
        } else
          o.push(String(u));
      }
      const r = Object.values(e.id2fieldName).join(", ");
      n.push(`INSERT INTO ${e.tableName} (${r}) VALUES (${o.join(", ")});`);
    }
    return n.join(`
`);
  }
  exportAsMarkdown(e, s) {
    return Eo.exportTable(e, s);
  }
  exportAsStandardData(e, s) {
    const n = {}, i = [];
    for (const o of s) {
      const r = {};
      for (const [a, l] of Object.entries(e.id2fieldName)) {
        const u = parseInt(a);
        r[l] = o[u] ?? null;
      }
      i.push(r);
    }
    return n[e.tableName] = i, JSON.stringify(n, null, 2);
  }
  exportAsDDL(e) {
    const s = {}, n = {};
    for (const [r] of Object.entries(e.id2fieldName)) {
      const a = parseInt(r), l = e.columnSchemas[a];
      if (l) {
        const u = l.type + (l.primitiveKey ? " PRIMARY KEY" : "");
        s[l.name] = u, l.comment && (n[l.name] = l.comment);
      }
    }
    const i = new Map(Object.entries(s)), o = new Map(Object.entries(n));
    return rt.ddl().createTable(e.tableName, i, e.comment, o);
  }
}
class yo {
  structure;
  dataStorage;
  ddlExecutor;
  dmlExecutor;
  dqlExecutor;
  dataExporter;
  constructor(e, s) {
    this.dataStorage = e || ds.newStorage(), this.structure = s || this.createEmptyStructure(), this.ddlExecutor = new Cr(
      this.structure,
      this.dataStorage,
      this.getTableIdxByName.bind(this)
    ), this.dmlExecutor = new wr(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dqlExecutor = new Dr(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dataExporter = new tm();
  }
  createEmptyStructure() {
    return {
      tableSchemas: {},
      tableName2Idx: {},
      tableIdxCounter: 0
    };
  }
  getTables() {
    return Object.values(this.structure.tableSchemas).map((s) => ({
      ...s,
      id2fieldName: { ...s.id2fieldName },
      fieldName2id: { ...s.fieldName2id },
      columnSchemas: { ...s.columnSchemas }
    }));
  }
  execute(e, s) {
    try {
      const n = di.parse(e);
      if (n.errors.length > 0)
        throw new Sn(
          n.errors.join("; "),
          0,
          e
        );
      const i = n.statements;
      if (i.length === 0)
        throw new Sn("No valid SQL statement found", 0, e);
      let o;
      for (let r = 0; r < i.length; r++) {
        const a = i[r];
        if (!a) continue;
        const l = this.getStatementType(a);
        if (!s.includes(l))
          throw new Re(
            `Expected SQL type ${s.join(" or ")}, got ${l}`,
            e
          );
        o = this.executeStatement(a);
      }
      if (!o)
        throw new Sn("No valid statement executed", 0, e);
      return o;
    } catch (n) {
      throw n instanceof Sn || n instanceof Re || n instanceof ss ? n : new ss(n.message, e);
    }
  }
  getStatementType(e) {
    const s = e.type;
    switch (s) {
      case $e.CREATE_TABLE:
      case $e.ALTER_TABLE:
      case $e.DROP_TABLE:
        return ee.DDL;
      case $e.INSERT:
      case $e.UPDATE:
      case $e.DELETE:
      case $e.APPEND:
        return ee.DML;
      case $e.SELECT:
        return ee.DQL;
      default:
        throw new ss(`Unknown statement type: ${s}`);
    }
  }
  executeStatement(e) {
    switch (e.type) {
      case $e.CREATE_TABLE:
        return this.ddlExecutor.executeCreateTable(e);
      case $e.ALTER_TABLE:
        return this.ddlExecutor.executeAlterTable(e);
      case $e.DROP_TABLE:
        return this.ddlExecutor.executeDropTable(e);
      case $e.INSERT:
        return this.dmlExecutor.executeInsert(e);
      case $e.UPDATE:
        return this.dmlExecutor.executeUpdate(e);
      case $e.DELETE:
        return this.dmlExecutor.executeDelete(e);
      case $e.APPEND:
        return this.dmlExecutor.executeAppend(e);
      case $e.SELECT:
        return this.dqlExecutor.executeSelect(e);
      default:
        throw new ss("Unsupported statement type");
    }
  }
  getTableIdxByName(e) {
    return this.structure.tableName2Idx[e];
  }
  getTableNameByIdx(e) {
    return this.structure.tableSchemas[e]?.tableName;
  }
  validateTableExists(e) {
    const s = this.getTableIdxByName(e);
    if (s === void 0)
      throw new Re(
        `Table '${e}' does not exist`,
        `Table '${e}' does not exist`
      );
    return s;
  }
  getDataStorage() {
    return this.dataStorage;
  }
  setDataStorage(e) {
    this.dataStorage = e;
  }
  export(e, s) {
    return this.dataExporter.export(
      this.dataStorage,
      this.structure.tableSchemas,
      e,
      s,
      this.getTableIdxByName.bind(this)
    );
  }
  clone() {
    const e = JSON.parse(JSON.stringify(this.structure));
    return new yo(void 0, e);
  }
  serialize() {
    return {
      structure: this.structure,
      dataStorage: this.dataStorage.serialize()
    };
  }
  deserialize(e) {
    const s = e;
    s.structure ? this.structure = s.structure : this.structure = this.createEmptyStructure(), s.dataStorage ? this.dataStorage.deserialize(s.dataStorage) : this.dataStorage.clear(), this.rebuildExecutors();
  }
  rebuildExecutors() {
    this.ddlExecutor = new Cr(
      this.structure,
      this.dataStorage,
      this.getTableIdxByName.bind(this)
    ), this.dmlExecutor = new wr(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dqlExecutor = new Dr(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    );
  }
}
class _o {
  data = {};
  constructor(e) {
    e && Object.keys(e).forEach((s) => {
      const n = parseInt(s), i = e[n];
      i && (this.data[n] = i.map((o) => ({ ...o })));
    });
  }
  /**
   * 
   */
  clone() {
    const e = {};
    return Object.keys(this.data).forEach((s) => {
      const n = parseInt(s), i = this.data[n];
      i && (e[n] = i.map((o) => ({ ...o })));
    }), new _o(e);
  }
  /**
   * 
   */
  getTableData(e) {
    return this.data[e] || [];
  }
  /**
   * 
   */
  setTableData(e, s) {
    this.data[e] = s.map((n) => ({ ...n }));
  }
  /**
   * 
   */
  clear() {
    this.data = {};
  }
  /**
   * 
   */
  serialize() {
    return this.data;
  }
  /**
   * 
   */
  deserialize(e) {
    this.data = {};
    const s = e;
    Object.keys(s).forEach((n) => {
      const i = parseInt(n), o = s[n];
      Array.isArray(o) ? this.data[i] = o.map((r) => ({ ...r })) : this.data[i] = [];
    });
  }
}
class Cr {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.getTableIdxByName = n;
  }
  executeCreateTable(e) {
    const s = e.tableName;
    this.validateTableNotExists(s);
    const n = this.allocateTableIdx(), i = e.columns, o = {}, r = {}, a = {};
    let l = 0;
    for (const c of i) {
      const d = l++;
      o[d] = c.name, r[c.name] = d;
      const m = {
        name: c.name,
        type: c.type,
        primitiveKey: c.primitiveKey || !1,
        defaultValue: c.defaultValue,
        comment: c.comment || ""
      };
      a[d] = m;
    }
    const u = {
      tableName: s,
      id2fieldName: o,
      fieldName2id: r,
      columnSchemas: a,
      counter: l,
      comment: e.comment || ""
    };
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [n]: u }, this.structure.tableName2Idx = { ...this.structure.tableName2Idx, [s]: n }, {
      success: !0,
      message: `Table '${s}' created successfully`,
      data: 0,
      type: ee.DDL
    };
  }
  executeAlterTable(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.structure.tableSchemas[n];
    switch (e.opType) {
      case "ADD_COLUMN":
        return this.addColumn(i, s, e.columnDef);
      case "DROP_COLUMN":
        return this.removeColumn(i, s, e.columnName);
      case "RENAME":
        return this.renameTable(i, n, s, e.newTableName);
      case "RENAME_COLUMN":
        return this.renameColumn(i, s, e.columnName, e.newColumnName);
      case "MODIFY_COLUMN_COMMENT":
        return this.modifyColumnComment(i, s, e.columnName, e.comment);
      case "MODIFY_COLUMN_PRIMITIVE_KEY":
        return this.modifyColumnPrimitiveKey(i, s, e.columnName, e.columnDef);
      case "ALTER_TABLE_COMMENT":
        return this.modifyTableComment(i, s, e.comment);
    }
    throw new Error("Invalid ALTER TABLE statement");
  }
  executeDropTable(e) {
    const s = e.tableName, n = this.validateTableExists(s), { [n]: i, ...o } = this.structure.tableSchemas, { [s]: r, ...a } = this.structure.tableName2Idx;
    return this.structure.tableSchemas = o, this.structure.tableName2Idx = a, this.dataStorage.setTableData(n, []), Object.keys(this.structure.tableSchemas).length === 0 && (this.structure.tableIdxCounter = 0), {
      success: !0,
      message: `Table '${s}' dropped`,
      data: 0,
      type: ee.DDL
    };
  }
  addColumn(e, s, n) {
    if (e.fieldName2id[n.name] !== void 0)
      throw new Re(
        `Column '${n.name}' already exists in table '${s}'`,
        `ALTER TABLE ${s} ADD COLUMN ${n.name}`
      );
    const i = e.counter, o = {
      name: n.name,
      type: n.type,
      primitiveKey: n.primitiveKey || !1,
      defaultValue: n.defaultValue,
      comment: n.comment || ""
    };
    e.id2fieldName = { ...e.id2fieldName, [i]: o.name }, e.fieldName2id = { ...e.fieldName2id, [o.name]: i }, e.columnSchemas = { ...e.columnSchemas, [i]: o }, e.counter = i + 1;
    const r = { ...e }, a = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [a]: r }, {
      success: !0,
      message: `Column '${n.name}' added to table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  removeColumn(e, s, n) {
    const i = e.fieldName2id[n];
    if (i === void 0)
      throw new Re(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} DROP COLUMN ${n}`
      );
    const { [i]: o, ...r } = e.id2fieldName, { [n]: a, ...l } = e.fieldName2id, { [i]: u, ...c } = e.columnSchemas;
    e.id2fieldName = r, e.fieldName2id = l, e.columnSchemas = c;
    const d = { ...e }, m = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [m]: d }, {
      success: !0,
      message: `Column '${n}' dropped from table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  renameTable(e, s, n, i) {
    if (!i)
      throw new Re("New table name is required", `ALTER TABLE ${n} RENAME TO`);
    if (this.getTableIdxByName(i) !== void 0)
      throw new Re(
        `Table '${i}' already exists`,
        `ALTER TABLE ${n} RENAME TO ${i}`
      );
    const o = { ...e, tableName: i }, { [n]: r, ...a } = this.structure.tableName2Idx;
    return this.structure.tableName2Idx = { ...a, [i]: s }, this.structure.tableSchemas = { ...this.structure.tableSchemas, [s]: o }, {
      success: !0,
      message: `Table renamed from '${n}' to '${i}'`,
      data: 0,
      type: ee.DDL
    };
  }
  renameColumn(e, s, n, i) {
    if (!n || !i)
      throw new Re("Column names are required", `ALTER TABLE ${s} RENAME COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Re(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} RENAME COLUMN ${n} TO ${i}`
      );
    if (e.fieldName2id[i] !== void 0)
      throw new Re(
        `Column '${i}' already exists in table '${s}'`,
        `ALTER TABLE ${s} RENAME COLUMN ${n} TO ${i}`
      );
    const { [n]: r, ...a } = e.fieldName2id, l = { ...e.id2fieldName, [o]: i }, u = e.columnSchemas[o], c = {
      name: i,
      type: u.type,
      primitiveKey: u.primitiveKey,
      defaultValue: u.defaultValue,
      comment: u.comment
    }, { [o]: d, ...m } = e.columnSchemas, h = { ...m, [o]: c };
    e.fieldName2id = { ...a, [i]: o }, e.id2fieldName = l, e.columnSchemas = h;
    const g = { ...e }, y = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [y]: g }, {
      success: !0,
      message: `Column '${n}' renamed to '${i}' in table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  modifyColumnComment(e, s, n, i) {
    if (!n)
      throw new Re("Column name is required", `ALTER TABLE ${s} MODIFY COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Re(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} MODIFY COLUMN ${n}`
      );
    const r = e.columnSchemas[o], a = {
      name: r.name,
      type: r.type,
      primitiveKey: r.primitiveKey,
      defaultValue: r.defaultValue,
      comment: i
    }, { [o]: l, ...u } = e.columnSchemas;
    e.columnSchemas = { ...u, [o]: a };
    const c = { ...e }, d = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [d]: c }, {
      success: !0,
      message: `Column '${n}' comment updated in table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  modifyTableComment(e, s, n) {
    const i = { ...e, comment: n }, o = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [o]: i }, {
      success: !0,
      message: `Table '${s}' comment updated`,
      data: 0,
      type: ee.DDL
    };
  }
  modifyColumnPrimitiveKey(e, s, n, i) {
    if (!n)
      throw new Re("Column name is required", `ALTER TABLE ${s} MODIFY COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Re(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} MODIFY COLUMN ${n}`
      );
    const r = e.columnSchemas[o], a = {
      name: r.name,
      type: r.type,
      primitiveKey: i.primitiveKey,
      defaultValue: r.defaultValue,
      comment: i.comment !== void 0 ? i.comment : r.comment
    }, { [o]: l, ...u } = e.columnSchemas;
    e.columnSchemas = { ...u, [o]: a };
    const c = { ...e }, d = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [d]: c }, {
      success: !0,
      message: `Column '${n}' primary key updated in table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  allocateTableIdx() {
    return this.structure.tableIdxCounter++;
  }
  validateTableExists(e) {
    const s = this.getTableIdxByName(e);
    if (s === void 0)
      throw new Re(
        `Table '${e}' does not exist`,
        `Table '${e}' does not exist`
      );
    return s;
  }
  validateTableNotExists(e) {
    if (this.getTableIdxByName(e) !== void 0)
      throw new Re(
        `Table '${e}' already exists`,
        `Table '${e}' already exists`
      );
  }
}
class wr {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.validateTableExists = n, this.expressionEvaluator = new ul();
  }
  expressionEvaluator;
  get tableSchemas() {
    return this.structure.tableSchemas;
  }
  executeInsert(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = 0;
    const r = Object.entries(i.columnSchemas).filter(([a, l]) => l.primitiveKey).map(([a, l]) => parseInt(a)).sort((a, l) => a - l);
    for (const a of e.values) {
      const l = {}, u = {}, c = e.columns;
      if (c && c.length > 0)
        for (let d = 0; d < c.length; d++) {
          const m = c[d];
          if (i.fieldName2id[m] === void 0)
            throw new Re(
              `Column '${m}' does not exist in table '${s}'`,
              `INSERT INTO ${s}`
            );
          u[m] = d;
        }
      else {
        const d = Object.entries(i.columnSchemas).filter(([m]) => !isNaN(parseInt(m))).sort((m, h) => parseInt(m[0]) - parseInt(h[0]));
        for (let m = 0; m < d.length; m++) {
          const h = d[m];
          if (!h) continue;
          const [g, y] = h;
          u[y.name] = m;
        }
      }
      for (const [d, m] of Object.entries(i.columnSchemas)) {
        const h = parseInt(d), g = m.name, y = u[g];
        if (y !== void 0) {
          const _ = a[y], E = this.expressionEvaluator.evaluateExpression(_, i, n, null);
          E === null && m.defaultValue !== void 0 ? l[h] = m.defaultValue : l[h] = E;
        } else m.defaultValue !== void 0 ? l[h] = m.defaultValue : l[h] = null;
      }
      if (r.length > 0) {
        const d = this.dataStorage.getTableData(n), m = d.find((h) => r.every((g) => JSON.stringify(h[g]) === JSON.stringify(l[g])));
        if (m) {
          for (const [h] of Object.entries(u)) {
            const g = i.fieldName2id[h];
            if (g !== void 0) {
              const y = l[g];
              m[g] = y !== void 0 ? y : null;
            }
          }
          this.dataStorage.setTableData(n, d);
        } else
          d.push(l), this.dataStorage.setTableData(n, d);
      } else {
        const d = this.dataStorage.getTableData(n);
        d.push(l), this.dataStorage.setTableData(n, d);
      }
      o++;
    }
    return {
      success: !0,
      message: `Inserted ${o} row(s) into '${s}'`,
      data: o,
      type: ee.DML
    };
  }
  executeUpdate(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = 0;
    const r = this.dataStorage.getTableData(n);
    for (const a of r)
      if (e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, a)) {
        for (const u of e.sets) {
          const c = i.fieldName2id[u.column];
          if (c === void 0)
            throw new Re(
              `Column '${u.column}' does not exist in table '${s}'`,
              `UPDATE ${s}`
            );
          const d = this.expressionEvaluator.evaluateExpression(u.value, i, n, a);
          a[c] = d;
        }
        o++;
      }
    return this.dataStorage.setTableData(n, r), {
      success: !0,
      message: `Updated ${o} row(s) in '${s}'`,
      data: o,
      type: ee.DML
    };
  }
  executeDelete(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n], o = this.dataStorage.getTableData(n), r = [];
    for (const l of o)
      e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, l) || r.push(l);
    const a = o.length - r.length;
    return this.dataStorage.setTableData(n, r), {
      success: !0,
      message: `Deleted ${a} row(s) from '${s}'`,
      data: a,
      type: ee.DML
    };
  }
  executeAppend(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n], o = e.columns, r = e.values;
    if (o.length !== r.length)
      throw new Re(
        `Number of columns (${o.length}) does not match number of values (${r.length})`,
        `APPEND INTO ${s}`
      );
    const a = [];
    for (let c = 0; c < o.length; c++) {
      const d = o[c], m = i.fieldName2id[d];
      if (m === void 0)
        throw new Re(
          `Column '${d}' does not exist in table '${s}'`,
          `APPEND INTO ${s}`
        );
      const h = i.columnSchemas[m];
      if (!h)
        throw new Re(
          `Column '${d}' does not exist in table '${s}'`,
          `APPEND INTO ${s}`
        );
      if (h.primitiveKey)
        throw new Re(
          `Cannot APPEND to primary key column '${d}'`,
          `APPEND INTO ${s}`
        );
      if (h.type !== Lt.STRING)
        throw new Re(
          `Column '${d}' must be STRING type for APPEND operation`,
          `APPEND INTO ${s}`
        );
      a.push({
        fieldIdx: m,
        colSchema: h,
        valueExpr: r[c]
      });
    }
    let l = 0;
    const u = this.dataStorage.getTableData(n);
    for (const c of u)
      if (e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, c)) {
        for (const m of a) {
          let h = c[m.fieldIdx];
          h == null && (h = "");
          const g = this.expressionEvaluator.evaluateExpression(m.valueExpr, i, n, c);
          c[m.fieldIdx] = h + g;
        }
        l++;
      }
    return this.dataStorage.setTableData(n, u), {
      success: !0,
      message: `Appended to ${l} row(s) in '${s}'`,
      data: l,
      type: ee.DML
    };
  }
}
class Dr {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.validateTableExists = n, this.expressionEvaluator = new ul();
  }
  expressionEvaluator;
  get tableSchemas() {
    return this.structure.tableSchemas;
  }
  executeSelect(e) {
    const s = e.from, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = this.dataStorage.getTableData(n);
    e.where && (o = o.filter(
      (a) => this.expressionEvaluator.evaluateWhere(e.where, i, n, a)
    ));
    const r = [];
    for (const a of o) {
      const l = {};
      for (const u of e.columns)
        if (u.type === "star")
          for (const [c, d] of Object.entries(i.id2fieldName)) {
            const m = parseInt(c);
            l[d] = a[m];
          }
        else if (u.type === "column") {
          const c = (u.tableName, u.name), d = i.fieldName2id[c];
          d !== void 0 && (l[c] = a[d]);
        }
      r.push(l);
    }
    if (e.orderBy) {
      const a = e.orderBy[0];
      if (a) {
        const l = a.column;
        i.fieldName2id[l] !== void 0 && r.sort((c, d) => {
          const m = c[l], h = d[l];
          return m === null && h === null ? 0 : m === null ? a.ascending ? -1 : 1 : h === null ? a.ascending ? 1 : -1 : m < h ? a.ascending ? -1 : 1 : m > h ? a.ascending ? 1 : -1 : 0;
        });
      }
    }
    return {
      success: !0,
      message: `Selected ${r.length} row(s)`,
      data: r,
      type: ee.DQL
    };
  }
}
class ds {
  static newExecutor() {
    return new yo();
  }
  static newStorage() {
    return new _o();
  }
}
class _e {
  static COMMITTED_START_TAG = "<committed>";
  static COMMITTED_END_TAG = "</committed>";
  static COMMIT_START_TAG = "<commit>";
  static COMMIT_END_TAG = "</commit>";
  static ERROR_START_TAG = "<error>";
  static ERROR_END_TAG = "</error>";
  static getCommitted() {
    const s = SillyTavern.getContext()?.chat || [], n = /* @__PURE__ */ new Map();
    for (let i = 0; i < s.length; i++) {
      const o = s[i];
      if (o?.mes) {
        const r = this.extractTagContent(o.mes, _e.COMMITTED_START_TAG, _e.COMMITTED_END_TAG);
        r && n.set(i, r);
      }
    }
    return n;
  }
  static processMessage(e, s, n, i) {
    const o = SillyTavern.getContext(), a = (o?.chat || [])[e];
    if (!a)
      return;
    const l = a.mes || "", u = this.extractTagContent(l, s, n), c = i(u);
    if (u === null)
      a.mes = l + c;
    else {
      const d = l.lastIndexOf(n), m = l.lastIndexOf(s, d), h = l.substring(0, m), g = l.substring(d + n.length);
      a.mes = h + c + g;
    }
    o?.saveChat();
  }
  static processCommit(e, s) {
    return _e.processMessage(e, _e.COMMIT_START_TAG, _e.COMMIT_END_TAG, s);
  }
  static processCommitted(e, s) {
    return _e.processMessage(e, _e.COMMITTED_START_TAG, _e.COMMITTED_END_TAG, s);
  }
  static processLastCommitted(e) {
    const s = SillyTavern.getContext();
    (s?.chat || []).length == 0 && s?.chat.push({
      id: 0,
      name: "",
      role: "assistant",
      mes: "",
      date: Date.now()
    }), this.processCommitted(s?.chat.length - 1, e);
  }
  static processLastError(e) {
    const s = SillyTavern.getContext();
    return (s?.chat || []).length == 0 && s?.chat.push({
      id: 0,
      name: "",
      role: "assistant",
      mes: "",
      date: Date.now()
    }), _e.processMessage(s?.chat.length - 1, _e.ERROR_START_TAG, _e.ERROR_END_TAG, e);
  }
  static extractCommit(e) {
    return this.extractTagContent(e, _e.COMMIT_START_TAG, _e.COMMIT_END_TAG);
  }
  static extractCommitted(e) {
    return this.extractTagContent(e, _e.COMMITTED_START_TAG, _e.COMMITTED_END_TAG);
  }
  static replaceCommitWithCommitted(e, s) {
    const n = SillyTavern.getContext(), o = (n?.chat || [])[e];
    if (!o)
      return;
    let r = o.mes || "";
    const a = r.lastIndexOf(_e.COMMIT_END_TAG);
    if (a !== -1) {
      const u = r.lastIndexOf(_e.COMMIT_START_TAG, a);
      if (u !== -1) {
        const c = r.substring(0, u), d = r.substring(a + _e.COMMIT_END_TAG.length), m = /\s$/.test(c), h = /^\s/.test(d);
        m && h ? r = c.replace(/\s$/, "") + d : r = c + d;
      }
    }
    const l = r.lastIndexOf(_e.COMMITTED_END_TAG);
    if (l !== -1) {
      const u = r.lastIndexOf(_e.COMMITTED_START_TAG, l);
      if (u !== -1) {
        const c = r.substring(0, u), d = r.substring(l + _e.COMMITTED_END_TAG.length);
        r = c + _e.COMMITTED_START_TAG + s + _e.COMMITTED_END_TAG + d;
      }
    } else
      r = r + _e.COMMITTED_START_TAG + s + _e.COMMITTED_END_TAG;
    o.mes = r, n?.saveChat();
  }
  static extractTagContent(e, s, n) {
    const i = e.lastIndexOf(n);
    if (i === -1) return null;
    const o = e.lastIndexOf(s, i);
    return o === -1 ? null : e.substring(o + s.length, i).trim() || null;
  }
}
class Or {
  static validateSql(e) {
    const s = [], n = di.parse(e);
    for (const o of n.errors)
      s.push(o);
    const i = e.split(";").map((o) => o.trim()).filter((o) => o.length > 0);
    for (const o of i) {
      const r = this.checkBasicSyntax(o);
      s.push(...r);
    }
    return s;
  }
  static checkBasicSyntax(e) {
    const s = [];
    (e.match(/'/g) || []).length % 2 !== 0 && s.push(`SQL : ${e}`);
    const i = [];
    let o = !1, r = 0;
    for (; r < e.length; ) {
      const a = e[r], l = e[r + 1];
      if (a === "'" && (!o || o && (l !== "'" || e[r - 1] === "'")) && (o = !o), !o) {
        if (a === "(")
          i.push("(");
        else if (a === ")") {
          if (i.length === 0)
            return s.push(`SQL : ${e}`), s;
          i.pop();
        }
      }
      r++;
    }
    return i.length > 0 && s.push(`SQL : ${e}`), s;
  }
  static compressDml(e, s) {
    let n = e;
    const i = Object.entries(s);
    i.sort((o, r) => {
      const [, a] = o, [, l] = r;
      return l.tableName.length - a.tableName.length;
    });
    for (const [o, r] of i) {
      const a = parseInt(o), l = r.tableName, u = `@t${a}`, c = Object.entries(r.columnSchemas);
      c.sort((d, m) => {
        const [, h] = d, [, g] = m;
        return g.name.length - h.name.length;
      });
      for (const [d, m] of c) {
        const h = parseInt(d), g = m.name, y = `@t${a}c${h}`;
        n = n.replace(new RegExp(`\\b${g.replace(/@/g, "\\@")}\\b`, "g"), y);
      }
      n = n.replace(new RegExp(`\\b${l.replace(/@/g, "\\@")}\\b`, "g"), u);
    }
    return n;
  }
  static decompressDml(e, s) {
    let n = e;
    const i = Object.entries(s);
    i.sort((o, r) => {
      const [a] = o, [l] = r;
      return l.length - a.length;
    });
    for (const [o, r] of i) {
      const a = parseInt(o), l = r.tableName, u = `@t${a}`, c = Object.entries(r.columnSchemas);
      c.sort((d, m) => {
        const [h] = d, [g] = m;
        return g.length - h.length;
      });
      for (const [d, m] of c) {
        const h = parseInt(d), g = m.name, y = `@t${a}c${h}`;
        n = n.replace(new RegExp(y.replace(/@/g, "\\@"), "g"), g);
      }
      n = n.replace(new RegExp(u.replace(/@/g, "\\@"), "g"), l);
    }
    return n;
  }
}
class $r {
  tableTemplate;
  cachedStorage = null;
  cachedCommittedHash = "";
  constructor(e) {
    this.tableTemplate = e.clone();
  }
  getTables() {
    return this.tableTemplate.getTables();
  }
  clone() {
    return this.tableTemplate.clone();
  }
  compressDml(e) {
    const s = this.getTableSchemas();
    return Or.compressDml(e, s);
  }
  decompressDml(e) {
    const s = this.getTableSchemas();
    return Or.decompressDml(e, s);
  }
  getTableSchemas() {
    const e = this.getTables(), s = {};
    for (const n of e) {
      const i = this.getTableIdxByName(n.tableName);
      i !== void 0 && (s[i] = n);
    }
    return s;
  }
  execute(e, s) {
    const n = e.split(";").map((a) => a.trim()).filter((a) => a.length > 0);
    if (n.length === 0)
      return { success: !0, message: "SQL", data: 0, type: ee.DML };
    let i = 0, o = [], r = [];
    for (const a of n) {
      const l = this.detectSqlType(a);
      if (!s.includes(l))
        throw new Error(`SQL ${s.join("  ")} ${l}`);
      if (l === ee.DML)
        r.length > 0 && (this.tableTemplate.execute(r.join(`;
`), [ee.DDL]), r = []), o.push(a);
      else if (l === ee.DDL)
        o.length > 0 && (i += this.executeDml(o.join(`;
`)), o = []), r.push(a);
      else if (l === ee.DQL)
        return r.length > 0 && (this.tableTemplate.execute(r.join(`;
`), [ee.DDL]), r = []), o.length > 0 && (i += this.executeDml(o.join(`;
`)), o = []), this.storage.execute(a, [ee.DQL]);
    }
    return r.length > 0 && this.tableTemplate.execute(r.join(`;
`), [ee.DDL]), o.length > 0 && (i += this.executeDml(o.join(`;
`))), { success: !0, message: "", data: i, type: ee.DML };
  }
  detectSqlType(e) {
    const s = e.trim().toUpperCase();
    if (/^CREATE\s+TABLE|^ALTER\s+TABLE|^DROP\s+TABLE/i.test(s))
      return ee.DDL;
    if (/^SELECT/i.test(s))
      return ee.DQL;
    if (/^INSERT|^UPDATE|^DELETE|^APPEND/i.test(s))
      return ee.DML;
    throw new Error(`SQL: ${e}`);
  }
  executeDml(e) {
    const s = this.filterUnsupportedSyntax(e), n = this.compressDml(s);
    return e !== s && console.log("[ChatSqlExecutor] executeDml: SQL was filtered to remove unsupported syntax"), _e.processLastCommitted((i) => {
      const o = i || "";
      return `<committed>${o ? `${o};
${n}` : n}</committed>`;
    }), this.invalidateStorageCache(), e.split(";").map((i) => i.trim()).filter((i) => i.length > 0).length;
  }
  filterUnsupportedSyntax(e) {
    let s = e;
    return s = s.replace(/\s+ON\s+CONFLICT\s+\([^)]+\)\s+DO\s+UPDATE\s+SET\s+[^;]+/gi, ""), s = s.replace(/\s+OR\s+REPLACE/gi, ""), s = s.replace(/\s+OR\s+IGNORE/gi, ""), s.trim();
  }
  invalidateStorageCache() {
    this.cachedStorage = null, this.cachedCommittedHash = "";
  }
  export(e, s) {
    return this.storage.export(e, s);
  }
  get storage() {
    const e = _e.getCommitted(), s = [];
    for (const [o, r] of e.entries())
      s.push(`${o}:${r.length}`);
    const n = s.join("|");
    if (this.cachedStorage && this.cachedCommittedHash === n)
      return this.cachedStorage;
    const i = this.tableTemplate.clone();
    if (e.size === 0)
      return this.cachedStorage = i, this.cachedCommittedHash = n, i;
    for (const [o, r] of e.entries())
      try {
        i.execute(this.decompressDml(r), [ee.DML]);
      } catch {
        _e.processCommitted(o, () => `<error>${r}</error>`);
      }
    return this.cachedStorage = i, this.cachedCommittedHash = n, i;
  }
  getDataStorage() {
    return this.storage.getDataStorage();
  }
  getTableIdxByName(e) {
    return this.tableTemplate.getTableIdxByName(e);
  }
  getTableNameByIdx(e) {
    return this.tableTemplate.getTableNameByIdx(e);
  }
  setDataStorage(e) {
  }
  serialize() {
    return this.tableTemplate.serialize();
  }
  deserialize(e) {
    this.tableTemplate.deserialize(e);
  }
}
function Wi(t, e) {
  return new Proxy(t, {
    get(s, n) {
      const i = s[n];
      return typeof i == "function" && n === "execute" ? function(...o) {
        const r = i.apply(s, o);
        return e(), r;
      } : i;
    }
  });
}
class Se {
  static MODULE_NAME = "ST_BETTER_DATABASE";
  static _instance = new Se();
  _tableTemplateCache = null;
  _tableTemplateProxy = null;
  _chatStatusBarSwitch = !1;
  _chatStatusBarCode = "";
  _extensionSwitch = !1;
  _systemSqlExecutorCache = null;
  _systemSqlExecutorProxy = null;
  _chatStatusBarChangeListeners = /* @__PURE__ */ new Set();
  constructor() {
    const { extensionSettings: e } = SillyTavern.getContext();
    e[Se.MODULE_NAME] || (e[Se.MODULE_NAME] = {
      tableTemplate: null,
      chatStatusBarSwitch: !1,
      chatStatusBarCode: "",
      extensionSwitch: !1,
      systemSqlExecutor: null
    }), this._loadFromSettings();
  }
  _loadFromSettings() {
    const { extensionSettings: e } = SillyTavern.getContext(), s = e[Se.MODULE_NAME];
    if (s) {
      if (s.tableTemplate)
        try {
          this._tableTemplateCache = ds.newExecutor(), this._tableTemplateCache.deserialize(s.tableTemplate);
        } catch {
          this._tableTemplateCache = null;
        }
      if (this._chatStatusBarSwitch = s.chatStatusBarSwitch ?? !1, this._chatStatusBarCode = s.chatStatusBarCode ?? "", this._extensionSwitch = s.extensionSwitch ?? !1, s.systemSqlExecutor)
        try {
          this._systemSqlExecutorCache = ds.newExecutor(), this._systemSqlExecutorCache.deserialize(s.systemSqlExecutor);
        } catch {
          this._systemSqlExecutorCache = null;
        }
    }
  }
  _saveToSettings() {
    const { extensionSettings: e } = SillyTavern.getContext();
    let s = e[Se.MODULE_NAME];
    s || (s = {
      tableTemplate: null,
      chatStatusBarSwitch: !1,
      chatStatusBarCode: "",
      extensionSwitch: !1,
      systemSqlExecutor: null
    }, e[Se.MODULE_NAME] = s), s.tableTemplate = this._tableTemplateCache?.serialize(), s.chatStatusBarSwitch = this._chatStatusBarSwitch, s.chatStatusBarCode = this._chatStatusBarCode, s.extensionSwitch = this._extensionSwitch, s.systemSqlExecutor = this._systemSqlExecutorCache?.serialize(), SillyTavern.getContext().saveSettingsDebounced();
  }
  get tableTemplate() {
    return this._tableTemplateCache || (this._tableTemplateCache = ds.newExecutor()), this._tableTemplateProxy || (this._tableTemplateProxy = Wi(this._tableTemplateCache, () => this._saveToSettings())), this._tableTemplateProxy;
  }
  set tableTemplate(e) {
    if (typeof e == "object" && "serialize" in e) {
      const s = e.serialize();
      this._tableTemplateCache = ds.newExecutor(), this._tableTemplateCache.deserialize(s);
    } else
      this._tableTemplateCache = e;
    this._tableTemplateProxy = null, this._saveToSettings();
  }
  get chatStatusBarSwitch() {
    return this._chatStatusBarSwitch;
  }
  set chatStatusBarSwitch(e) {
    this._chatStatusBarSwitch !== e && (this._chatStatusBarSwitch = e, this._saveToSettings(), this._notifyChatStatusBarChange());
  }
  onChatStatusBarChange(e) {
    return this._chatStatusBarChangeListeners.add(e), () => this._chatStatusBarChangeListeners.delete(e);
  }
  _notifyChatStatusBarChange() {
    this._chatStatusBarChangeListeners.forEach((e) => e());
  }
  get chatStatusBarCode() {
    return this._chatStatusBarCode;
  }
  set chatStatusBarCode(e) {
    this._chatStatusBarCode = e, this._saveToSettings(), this._notifyChatStatusBarChange();
  }
  get extensionSwitch() {
    return this._extensionSwitch;
  }
  set extensionSwitch(e) {
    this._extensionSwitch = e, this._saveToSettings();
  }
  get systemSqlExecutor() {
    return this._systemSqlExecutorCache || (this._systemSqlExecutorCache = ds.newExecutor()), this._systemSqlExecutorProxy || (this._systemSqlExecutorProxy = Wi(this._systemSqlExecutorCache, () => this._saveToSettings())), this._systemSqlExecutorProxy;
  }
  set systemSqlExecutor(e) {
    if (typeof e == "object" && "serialize" in e) {
      const s = e.serialize();
      this._systemSqlExecutorCache = ds.newExecutor(), this._systemSqlExecutorCache.deserialize(s);
    } else
      this._systemSqlExecutorCache = e;
    this._systemSqlExecutorProxy = null, this._saveToSettings();
  }
  static get instance() {
    return Se._instance;
  }
}
class Pe {
  static MODULE_NAME = "ST_BETTER_DATABASE";
  /**
   *  null 
   *
   * 
   * -  readonly _instance = new ChatMetaManager()
   * -  SillyTavern.getContext() 
   * -  chatMetadata 
   */
  static _instance = null;
  /**
   * 
   *  object  SimpleSqlExecutor.serialize() 
   * 
   */
  _serializedTemplateCache = null;
  /**
   * SqlExecutor 
   *  tableTemplate  _serializedTemplateCache 
   * 
   */
  _tableTemplateCache = null;
  /**
   * 
   *  execute  _saveToMetadata()
   */
  _tableTemplateProxy = null;
  constructor() {
    const { chatMetadata: e } = SillyTavern.getContext();
    e[Pe.MODULE_NAME] || (e[Pe.MODULE_NAME] = {
      tableTemplate: null
    }), this._loadFromMetadata();
  }
  /**
   *  chatMetadata 
   *
   *  SillyTavern.getContext().chatMetadata
   * chatMetadata 
   */
  _loadFromMetadata() {
    const { chatMetadata: e } = SillyTavern.getContext(), s = e[Pe.MODULE_NAME];
    if (!s || !s.tableTemplate) {
      const n = Se.instance.tableTemplate, i = new $r(n);
      this._serializedTemplateCache = i.serialize();
    } else
      this._serializedTemplateCache = s.tableTemplate;
    this._tableTemplateCache = null, this._tableTemplateProxy = null;
  }
  /**
   *  chatMetadata
   *
   *  SillyTavern.getContext().chatMetadata
   * chatMetadata 
   */
  _saveToMetadata() {
    const { chatMetadata: e } = SillyTavern.getContext(), s = e[Pe.MODULE_NAME] || {};
    s.tableTemplate = this._serializedTemplateCache, e[Pe.MODULE_NAME] = s, SillyTavern.getContext().saveMetadata();
  }
  get tableTemplate() {
    if (!this._tableTemplateCache && this._serializedTemplateCache) {
      const e = Se.instance.tableTemplate;
      this._tableTemplateCache = new $r(e), this._tableTemplateCache.deserialize(this._serializedTemplateCache);
    }
    return !this._tableTemplateProxy && this._tableTemplateCache && (this._tableTemplateProxy = Wi(this._tableTemplateCache, () => {
      this._saveToMetadata();
    })), this._tableTemplateProxy || Se.instance.tableTemplate;
  }
  set tableTemplate(e) {
    typeof e == "object" && "serialize" in e ? this._serializedTemplateCache = e.serialize() : this._serializedTemplateCache = e, this._tableTemplateCache = null, this._tableTemplateProxy = null, this._saveToMetadata();
  }
  /**
   * 
   *
   * 
   *  SillyTavern.getContext() 
   */
  static get instance() {
    return Pe._instance || (Pe._instance = new Pe()), Pe._instance;
  }
  /**
   * 
   *
   *  chatMetadata 
   *
   * chatMetadata 
   * 
   */
  reload() {
    this._tableTemplateCache = null, this._tableTemplateProxy = null, this._loadFromMetadata();
  }
}
const Cn = "chatTemplateContainer", sm = "chat";
class Mt {
  static _instance = null;
  constructor() {
  }
  static getInstance() {
    return Mt._instance || (Mt._instance = new Mt()), Mt._instance;
  }
  updateChatTemplateDisplay() {
    const e = Se.instance;
    if (!e.chatStatusBarSwitch) {
      this.removeTemplateContainer();
      return;
    }
    const s = e.chatStatusBarCode.trim();
    if (!s) {
      this.removeTemplateContainer();
      return;
    }
    this.renderTemplateToChat(s);
  }
  removeTemplateContainer() {
    const e = document.getElementById(Cn);
    e && e.remove();
  }
  renderTemplateToChat(e) {
    const s = this.escapeIframeContent(e), n = document.getElementById(sm);
    if (!n) return;
    const i = document.getElementById(Cn);
    i && i.remove(), n.insertAdjacentHTML("beforeend", `<div class="wide100p" id="${Cn}">${s}</div>`);
    const o = document.getElementById(Cn);
    o && this.attachTouchEventHandlers(o);
  }
  attachTouchEventHandlers(e) {
    const s = (n) => n.stopPropagation();
    e.addEventListener("touchstart", s, { passive: !1 }), e.addEventListener("touchmove", s, { passive: !1 }), e.addEventListener("touchend", s, { passive: !1 });
  }
  escapeIframeContent(e) {
    return e.replace(/<iframe\b([^>]*)>([\s\S]*?)<\/iframe>/gi, (s, n, i) => {
      if (/\bsrcdoc=/i.test(n))
        return s;
      const o = i.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      return `<iframe${n} srcdoc="${o}"></iframe>`;
    });
  }
}
class Xs {
  static instance;
  constructor() {
  }
  static init() {
    if (Se.instance.extensionSwitch && !Xs.instance) {
      const e = new Xs();
      e.registerEventListeners(), Xs.instance = e;
    }
  }
  registerEventListeners() {
    const e = SillyTavern.getContext(), { eventSource: s, event_types: n } = e;
    s.on(n.MESSAGE_RECEIVED, (i) => this.onMessageReceived(i)), s.on(n.MESSAGE_EDITED, (i) => this.onMessageEdited(i)), s.on(n.MESSAGE_DELETED, (i) => this.onMessageDeleted()), s.on(n.CHAT_CHANGED, () => this.onChatChanged());
  }
  onMessageReceived(e) {
    this.processMessage(e), Mt.getInstance().updateChatTemplateDisplay();
  }
  onMessageEdited(e) {
    this.processMessage(e), Mt.getInstance().updateChatTemplateDisplay();
  }
  onMessageDeleted() {
    Mt.getInstance().updateChatTemplateDisplay();
  }
  onChatChanged() {
    Pe.instance.reload(), Mt.getInstance().updateChatTemplateDisplay();
  }
  processMessage(e) {
    const i = (SillyTavern.getContext().chat || [])[e];
    if (!i || !i.mes)
      return;
    const o = _e.extractCommit(i.mes);
    if (o)
      try {
        const a = Pe.instance.tableTemplate.compressDml(o), l = _e.extractCommitted(i.mes);
        let u = "";
        l && (u = l);
        const c = u ? `${u};
${a}` : a;
        _e.replaceCommitWithCommitted(e, c);
      } catch (r) {
        console.error("[ChatMessageHandler] Failed to compress commit:", r);
        return;
      }
  }
}
class Os {
  root;
  currentCondition;
  static of() {
    return new Os();
  }
  eq(e, s) {
    const n = `${e} = ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  ne(e, s) {
    const n = `${e} != ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  gt(e, s) {
    const n = `${e} > ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  lt(e, s) {
    const n = `${e} < ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  ge(e, s) {
    const n = `${e} >= ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  le(e, s) {
    const n = `${e} <= ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  between(e, s, n) {
    const i = `${e} BETWEEN ${this.formatValue(s)} AND ${this.formatValue(n)}`;
    return this.addCondition({ type: "condition", sql: i });
  }
  notBetween(e, s, n) {
    const i = `${e} NOT BETWEEN ${this.formatValue(s)} AND ${this.formatValue(n)}`;
    return this.addCondition({ type: "condition", sql: i });
  }
  in(e, s) {
    const n = s.map((o) => this.formatValue(o)).join(", "), i = `${e} IN (${n})`;
    return this.addCondition({ type: "condition", sql: i });
  }
  notIn(e, s) {
    const n = s.map((o) => this.formatValue(o)).join(", "), i = `${e} NOT IN (${n})`;
    return this.addCondition({ type: "condition", sql: i });
  }
  isNull(e) {
    const s = `${e} IS NULL`;
    return this.addCondition({ type: "condition", sql: s });
  }
  isNotNull(e) {
    const s = `${e} IS NOT NULL`;
    return this.addCondition({ type: "condition", sql: s });
  }
  and(e) {
    return this.combine("and", e);
  }
  or(e) {
    return this.combine("or", e);
  }
  addCondition(e) {
    return this.currentCondition ? this.currentCondition = { type: "and", left: this.currentCondition, right: e } : this.currentCondition = e, this.root = this.currentCondition, this;
  }
  combine(e, s) {
    const n = s.root || s.currentCondition;
    return n ? (this.currentCondition ? this.currentCondition = { type: e, left: this.currentCondition, right: n } : this.currentCondition = n, this.root = this.currentCondition, this) : this;
  }
  formatValue(e) {
    return e === null ? "NULL" : typeof e == "string" ? `"${e}"` : String(e);
  }
  build() {
    const e = this.root || this.currentCondition;
    return e ? this.buildNode(e) : "";
  }
  buildNode(e) {
    if (e.type === "condition")
      return e.sql;
    const s = this.buildNode(e.left), n = this.buildNode(e.right), i = e.type.toUpperCase();
    return `(${s} ${i} ${n})`;
  }
}
class gn {
  whereCondition;
  orderByClauses = [];
  joins = [];
  where(e) {
    return this.whereCondition = e, this;
  }
  orderBy(e, s = !0) {
    return this.orderByClauses.push(`${e} ${s ? "ASC" : "DESC"}`), this;
  }
  formatValue(e) {
    return e === null ? "NULL" : typeof e == "string" ? `"${e}"` : String(e);
  }
  buildWhere() {
    if (!this.whereCondition) return "";
    const e = this.whereCondition.build();
    return e ? ` WHERE ${e}` : "";
  }
}
class nm extends gn {
  tableName;
  columns = [];
  from(e) {
    return this.tableName = e, this;
  }
  select(...e) {
    return this.columns = e, this;
  }
  join(e, s, n, i) {
    return this.joins.push({ type: e.toString(), table: s, on: `${n} = ${i}` }), this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    let s = `SELECT ${this.columns.length > 0 ? this.columns.join(", ") : "*"} FROM ${this.tableName}`;
    return this.joins.length > 0 && (s += this.joins.map((n) => ` ${n.type} JOIN ${n.table} ON ${n.on}`).join("")), s += this.buildWhere(), this.orderByClauses.length > 0 && (s += ` ORDER BY ${this.orderByClauses.join(", ")}`), s;
  }
}
class im extends gn {
  tableName;
  values = /* @__PURE__ */ new Map();
  batchValues = [];
  into(e) {
    return this.tableName = e, this;
  }
  set(e, s) {
    return this.values.set(e, s), this;
  }
  setValues(e) {
    return e.forEach((s, n) => this.values.set(n, s)), this;
  }
  batch(e) {
    return this.batchValues = e, this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    const e = this.batchValues.length > 0 ? this.batchValues : [this.values], s = e[0];
    if (!s || s.size === 0)
      throw new Error("No data to insert");
    const n = Array.from(s.keys()).join(", "), i = e.map((o) => `(${Array.from(s.keys()).map((a) => {
      const l = o.get(a);
      return this.formatValue(l !== void 0 ? l : null);
    }).join(", ")})`).join(", ");
    return `INSERT INTO ${this.tableName} (${n}) VALUES ${i}`;
  }
}
class om extends gn {
  tableName;
  sets = /* @__PURE__ */ new Map();
  table(e) {
    return this.tableName = e, this;
  }
  set(e, s) {
    return this.sets.set(e, s), this;
  }
  setValues(e) {
    return e.forEach((s, n) => this.sets.set(n, s)), this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    if (this.sets.size === 0)
      throw new Error("At least one SET clause is required");
    const e = Array.from(this.sets.entries()).map(([s, n]) => `${s} = ${this.formatValue(n)}`).join(", ");
    return `UPDATE ${this.tableName} SET ${e}${this.buildWhere()}`;
  }
}
class rm extends gn {
  tableName;
  from(e) {
    return this.tableName = e, this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    return `DELETE FROM ${this.tableName}${this.buildWhere()}`;
  }
}
class am extends gn {
  tableName;
  columnName;
  appendValue;
  into(e) {
    return this.tableName = e, this;
  }
  column(e) {
    return this.columnName = e, this;
  }
  value(e) {
    return this.appendValue = e, this;
  }
  build() {
    if (!this.tableName || !this.columnName || this.appendValue === void 0)
      throw new Error("Table name, column, and value are required");
    const e = this.formatValue(this.appendValue);
    return `APPEND INTO ${this.tableName} (${this.columnName}) VALUES (${e})${this.buildWhere()}`;
  }
}
class lm {
  static createTable(e, s, n, i) {
    const o = Array.from(s.entries()).map(([a, l]) => {
      let u = `    ${a} ${l}`;
      return i && i.has(a) && (u += ` COMMENT ${this.formatValue(i.get(a))}`), u;
    }).join(`,
`);
    let r = `CREATE TABLE ${e} (
${o}
)`;
    return n && (r += ` COMMENT ${this.formatValue(n)}`), r;
  }
  static alterTableAddColumn(e, s, n, i) {
    let o = `ALTER TABLE ${e} ADD COLUMN ${s} ${n}`;
    return i && (o += ` COMMENT ${this.formatValue(i)}`), o;
  }
  static alterTableDropColumn(e, s) {
    return `ALTER TABLE ${e} DROP COLUMN ${s}`;
  }
  static alterTableRename(e, s) {
    return `ALTER TABLE ${e} RENAME TO ${s}`;
  }
  static alterTableModifyColumnComment(e, s, n, i) {
    return `ALTER TABLE ${e} MODIFY COLUMN ${s} ${n} COMMENT ${this.formatValue(i)}`;
  }
  static alterTableRenameColumn(e, s, n) {
    return `ALTER TABLE ${e} RENAME COLUMN ${s} TO ${n}`;
  }
  static alterTableComment(e, s) {
    return `ALTER TABLE ${e} COMMENT ${this.formatValue(s)}`;
  }
  static dropTable(e) {
    return `DROP TABLE ${e}`;
  }
  static formatValue(e) {
    return `"${e}"`;
  }
}
class rt {
  static select() {
    return new nm();
  }
  static insert() {
    return new im();
  }
  static update() {
    return new om();
  }
  static delete() {
    return new rm();
  }
  static append() {
    return new am();
  }
  static ddl() {
    return lm;
  }
}
class dl {
  queryData(e, s) {
    const n = rt.select().from(e).where(s || Os.of()).build();
    return this.executor.execute(n, [ee.DQL]);
  }
  insertData(e, s) {
    const n = rt.insert().into(e);
    Array.isArray(s) ? n.batch(s) : n.setValues(s);
    const i = n.build();
    return this.executor.execute(i, [ee.DML]);
  }
  deleteData(e, s) {
    const n = rt.delete().from(e).where(s).build();
    return this.executor.execute(n, [ee.DML]);
  }
  updateData(e, s, n) {
    const i = rt.update().table(e).setValues(s).where(n).build();
    return this.executor.execute(i, [ee.DML]);
  }
  export(e) {
    return this.executor.export(at.INSERT_SQL, e);
  }
}
class cm extends dl {
  get executor() {
    return Pe.instance.tableTemplate;
  }
}
class To {
  createTable(e, s, n) {
    const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    s.forEach((a) => {
      const l = a.type + (a.primitiveKey ? " PRIMARY KEY" : "");
      i.set(a.name, l), a.comment && o.set(a.name, a.comment);
    });
    const r = rt.ddl().createTable(e, i, n, o);
    return this.executor.execute(r, [ee.DDL]);
  }
  dropTable(e) {
    const s = rt.ddl().dropTable(e);
    return this.executor.execute(s, [ee.DDL]);
  }
  addColumn(e, s, n) {
    const i = n.type + (n.primitiveKey ? " PRIMARY KEY" : ""), o = rt.ddl().alterTableAddColumn(e, s, i, n.comment);
    return this.executor.execute(o, [ee.DDL]);
  }
  dropColumn(e, s) {
    const n = rt.ddl().alterTableDropColumn(e, s);
    return this.executor.execute(n, [ee.DDL]);
  }
  alterTableName(e, s) {
    const n = rt.ddl().alterTableRename(e, s);
    return this.executor.execute(n, [ee.DDL]);
  }
  alterTableComment(e, s) {
    const n = rt.ddl().alterTableComment(e, s);
    return this.executor.execute(n, [ee.DDL]);
  }
  alterColumnComment(e, s, n) {
    if (this.executor.getTableIdxByName(e) === void 0)
      return {
        success: !1,
        message: `Table ${e} not found`,
        data: 0,
        type: ee.DDL
      };
    const o = rt.ddl().alterTableModifyColumnComment(e, s, "STRING", n);
    return this.executor.execute(o, [ee.DDL]);
  }
  alterColumnName(e, s, n) {
    const i = rt.ddl().alterTableRenameColumn(e, s, n);
    return this.executor.execute(i, [ee.DDL]);
  }
  exportData(e) {
    return this.executor.export(at.INSERT_SQL, e);
  }
  exportDDL(e) {
    return this.executor.export(at.DDL, e);
  }
  getTables() {
    return this.executor.getTables();
  }
}
class um extends To {
  get executor() {
    return Pe.instance.tableTemplate;
  }
}
class dm extends To {
  get executor() {
    return Se.instance.tableTemplate;
  }
}
class fm extends dl {
  get executor() {
    return Se.instance.systemSqlExecutor;
  }
}
class pm extends To {
  get executor() {
    return Se.instance.systemSqlExecutor;
  }
}
class hm {
  execute(e) {
    return Se.instance.systemSqlExecutor.execute(e, [ee.DDL, ee.DML]);
  }
}
class mm {
  syncTableFromTemplate() {
    Se.instance.systemSqlExecutor = Se.instance.tableTemplate.clone();
  }
  pushTableToTemplate() {
    const e = Se.instance.systemSqlExecutor, s = Se.instance.tableTemplate, n = e.serialize();
    s.deserialize({ structure: n.tableTemplate.structure });
  }
}
class vm {
  execute(e) {
    return Pe.instance.tableTemplate.execute(e, [ee.DDL]);
  }
}
class bm {
  execute(e) {
    return Se.instance.tableTemplate.execute(e, [ee.DDL]);
  }
}
class gm {
  /**
   * 
   */
  pushTableToTemplate() {
    const e = Pe.instance.tableTemplate, s = Se.instance.tableTemplate, n = e.serialize();
    s.deserialize({ structure: n.tableTemplate.structure });
  }
  /**
   * 
   */
  syncTableFromTemplate() {
    Pe.instance.tableTemplate = Se.instance.tableTemplate.clone();
  }
}
class ke {
  static _chatDataManagementService = new cm();
  static _chatTableManagementService = new um();
  static _chatSqlExecutorService = new vm();
  static _templateSqlExecutorService = new bm();
  static _templateTableManagementService = new dm();
  static _chatDatabaseSyncService = new gm();
  static _systemDataManagementService = new fm();
  static _systemTableManagementService = new pm();
  static _systemSqlExecutorService = new hm();
  static _systemDatabaseSyncService = new mm();
  static get chatDataManagementService() {
    return ke._chatDataManagementService;
  }
  static get chatTableManagementService() {
    return ke._chatTableManagementService;
  }
  static get chatSqlExecutorService() {
    return ke._chatSqlExecutorService;
  }
  static get templateSqlExecutorService() {
    return ke._templateSqlExecutorService;
  }
  static get templateTableManagementService() {
    return ke._templateTableManagementService;
  }
  static get chatDatabaseSyncService() {
    return ke._chatDatabaseSyncService;
  }
  static get systemDataManagementService() {
    return ke._systemDataManagementService;
  }
  static get systemTableManagementService() {
    return ke._systemTableManagementService;
  }
  static get systemSqlExecutorService() {
    return ke._systemSqlExecutorService;
  }
  static get systemDatabaseSyncService() {
    return ke._systemDatabaseSyncService;
  }
}
function Em() {
  const t = te(() => ke.chatDataManagementService), e = te(() => ke.chatTableManagementService), s = te(() => ke.chatSqlExecutorService), n = te(() => ke.chatDatabaseSyncService);
  return {
    dataManagementService: t,
    tableManagementService: e,
    sqlExecutorService: s,
    databaseSyncService: n
  };
}
function ym() {
  const t = te(() => ke.templateTableManagementService), e = te(() => ke.templateSqlExecutorService);
  return {
    tableManagementService: t,
    sqlExecutorService: e
  };
}
function _m() {
  const t = te(() => ke.systemDataManagementService), e = te(() => ke.systemTableManagementService), s = te(() => ke.systemSqlExecutorService), n = te(() => ke.systemDatabaseSyncService);
  return {
    dataManagementService: t,
    tableManagementService: e,
    sqlExecutorService: s,
    databaseSyncService: n
  };
}
const Tm = /* @__PURE__ */ Te({
  __name: "TemplateManagementPanel",
  props: /* @__PURE__ */ oo({
    defaultTabOnTableSelect: { default: "template" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { tableManagementService: n, sqlExecutorService: i } = ym(), o = ro(t, "visible"), r = /* @__PURE__ */ q(!1), a = /* @__PURE__ */ q("template"), l = /* @__PURE__ */ q(""), u = /* @__PURE__ */ q([]), c = /* @__PURE__ */ q(null), d = [
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], m = () => {
      u.value = n.value.getTables();
    }, h = (E) => {
      l.value = E, a.value = s.defaultTabOnTableSelect;
    }, g = () => {
      r.value = !r.value;
    }, y = async () => {
      a.value = "template", await It(), c.value?.openCreateTableModal();
    }, _ = () => {
      o.value = !1;
    };
    return it(o, (E) => {
      E && m();
    }), e({
      open: () => {
        o.value = !0;
      }
    }), (E, x) => (S(), k("div", null, [
      mt(E.$slots, "default"),
      C(Ge, {
        visible: o.value,
        "onUpdate:visible": x[2] || (x[2] = (T) => o.value = T),
        title: "",
        closable: !0,
        height: "650px",
        onClose: _
      }, {
        titlePrefix: B(() => [
          C(mo, {
            expanded: r.value,
            onToggle: g
          }, null, 8, ["expanded"])
        ]),
        default: B(() => [
          C(po, {
            "drawer-expanded": r.value,
            "onUpdate:drawerExpanded": x[1] || (x[1] = (T) => r.value = T),
            tables: u.value,
            "selected-table": l.value,
            onSelectTable: h,
            onCreateTable: y
          }, {
            default: B(() => [
              C(ho, {
                "active-tab": a.value,
                "onUpdate:activeTab": x[0] || (x[0] = (T) => a.value = T),
                tabs: d
              }, {
                template: B(() => [
                  C(vo, {
                    ref_key: "tableTabRef",
                    ref: c,
                    "table-service": Q(n),
                    tables: u.value,
                    "selected-table": l.value,
                    onRefresh: m,
                    "onUpdate:selectedTable": h
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: B(() => [
                  C(bo, {
                    "sql-executor-service": Q(i),
                    onRefresh: m
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), Nm = { class: "data-form" }, xm = { class: "form-content" }, Sm = { class: "form-label" }, Cm = {
  key: 0,
  class: "required-mark"
}, wm = ["value", "onInput", "type"], Dm = { class: "form-actions" }, Om = /* @__PURE__ */ Te({
  __name: "DataForm",
  props: {
    visible: { type: Boolean, default: !0 },
    columns: {},
    initialData: {},
    title: { default: "" },
    modalWidth: { default: "50vw" },
    modalHeight: { default: "auto" }
  },
  emits: ["submit", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1), o = () => {
      i.value = window.innerWidth <= 768;
    };
    ot(() => {
      o(), window.addEventListener("resize", o);
    }), Pt(() => {
      window.removeEventListener("resize", o);
    });
    const r = te(() => i.value ? "100%" : s.modalWidth), a = te(() => {
      const E = {};
      return s.modalWidth && (E["--form-modal-width"] = i.value ? "100%" : s.modalWidth), s.modalHeight && (E["--form-modal-height"] = s.modalHeight), E;
    }), l = /* @__PURE__ */ is({}), u = /* @__PURE__ */ is({}), c = /* @__PURE__ */ new Set(), d = () => {
      c.clear(), s.columns.forEach((E) => {
        let x;
        s.initialData && s.initialData[E.name] !== void 0 ? x = s.initialData[E.name] : E.defaultValue !== void 0 ? x = E.defaultValue : x = "", l[E.name] = x, u[E.name] = x;
      });
    }, m = (E) => {
      const x = E.toUpperCase();
      return x.includes("STRING") || x.includes("TEXT");
    }, h = (E) => E.toUpperCase().includes("INT") || E.toUpperCase().includes("REAL") || E.toUpperCase().includes("FLOA") || E.toUpperCase().includes("DOUB") ? "number" : "text", g = (E, x) => {
      let T;
      if (typeof x == "string")
        T = x;
      else {
        const M = x.target;
        T = M.type === "number" ? parseFloat(M.value) : M.value;
      }
      l[E] = T;
      const O = u[E];
      String(T) !== String(O) ? c.add(E) : c.delete(E);
    }, y = () => {
      const E = /* @__PURE__ */ new Map(), x = s.initialData !== void 0;
      s.columns.forEach((T) => {
        if (x && !c.has(T.name))
          return;
        let O = l[T.name], M;
        O === "" || O === void 0 ? T.primitiveKey && T.defaultValue !== void 0 ? M = T.defaultValue : M = null : M = O;
        const K = T.type.toUpperCase();
        K.includes("INT") && M !== null ? M = parseInt(String(M)) : (K.includes("REAL") || K.includes("FLOA") || K.includes("DOUB")) && M !== null && (M = parseFloat(String(M))), E.set(T.name, M);
      }), n("submit", E);
    }, _ = () => {
      n("cancel");
    };
    return it(() => s.visible, (E) => {
      E && d();
    }), it(() => s.initialData, () => {
      s.visible && d();
    }, { immediate: !0 }), (E, x) => (S(), k("div", {
      class: "data-form-wrapper",
      style: Ke(a.value)
    }, [
      C(Ge, {
        visible: t.visible,
        title: t.title,
        width: r.value,
        height: t.modalHeight,
        closable: !1,
        onClose: _
      }, {
        default: B(() => [
          f("div", Nm, [
            f("div", xm, [
              (S(!0), k(Ae, null, Wt(t.columns, (T) => (S(), k("div", {
                key: T.name,
                class: "form-item"
              }, [
                f("label", Sm, [
                  se(ue(T.name) + " ", 1),
                  T.primitiveKey ? (S(), k("span", Cm, "*")) : ne("", !0)
                ]),
                m(T.type) ? (S(), Le(Vs, {
                  key: 1,
                  "model-value": String(l[T.name] || ""),
                  "onUpdate:modelValue": (O) => g(T.name, O),
                  "min-rows": 1,
                  "max-rows": 10
                }, null, 8, ["model-value", "onUpdate:modelValue"])) : (S(), k("input", {
                  key: 0,
                  value: l[T.name],
                  onInput: (O) => g(T.name, O),
                  type: h(T.type),
                  class: "form-input"
                }, null, 40, wm))
              ]))), 128))
            ]),
            f("div", Dm, [
              C(ae, { onClick: _ }, {
                default: B(() => [...x[0] || (x[0] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "primary",
                onClick: y
              }, {
                default: B(() => [...x[1] || (x[1] = [
                  se("", -1)
                ])]),
                _: 1
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["visible", "title", "width", "height"])
    ], 4));
  }
}), Ar = /* @__PURE__ */ De(Om, [["__scopeId", "data-v-daf1bd0f"]]), $m = { class: "confirm-container" }, Am = { class: "form-actions" }, Vm = /* @__PURE__ */ Te({
  __name: "DeleteDataConfirm",
  props: {
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = te(() => {
      const a = {};
      return s.modalWidth && (a["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (a["--confirm-modal-height"] = s.modalHeight), a;
    }), o = () => {
      n("confirm");
    }, r = () => {
      n("cancel");
    };
    return (a, l) => (S(), k("div", {
      class: "delete-data-confirm-wrapper",
      style: Ke(i.value)
    }, [
      C(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: r
      }, {
        default: B(() => [
          f("div", $m, [
            l[2] || (l[2] = f("div", { class: "confirm-content" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" }),
              f("p", { class: "confirm-message" }, "")
            ], -1)),
            f("div", Am, [
              C(ae, { onClick: r }, {
                default: B(() => [...l[0] || (l[0] = [
                  se("", -1)
                ])]),
                _: 1
              }),
              C(ae, {
                type: "danger",
                onClick: o
              }, {
                default: B(() => [...l[1] || (l[1] = [
                  se("", -1)
                ])]),
                _: 1
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), Mm = /* @__PURE__ */ De(Vm, [["__scopeId", "data-v-b672c047"]]), Im = { class: "export-container" }, Rm = { class: "export-header" }, Lm = { class: "export-content" }, km = { class: "export-code" }, Pm = { class: "form-actions" }, Bm = /* @__PURE__ */ Te({
  __name: "ExportDisplay",
  props: {
    sql: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ q(!1);
    let o = null;
    const r = async () => {
      try {
        await navigator.clipboard.writeText(s.sql), i.value = !0, o && clearTimeout(o), o = setTimeout(() => {
          i.value = !1;
        }, 2e3);
      } catch (l) {
        console.error(":", l);
      }
    }, a = () => {
      n("close");
    };
    return (l, u) => (S(), k("div", Im, [
      f("div", Rm, [
        u[0] || (u[0] = f("span", { class: "export-title" }, "SQL", -1)),
        f("button", {
          class: "copy-btn",
          onClick: r
        }, [
          f("i", {
            class: Ie(i.value ? "fa-solid fa-check" : "fa-solid fa-copy")
          }, null, 2),
          se(" " + ue(i.value ? "" : ""), 1)
        ])
      ]),
      f("div", Lm, [
        f("pre", km, ue(t.sql), 1)
      ]),
      f("div", Pm, [
        C(ae, { onClick: a }, {
          default: B(() => [...u[1] || (u[1] = [
            se("", -1)
          ])]),
          _: 1
        })
      ])
    ]));
  }
}), Fm = /* @__PURE__ */ De(Bm, [["__scopeId", "data-v-affef56e"]]), Um = { class: "chat-data-management-tab" }, jm = {
  key: 1,
  class: "data-detail"
}, qm = { class: "data-toolbar" }, Hm = { class: "data-title" }, Wm = { class: "table-name" }, Km = {
  key: 0,
  class: "table-comment"
}, zm = { class: "data-actions" }, Gm = { class: "data-list" }, Ym = {
  key: 1,
  class: "table-container"
}, Qm = { class: "data-table" }, Jm = {
  key: 0,
  class: "checkbox-header sticky-col",
  style: { left: "0" }
}, Xm = { class: "checkbox-wrapper" }, Zm = ["checked"], ev = {
  key: 0,
  class: "checkbox-cell sticky-col",
  style: { left: "0" }
}, tv = { class: "checkbox-wrapper" }, sv = ["checked", "onChange"], nv = { class: "row-actions" }, iv = { class: "cell-value" }, ov = /* @__PURE__ */ Te({
  __name: "ChatDataManagementTab",
  props: {
    dataService: {},
    tables: {},
    selectedTable: {}
  },
  setup(t) {
    const e = t, s = te(() => e.tables.find((w) => w.tableName === e.selectedTable) || {}), n = te(() => s.value.columnSchemas ? Object.values(s.value.columnSchemas) : []), i = te(() => l.value === "none" ? "" : l.value === "selecting" ? "" : l.value === "confirming" ? "" : ""), o = /* @__PURE__ */ q([]), r = /* @__PURE__ */ q(/* @__PURE__ */ new Set()), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q("none"), { toast: u, showToast: c } = cl(), d = /* @__PURE__ */ q(!1), m = /* @__PURE__ */ q(!1), h = /* @__PURE__ */ q(!1), g = /* @__PURE__ */ q(!1), y = /* @__PURE__ */ q(null), _ = /* @__PURE__ */ q(""), E = (w) => w === null ? "NULL" : w === void 0 ? "" : String(w).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "\\n").replace(/<br>/gi, "&lt;br&gt;"), x = () => {
      if (s.value.tableName) {
        const w = e.dataService.queryData(s.value.tableName);
        w.success && Array.isArray(w.data) ? o.value = w.data : o.value = [];
      }
    }, T = (w) => {
      if (s.value.tableName) {
        const W = e.dataService.insertData(s.value.tableName, w);
        W.success ? (d.value = !1, x(), c("")) : c(W.message || "", "error");
      }
    }, O = (w, W) => {
      y.value = { index: w, row: W }, m.value = !0;
    }, M = (w) => {
      if (s.value.tableName && y.value) {
        const W = n.value.find((le) => le.primitiveKey), oe = o.value[y.value.index];
        let be = Os.of();
        if (W) {
          const le = oe[W.name];
          be = be.eq(W.name, le);
        }
        const fe = e.dataService.updateData(s.value.tableName, w, be);
        fe.success ? (m.value = !1, y.value = null, x(), c("")) : c(fe.message || "", "error");
      }
    }, K = (w) => {
      y.value = { index: w, row: o.value[w] }, h.value = !0;
    }, pe = () => {
      if (s.value.tableName && y.value) {
        const w = n.value.find((fe) => fe.primitiveKey), W = o.value[y.value.index];
        let oe = Os.of();
        if (w) {
          const fe = W[w.name];
          oe = oe.eq(w.name, fe);
        }
        const be = e.dataService.deleteData(s.value.tableName, oe);
        be.success ? (h.value = !1, y.value = null, x(), c("")) : c(be.message || "", "error");
      }
    }, he = (w) => {
      r.value.has(w) ? r.value.delete(w) : r.value.add(w), r.value.size > 0 ? l.value = "confirming" : l.value = "selecting";
    }, H = (w) => {
      w.target.checked ? o.value.forEach((oe, be) => r.value.add(be)) : r.value.clear(), r.value.size > 0 ? l.value = "confirming" : l.value = "selecting";
    }, re = () => {
      if (l.value === "none")
        l.value = "selecting", a.value = !0, r.value.clear();
      else if (l.value === "selecting")
        l.value = "none", a.value = !1, r.value.clear();
      else if (l.value === "confirming") {
        if (r.value.size === 0) {
          c("", "error");
          return;
        }
        if (s.value.tableName) {
          let w = 0;
          const W = n.value.find((oe) => oe.primitiveKey);
          r.value.forEach((oe) => {
            const be = o.value[oe];
            let fe = Os.of();
            if (W) {
              const de = be[W.name];
              fe = fe.eq(W.name, de);
            }
            e.dataService.deleteData(s.value.tableName, fe).success && w++;
          }), r.value.clear(), x(), c(` ${w} `), l.value = "none", a.value = !1;
        }
      }
    }, me = () => {
      s.value.tableName && (_.value = e.dataService.export(s.value.tableName), g.value = !0);
    };
    return it(() => e.selectedTable, () => {
      x();
    }), ot(() => {
      x();
    }), (w, W) => (S(), k("div", Um, [
      t.selectedTable ? (S(), k("div", jm, [
        f("div", qm, [
          f("div", Hm, [
            f("span", Wm, ue(s.value.tableName), 1),
            s.value.comment ? (S(), k("span", Km, ue(s.value.comment), 1)) : ne("", !0)
          ]),
          f("div", zm, [
            C(ae, {
              onClick: W[0] || (W[0] = (oe) => d.value = !0)
            }, {
              default: B(() => [...W[6] || (W[6] = [
                f("i", {
                  class: "fa-solid fa-plus",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            }),
            C(ae, {
              type: "danger",
              onClick: re
            }, {
              default: B(() => [
                W[7] || (W[7] = f("i", {
                  class: "fa-solid fa-trash",
                  style: { "margin-right": "6px" }
                }, null, -1)),
                se(" " + ue(i.value), 1)
              ]),
              _: 1
            }),
            C(ae, { onClick: me }, {
              default: B(() => [...W[8] || (W[8] = [
                f("i", {
                  class: "fa-solid fa-download",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            })
          ])
        ]),
        f("div", Gm, [
          o.value.length === 0 ? (S(), Le(Qn, {
            key: 0,
            icon: "fa-solid fa-database",
            text: ""
          })) : (S(), k("div", Ym, [
            f("table", Qm, [
              f("thead", null, [
                f("tr", null, [
                  a.value ? (S(), k("th", Jm, [
                    f("label", Xm, [
                      f("input", {
                        type: "checkbox",
                        checked: r.value.size === o.value.length && o.value.length > 0,
                        onChange: H
                      }, null, 40, Zm)
                    ])
                  ])) : ne("", !0),
                  f("th", {
                    class: "actions-header sticky-col",
                    style: Ke({ left: a.value ? "50px" : "0" })
                  }, "  ", 4),
                  (S(!0), k(Ae, null, Wt(n.value, (oe) => (S(), k("th", {
                    key: oe.name,
                    class: Ie(["column-header", oe.primitiveKey ? "primary-key" : ""])
                  }, ue(oe.name), 3))), 128))
                ])
              ]),
              f("tbody", null, [
                (S(!0), k(Ae, null, Wt(o.value, (oe, be) => (S(), k("tr", {
                  key: be,
                  class: "table-row"
                }, [
                  a.value ? (S(), k("td", ev, [
                    f("label", tv, [
                      f("input", {
                        type: "checkbox",
                        checked: r.value.has(be),
                        onChange: (fe) => he(be)
                      }, null, 40, sv)
                    ])
                  ])) : ne("", !0),
                  f("td", {
                    class: "actions-cell sticky-col",
                    style: Ke({ left: a.value ? "50px" : "0" })
                  }, [
                    f("div", nv, [
                      C(ae, {
                        size: "small",
                        onClick: (fe) => O(be, oe)
                      }, {
                        default: B(() => [...W[9] || (W[9] = [
                          f("i", { class: "fa-solid fa-pen" }, null, -1)
                        ])]),
                        _: 1
                      }, 8, ["onClick"]),
                      C(ae, {
                        type: "danger",
                        size: "small",
                        onClick: (fe) => K(be)
                      }, {
                        default: B(() => [...W[10] || (W[10] = [
                          f("i", { class: "fa-solid fa-trash" }, null, -1)
                        ])]),
                        _: 1
                      }, 8, ["onClick"])
                    ])
                  ], 4),
                  (S(!0), k(Ae, null, Wt(n.value, (fe) => (S(), k("td", {
                    key: fe.name,
                    class: Ie(["table-cell", fe.primitiveKey ? "primary-key" : ""])
                  }, [
                    f("span", iv, ue(E(oe[fe.name])), 1)
                  ], 2))), 128))
                ]))), 128))
              ])
            ])
          ]))
        ])
      ])) : (S(), Le(Qn, {
        key: 0,
        icon: "fa-solid fa-table",
        text: ""
      })),
      C(ll, {
        visible: Q(u).visible,
        message: Q(u).message,
        type: Q(u).type,
        icon: Q(u).icon
      }, null, 8, ["visible", "message", "type", "icon"]),
      Xe(C(Ar, {
        visible: d.value,
        title: "",
        columns: n.value,
        "modal-width": "50vw",
        onSubmit: T,
        onCancel: W[1] || (W[1] = (oe) => d.value = !1)
      }, null, 8, ["visible", "columns"]), [
        [cr, d.value]
      ]),
      Xe(C(Ar, {
        visible: m.value,
        title: "",
        columns: n.value,
        "initial-data": y.value?.row,
        "modal-width": "50vw",
        onSubmit: M,
        onCancel: W[2] || (W[2] = (oe) => m.value = !1)
      }, null, 8, ["visible", "columns", "initial-data"]), [
        [cr, m.value]
      ]),
      h.value ? (S(), Le(Mm, {
        key: 2,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: pe,
        onCancel: W[3] || (W[3] = (oe) => h.value = !1)
      })) : ne("", !0),
      g.value ? (S(), Le(Ge, {
        key: 3,
        visible: "",
        title: "",
        onClose: W[5] || (W[5] = (oe) => g.value = !1)
      }, {
        default: B(() => [
          C(Fm, {
            sql: _.value,
            onClose: W[4] || (W[4] = (oe) => g.value = !1)
          }, null, 8, ["sql"])
        ]),
        _: 1
      })) : ne("", !0)
    ]));
  }
}), fl = /* @__PURE__ */ De(ov, [["__scopeId", "data-v-0cce85f5"]]), rv = /* @__PURE__ */ Te({
  __name: "SystemDataManagementPanel",
  props: /* @__PURE__ */ oo({
    defaultTabOnTableSelect: { default: "data" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { dataManagementService: n, tableManagementService: i, sqlExecutorService: o } = _m(), r = ro(t, "visible"), a = /* @__PURE__ */ q(!1), l = /* @__PURE__ */ q("data"), u = /* @__PURE__ */ q(""), c = /* @__PURE__ */ q([]), d = /* @__PURE__ */ q(null), m = [
      { key: "data", label: "", icon: "fa-solid fa-database" },
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], h = () => {
      c.value = i.value.getTables();
    }, g = (x) => {
      u.value = x, l.value = s.defaultTabOnTableSelect;
    }, y = () => {
      a.value = !a.value;
    }, _ = async () => {
      l.value = "template", await It(), d.value?.openCreateTableModal();
    }, E = () => {
      r.value = !1;
    };
    return it(r, (x) => {
      x && h();
    }), e({
      open: () => {
        r.value = !0;
      }
    }), (x, T) => (S(), k("div", null, [
      mt(x.$slots, "default"),
      C(Ge, {
        visible: r.value,
        "onUpdate:visible": T[2] || (T[2] = (O) => r.value = O),
        title: "",
        closable: !0,
        height: "650px",
        onClose: E
      }, {
        titlePrefix: B(() => [
          C(mo, {
            expanded: a.value,
            onToggle: y
          }, null, 8, ["expanded"])
        ]),
        default: B(() => [
          C(po, {
            "drawer-expanded": a.value,
            "onUpdate:drawerExpanded": T[1] || (T[1] = (O) => a.value = O),
            tables: c.value,
            "selected-table": u.value,
            "show-sync-buttons": !1,
            onSelectTable: g,
            onCreateTable: _
          }, {
            default: B(() => [
              C(ho, {
                "active-tab": l.value,
                "onUpdate:activeTab": T[0] || (T[0] = (O) => l.value = O),
                tabs: m
              }, {
                data: B(() => [
                  C(fl, {
                    "data-service": Q(n),
                    tables: c.value,
                    "selected-table": u.value,
                    onRefresh: h
                  }, null, 8, ["data-service", "tables", "selected-table"])
                ]),
                template: B(() => [
                  C(vo, {
                    ref_key: "tableTabRef",
                    ref: d,
                    "table-service": Q(i),
                    tables: c.value,
                    "selected-table": u.value,
                    onRefresh: h,
                    "onUpdate:selectedTable": g
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: B(() => [
                  C(bo, {
                    "sql-executor-service": Q(o),
                    onRefresh: h
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), av = { class: "category_container" }, lv = { style: { display: "flex", "align-items": "center", gap: "10px" } }, cv = { class: "category_container" }, uv = { class: "category_container" }, dv = { style: { display: "flex", "flex-direction": "column", gap: "12px" } }, fv = /* @__PURE__ */ Te({
  __name: "SettingsPanel",
  setup(t) {
    const e = Se.instance, s = te({
      get: () => e.extensionSwitch,
      set: (y) => e.extensionSwitch = y
    }), n = te({
      get: () => e.chatStatusBarSwitch,
      set: (y) => e.chatStatusBarSwitch = y
    }), i = /* @__PURE__ */ q(!1), o = /* @__PURE__ */ q(""), r = /* @__PURE__ */ q(), a = /* @__PURE__ */ q(0);
    it(i, async (y) => {
      if (y) {
        a.value++, await It();
        const _ = e.chatStatusBarCode;
        o.value = _, await It(), r.value && (r.value.value = _);
      }
    });
    const l = () => {
      i.value = !0;
    }, u = () => {
      i.value = !1;
    }, c = () => {
      e.chatStatusBarCode = o.value, i.value = !1;
    }, d = /* @__PURE__ */ q(), m = /* @__PURE__ */ q(), h = () => {
      d.value?.open();
    }, g = () => {
      m.value?.open();
    };
    return (y, _) => (S(), k(Ae, null, [
      f("div", av, [
        C(xn, null, {
          left: B(() => [..._[4] || (_[4] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-sliders",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: B(() => [
            C(xr, {
              checked: s.value,
              onChange: _[0] || (_[0] = (E) => s.value = E)
            }, null, 8, ["checked"])
          ]),
          _: 1
        }),
        C(xn, null, {
          left: B(() => [..._[5] || (_[5] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-paper-plane",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: B(() => [
            f("div", lv, [
              C(xr, {
                checked: n.value,
                onChange: _[1] || (_[1] = (E) => n.value = E)
              }, null, 8, ["checked"]),
              C(ae, { onClick: l }, {
                default: B(() => [..._[6] || (_[6] = [
                  f("i", {
                    class: "fa-solid fa-pen-to-square",
                    style: { "margin-right": "6px" }
                  }, null, -1),
                  se("  ", -1)
                ])]),
                _: 1
              })
            ])
          ]),
          _: 1
        })
      ]),
      f("div", cv, [
        C(xn, null, {
          left: B(() => [..._[7] || (_[7] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-file-code",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: B(() => [
            C(ae, { onClick: h }, {
              default: B(() => [..._[8] || (_[8] = [
                f("i", {
                  class: "fa-solid fa-gear",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      f("div", uv, [
        C(xn, null, {
          left: B(() => [..._[9] || (_[9] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-database",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: B(() => [
            C(ae, { onClick: g }, {
              default: B(() => [..._[10] || (_[10] = [
                f("i", {
                  class: "fa-solid fa-gear",
                  style: { "margin-right": "6px" }
                }, null, -1),
                se("  ", -1)
              ])]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      C(Tm, {
        ref_key: "templateManagementPanelRef",
        ref: d
      }, {
        default: B(() => [..._[11] || (_[11] = [])]),
        _: 1
      }, 512),
      C(rv, {
        ref_key: "systemDataManagementPanelRef",
        ref: m
      }, {
        default: B(() => [..._[12] || (_[12] = [])]),
        _: 1
      }, 512),
      C(Ge, {
        visible: i.value,
        "onUpdate:visible": _[3] || (_[3] = (E) => i.value = E),
        title: "",
        closable: !0,
        onClose: u
      }, {
        footer: B(() => [
          C(ae, { onClick: u }, {
            default: B(() => [..._[13] || (_[13] = [
              se("", -1)
            ])]),
            _: 1
          }),
          C(ae, { onClick: c }, {
            default: B(() => [..._[14] || (_[14] = [
              se("", -1)
            ])]),
            _: 1
          })
        ]),
        default: B(() => [
          f("div", dv, [
            Xe(f("textarea", {
              ref_key: "textareaRef",
              ref: r,
              "onUpdate:modelValue": _[2] || (_[2] = (E) => o.value = E),
              rows: "10",
              style: { width: "100%", padding: "12px", border: "1px solid var(--SmartThemeBorderColor)", "border-radius": "6px", background: "var(--black30a)", color: "var(--SmartThemeBodyColor)", "font-family": "monospace", resize: "vertical" },
              placeholder: "..."
            }, null, 512), [
              [zt, o.value]
            ])
          ])
        ]),
        _: 1
      }, 8, ["visible"])
    ], 64));
  }
}), pv = /* @__PURE__ */ Te({
  __name: "ExtraMesButtons",
  emits: ["click"],
  setup(t, { emit: e }) {
    const s = e;
    function n() {
      s("click");
    }
    return ot(() => {
      $(document).on("click", ".open_database_table", n);
    }), hn(() => {
      $(document).off("click", ".open_database_table", n);
    }), (i, o) => (S(), Le(ya, { to: ".extraMesButtons" }, [
      o[0] || (o[0] = f("div", {
        class: "mes_button open_database_table",
        title: ""
      }, [
        f("i", { class: "fa-solid fa-table" })
      ], -1))
    ]));
  }
}), hv = /* @__PURE__ */ Te({
  __name: "ChatManagementPanel",
  props: /* @__PURE__ */ oo({
    defaultTabOnTableSelect: { default: "data" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { dataManagementService: n, tableManagementService: i, sqlExecutorService: o, databaseSyncService: r } = Em(), a = ro(t, "visible"), l = /* @__PURE__ */ q(!1), u = /* @__PURE__ */ q("data"), c = /* @__PURE__ */ q(""), d = /* @__PURE__ */ q([]), m = /* @__PURE__ */ q(null), h = [
      { key: "data", label: "", icon: "fa-solid fa-database" },
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], g = () => {
      d.value = i.value.getTables();
    }, y = (M) => {
      c.value = M, u.value = s.defaultTabOnTableSelect;
    }, _ = () => {
      l.value = !l.value;
    }, E = async () => {
      u.value = "template", await It(), m.value?.openCreateTableModal();
    }, x = () => {
      r.value.syncTableFromTemplate(), g();
    }, T = () => {
      r.value.pushTableToTemplate(), g();
    }, O = () => {
      a.value = !1;
    };
    return it(a, (M) => {
      M && g();
    }), e({
      open: () => {
        a.value = !0;
      }
    }), (M, K) => (S(), k("div", null, [
      mt(M.$slots, "default"),
      C(Ge, {
        visible: a.value,
        "onUpdate:visible": K[2] || (K[2] = (pe) => a.value = pe),
        title: "",
        closable: !0,
        height: "650px",
        onClose: O
      }, {
        titlePrefix: B(() => [
          C(mo, {
            expanded: l.value,
            onToggle: _
          }, null, 8, ["expanded"])
        ]),
        default: B(() => [
          C(po, {
            "drawer-expanded": l.value,
            "onUpdate:drawerExpanded": K[1] || (K[1] = (pe) => l.value = pe),
            tables: d.value,
            "selected-table": c.value,
            "show-sync-buttons": !0,
            onSelectTable: y,
            onCreateTable: E,
            onSync: x,
            onPush: T
          }, {
            default: B(() => [
              C(ho, {
                "active-tab": u.value,
                "onUpdate:activeTab": K[0] || (K[0] = (pe) => u.value = pe),
                tabs: h
              }, {
                data: B(() => [
                  C(fl, {
                    "data-service": Q(n),
                    tables: d.value,
                    "selected-table": c.value,
                    onRefresh: g
                  }, null, 8, ["data-service", "tables", "selected-table"])
                ]),
                template: B(() => [
                  C(vo, {
                    ref_key: "tableTabRef",
                    ref: m,
                    "table-service": Q(i),
                    tables: d.value,
                    "selected-table": c.value,
                    onRefresh: g,
                    "onUpdate:selectedTable": y
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: B(() => [
                  C(bo, {
                    "sql-executor-service": Q(o),
                    onRefresh: g
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), mv = { class: "translation_settings" }, vv = { class: "inline-drawer" }, bv = { class: "inline-drawer-content" }, gv = { style: { padding: "10px" } }, Ev = /* @__PURE__ */ Te({
  __name: "MainView",
  setup(t) {
    const e = /* @__PURE__ */ q(!1), s = () => {
      e.value = !0;
    };
    return (n, i) => (S(), k("div", mv, [
      f("div", vv, [
        i[1] || (i[1] = f("div", { class: "inline-drawer-toggle inline-drawer-header" }, [
          f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
            f("b", null, "")
          ]),
          f("div", { class: "inline-drawer-icon fa-solid fa-circle-chevron-down down" })
        ], -1)),
        f("div", bv, [
          f("div", gv, [
            C(fv)
          ])
        ])
      ]),
      C(pv, { onClick: s }),
      C(hv, {
        visible: e.value,
        "onUpdate:visible": i[0] || (i[0] = (o) => e.value = o)
      }, null, 8, ["visible"])
    ]));
  }
}), yv = /* @__PURE__ */ De(Ev, [["__scopeId", "data-v-d18c04a2"]]);
class _v {
  static init() {
    if (Se.instance.extensionSwitch) {
      const e = SillyTavern.getContext(), { registerMacro: s, eventSource: n } = e;
      if (typeof window > "u")
        return;
      window.getTemplateSqlExecutor = () => Se.instance.tableTemplate, window.getChatSqlExecutor = () => Pe.instance.tableTemplate, window.chatDatabaseData = () => JSON.parse(Pe.instance.tableTemplate.export(at.STANDARD_DATA)), n.on("prompt_template_prepare", (i) => {
        i.getTemplateSqlExecutor = () => Se.instance.tableTemplate, i.getChatSqlExecutor = () => Pe.instance.tableTemplate;
      }), this.registerMacros(s);
    }
  }
  static registerMacros(e) {
    const s = ke.chatTableManagementService;
    e("GET_ALL_TABLE_NAMES", () => s.getTables().map((n) => n.tableName)), e("GET_ALL_TABLE_SCHEMAS", () => Pe.instance.tableTemplate.export(at.DDL)), e("GET_ALL_TABLE_DATA", () => Pe.instance.tableTemplate.export(at.MARKDOWN));
  }
}
class Tv {
  static init() {
    Xs.init(), _v.init();
    const e = Mt.getInstance();
    e.updateChatTemplateDisplay(), Se.instance.onChatStatusBarChange(() => {
      e.updateChatTemplateDisplay();
    });
  }
}
Tv.init();
const Vr = document.createElement("div"), Mr = document.querySelector("#extensions_settings");
Mr && (Mr.appendChild(Vr), Sd(yv).mount(Vr));
//# sourceMappingURL=index.js.map
