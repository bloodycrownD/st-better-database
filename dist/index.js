(function(){"use strict";try{if(typeof document<"u"){var a=document.createElement("style");a.appendChild(document.createTextNode('.st-card-unified[data-v-5b66fbc1]{min-height:48px;display:flex;align-items:center;transition:background-color var(--animation-duration, 125ms)}.st-card-unified>div[data-v-5b66fbc1]{width:100%}.st-toggle-switch[data-v-f73e4a93]{position:relative;display:inline-block;width:40px;height:22px;transform:scale(.9)}.st-toggle-switch input[data-v-f73e4a93]{opacity:0;width:0;height:0}.st-toggle-slider[data-v-f73e4a93]{position:absolute;cursor:pointer;inset:0;background-color:var(--SmartThemeEmColor);transition:var(--animation-duration, 125ms);border-radius:22px}.st-toggle-slider[data-v-f73e4a93]:before{position:absolute;content:"";height:16px;width:16px;left:3px;bottom:3px;background-color:var(--SmartThemeBodyColor);transition:var(--animation-duration, 125ms);border-radius:50%;box-shadow:0 2px 4px var(--SmartThemeShadowColor)}input:checked+.st-toggle-slider[data-v-f73e4a93]{background-color:var(--SmartThemeBodyColor)}input:checked+.st-toggle-slider[data-v-f73e4a93]:before{transform:translate(18px);background-color:var(--SmartThemeBlurTintColor)}.button-wrapper[data-v-8b9ccff3]{display:inline-flex;align-items:center;justify-content:center;flex-direction:row}.button-content[data-v-8b9ccff3]{display:flex;align-items:center;gap:6px;flex-direction:row;white-space:nowrap}.popup-modal-overlay[data-v-546209e7]{position:fixed;inset:0;background:#00000080;display:flex;align-items:center;justify-content:center;z-index:9999;padding:20px}.popup-modal[data-v-546209e7]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:8px;box-shadow:0 4px 20px var(--SmartThemeShadowColor);max-width:1200px;width:100%;max-height:90vh;display:flex;flex-direction:column}.popup-modal-header[data-v-546209e7]{display:flex;justify-content:space-between;align-items:center;padding:16px 20px;border-bottom:1px solid var(--SmartThemeBorderColor)}.popup-modal-title[data-v-546209e7]{font-size:18px;font-weight:600;color:var(--SmartThemeBodyColor);display:flex;align-items:center;gap:8px}.popup-modal-close[data-v-546209e7]{width:32px;height:32px;display:flex;align-items:center;justify-content:center;cursor:pointer;border-radius:4px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);transition:all .2s}.popup-modal-close[data-v-546209e7]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.popup-modal-close i[data-v-546209e7]{font-size:18px}.popup-modal-body[data-v-546209e7]{flex:1;overflow:auto;padding:20px}.popup-modal-footer[data-v-546209e7]{padding:16px 20px;border-top:1px solid var(--SmartThemeBorderColor);display:flex;justify-content:flex-end;gap:10px}.modal-enter-active[data-v-546209e7],.modal-leave-active[data-v-546209e7]{transition:opacity .3s ease}.modal-enter-from[data-v-546209e7],.modal-leave-to[data-v-546209e7]{opacity:0}.modal-enter-active .popup-modal[data-v-546209e7],.modal-leave-active .popup-modal[data-v-546209e7]{transition:transform .3s ease,opacity .3s ease}.modal-enter-from .popup-modal[data-v-546209e7],.modal-leave-to .popup-modal[data-v-546209e7]{transform:scale(.9);opacity:0}@media(max-width:768px){.popup-modal-overlay[data-v-546209e7]{padding:10px}.popup-modal[data-v-546209e7]{height:90vh;border-radius:8px 8px 0 0;margin-top:auto}.popup-modal-header[data-v-546209e7]{padding:12px 16px}.popup-modal-title[data-v-546209e7]{font-size:16px}.popup-modal-body[data-v-546209e7]{padding:16px}.popup-modal-footer[data-v-546209e7]{padding:12px 16px}}.table-list-drawer[data-v-85bfbdca]{display:flex;flex-direction:column;height:100%;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);border-right:1px solid var(--SmartThemeBorderColor)}.drawer-header[data-v-85bfbdca]{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor)}.drawer-title[data-v-85bfbdca]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.header-actions[data-v-85bfbdca]{display:flex;align-items:center;gap:6px}.sync-btn[data-v-85bfbdca],.push-btn[data-v-85bfbdca]{display:flex;align-items:center;justify-content:center;width:28px;height:28px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);cursor:pointer;transition:all .2s}.sync-btn[data-v-85bfbdca]:hover,.push-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.sync-btn i[data-v-85bfbdca],.push-btn i[data-v-85bfbdca]{font-size:13px}.create-table-btn[data-v-85bfbdca]{display:flex;align-items:center;justify-content:center;width:28px;height:28px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);cursor:pointer;transition:all .2s}.create-table-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.create-table-btn i[data-v-85bfbdca]{font-size:13px}.drawer-body[data-v-85bfbdca]{flex:1;overflow-y:auto;padding:8px}.empty-state[data-v-85bfbdca]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:200px;gap:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.empty-state i[data-v-85bfbdca]{font-size:32px}.empty-state span[data-v-85bfbdca]{font-size:14px}.empty-create-btn[data-v-85bfbdca]{display:flex;align-items:center;gap:6px;padding:8px 16px;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s;margin-top:8px}.empty-create-btn[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);color:var(--SmartThemeBodyColor)}.empty-create-btn i[data-v-85bfbdca]{font-size:12px}.table-list[data-v-85bfbdca]{display:flex;flex-direction:column;gap:4px}.table-item[data-v-85bfbdca]{padding:12px;border-radius:6px;cursor:pointer;transition:all .2s;border:1px solid transparent}.table-item[data-v-85bfbdca]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.table-item.active[data-v-85bfbdca]{background:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent);border-color:var(--SmartThemeBorderColor)}.table-item-main[data-v-85bfbdca]{display:flex;align-items:center;gap:8px;margin-bottom:4px}.table-icon[data-v-85bfbdca]{font-size:14px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.table-name[data-v-85bfbdca]{font-size:14px;font-weight:500;color:var(--SmartThemeBodyColor);flex:1;word-break:break-all}.table-comment[data-v-85bfbdca]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);margin-left:22px;word-break:break-all}@media(max-width:768px){.drawer-header[data-v-85bfbdca],.drawer-body[data-v-85bfbdca]{padding:12px}.empty-state[data-v-85bfbdca]{height:auto;min-height:150px;padding:20px}.table-list[data-v-85bfbdca]{gap:8px}.table-item[data-v-85bfbdca]{padding:14px 12px}.table-name[data-v-85bfbdca]{font-size:15px}.table-comment[data-v-85bfbdca]{font-size:13px;margin-top:4px;margin-left:0}}.table-drawer-layout[data-v-3e0df31e]{display:flex;flex-direction:column;height:100%;min-height:500px}.layout-content[data-v-3e0df31e]{flex:1;display:flex;overflow:hidden;position:relative}.layout-drawer[data-v-3e0df31e]{width:240px;flex-shrink:0;border-right:1px solid var(--SmartThemeBorderColor)}.layout-main[data-v-3e0df31e]{flex:1;overflow:hidden}.drawer-slide-enter-active[data-v-3e0df31e],.drawer-slide-leave-active[data-v-3e0df31e]{transition:all .3s ease}.drawer-slide-enter-from[data-v-3e0df31e],.drawer-slide-leave-to[data-v-3e0df31e]{width:0;opacity:0}@media(max-width:768px){.table-drawer-layout[data-v-3e0df31e]{min-height:400px}.layout-drawer[data-v-3e0df31e]{width:100%}}.tab-container[data-v-9d94b988]{display:flex;flex-direction:column;height:100%}.tab-header[data-v-9d94b988]{display:flex;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);overflow-x:auto;scrollbar-width:none}.tab-header[data-v-9d94b988]::-webkit-scrollbar{display:none}.tab-item[data-v-9d94b988]{padding:12px 24px;cursor:pointer;border-bottom:2px solid transparent;transition:all .2s;display:flex;align-items:center;gap:8px;font-size:14px;color:var(--SmartThemeEmColor)}.tab-item[data-v-9d94b988]:hover{color:var(--SmartThemeBodyColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.tab-item.active[data-v-9d94b988]{color:var(--SmartThemeBodyColor);border-bottom-color:var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.tab-item i[data-v-9d94b988]{font-size:14px}.tab-body[data-v-9d94b988]{flex:1;overflow:hidden}@media(max-width:768px){.tab-header .tab-item[data-v-9d94b988]{width:40vw;flex-shrink:0;justify-content:center;padding:14px 16px;font-size:13px;white-space:nowrap}.tab-item[data-v-9d94b988]{gap:6px}}.drawer-toggle[data-v-04d4da93]{background:none;border:none;cursor:pointer;padding:7.2px;display:flex;align-items:center;justify-content:center;color:var(--SmartThemeBodyColor);transition:all .2s;border-radius:3.6px;transform:scale(.9)}.drawer-toggle[data-v-04d4da93]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.drawer-toggle[data-v-04d4da93]:active{transform:scale(.855)}.drawer-toggle.fab[data-v-04d4da93]{position:fixed;bottom:80px;right:20px;width:56px;height:56px;border-radius:50%;background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);box-shadow:0 4px 12px var(--SmartThemeShadowColor);z-index:1001}.drawer-toggle.fab[data-v-04d4da93]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.drawer-toggle.fab .hamburger-icon[data-v-04d4da93]{width:24px;height:24px}@media(min-width:769px){.drawer-toggle.fab[data-v-04d4da93]{display:none}}.hamburger-icon[data-v-04d4da93]{width:21.6px;height:16.2px;display:flex;flex-direction:column;justify-content:space-between;position:relative}.line[data-v-04d4da93]{width:100%;height:1.8px;background:var(--SmartThemeBodyColor);border-radius:1.8px;transition:all .3s ease}.toast-notification[data-v-76c92735]{position:fixed;top:20px;left:50%;transform:translate(-50%);display:flex;align-items:center;gap:10px;padding:12px 20px;border-radius:6px;font-size:14px;font-weight:500;z-index:10000;box-shadow:0 4px 12px #00000026}.toast-notification.success[data-v-76c92735]{background:#10b981;color:#fff}.toast-notification.error[data-v-76c92735]{background:#ef4444;color:#fff}.toast-notification i[data-v-76c92735]{font-size:16px}.toast-enter-active[data-v-76c92735],.toast-leave-active[data-v-76c92735]{transition:all .3s ease}.toast-enter-from[data-v-76c92735],.toast-leave-to[data-v-76c92735]{opacity:0;transform:translate(-50%) translateY(-20px)}@media(max-width:768px){.toast-notification[data-v-76c92735]{left:16px;right:16px;transform:none;justify-content:center}.toast-enter-from[data-v-76c92735],.toast-leave-to[data-v-76c92735]{transform:translateY(-20px)}}.empty-state[data-v-5ddb0dfd]{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.empty-state span[data-v-5ddb0dfd]{font-size:14px}.empty-state.compact[data-v-5ddb0dfd]{gap:12px;padding:40px 20px}.empty-state.compact span[data-v-5ddb0dfd]{font-size:14px}.auto-resize-wrapper[data-v-fd129974]{position:relative;width:100%;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);transition:all .25s cubic-bezier(.4,0,.2,1)}.auto-resize-wrapper[data-v-fd129974]:hover:not(.disabled){border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.auto-resize-wrapper.focused[data-v-fd129974]{border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.auto-resize-wrapper.disabled[data-v-fd129974]{opacity:.6;cursor:not-allowed}.textarea-mirror[data-v-fd129974]{position:absolute;top:0;left:0;visibility:hidden;pointer-events:none;height:auto;overflow:hidden;z-index:-1}.auto-resize-textarea[data-v-fd129974]{display:block;width:100%;padding:12px 16px;border:none;outline:none;background:transparent;font-family:inherit;font-size:14px;line-height:1.5;color:var(--SmartThemeBodyColor);resize:none;overflow:hidden;box-sizing:border-box;transition:height .15s ease}.auto-resize-textarea[data-v-fd129974]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.auto-resize-textarea[data-v-fd129974]:disabled{cursor:not-allowed}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar{width:8px}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-track{background:transparent}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-thumb{background:color-mix(in srgb,var(--SmartThemeBorderColor) 60%,transparent);border-radius:4px}.auto-resize-textarea[data-v-fd129974]::-webkit-scrollbar-thumb:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 80%,transparent)}.textarea-footer[data-v-fd129974]{display:flex;justify-content:flex-end;padding:2px 14px 8px;margin-top:-4px}.char-count[data-v-fd129974]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);transition:color .2s}.char-count.warning[data-v-fd129974]{color:#ef4444;font-weight:600}@media(max-width:768px){.auto-resize-textarea[data-v-fd129974]{padding:14px 16px;font-size:16px}}.form-wrapper[data-v-08eccbfb]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-08eccbfb]{display:flex;flex-direction:column;gap:24px;max-height:65vh;overflow-y:auto}.form-section[data-v-08eccbfb]{display:flex;flex-direction:column;gap:16px}.form-item[data-v-08eccbfb]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-08eccbfb]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);display:flex;align-items:center;gap:4px;letter-spacing:.3px}.required[data-v-08eccbfb]{color:#ef4444;margin-left:4px}.form-input[data-v-08eccbfb],.form-select[data-v-08eccbfb]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-08eccbfb]:hover,.form-select[data-v-08eccbfb]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-08eccbfb]:focus,.form-select[data-v-08eccbfb]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-08eccbfb]::placeholder,.form-select[data-v-08eccbfb]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input.has-error[data-v-08eccbfb],.form-select.has-error[data-v-08eccbfb]{border-color:#ef4444}.form-input.has-error[data-v-08eccbfb]:focus,.form-select.has-error[data-v-08eccbfb]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-08eccbfb]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-08eccbfb]{font-size:14px}.section-error[data-v-08eccbfb]{padding:10px 12px;background:#ef44441a;border-radius:6px;margin-bottom:8px}.field-hint[data-v-08eccbfb]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.columns-section[data-v-08eccbfb]{border-top:1.5px solid var(--SmartThemeBorderColor);padding-top:20px}.section-header[data-v-08eccbfb]{display:flex;justify-content:space-between;align-items:center}.column-count[data-v-08eccbfb]{font-size:13px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);padding:4px 10px;border-radius:12px}.columns-list[data-v-08eccbfb]{display:flex;flex-direction:column;gap:12px}.column-card[data-v-08eccbfb]{background:var(--SmartThemeBlurTintColor);border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;overflow:hidden}.column-card.has-error[data-v-08eccbfb]{border-color:#ef4444}.column-card-header[data-v-08eccbfb]{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:color-mix(in srgb,var(--SmartThemeBorderColor) 20%,transparent);border-bottom:1.5px solid var(--SmartThemeBorderColor)}.column-number[data-v-08eccbfb]{font-size:12px;font-weight:600;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.remove-btn[data-v-08eccbfb]{background:none;border:none;cursor:pointer;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);padding:6px;border-radius:4px;transition:all .2s}.remove-btn[data-v-08eccbfb]:hover{color:#ef4444;background:#ef44441a}.remove-btn i[data-v-08eccbfb]{font-size:14px}.column-card-body[data-v-08eccbfb]{padding:16px;display:flex;flex-direction:column;gap:12px}.form-row[data-v-08eccbfb]{display:flex;gap:12px}.form-col[data-v-08eccbfb]{display:flex;flex-direction:column;gap:6px}.form-col.form-col-name[data-v-08eccbfb]{flex:2}.form-col.form-col-type[data-v-08eccbfb],.form-col.form-col-default[data-v-08eccbfb],.form-col.form-col-comment[data-v-08eccbfb]{flex:1}.field-label[data-v-08eccbfb]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 70%,transparent)}.field-label .required[data-v-08eccbfb]{font-size:12px;margin-left:4px}.checkbox-label[data-v-08eccbfb]{display:flex;align-items:center;gap:8px;color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;width:fit-content}.checkbox-label input[data-v-08eccbfb]{cursor:pointer;width:16px;height:16px}.add-column-btn[data-v-08eccbfb]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px;border:2px dashed var(--SmartThemeBorderColor);border-radius:8px;background:transparent;color:color-mix(in srgb,var(--SmartThemeBodyColor) 70%,transparent);font-size:14px;cursor:pointer;transition:all .2s}.add-column-btn[data-v-08eccbfb]:hover{border-color:var(--SmartThemeBorderColor);color:var(--SmartThemeBodyColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 10%,transparent)}.add-column-btn i[data-v-08eccbfb]{font-size:14px}.form-actions[data-v-08eccbfb]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-08eccbfb]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-08eccbfb]{--form-modal-width: 100%}.form-container[data-v-08eccbfb]{gap:20px}.form-row[data-v-08eccbfb]{flex-direction:column;gap:12px}.form-col.form-col-name[data-v-08eccbfb],.form-col.form-col-type[data-v-08eccbfb],.form-col.form-col-default[data-v-08eccbfb],.form-col.form-col-comment[data-v-08eccbfb]{flex:1}.column-card-body[data-v-08eccbfb]{padding:12px}.form-actions[data-v-08eccbfb]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-08eccbfb]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-58e374f4]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-58e374f4]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-58e374f4]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-58e374f4]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-58e374f4]{color:#ef4444;margin-left:4px}.form-input[data-v-58e374f4]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-58e374f4]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-58e374f4]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-58e374f4]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-58e374f4]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-input.has-error[data-v-58e374f4]{border-color:#ef4444}.form-input.has-error[data-v-58e374f4]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-58e374f4]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-58e374f4]{font-size:14px}.field-hint[data-v-58e374f4]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.form-actions[data-v-58e374f4]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-58e374f4]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-58e374f4]{--form-modal-width: 100%}.form-container[data-v-58e374f4]{gap:16px}.form-item[data-v-58e374f4]{gap:8px}.form-label[data-v-58e374f4]{font-size:15px}.form-input[data-v-58e374f4]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-58e374f4]::placeholder{font-size:15px}.field-hint[data-v-58e374f4]{font-size:13px}.form-actions[data-v-58e374f4]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-58e374f4]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-03532044]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-03532044]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-03532044]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-03532044]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.form-actions[data-v-03532044]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-03532044]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-03532044]{--form-modal-width: 100%}.form-container[data-v-03532044]{gap:16px}.form-item[data-v-03532044]{gap:8px}.form-label[data-v-03532044]{font-size:15px}.form-actions[data-v-03532044]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-03532044]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.drop-table-confirm-wrapper[data-v-4629727b]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-4629727b]{padding:24px 20px;text-align:center}.confirm-icon-wrapper[data-v-4629727b]{margin-bottom:16px}.warning-icon[data-v-4629727b]{font-size:48px;color:#f59e0b}.confirm-content[data-v-4629727b]{margin-bottom:24px}.confirm-message[data-v-4629727b]{font-size:16px;color:var(--SmartThemeBodyColor);margin-bottom:12px;line-height:1.5}.confirm-message strong[data-v-4629727b]{color:#ef4444;font-weight:600}.confirm-warning[data-v-4629727b]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#ef44441a;border-radius:6px;font-size:13px;color:#ef4444;text-align:left}.confirm-warning i[data-v-4629727b]{font-size:14px;flex-shrink:0}.form-actions[data-v-4629727b]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.drop-table-confirm-wrapper[data-v-4629727b]{--confirm-modal-width: 90vw}.confirm-container[data-v-4629727b]{padding:20px 16px}.warning-icon[data-v-4629727b]{font-size:40px}.confirm-message[data-v-4629727b]{font-size:15px}.form-actions[data-v-4629727b]{flex-direction:column-reverse}.form-actions[data-v-4629727b]>*{width:100%}}.form-wrapper[data-v-019138f2]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-019138f2]{display:flex;flex-direction:column;gap:20px;max-height:70vh;overflow-y:auto}.form-item[data-v-019138f2]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-019138f2]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-019138f2]{color:#ef4444;margin-left:4px}.form-input[data-v-019138f2],.form-select[data-v-019138f2]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-019138f2]:hover,.form-select[data-v-019138f2]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-019138f2]:focus,.form-select[data-v-019138f2]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-019138f2]::placeholder,.form-select[data-v-019138f2]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input.has-error[data-v-019138f2],.form-select.has-error[data-v-019138f2]{border-color:#ef4444}.form-input.has-error[data-v-019138f2]:focus,.form-select.has-error[data-v-019138f2]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-019138f2]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-019138f2]{font-size:14px}.field-hint[data-v-019138f2]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.checkbox-label[data-v-019138f2]{display:flex;align-items:center;gap:8px;color:var(--SmartThemeEmColor);font-size:14px;cursor:pointer;width:fit-content}.checkbox-label input[data-v-019138f2]{cursor:pointer;width:18px;height:18px}.checkbox-label span[data-v-019138f2]{cursor:pointer}.form-actions[data-v-019138f2]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-019138f2]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-019138f2]{--form-modal-width: 100%}.form-container[data-v-019138f2]{gap:16px}.form-item[data-v-019138f2]{gap:8px}.form-label[data-v-019138f2]{font-size:15px}.form-input[data-v-019138f2],.form-select[data-v-019138f2]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-019138f2]::placeholder,.form-select[data-v-019138f2]::placeholder{font-size:15px}.field-hint[data-v-019138f2]{font-size:13px}.form-actions[data-v-019138f2]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-019138f2]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-36708f97]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-36708f97]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-36708f97]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-36708f97]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required[data-v-36708f97]{color:#ef4444;margin-left:4px}.form-input[data-v-36708f97]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-36708f97]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-36708f97]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-36708f97]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-36708f97]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-input.has-error[data-v-36708f97]{border-color:#ef4444}.form-input.has-error[data-v-36708f97]:focus{box-shadow:0 0 0 3px #ef444433}.field-error[data-v-36708f97]{display:flex;align-items:center;gap:6px;font-size:13px;color:#ef4444}.field-error i[data-v-36708f97]{font-size:14px}.field-hint[data-v-36708f97]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);line-height:1.5;padding-left:2px}.form-actions[data-v-36708f97]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-36708f97]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-36708f97]{--form-modal-width: 100%}.form-container[data-v-36708f97]{gap:16px}.form-item[data-v-36708f97]{gap:8px}.form-label[data-v-36708f97]{font-size:15px}.form-input[data-v-36708f97]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-36708f97]::placeholder{font-size:15px}.field-hint[data-v-36708f97]{font-size:13px}.form-actions[data-v-36708f97]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-36708f97]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.form-wrapper[data-v-1f79f493]{--form-modal-width: 50vw;--form-modal-height: auto}.form-container[data-v-1f79f493]{display:flex;flex-direction:column;gap:20px}.form-item[data-v-1f79f493]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-1f79f493]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.form-input[data-v-1f79f493]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-1f79f493]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-1f79f493]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-1f79f493]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-1f79f493]:disabled{opacity:.6;cursor:not-allowed;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.form-actions[data-v-1f79f493]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-1f79f493]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.form-wrapper[data-v-1f79f493]{--form-modal-width: 100%}.form-container[data-v-1f79f493]{gap:16px}.form-item[data-v-1f79f493]{gap:8px}.form-label[data-v-1f79f493]{font-size:15px}.form-input[data-v-1f79f493]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-1f79f493]::placeholder{font-size:15px}.form-actions[data-v-1f79f493]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-1f79f493]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.drop-column-confirm-wrapper[data-v-7565defa]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-7565defa]{padding:24px 20px;text-align:center}.confirm-icon-wrapper[data-v-7565defa]{margin-bottom:16px}.warning-icon[data-v-7565defa]{font-size:48px;color:#f59e0b}.confirm-content[data-v-7565defa]{margin-bottom:24px}.confirm-message[data-v-7565defa]{font-size:16px;color:var(--SmartThemeBodyColor);margin-bottom:12px;line-height:1.5}.confirm-message strong[data-v-7565defa]{color:#ef4444;font-weight:600}.confirm-warning[data-v-7565defa]{display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#ef44441a;border-radius:6px;font-size:13px;color:#ef4444;text-align:left}.confirm-warning i[data-v-7565defa]{font-size:14px;flex-shrink:0}.form-actions[data-v-7565defa]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.drop-column-confirm-wrapper[data-v-7565defa]{--confirm-modal-width: 90vw}.confirm-container[data-v-7565defa]{padding:20px 16px}.warning-icon[data-v-7565defa]{font-size:40px}.confirm-message[data-v-7565defa]{font-size:15px}.form-actions[data-v-7565defa]{flex-direction:column-reverse}.form-actions[data-v-7565defa]>*{width:100%}}.ddl-container[data-v-da039aee]{padding:20px}.ddl-header[data-v-da039aee]{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.ddl-title[data-v-da039aee]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.copy-btn[data-v-da039aee]{display:flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--SmartThemeBorderColor);border-radius:4px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s}.copy-btn[data-v-da039aee]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.copy-btn i[data-v-da039aee]{font-size:12px}.ddl-content[data-v-da039aee]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:6px;padding:16px;margin-bottom:20px;max-height:400px;overflow:auto}.ddl-code[data-v-da039aee]{margin:0;font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;color:var(--SmartThemeBodyColor);white-space:pre-wrap;word-wrap:break-word}.form-actions[data-v-da039aee]{display:flex;gap:12px;justify-content:flex-end}@media(max-width:768px){.ddl-container[data-v-da039aee]{padding:16px}.ddl-content[data-v-da039aee]{padding:12px;max-height:300px}.ddl-code[data-v-da039aee]{font-size:12px}.form-actions[data-v-da039aee]>*{width:100%}}.table-management-tab[data-v-f00e195b]{display:flex;flex-direction:column;height:100%;overflow:hidden}.table-detail[data-v-f00e195b]{flex:1;display:flex;flex-direction:column;overflow:hidden}.table-header[data-v-f00e195b]{padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.table-title-section[data-v-f00e195b]{margin-bottom:12px}.table-name-row[data-v-f00e195b],.table-comment-row[data-v-f00e195b]{display:flex;align-items:center;gap:8px;margin-bottom:8px}.table-name-row[data-v-f00e195b]:last-child,.table-comment-row[data-v-f00e195b]:last-child{margin-bottom:0}.table-label[data-v-f00e195b]{font-size:13px;color:var(--SmartThemeEmColor);min-width:50px;flex-shrink:0}.table-name[data-v-f00e195b]{font-size:15px;font-weight:600;color:var(--SmartThemeBodyColor);flex:1;word-break:break-all}.table-comment[data-v-f00e195b]{font-size:14px;color:var(--SmartThemeEmColor);flex:1;word-break:break-all}.table-comment.placeholder[data-v-f00e195b]{color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent);font-style:italic}.table-actions[data-v-f00e195b]{display:flex;gap:8px}.columns-section[data-v-f00e195b]{flex:1;display:flex;flex-direction:column;overflow:hidden}.section-header[data-v-f00e195b]{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.section-title[data-v-f00e195b]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.columns-list[data-v-f00e195b]{flex:1;overflow-y:auto;padding:12px}.column-item[data-v-f00e195b]{display:flex;justify-content:space-between;align-items:flex-start;padding:12px;border-radius:6px;background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);margin-bottom:8px;transition:all .2s}.column-item[data-v-f00e195b]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent)}.column-main[data-v-f00e195b]{flex:1;min-width:0;margin-right:12px}.column-first-row[data-v-f00e195b]{display:flex;align-items:center;gap:24px;margin-bottom:6px}.column-name-wrapper[data-v-f00e195b]{display:flex;align-items:center;gap:6px;min-width:0}.column-icon[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);flex-shrink:0}.column-name[data-v-f00e195b]{font-size:14px;font-weight:500;color:var(--SmartThemeBodyColor);word-break:break-all;min-width:0}.type-badge[data-v-f00e195b]{display:inline-block;padding:2px 8px;border-radius:4px;font-size:12px;font-weight:500;background:color-mix(in srgb,var(--SmartThemeBorderColor) 70%,transparent);color:var(--SmartThemeEmColor);flex-shrink:0}.primary-key-badge[data-v-f00e195b]{display:inline-flex;align-items:center;justify-content:center;width:24px;height:24px;border-radius:4px;background:#f59e0b26;border:1px solid rgba(245,158,11,.3);flex-shrink:0}.primary-key-badge i[data-v-f00e195b]{font-size:12px;color:#f59e0b}.column-comment[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);word-break:break-all;line-height:1.4;max-height:2.8em;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical}.default-value[data-v-f00e195b]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent);margin-top:4px}.column-actions[data-v-f00e195b]{display:flex;gap:4px;flex-shrink:0}@media(max-width:768px){.tab-toolbar[data-v-f00e195b]{flex-wrap:wrap;padding:10px 12px}.table-header[data-v-f00e195b]{padding:12px}.table-name-row[data-v-f00e195b],.table-comment-row[data-v-f00e195b]{flex-wrap:wrap}.table-actions[data-v-f00e195b]{width:100%;justify-content:stretch;margin-top:12px}.table-actions>button[data-v-f00e195b]{flex:1}.section-header[data-v-f00e195b]{padding:10px 12px}.columns-list[data-v-f00e195b]{padding:8px}.column-item[data-v-f00e195b]{flex-direction:column;gap:10px;padding:10px}.column-main[data-v-f00e195b]{margin-right:0}.column-first-row[data-v-f00e195b]{flex-wrap:wrap;gap:6px}.column-name-wrapper[data-v-f00e195b]{flex:1;min-width:0}.column-actions[data-v-f00e195b]{gap:2px;width:100%;justify-content:flex-end;border-top:1px solid var(--SmartThemeBorderColor);padding-top:8px;margin-top:4px}}.sql-panel-tab[data-v-34ac73ac]{display:flex;flex-direction:column;height:100%;gap:16px;overflow:hidden}.sql-editor-container[data-v-34ac73ac]{display:flex;flex-direction:column;height:100%;border:1px solid var(--SmartThemeBorderColor);border-radius:6px;background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.sql-toolbar[data-v-34ac73ac]{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-bottom:1px solid var(--SmartThemeBorderColor)}.toolbar-title[data-v-34ac73ac]{font-size:13px;font-weight:500;color:var(--SmartThemeEmColor)}.sql-editor[data-v-34ac73ac]{min-height:200px;max-height:400px;padding:16px;background:var(--SmartThemeBlurTintColor);border:none;outline:none;color:var(--SmartThemeBodyColor);font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;resize:vertical;overflow-y:auto;height:100%}.sql-editor[data-v-34ac73ac]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 30%,transparent)}.sql-footer[data-v-34ac73ac]{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;border-top:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.result-status[data-v-34ac73ac]{font-size:12px;font-weight:500;color:var(--SmartThemeBodyColor)}.editor-stats[data-v-34ac73ac]{display:flex;gap:16px}.stat-item[data-v-34ac73ac]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.result-message[data-v-34ac73ac]{padding:10px 16px;font-size:12px;border-top:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.result-message.error[data-v-34ac73ac]{background:color-mix(in srgb,#e74c3c 20%,transparent);color:#e74c3c}@media(max-width:768px){.sql-panel-tab[data-v-34ac73ac]{gap:12px}.sql-editor[data-v-34ac73ac]{font-size:12px;min-height:150px;height:100%}.sql-footer[data-v-34ac73ac]{gap:8px}}.data-form-wrapper[data-v-a92ff958]{--form-modal-width: 50vw;--form-modal-height: auto}.data-form[data-v-a92ff958]{display:flex;flex-direction:column;gap:24px;max-height:65vh}.form-content[data-v-a92ff958]{display:flex;flex-direction:column;gap:20px;overflow-y:auto;padding:8px 4px}.form-item[data-v-a92ff958]{display:flex;flex-direction:column;gap:8px}.form-label[data-v-a92ff958]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor);letter-spacing:.3px}.required-mark[data-v-a92ff958]{color:#ef4444;margin-left:4px;font-size:14px}.form-input[data-v-a92ff958]{padding:12px 16px;border:1.5px solid var(--SmartThemeBorderColor);border-radius:8px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeBodyColor);font-size:14px;transition:all .25s cubic-bezier(.4,0,.2,1);font-family:inherit}.form-input[data-v-a92ff958]:hover{border-color:color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent)}.form-input[data-v-a92ff958]:focus{outline:none;border-color:var(--SmartThemeEmColor);box-shadow:0 0 0 3px color-mix(in srgb,var(--SmartThemeEmColor) 20%,transparent);background:var(--SmartThemeBlurTintColor)}.form-input[data-v-a92ff958]::placeholder{color:color-mix(in srgb,var(--SmartThemeBodyColor) 40%,transparent);font-size:13px}.form-input[data-v-a92ff958]:disabled{opacity:.6;cursor:not-allowed}.form-hint[data-v-a92ff958]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 45%,transparent);margin-top:-4px;line-height:1.5;padding-left:2px}.loading-container[data-v-a92ff958]{display:flex;align-items:center;justify-content:center;min-height:300px}.loading-spinner[data-v-a92ff958]{width:40px;height:40px;border:4px solid color-mix(in srgb,var(--SmartThemeBorderColor) 50%,transparent);border-top:4px solid var(--SmartThemeEmColor);border-radius:50%;animation:spin-a92ff958 .8s linear infinite}@keyframes spin-a92ff958{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.form-actions[data-v-a92ff958]{display:flex;gap:12px;justify-content:flex-end;padding:20px 0 8px;border-top:1.5px solid var(--SmartThemeBorderColor);margin-top:4px}.form-actions>button[data-v-a92ff958]{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:500;transition:all .2s cubic-bezier(.4,0,.2,1)}@media(max-width:768px){.data-form-wrapper[data-v-a92ff958]{--form-modal-width: 100%}.data-form[data-v-a92ff958]{gap:20px;max-height:70vh}.form-content[data-v-a92ff958]{gap:16px;padding:4px}.form-item[data-v-a92ff958]{gap:8px}.form-label[data-v-a92ff958]{font-size:15px}.form-input[data-v-a92ff958]{padding:14px 16px;font-size:16px;border-radius:10px}.form-input[data-v-a92ff958]::placeholder{font-size:15px}.form-hint[data-v-a92ff958]{font-size:13px}.form-actions[data-v-a92ff958]{flex-direction:column-reverse;gap:10px;padding:16px 0 4px}.form-actions>button[data-v-a92ff958]{width:100%;padding:14px 20px;font-size:15px;border-radius:10px}}.delete-data-confirm-wrapper[data-v-b672c047]{--confirm-modal-width: 500px;--confirm-modal-height: auto}.confirm-container[data-v-b672c047]{padding:20px}.confirm-content[data-v-b672c047]{display:flex;flex-direction:column;align-items:center;gap:16px;padding:20px 0}.warning-icon[data-v-b672c047]{font-size:48px;color:#f59e0b}.confirm-message[data-v-b672c047]{font-size:14px;color:var(--SmartThemeBodyColor);text-align:center;line-height:1.6;margin:0}.form-actions[data-v-b672c047]{display:flex;gap:12px;justify-content:center}@media(max-width:768px){.delete-data-confirm-wrapper[data-v-b672c047]{--confirm-modal-width: 90vw}.confirm-container[data-v-b672c047]{padding:16px}.form-actions[data-v-b672c047]{flex-direction:column-reverse}.form-actions>button[data-v-b672c047]{width:100%}}.export-container[data-v-affef56e]{padding:20px}.export-header[data-v-affef56e]{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}.export-title[data-v-affef56e]{font-size:14px;font-weight:600;color:var(--SmartThemeBodyColor)}.copy-btn[data-v-affef56e]{display:flex;align-items:center;gap:6px;padding:6px 12px;border:1px solid var(--SmartThemeBorderColor);border-radius:4px;background:var(--SmartThemeBlurTintColor);color:var(--SmartThemeEmColor);font-size:13px;cursor:pointer;transition:all .2s}.copy-btn[data-v-affef56e]:hover{background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent);color:var(--SmartThemeBodyColor)}.copy-btn i[data-v-affef56e]{font-size:12px}.export-content[data-v-affef56e]{background:var(--SmartThemeBlurTintColor);border:1px solid var(--SmartThemeBorderColor);border-radius:6px;padding:16px;margin-bottom:20px;max-height:400px;overflow:auto}.export-code[data-v-affef56e]{margin:0;font-family:Monaco,Menlo,Ubuntu Mono,monospace;font-size:13px;line-height:1.6;color:var(--SmartThemeBodyColor);white-space:pre-wrap;word-wrap:break-word}.form-actions[data-v-affef56e]{display:flex;gap:12px;justify-content:flex-end}@media(max-width:768px){.export-container[data-v-affef56e]{padding:16px}.export-content[data-v-affef56e]{padding:12px;max-height:300px}.export-code[data-v-affef56e]{font-size:12px}.form-actions[data-v-affef56e]>*{width:100%}}.chat-data-management-tab[data-v-c1523f72]{display:flex;flex-direction:column;height:100%;overflow:hidden}.data-detail[data-v-c1523f72]{flex:1;display:flex;flex-direction:column;overflow:hidden}.data-toolbar[data-v-c1523f72]{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--SmartThemeBorderColor);background:color-mix(in srgb,var(--SmartThemeBorderColor) 30%,transparent)}.data-title[data-v-c1523f72]{display:flex;flex-direction:column;gap:4px}.table-name[data-v-c1523f72]{font-size:15px;font-weight:600;color:var(--SmartThemeBodyColor)}.table-comment[data-v-c1523f72]{font-size:12px;color:color-mix(in srgb,var(--SmartThemeBodyColor) 50%,transparent)}.data-actions[data-v-c1523f72]{display:flex;gap:8px}.data-list[data-v-c1523f72]{flex:1;overflow:hidden;display:flex;flex-direction:column}.table-container[data-v-c1523f72]{flex:1;overflow:auto}.data-table[data-v-c1523f72]{width:100%;border-collapse:collapse;font-size:13px}thead[data-v-c1523f72]{position:sticky;top:0;z-index:30;background:var(--SmartThemeBlurTintColor)}thead th[data-v-c1523f72]{padding:12px 16px;border-bottom:2px solid var(--SmartThemeBorderColor);font-weight:600;color:var(--SmartThemeBodyColor);white-space:nowrap;background:var(--SmartThemeBlurTintColor)}tbody th[data-v-c1523f72]{text-align:left;padding:12px 16px;font-weight:600;color:var(--SmartThemeBodyColor);white-space:nowrap}.checkbox-header[data-v-c1523f72]{width:50px;text-align:center;padding:12px 8px}.column-header[data-v-c1523f72]{min-width:120px}.actions-header[data-v-c1523f72]{width:100px;text-align:center;padding:12px 8px}.sticky-col[data-v-c1523f72]{position:sticky;background:var(--SmartThemeBlurTintColor);z-index:20;left:0}thead th.sticky-col[data-v-c1523f72]{z-index:32;left:0}.primary-key[data-v-c1523f72]{background:color-mix(in srgb,rgba(218,165,32,.15) 50%,var(--SmartThemeBlurTintColor));border-right:2px solid color-mix(in srgb,rgba(218,165,32,.3) 50%,var(--SmartThemeBorderColor))}thead th.primary-key[data-v-c1523f72]{background:color-mix(in srgb,rgba(218,165,32,.2) 50%,var(--SmartThemeBlurTintColor))}thead th.actions-header.sticky-col[data-v-c1523f72]{z-index:31}thead th.checkbox-header.sticky-col[data-v-c1523f72]{z-index:32}.table-row[data-v-c1523f72]{border-bottom:1px solid var(--SmartThemeBorderColor);transition:background-color .2s}.table-row[data-v-c1523f72]:hover{background-color:color-mix(in srgb,var(--SmartThemeBorderColor) 20%,transparent)}.table-row[data-v-c1523f72]:last-child{border-bottom:none}.table-cell[data-v-c1523f72]{padding:10px 16px;border-right:1px solid var(--SmartThemeBorderColor);max-width:300px;min-width:120px;background:var(--SmartThemeBlurTintColor);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.table-cell[data-v-c1523f72]:last-child{border-right:none}.table-cell.primary-key[data-v-c1523f72]{background:color-mix(in srgb,rgba(59,130,246,.1) 50%,var(--SmartThemeBlurTintColor));border-right:2px solid color-mix(in srgb,rgba(59,130,246,.3) 50%,var(--SmartThemeBorderColor))}.cell-value[data-v-c1523f72]{color:var(--SmartThemeBodyColor);text-align:center;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;line-height:1.5}.checkbox-cell[data-v-c1523f72]{width:50px;text-align:center;padding:10px 8px;border-right:1px solid var(--SmartThemeBorderColor)}.actions-cell[data-v-c1523f72]{width:100px;padding:10px 8px;text-align:center;border-right:1px solid var(--SmartThemeBorderColor)}.actions-cell.sticky-col[data-v-c1523f72]{box-shadow:3px 0 10px -3px #00000040}.checkbox-cell.sticky-col[data-v-c1523f72]{box-shadow:2px 0 10px -3px #00000026}.checkbox-wrapper[data-v-c1523f72]{display:flex;align-items:center;justify-content:center;cursor:pointer}.checkbox-wrapper input[type=checkbox][data-v-c1523f72]{width:16px;height:16px;cursor:pointer}.row-actions[data-v-c1523f72]{display:flex;gap:4px;justify-content:center}@media(max-width:768px){.data-toolbar[data-v-c1523f72]{flex-direction:column;align-items:stretch;gap:12px;padding:12px}.data-title[data-v-c1523f72]{align-items:flex-start}.data-actions[data-v-c1523f72]{width:100%}.data-actions>button[data-v-c1523f72]{flex:1}thead th[data-v-c1523f72],.table-cell[data-v-c1523f72]{padding:8px 10px}.column-header[data-v-c1523f72]{min-width:80px}.table-cell[data-v-c1523f72]{max-width:150px;min-width:80px}.actions-header[data-v-c1523f72],.actions-cell[data-v-c1523f72]{width:70px}}.translation_settings[data-v-d18c04a2],.inline-drawer[data-v-d18c04a2]{width:100%}.inline-drawer-toggle[data-v-d18c04a2]{cursor:pointer}.inline-drawer-icon[data-v-d18c04a2]{transition:transform .2s}.inline-drawer-icon.down[data-v-d18c04a2]{transform:rotate(0)}.inline-drawer-icon.up[data-v-d18c04a2]{transform:rotate(180deg)}')),document.head.appendChild(a)}}catch(r){console.error("vite-plugin-css-injected-by-js",r)}})();
var Vr = {};
// @__NO_SIDE_EFFECTS__
function Yt(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const s of t.split(",")) e[s] = 1;
  return (s) => s in e;
}
const ye = Vr.NODE_ENV !== "production" ? Object.freeze({}) : {}, Ss = Vr.NODE_ENV !== "production" ? Object.freeze([]) : [], qe = () => {
}, Mr = () => !1, an = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter
(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), In = (t) => t.startsWith("onUpdate:"), Ve = Object.assign, Hi = (t, e) => {
  const s = t.indexOf(e);
  s > -1 && t.splice(s, 1);
}, fl = Object.prototype.hasOwnProperty, Ee = (t, e) => fl.call(t, e), z = Array.isArray, ps = (t) => ln(t) === "[object Map]", Ms = (t) => ln(t) === "[object Set]", So = (t) => ln(t) === "[object Date]", Z = (t) => typeof t == "function", Me = (t) => typeof t == "string", vt = (t) => typeof t == "symbol", ve = (t) => t !== null && typeof t == "object", Wi = (t) => (ve(t) || Z(t)) && Z(t.then) && Z(t.catch), Ir = Object.prototype.toString, ln = (t) => Ir.call(t), Ki = (t) => ln(t).slice(8, -1), Rr = (t) => ln(t) === "[object Object]", zi = (t) => Me(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Ws = /* @__PURE__ */ Yt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), pl = /* @__PURE__ */ Yt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), Yn = (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  return ((s) => e[s] || (e[s] = t(s)));
}, hl = /-\w/g, ut = Yn(
  (t) => t.replace(hl, (e) => e.slice(1).toUpperCase())
), ml = /\B([A-Z])/g, Gt = Yn(
  (t) => t.replace(ml, "-$1").toLowerCase()
), Qn = Yn((t) => t.charAt(0).toUpperCase() + t.slice(1)), cs = Yn(
  (t) => t ? `on${Qn(t)}` : ""
), st = (t, e) => !Object.is(t, e), Ns = (t, ...e) => {
  for (let s = 0; s < t.length; s++)
    t[s](...e);
}, Rn = (t, e, s, n = !1) => {
  Object.defineProperty(t, e, {
    configurable: !0,
    enumerable: !1,
    writable: n,
    value: s
  });
}, Jn = (t) => {
  const e = parseFloat(t);
  return isNaN(e) ? t : e;
}, vl = (t) => {
  const e = Me(t) ? Number(t) : NaN;
  return isNaN(e) ? t : e;
};
let Co;
const cn = () => Co || (Co = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {});
function Ke(t) {
  if (z(t)) {
    const e = {};
    for (let s = 0; s < t.length; s++) {
      const n = t[s], i = Me(n) ? yl(n) : Ke(n);
      if (i)
        for (const o in i)
          e[o] = i[o];
    }
    return e;
  } else if (Me(t) || ve(t))
    return t;
}
const bl = /;(?![^(]*\))/g, gl = /:([^]+)/, El = /\/\*[^]*?\*\//g;
function yl(t) {
  const e = {};
  return t.replace(El, "").split(bl).forEach((s) => {
    if (s) {
      const n = s.split(gl);
      n.length > 1 && (e[n[0].trim()] = n[1].trim());
    }
  }), e;
}
function Re(t) {
  let e = "";
  if (Me(t))
    e = t;
  else if (z(t))
    for (let s = 0; s < t.length; s++) {
      const n = Re(t[s]);
      n && (e += n + " ");
    }
  else if (ve(t))
    for (const s in t)
      t[s] && (e += s + " ");
  return e.trim();
}
const _l = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Tl = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", Nl = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", xl = /* @__PURE__ */ Yt(_l), Sl = /* @__PURE__ */ Yt(Tl), Cl = /* @__PURE__ */ Yt(Nl), wl = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Dl = /* @__PURE__ */ Yt(wl);
function Lr(t) {
  return !!t || t === "";
}
function Ol(t, e) {
  if (t.length !== e.length) return !1;
  let s = !0;
  for (let n = 0; s && n < t.length; n++)
    s = Is(t[n], e[n]);
  return s;
}
function Is(t, e) {
  if (t === e) return !0;
  let s = So(t), n = So(e);
  if (s || n)
    return s && n ? t.getTime() === e.getTime() : !1;
  if (s = vt(t), n = vt(e), s || n)
    return t === e;
  if (s = z(t), n = z(e), s || n)
    return s && n ? Ol(t, e) : !1;
  if (s = ve(t), n = ve(e), s || n) {
    if (!s || !n)
      return !1;
    const i = Object.keys(t).length, o = Object.keys(e).length;
    if (i !== o)
      return !1;
    for (const r in t) {
      const a = t.hasOwnProperty(r), l = e.hasOwnProperty(r);
      if (a && !l || !a && l || !Is(t[r], e[r]))
        return !1;
    }
  }
  return String(t) === String(e);
}
function Gi(t, e) {
  return t.findIndex((s) => Is(s, e));
}
const kr = (t) => !!(t && t.__v_isRef === !0), de = (t) => Me(t) ? t : t == null ? "" : z(t) || ve(t) && (t.toString === Ir || !Z(t.toString)) ? kr(t) ? de(t.value) : JSON.stringify(t, Pr, 2) : String(t), Pr = (t, e) => kr(e) ? Pr(t, e.value) : ps(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (s, [n, i], o) => (s[fi(n, o) + " =>"] = i, s),
    {}
  )
} : Ms(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((s) => fi(s))
} : vt(e) ? fi(e) : ve(e) && !z(e) && !Rr(e) ? String(e) : e, fi = (t, e = "") => {
  var s;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    vt(t) ? `Symbol(${(s = t.description) != null ? s : e})` : t
  );
};
var Ce = {};
function bt(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
let tt;
class $l {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.__v_skip = !0, this.parent = tt, !e && tt && (this.index = (tt.scopes || (tt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, s;
      if (this.scopes)
        for (e = 0, s = this.scopes.length; e < s; e++)
          this.scopes[e].pause();
      for (e = 0, s = this.effects.length; e < s; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, s;
      if (this.scopes)
        for (e = 0, s = this.scopes.length; e < s; e++)
          this.scopes[e].resume();
      for (e = 0, s = this.effects.length; e < s; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const s = tt;
      try {
        return tt = this, e();
      } finally {
        tt = s;
      }
    } else Ce.NODE_ENV !== "production" && bt("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = tt, tt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (tt = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let s, n;
      for (s = 0, n = this.effects.length; s < n; s++)
        this.effects[s].stop();
      for (this.effects.length = 0, s = 0, n = this.cleanups.length; s < n; s++)
        this.cleanups[s]();
      if (this.cleanups.length = 0, this.scopes) {
        for (s = 0, n = this.scopes.length; s < n; s++)
          this.scopes[s].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Al() {
  return tt;
}
let Ne;
const pi = /* @__PURE__ */ new WeakSet();
class Br {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, tt && tt.active && tt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, pi.has(this) && (pi.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Ur(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, wo(this), jr(this);
    const e = Ne, s = ht;
    Ne = this, ht = !0;
    try {
      return this.fn();
    } finally {
      Ce.NODE_ENV !== "production" && Ne !== this && bt(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), qr(this), Ne = e, ht = s, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        Ji(e);
      this.deps = this.depsTail = void 0, wo(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? pi.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    xi(this) && this.run();
  }
  get dirty() {
    return xi(this);
  }
}
let Fr = 0, Ks, zs;
function Ur(t, e = !1) {
  if (t.flags |= 8, e) {
    t.next = zs, zs = t;
    return;
  }
  t.next = Ks, Ks = t;
}
function Yi() {
  Fr++;
}
function Qi() {
  if (--Fr > 0)
    return;
  if (zs) {
    let e = zs;
    for (zs = void 0; e; ) {
      const s = e.next;
      e.next = void 0, e.flags &= -9, e = s;
    }
  }
  let t;
  for (; Ks; ) {
    let e = Ks;
    for (Ks = void 0; e; ) {
      const s = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (n) {
          t || (t = n);
        }
      e = s;
    }
  }
  if (t) throw t;
}
function jr(t) {
  for (let e = t.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function qr(t) {
  let e, s = t.depsTail, n = s;
  for (; n; ) {
    const i = n.prevDep;
    n.version === -1 ? (n === s && (s = i), Ji(n), Vl(n)) : e = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = i;
  }
  t.deps = e, t.depsTail = s;
}
function xi(t) {
  for (let e = t.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (Hr(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!t._dirty;
}
function Hr(t) {
  if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17, t.globalVersion === Xs) || (t.globalVersion = Xs, !t.isSSR && t.flags & 128 && (!t.deps && !t._dirty || !xi(t))))
    return;
  t.flags |= 2;
  const e = t.dep, s = Ne, n = ht;
  Ne = t, ht = !0;
  try {
    jr(t);
    const i = t.fn(t._value);
    (e.version === 0 || st(i, t._value)) && (t.flags |= 128, t._value = i, e.version++);
  } catch (i) {
    throw e.version++, i;
  } finally {
    Ne = s, ht = n, qr(t), t.flags &= -3;
  }
}
function Ji(t, e = !1) {
  const { dep: s, prevSub: n, nextSub: i } = t;
  if (n && (n.nextSub = i, t.prevSub = void 0), i && (i.prevSub = n, t.nextSub = void 0), Ce.NODE_ENV !== "production" && s.subsHead === t && (s.subsHead = i), s.subs === t && (s.subs = n, !n && s.computed)) {
    s.computed.flags &= -5;
    for (let o = s.computed.deps; o; o = o.nextDep)
      Ji(o, !0);
  }
  !e && !--s.sc && s.map && s.map.delete(s.key);
}
function Vl(t) {
  const { prevDep: e, nextDep: s } = t;
  e && (e.nextDep = s, t.prevDep = void 0), s && (s.prevDep = e, t.nextDep = void 0);
}
let ht = !0;
const Wr = [];
function gt() {
  Wr.push(ht), ht = !1;
}
function Et() {
  const t = Wr.pop();
  ht = t === void 0 ? !0 : t;
}
function wo(t) {
  const { cleanup: e } = t;
  if (t.cleanup = void 0, e) {
    const s = Ne;
    Ne = void 0;
    try {
      e();
    } finally {
      Ne = s;
    }
  }
}
let Xs = 0;
class Ml {
  constructor(e, s) {
    this.sub = e, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Xn {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0, Ce.NODE_ENV !== "production" && (this.subsHead = void 0);
  }
  track(e) {
    if (!Ne || !ht || Ne === this.computed)
      return;
    let s = this.activeLink;
    if (s === void 0 || s.sub !== Ne)
      s = this.activeLink = new Ml(Ne, this), Ne.deps ? (s.prevDep = Ne.depsTail, Ne.depsTail.nextDep = s, Ne.depsTail = s) : Ne.deps = Ne.depsTail = s, Kr(s);
    else if (s.version === -1 && (s.version = this.version, s.nextDep)) {
      const n = s.nextDep;
      n.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = n), s.prevDep = Ne.depsTail, s.nextDep = void 0, Ne.depsTail.nextDep = s, Ne.depsTail = s, Ne.deps === s && (Ne.deps = n);
    }
    return Ce.NODE_ENV !== "production" && Ne.onTrack && Ne.onTrack(
      Ve(
        {
          effect: Ne
        },
        e
      )
    ), s;
  }
  trigger(e) {
    this.version++, Xs++, this.notify(e);
  }
  notify(e) {
    Yi();
    try {
      if (Ce.NODE_ENV !== "production")
        for (let s = this.subsHead; s; s = s.nextSub)
          s.sub.onTrigger && !(s.sub.flags & 8) && s.sub.onTrigger(
            Ve(
              {
                effect: s.sub
              },
              e
            )
          );
      for (let s = this.subs; s; s = s.prevSub)
        s.sub.notify() && s.sub.dep.notify();
    } finally {
      Qi();
    }
  }
}
function Kr(t) {
  if (t.dep.sc++, t.sub.flags & 4) {
    const e = t.dep.computed;
    if (e && !t.dep.subs) {
      e.flags |= 20;
      for (let n = e.deps; n; n = n.nextDep)
        Kr(n);
    }
    const s = t.dep.subs;
    s !== t && (t.prevSub = s, s && (s.nextSub = t)), Ce.NODE_ENV !== "production" && t.dep.subsHead === void 0 && (t.dep.subsHead = t), t.dep.subs = t;
  }
}
const Si = /* @__PURE__ */ new WeakMap(), hs = /* @__PURE__ */ Symbol(
  Ce.NODE_ENV !== "production" ? "Object iterate" : ""
), Ci = /* @__PURE__ */ Symbol(
  Ce.NODE_ENV !== "production" ? "Map keys iterate" : ""
), Zs = /* @__PURE__ */ Symbol(
  Ce.NODE_ENV !== "production" ? "Array iterate" : ""
);
function je(t, e, s) {
  if (ht && Ne) {
    let n = Si.get(t);
    n || Si.set(t, n = /* @__PURE__ */ new Map());
    let i = n.get(s);
    i || (n.set(s, i = new Xn()), i.map = n, i.key = s), Ce.NODE_ENV !== "production" ? i.track({
      target: t,
      type: e,
      key: s
    }) : i.track();
  }
}
function $t(t, e, s, n, i, o) {
  const r = Si.get(t);
  if (!r) {
    Xs++;
    return;
  }
  const a = (l) => {
    l && (Ce.NODE_ENV !== "production" ? l.trigger({
      target: t,
      type: e,
      key: s,
      newValue: n,
      oldValue: i,
      oldTarget: o
    }) : l.trigger());
  };
  if (Yi(), e === "clear")
    r.forEach(a);
  else {
    const l = z(t), u = l && zi(s);
    if (l && s === "length") {
      const c = Number(n);
      r.forEach((d, m) => {
        (m === "length" || m === Zs || !vt(m) && m >= c) && a(d);
      });
    } else
      switch ((s !== void 0 || r.has(void 0)) && a(r.get(s)), u && a(r.get(Zs)), e) {
        case "add":
          l ? u && a(r.get("length")) : (a(r.get(hs)), ps(t) && a(r.get(Ci)));
          break;
        case "delete":
          l || (a(r.get(hs)), ps(t) && a(r.get(Ci)));
          break;
        case "set":
          ps(t) && a(r.get(hs));
          break;
      }
  }
  Qi();
}
function ys(t) {
  const e = /* @__PURE__ */ ue(t);
  return e === t ? e : (je(e, "iterate", Zs), /* @__PURE__ */ Xe(t) ? e : e.map(_t));
}
function Zn(t) {
  return je(t = /* @__PURE__ */ ue(t), "iterate", Zs), t;
}
function Zt(t, e) {
  return /* @__PURE__ */ yt(t) ? $s(/* @__PURE__ */ ns(t) ? _t(e) : e) : _t(e);
}
const Il = {
  __proto__: null,
  [Symbol.iterator]() {
    return hi(this, Symbol.iterator, (t) => Zt(this, t));
  },
  concat(...t) {
    return ys(this).concat(
      ...t.map((e) => z(e) ? ys(e) : e)
    );
  },
  entries() {
    return hi(this, "entries", (t) => (t[1] = Zt(this, t[1]), t));
  },
  every(t, e) {
    return Bt(this, "every", t, e, void 0, arguments);
  },
  filter(t, e) {
    return Bt(
      this,
      "filter",
      t,
      e,
      (s) => s.map((n) => Zt(this, n)),
      arguments
    );
  },
  find(t, e) {
    return Bt(
      this,
      "find",
      t,
      e,
      (s) => Zt(this, s),
      arguments
    );
  },
  findIndex(t, e) {
    return Bt(this, "findIndex", t, e, void 0, arguments);
  },
  findLast(t, e) {
    return Bt(
      this,
      "findLast",
      t,
      e,
      (s) => Zt(this, s),
      arguments
    );
  },
  findLastIndex(t, e) {
    return Bt(this, "findLastIndex", t, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(t, e) {
    return Bt(this, "forEach", t, e, void 0, arguments);
  },
  includes(...t) {
    return mi(this, "includes", t);
  },
  indexOf(...t) {
    return mi(this, "indexOf", t);
  },
  join(t) {
    return ys(this).join(t);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...t) {
    return mi(this, "lastIndexOf", t);
  },
  map(t, e) {
    return Bt(this, "map", t, e, void 0, arguments);
  },
  pop() {
    return Bs(this, "pop");
  },
  push(...t) {
    return Bs(this, "push", t);
  },
  reduce(t, ...e) {
    return Do(this, "reduce", t, e);
  },
  reduceRight(t, ...e) {
    return Do(this, "reduceRight", t, e);
  },
  shift() {
    return Bs(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(t, e) {
    return Bt(this, "some", t, e, void 0, arguments);
  },
  splice(...t) {
    return Bs(this, "splice", t);
  },
  toReversed() {
    return ys(this).toReversed();
  },
  toSorted(t) {
    return ys(this).toSorted(t);
  },
  toSpliced(...t) {
    return ys(this).toSpliced(...t);
  },
  unshift(...t) {
    return Bs(this, "unshift", t);
  },
  values() {
    return hi(this, "values", (t) => Zt(this, t));
  }
};
function hi(t, e, s) {
  const n = Zn(t), i = n[e]();
  return n !== t && !/* @__PURE__ */ Xe(t) && (i._next = i.next, i.next = () => {
    const o = i._next();
    return o.done || (o.value = s(o.value)), o;
  }), i;
}
const Rl = Array.prototype;
function Bt(t, e, s, n, i, o) {
  const r = Zn(t), a = r !== t && !/* @__PURE__ */ Xe(t), l = r[e];
  if (l !== Rl[e]) {
    const d = l.apply(t, o);
    return a ? _t(d) : d;
  }
  let u = s;
  r !== t && (a ? u = function(d, m) {
    return s.call(this, Zt(t, d), m, t);
  } : s.length > 2 && (u = function(d, m) {
    return s.call(this, d, m, t);
  }));
  const c = l.call(r, u, n);
  return a && i ? i(c) : c;
}
function Do(t, e, s, n) {
  const i = Zn(t);
  let o = s;
  return i !== t && (/* @__PURE__ */ Xe(t) ? s.length > 3 && (o = function(r, a, l) {
    return s.call(this, r, a, l, t);
  }) : o = function(r, a, l) {
    return s.call(this, r, Zt(t, a), l, t);
  }), i[e](o, ...n);
}
function mi(t, e, s) {
  const n = /* @__PURE__ */ ue(t);
  je(n, "iterate", Zs);
  const i = n[e](...s);
  return (i === -1 || i === !1) && /* @__PURE__ */ Ln(s[0]) ? (s[0] = /* @__PURE__ */ ue(s[0]), n[e](...s)) : i;
}
function Bs(t, e, s = []) {
  gt(), Yi();
  const n = (/* @__PURE__ */ ue(t))[e].apply(t, s);
  return Qi(), Et(), n;
}
const Ll = /* @__PURE__ */ Yt("__proto__,__v_isRef,__isVue"), zr = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(vt)
);
function kl(t) {
  vt(t) || (t = String(t));
  const e = /* @__PURE__ */ ue(this);
  return je(e, "has", t), e.hasOwnProperty(t);
}
class Gr {
  constructor(e = !1, s = !1) {
    this._isReadonly = e, this._isShallow = s;
  }
  get(e, s, n) {
    if (s === "__v_skip") return e.__v_skip;
    const i = this._isReadonly, o = this._isShallow;
    if (s === "__v_isReactive")
      return !i;
    if (s === "__v_isReadonly")
      return i;
    if (s === "__v_isShallow")
      return o;
    if (s === "__v_raw")
      return n === (i ? o ? ea : Zr : o ? Xr : Jr).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
    const r = z(e);
    if (!i) {
      let l;
      if (r && (l = Il[s]))
        return l;
      if (s === "hasOwnProperty")
        return kl;
    }
    const a = Reflect.get(
      e,
      s,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      /* @__PURE__ */ Fe(e) ? e : n
    );
    if ((vt(s) ? zr.has(s) : Ll(s)) || (i || je(e, "get", s), o))
      return a;
    if (/* @__PURE__ */ Fe(a)) {
      const l = r && zi(s) ? a : a.value;
      return i && ve(l) ? /* @__PURE__ */ Di(l) : l;
    }
    return ve(a) ? i ? /* @__PURE__ */ Di(a) : /* @__PURE__ */ is(a) : a;
  }
}
class Yr extends Gr {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, s, n, i) {
    let o = e[s];
    const r = z(e) && zi(s);
    if (!this._isShallow) {
      const u = /* @__PURE__ */ yt(o);
      if (!/* @__PURE__ */ Xe(n) && !/* @__PURE__ */ yt(n) && (o = /* @__PURE__ */ ue(o), n = /* @__PURE__ */ ue(n)), !r && /* @__PURE__ */ Fe(o) && !/* @__PURE__ */ Fe(n))
        return u ? (Ce.NODE_ENV !== "production" && bt(
          `Set operation on key "${String(s)}" failed: target is readonly.`,
          e[s]
        ), !0) : (o.value = n, !0);
    }
    const a = r ? Number(s) < e.length : Ee(e, s), l = Reflect.set(
      e,
      s,
      n,
      /* @__PURE__ */ Fe(e) ? e : i
    );
    return e === /* @__PURE__ */ ue(i) && (a ? st(n, o) && $t(e, "set", s, n, o) : $t(e, "add", s, n)), l;
  }
  deleteProperty(e, s) {
    const n = Ee(e, s), i = e[s], o = Reflect.deleteProperty(e, s);
    return o && n && $t(e, "delete", s, void 0, i), o;
  }
  has(e, s) {
    const n = Reflect.has(e, s);
    return (!vt(s) || !zr.has(s)) && je(e, "has", s), n;
  }
  ownKeys(e) {
    return je(
      e,
      "iterate",
      z(e) ? "length" : hs
    ), Reflect.ownKeys(e);
  }
}
class Qr extends Gr {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, s) {
    return Ce.NODE_ENV !== "production" && bt(
      `Set operation on key "${String(s)}" failed: target is readonly.`,
      e
    ), !0;
  }
  deleteProperty(e, s) {
    return Ce.NODE_ENV !== "production" && bt(
      `Delete operation on key "${String(s)}" failed: target is readonly.`,
      e
    ), !0;
  }
}
const Pl = /* @__PURE__ */ new Yr(), Bl = /* @__PURE__ */ new Qr(), Fl = /* @__PURE__ */ new Yr(!0), Ul = /* @__PURE__ */ new Qr(!0), wi = (t) => t, En = (t) => Reflect.getPrototypeOf(t);
function jl(t, e, s) {
  return function(...n) {
    const i = this.__v_raw, o = /* @__PURE__ */ ue(i), r = ps(o), a = t === "entries" || t === Symbol.iterator && r, l = t === "keys" && r, u = i[t](...n), c = s ? wi : e ? $s : _t;
    return !e && je(
      o,
      "iterate",
      l ? Ci : hs
    ), Ve(
      // inheriting all iterator properties
      Object.create(u),
      {
        // iterator protocol
        next() {
          const { value: d, done: m } = u.next();
          return m ? { value: d, done: m } : {
            value: a ? [c(d[0]), c(d[1])] : c(d),
            done: m
          };
        }
      }
    );
  };
}
function yn(t) {
  return function(...e) {
    if (Ce.NODE_ENV !== "production") {
      const s = e[0] ? `on key "${e[0]}" ` : "";
      bt(
        `${Qn(t)} operation ${s}failed: target is readonly.`,
        /* @__PURE__ */ ue(this)
      );
    }
    return t === "delete" ? !1 : t === "clear" ? void 0 : this;
  };
}
function ql(t, e) {
  const s = {
    get(i) {
      const o = this.__v_raw, r = /* @__PURE__ */ ue(o), a = /* @__PURE__ */ ue(i);
      t || (st(i, a) && je(r, "get", i), je(r, "get", a));
      const { has: l } = En(r), u = e ? wi : t ? $s : _t;
      if (l.call(r, i))
        return u(o.get(i));
      if (l.call(r, a))
        return u(o.get(a));
      o !== r && o.get(i);
    },
    get size() {
      const i = this.__v_raw;
      return !t && je(/* @__PURE__ */ ue(i), "iterate", hs), i.size;
    },
    has(i) {
      const o = this.__v_raw, r = /* @__PURE__ */ ue(o), a = /* @__PURE__ */ ue(i);
      return t || (st(i, a) && je(r, "has", i), je(r, "has", a)), i === a ? o.has(i) : o.has(i) || o.has(a);
    },
    forEach(i, o) {
      const r = this, a = r.__v_raw, l = /* @__PURE__ */ ue(a), u = e ? wi : t ? $s : _t;
      return !t && je(l, "iterate", hs), a.forEach((c, d) => i.call(o, u(c), u(d), r));
    }
  };
  return Ve(
    s,
    t ? {
      add: yn("add"),
      set: yn("set"),
      delete: yn("delete"),
      clear: yn("clear")
    } : {
      add(i) {
        !e && !/* @__PURE__ */ Xe(i) && !/* @__PURE__ */ yt(i) && (i = /* @__PURE__ */ ue(i));
        const o = /* @__PURE__ */ ue(this);
        return En(o).has.call(o, i) || (o.add(i), $t(o, "add", i, i)), this;
      },
      set(i, o) {
        !e && !/* @__PURE__ */ Xe(o) && !/* @__PURE__ */ yt(o) && (o = /* @__PURE__ */ ue(o));
        const r = /* @__PURE__ */ ue(this), { has: a, get: l } = En(r);
        let u = a.call(r, i);
        u ? Ce.NODE_ENV !== "production" && Oo(r, a, i) : (i = /* @__PURE__ */ ue(i), u = a.call(r, i));
        const c = l.call(r, i);
        return r.set(i, o), u ? st(o, c) && $t(r, "set", i, o, c) : $t(r, "add", i, o), this;
      },
      delete(i) {
        const o = /* @__PURE__ */ ue(this), { has: r, get: a } = En(o);
        let l = r.call(o, i);
        l ? Ce.NODE_ENV !== "production" && Oo(o, r, i) : (i = /* @__PURE__ */ ue(i), l = r.call(o, i));
        const u = a ? a.call(o, i) : void 0, c = o.delete(i);
        return l && $t(o, "delete", i, void 0, u), c;
      },
      clear() {
        const i = /* @__PURE__ */ ue(this), o = i.size !== 0, r = Ce.NODE_ENV !== "production" ? ps(i) ? new Map(i) : new Set(i) : void 0, a = i.clear();
        return o && $t(
          i,
          "clear",
          void 0,
          void 0,
          r
        ), a;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((i) => {
    s[i] = jl(i, t, e);
  }), s;
}
function ei(t, e) {
  const s = ql(t, e);
  return (n, i, o) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? n : Reflect.get(
    Ee(s, i) && i in n ? s : n,
    i,
    o
  );
}
const Hl = {
  get: /* @__PURE__ */ ei(!1, !1)
}, Wl = {
  get: /* @__PURE__ */ ei(!1, !0)
}, Kl = {
  get: /* @__PURE__ */ ei(!0, !1)
}, zl = {
  get: /* @__PURE__ */ ei(!0, !0)
};
function Oo(t, e, s) {
  const n = /* @__PURE__ */ ue(s);
  if (n !== s && e.call(t, n)) {
    const i = Ki(t);
    bt(
      `Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const Jr = /* @__PURE__ */ new WeakMap(), Xr = /* @__PURE__ */ new WeakMap(), Zr = /* @__PURE__ */ new WeakMap(), ea = /* @__PURE__ */ new WeakMap();
function Gl(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Yl(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : Gl(Ki(t));
}
// @__NO_SIDE_EFFECTS__
function is(t) {
  return /* @__PURE__ */ yt(t) ? t : ti(
    t,
    !1,
    Pl,
    Hl,
    Jr
  );
}
// @__NO_SIDE_EFFECTS__
function Ql(t) {
  return ti(
    t,
    !1,
    Fl,
    Wl,
    Xr
  );
}
// @__NO_SIDE_EFFECTS__
function Di(t) {
  return ti(
    t,
    !0,
    Bl,
    Kl,
    Zr
  );
}
// @__NO_SIDE_EFFECTS__
function Vt(t) {
  return ti(
    t,
    !0,
    Ul,
    zl,
    ea
  );
}
function ti(t, e, s, n, i) {
  if (!ve(t))
    return Ce.NODE_ENV !== "production" && bt(
      `value cannot be made ${e ? "readonly" : "reactive"}: ${String(
        t
      )}`
    ), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  const o = Yl(t);
  if (o === 0)
    return t;
  const r = i.get(t);
  if (r)
    return r;
  const a = new Proxy(
    t,
    o === 2 ? n : s
  );
  return i.set(t, a), a;
}
// @__NO_SIDE_EFFECTS__
function ns(t) {
  return /* @__PURE__ */ yt(t) ? /* @__PURE__ */ ns(t.__v_raw) : !!(t && t.__v_isReactive);
}
// @__NO_SIDE_EFFECTS__
function yt(t) {
  return !!(t && t.__v_isReadonly);
}
// @__NO_SIDE_EFFECTS__
function Xe(t) {
  return !!(t && t.__v_isShallow);
}
// @__NO_SIDE_EFFECTS__
function Ln(t) {
  return t ? !!t.__v_raw : !1;
}
// @__NO_SIDE_EFFECTS__
function ue(t) {
  const e = t && t.__v_raw;
  return e ? /* @__PURE__ */ ue(e) : t;
}
function Jl(t) {
  return !Ee(t, "__v_skip") && Object.isExtensible(t) && Rn(t, "__v_skip", !0), t;
}
const _t = (t) => ve(t) ? /* @__PURE__ */ is(t) : t, $s = (t) => ve(t) ? /* @__PURE__ */ Di(t) : t;
// @__NO_SIDE_EFFECTS__
function Fe(t) {
  return t ? t.__v_isRef === !0 : !1;
}
// @__NO_SIDE_EFFECTS__
function H(t) {
  return Xl(t, !1);
}
function Xl(t, e) {
  return /* @__PURE__ */ Fe(t) ? t : new Zl(t, e);
}
class Zl {
  constructor(e, s) {
    this.dep = new Xn(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? e : /* @__PURE__ */ ue(e), this._value = s ? e : _t(e), this.__v_isShallow = s;
  }
  get value() {
    return Ce.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track(), this._value;
  }
  set value(e) {
    const s = this._rawValue, n = this.__v_isShallow || /* @__PURE__ */ Xe(e) || /* @__PURE__ */ yt(e);
    e = n ? e : /* @__PURE__ */ ue(e), st(e, s) && (this._rawValue = e, this._value = n ? e : _t(e), Ce.NODE_ENV !== "production" ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: e,
      oldValue: s
    }) : this.dep.trigger());
  }
}
function Q(t) {
  return /* @__PURE__ */ Fe(t) ? t.value : t;
}
const ec = {
  get: (t, e, s) => e === "__v_raw" ? t : Q(Reflect.get(t, e, s)),
  set: (t, e, s, n) => {
    const i = t[e];
    return /* @__PURE__ */ Fe(i) && !/* @__PURE__ */ Fe(s) ? (i.value = s, !0) : Reflect.set(t, e, s, n);
  }
};
function ta(t) {
  return /* @__PURE__ */ ns(t) ? t : new Proxy(t, ec);
}
class tc {
  constructor(e) {
    this.__v_isRef = !0, this._value = void 0;
    const s = this.dep = new Xn(), { get: n, set: i } = e(s.track.bind(s), s.trigger.bind(s));
    this._get = n, this._set = i;
  }
  get value() {
    return this._value = this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function sc(t) {
  return new tc(t);
}
class nc {
  constructor(e, s, n) {
    this.fn = e, this.setter = s, this._value = void 0, this.dep = new Xn(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Xs - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !s, this.isSSR = n;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Ne !== this)
      return Ur(this, !0), !0;
  }
  get value() {
    const e = Ce.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    return Hr(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter ? this.setter(e) : Ce.NODE_ENV !== "production" && bt("Write operation failed: computed value is readonly");
  }
}
// @__NO_SIDE_EFFECTS__
function ic(t, e, s = !1) {
  let n, i;
  return Z(t) ? n = t : (n = t.get, i = t.set), new nc(n, i, s);
}
const _n = {}, kn = /* @__PURE__ */ new WeakMap();
let us;
function oc(t, e = !1, s = us) {
  if (s) {
    let n = kn.get(s);
    n || kn.set(s, n = []), n.push(t);
  } else Ce.NODE_ENV !== "production" && !e && bt(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function rc(t, e, s = ye) {
  const { immediate: n, deep: i, once: o, scheduler: r, augmentJob: a, call: l } = s, u = (R) => {
    (s.onWarn || bt)(
      "Invalid watch source: ",
      R,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, c = (R) => i ? R : /* @__PURE__ */ Xe(R) || i === !1 || i === 0 ? Ht(R, 1) : Ht(R);
  let d, m, h, g, E = !1, y = !1;
  if (/* @__PURE__ */ Fe(t) ? (m = () => t.value, E = /* @__PURE__ */ Xe(t)) : /* @__PURE__ */ ns(t) ? (m = () => c(t), E = !0) : z(t) ? (y = !0, E = t.some((R) => /* @__PURE__ */ ns(R) || /* @__PURE__ */ Xe(R)), m = () => t.map((R) => {
    if (/* @__PURE__ */ Fe(R))
      return R.value;
    if (/* @__PURE__ */ ns(R))
      return c(R);
    if (Z(R))
      return l ? l(R, 2) : R();
    Ce.NODE_ENV !== "production" && u(R);
  })) : Z(t) ? e ? m = l ? () => l(t, 2) : t : m = () => {
    if (h) {
      gt();
      try {
        h();
      } finally {
        Et();
      }
    }
    const R = us;
    us = d;
    try {
      return l ? l(t, 3, [g]) : t(g);
    } finally {
      us = R;
    }
  } : (m = qe, Ce.NODE_ENV !== "production" && u(t)), e && i) {
    const R = m, U = i === !0 ? 1 / 0 : i;
    m = () => Ht(R(), U);
  }
  const T = Al(), N = () => {
    d.stop(), T && T.active && Hi(T.effects, d);
  };
  if (o && e) {
    const R = e;
    e = (...U) => {
      R(...U), N();
    };
  }
  let _ = y ? new Array(t.length).fill(_n) : _n;
  const C = (R) => {
    if (!(!(d.flags & 1) || !d.dirty && !R))
      if (e) {
        const U = d.run();
        if (i || E || (y ? U.some((le, he) => st(le, _[he])) : st(U, _))) {
          h && h();
          const le = us;
          us = d;
          try {
            const he = [
              U,
              // pass undefined as the old value when it's changed for the first time
              _ === _n ? void 0 : y && _[0] === _n ? [] : _,
              g
            ];
            _ = U, l ? l(e, 3, he) : (
              // @ts-expect-error
              e(...he)
            );
          } finally {
            us = le;
          }
        }
      } else
        d.run();
  };
  return a && a(C), d = new Br(m), d.scheduler = r ? () => r(C, !1) : C, g = (R) => oc(R, !1, d), h = d.onStop = () => {
    const R = kn.get(d);
    if (R) {
      if (l)
        l(R, 4);
      else
        for (const U of R) U();
      kn.delete(d);
    }
  }, Ce.NODE_ENV !== "production" && (d.onTrack = s.onTrack, d.onTrigger = s.onTrigger), e ? n ? C(!0) : _ = d.run() : r ? r(C.bind(null, !0), !0) : d.run(), N.pause = d.pause.bind(d), N.resume = d.resume.bind(d), N.stop = N, N;
}
function Ht(t, e = 1 / 0, s) {
  if (e <= 0 || !ve(t) || t.__v_skip || (s = s || /* @__PURE__ */ new Map(), (s.get(t) || 0) >= e))
    return t;
  if (s.set(t, e), e--, /* @__PURE__ */ Fe(t))
    Ht(t.value, e, s);
  else if (z(t))
    for (let n = 0; n < t.length; n++)
      Ht(t[n], e, s);
  else if (Ms(t) || ps(t))
    t.forEach((n) => {
      Ht(n, e, s);
    });
  else if (Rr(t)) {
    for (const n in t)
      Ht(t[n], e, s);
    for (const n of Object.getOwnPropertySymbols(t))
      Object.prototype.propertyIsEnumerable.call(t, n) && Ht(t[n], e, s);
  }
  return t;
}
var b = {};
const ms = [];
function Cn(t) {
  ms.push(t);
}
function wn() {
  ms.pop();
}
let vi = !1;
function I(t, ...e) {
  if (vi) return;
  vi = !0, gt();
  const s = ms.length ? ms[ms.length - 1].component : null, n = s && s.appContext.config.warnHandler, i = ac();
  if (n)
    Rs(
      n,
      s,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        t + e.map((o) => {
          var r, a;
          return (a = (r = o.toString) == null ? void 0 : r.call(o)) != null ? a : JSON.stringify(o);
        }).join(""),
        s && s.proxy,
        i.map(
          ({ vnode: o }) => `at <${vn(s, o.type)}>`
        ).join(`
`),
        i
      ]
    );
  else {
    const o = [`[Vue warn]: ${t}`, ...e];
    i.length && o.push(`
`, ...lc(i)), console.warn(...o);
  }
  Et(), vi = !1;
}
function ac() {
  let t = ms[ms.length - 1];
  if (!t)
    return [];
  const e = [];
  for (; t; ) {
    const s = e[0];
    s && s.vnode === t ? s.recurseCount++ : e.push({
      vnode: t,
      recurseCount: 0
    });
    const n = t.component && t.component.parent;
    t = n && n.vnode;
  }
  return e;
}
function lc(t) {
  const e = [];
  return t.forEach((s, n) => {
    e.push(...n === 0 ? [] : [`
`], ...cc(s));
  }), e;
}
function cc({ vnode: t, recurseCount: e }) {
  const s = e > 0 ? `... (${e} recursive calls)` : "", n = t.component ? t.component.parent == null : !1, i = ` at <${vn(
    t.component,
    t.type,
    n
  )}`, o = ">" + s;
  return t.props ? [i, ...uc(t.props), o] : [i + o];
}
function uc(t) {
  const e = [], s = Object.keys(t);
  return s.slice(0, 3).forEach((n) => {
    e.push(...sa(n, t[n]));
  }), s.length > 3 && e.push(" ..."), e;
}
function sa(t, e, s) {
  return Me(e) ? (e = JSON.stringify(e), s ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? s ? e : [`${t}=${e}`] : /* @__PURE__ */ Fe(e) ? (e = sa(t, /* @__PURE__ */ ue(e.value), !0), s ? e : [`${t}=Ref<`, e, ">"]) : Z(e) ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`] : (e = /* @__PURE__ */ ue(e), s ? e : [`${t}=`, e]);
}
function dc(t, e) {
  b.NODE_ENV !== "production" && t !== void 0 && (typeof t != "number" ? I(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && I(`${e} is NaN - the duration expression might be incorrect.`));
}
const Xi = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function Rs(t, e, s, n) {
  try {
    return n ? t(...n) : t();
  } catch (i) {
    un(i, e, s);
  }
}
function Tt(t, e, s, n) {
  if (Z(t)) {
    const i = Rs(t, e, s, n);
    return i && Wi(i) && i.catch((o) => {
      un(o, e, s);
    }), i;
  }
  if (z(t)) {
    const i = [];
    for (let o = 0; o < t.length; o++)
      i.push(Tt(t[o], e, s, n));
    return i;
  } else b.NODE_ENV !== "production" && I(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof t}`
  );
}
function un(t, e, s, n = !0) {
  const i = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: r } = e && e.appContext.config || ye;
  if (e) {
    let a = e.parent;
    const l = e.proxy, u = b.NODE_ENV !== "production" ? Xi[s] : `https://vuejs.org/error-reference/#runtime-${s}`;
    for (; a; ) {
      const c = a.ec;
      if (c) {
        for (let d = 0; d < c.length; d++)
          if (c[d](t, l, u) === !1)
            return;
      }
      a = a.parent;
    }
    if (o) {
      gt(), Rs(o, null, 10, [
        t,
        l,
        u
      ]), Et();
      return;
    }
  }
  fc(t, s, i, n, r);
}
function fc(t, e, s, n = !0, i = !1) {
  if (b.NODE_ENV !== "production") {
    const o = Xi[e];
    if (s && Cn(s), I(`Unhandled error${o ? ` during execution of ${o}` : ""}`), s && wn(), n)
      throw t;
    console.error(t);
  } else {
    if (i)
      throw t;
    console.error(t);
  }
}
const Je = [];
let Dt = -1;
const Cs = [];
let es = null, xs = 0;
const na = /* @__PURE__ */ Promise.resolve();
let Pn = null;
const pc = 100;
function It(t) {
  const e = Pn || na;
  return t ? e.then(this ? t.bind(this) : t) : e;
}
function hc(t) {
  let e = Dt + 1, s = Je.length;
  for (; e < s; ) {
    const n = e + s >>> 1, i = Je[n], o = en(i);
    o < t || o === t && i.flags & 2 ? e = n + 1 : s = n;
  }
  return e;
}
function si(t) {
  if (!(t.flags & 1)) {
    const e = en(t), s = Je[Je.length - 1];
    !s || // fast path when the job id is larger than the tail
    !(t.flags & 2) && e >= en(s) ? Je.push(t) : Je.splice(hc(e), 0, t), t.flags |= 1, ia();
  }
}
function ia() {
  Pn || (Pn = na.then(aa));
}
function oa(t) {
  z(t) ? Cs.push(...t) : es && t.id === -1 ? es.splice(xs + 1, 0, t) : t.flags & 1 || (Cs.push(t), t.flags |= 1), ia();
}
function $o(t, e, s = Dt + 1) {
  for (b.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()); s < Je.length; s++) {
    const n = Je[s];
    if (n && n.flags & 2) {
      if (t && n.id !== t.uid || b.NODE_ENV !== "production" && Zi(e, n))
        continue;
      Je.splice(s, 1), s--, n.flags & 4 && (n.flags &= -2), n(), n.flags & 4 || (n.flags &= -2);
    }
  }
}
function ra(t) {
  if (Cs.length) {
    const e = [...new Set(Cs)].sort(
      (s, n) => en(s) - en(n)
    );
    if (Cs.length = 0, es) {
      es.push(...e);
      return;
    }
    for (es = e, b.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()), xs = 0; xs < es.length; xs++) {
      const s = es[xs];
      b.NODE_ENV !== "production" && Zi(t, s) || (s.flags & 4 && (s.flags &= -2), s.flags & 8 || s(), s.flags &= -2);
    }
    es = null, xs = 0;
  }
}
const en = (t) => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id;
function aa(t) {
  b.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map());
  const e = b.NODE_ENV !== "production" ? (s) => Zi(t, s) : qe;
  try {
    for (Dt = 0; Dt < Je.length; Dt++) {
      const s = Je[Dt];
      if (s && !(s.flags & 8)) {
        if (b.NODE_ENV !== "production" && e(s))
          continue;
        s.flags & 4 && (s.flags &= -2), Rs(
          s,
          s.i,
          s.i ? 15 : 14
        ), s.flags & 4 || (s.flags &= -2);
      }
    }
  } finally {
    for (; Dt < Je.length; Dt++) {
      const s = Je[Dt];
      s && (s.flags &= -2);
    }
    Dt = -1, Je.length = 0, ra(t), Pn = null, (Je.length || Cs.length) && aa(t);
  }
}
function Zi(t, e) {
  const s = t.get(e) || 0;
  if (s > pc) {
    const n = e.i, i = n && Xa(n.type);
    return un(
      `Maximum recursive updates exceeded${i ? ` in component <${i}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), !0;
  }
  return t.set(e, s + 1), !1;
}
let pt = !1;
const Dn = /* @__PURE__ */ new Map();
b.NODE_ENV !== "production" && (cn().__VUE_HMR_RUNTIME__ = {
  createRecord: bi(la),
  rerender: bi(bc),
  reload: bi(gc)
});
const gs = /* @__PURE__ */ new Map();
function mc(t) {
  const e = t.type.__hmrId;
  let s = gs.get(e);
  s || (la(e, t.type), s = gs.get(e)), s.instances.add(t);
}
function vc(t) {
  gs.get(t.type.__hmrId).instances.delete(t);
}
function la(t, e) {
  return gs.has(t) ? !1 : (gs.set(t, {
    initialDef: Bn(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Bn(t) {
  return Za(t) ? t.__vccOpts : t;
}
function bc(t, e) {
  const s = gs.get(t);
  s && (s.initialDef.render = e, [...s.instances].forEach((n) => {
    e && (n.render = e, Bn(n.type).render = e), n.renderCache = [], pt = !0, n.job.flags & 8 || n.update(), pt = !1;
  }));
}
function gc(t, e) {
  const s = gs.get(t);
  if (!s) return;
  e = Bn(e), Ao(s.initialDef, e);
  const n = [...s.instances];
  for (let i = 0; i < n.length; i++) {
    const o = n[i], r = Bn(o.type);
    let a = Dn.get(r);
    a || (r !== s.initialDef && Ao(r, e), Dn.set(r, a = /* @__PURE__ */ new Set())), a.add(o), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (a.add(o), o.ceReload(e.styles), a.delete(o)) : o.parent ? si(() => {
      o.job.flags & 8 || (pt = !0, o.parent.update(), pt = !1, a.delete(o));
    }) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), o.root.ce && o !== o.root && o.root.ce._removeChildStyle(r);
  }
  oa(() => {
    Dn.clear();
  });
}
function Ao(t, e) {
  Ve(t, e);
  for (const s in t)
    s !== "__file" && !(s in e) && delete t[s];
}
function bi(t) {
  return (e, s) => {
    try {
      return t(e, s);
    } catch (n) {
      console.error(n), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let At, qs = [], Oi = !1;
function dn(t, ...e) {
  At ? At.emit(t, ...e) : Oi || qs.push({ event: t, args: e });
}
function ca(t, e) {
  var s, n;
  At = t, At ? (At.enabled = !0, qs.forEach(({ event: i, args: o }) => At.emit(i, ...o)), qs = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((n = (s = window.navigator) == null ? void 0 : s.userAgent) != null && n.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((o) => {
    ca(o, e);
  }), setTimeout(() => {
    At || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Oi = !0, qs = []);
  }, 3e3)) : (Oi = !0, qs = []);
}
function Ec(t, e) {
  dn("app:init", t, e, {
    Fragment: Ae,
    Text: hn,
    Comment: Be,
    Static: An
  });
}
function yc(t) {
  dn("app:unmount", t);
}
const _c = /* @__PURE__ */ eo(
  "component:added"
  /* COMPONENT_ADDED */
), ua = /* @__PURE__ */ eo(
  "component:updated"
  /* COMPONENT_UPDATED */
), Tc = /* @__PURE__ */ eo(
  "component:removed"
  /* COMPONENT_REMOVED */
), Nc = (t) => {
  At && typeof At.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !At.cleanupBuffer(t) && Tc(t);
};
// @__NO_SIDE_EFFECTS__
function eo(t) {
  return (e) => {
    dn(
      t,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const xc = /* @__PURE__ */ da(
  "perf:start"
  /* PERFORMANCE_START */
), Sc = /* @__PURE__ */ da(
  "perf:end"
  /* PERFORMANCE_END */
);
function da(t) {
  return (e, s, n) => {
    dn(t, e.appContext.app, e.uid, e, s, n);
  };
}
function Cc(t, e, s) {
  dn(
    "component:emit",
    t.appContext.app,
    t,
    e,
    s
  );
}
let He = null, fa = null;
function Fn(t) {
  const e = He;
  return He = t, fa = t && t.type.__scopeId || null, e;
}
function B(t, e = He, s) {
  if (!e || t._n)
    return t;
  const n = (...i) => {
    n._d && Kn(-1);
    const o = Fn(e);
    let r;
    try {
      r = t(...i);
    } finally {
      Fn(o), n._d && Kn(1);
    }
    return b.NODE_ENV !== "production" && ua(e), r;
  };
  return n._n = !0, n._c = !0, n._d = !0, n;
}
function pa(t) {
  pl(t) && I("Do not use built-in directive ids as custom directive id: " + t);
}
function rt(t, e) {
  if (He === null)
    return b.NODE_ENV !== "production" && I("withDirectives can only be used inside render functions."), t;
  const s = ri(He), n = t.dirs || (t.dirs = []);
  for (let i = 0; i < e.length; i++) {
    let [o, r, a, l = ye] = e[i];
    o && (Z(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Ht(r), n.push({
      dir: o,
      instance: s,
      value: r,
      oldValue: void 0,
      arg: a,
      modifiers: l
    }));
  }
  return t;
}
function os(t, e, s, n) {
  const i = t.dirs, o = e && e.dirs;
  for (let r = 0; r < i.length; r++) {
    const a = i[r];
    o && (a.oldValue = o[r].value);
    let l = a.dir[n];
    l && (gt(), Tt(l, s, 8, [
      t.el,
      a,
      t,
      e
    ]), Et());
  }
}
function wc(t, e) {
  if (b.NODE_ENV !== "production" && (!Ue || Ue.isMounted) && I("provide() can only be used inside setup()."), Ue) {
    let s = Ue.provides;
    const n = Ue.parent && Ue.parent.provides;
    n === s && (s = Ue.provides = Object.create(n)), s[t] = e;
  }
}
function On(t, e, s = !1) {
  const n = oi();
  if (n || Ds) {
    let i = Ds ? Ds._context.provides : n ? n.parent == null || n.ce ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0;
    if (i && t in i)
      return i[t];
    if (arguments.length > 1)
      return s && Z(e) ? e.call(n && n.proxy) : e;
    b.NODE_ENV !== "production" && I(`injection "${String(t)}" not found.`);
  } else b.NODE_ENV !== "production" && I("inject() can only be used inside setup() or functional components.");
}
const Dc = /* @__PURE__ */ Symbol.for("v-scx"), Oc = () => {
  {
    const t = On(Dc);
    return t || b.NODE_ENV !== "production" && I(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), t;
  }
};
function $c(t, e) {
  return to(
    t,
    null,
    b.NODE_ENV !== "production" ? Ve({}, e, { flush: "sync" }) : { flush: "sync" }
  );
}
function lt(t, e, s) {
  return b.NODE_ENV !== "production" && !Z(e) && I(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), to(t, e, s);
}
function to(t, e, s = ye) {
  const { immediate: n, deep: i, flush: o, once: r } = s;
  b.NODE_ENV !== "production" && !e && (n !== void 0 && I(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), i !== void 0 && I(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), r !== void 0 && I(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const a = Ve({}, s);
  b.NODE_ENV !== "production" && (a.onWarn = I);
  const l = e && n || !e && o !== "post";
  let u;
  if (nn) {
    if (o === "sync") {
      const h = Oc();
      u = h.__watcherHandles || (h.__watcherHandles = []);
    } else if (!l) {
      const h = () => {
      };
      return h.stop = qe, h.resume = qe, h.pause = qe, h;
    }
  }
  const c = Ue;
  a.call = (h, g, E) => Tt(h, c, g, E);
  let d = !1;
  o === "post" ? a.scheduler = (h) => {
    ze(h, c && c.suspense);
  } : o !== "sync" && (d = !0, a.scheduler = (h, g) => {
    g ? h() : si(h);
  }), a.augmentJob = (h) => {
    e && (h.flags |= 4), d && (h.flags |= 2, c && (h.id = c.uid, h.i = c));
  };
  const m = rc(t, e, a);
  return nn && (u ? u.push(m) : l && m()), m;
}
function Ac(t, e, s) {
  const n = this.proxy, i = Me(t) ? t.includes(".") ? ha(n, t) : () => n[t] : t.bind(n, n);
  let o;
  Z(e) ? o = e : (o = e.handler, s = e);
  const r = mn(this), a = to(i, o.bind(n), s);
  return r(), a;
}
function ha(t, e) {
  const s = e.split(".");
  return () => {
    let n = t;
    for (let i = 0; i < s.length && n; i++)
      n = n[s[i]];
    return n;
  };
}
const ma = /* @__PURE__ */ Symbol("_vte"), va = (t) => t.__isTeleport, vs = (t) => t && (t.disabled || t.disabled === ""), Vo = (t) => t && (t.defer || t.defer === ""), Mo = (t) => typeof SVGElement < "u" && t instanceof SVGElement, Io = (t) => typeof MathMLElement == "function" && t instanceof MathMLElement, $i = (t, e) => {
  const s = t && t.to;
  if (Me(s))
    if (e) {
      const n = e(s);
      return b.NODE_ENV !== "production" && !n && !vs(t) && I(
        `Failed to locate Teleport target with selector "${s}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), n;
    } else
      return b.NODE_ENV !== "production" && I(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return b.NODE_ENV !== "production" && !s && !vs(t) && I(`Invalid Teleport target: ${s}`), s;
}, ba = {
  name: "Teleport",
  __isTeleport: !0,
  process(t, e, s, n, i, o, r, a, l, u) {
    const {
      mc: c,
      pc: d,
      pbc: m,
      o: { insert: h, querySelector: g, createText: E, createComment: y }
    } = u, T = vs(e.props);
    let { shapeFlag: N, children: _, dynamicChildren: C } = e;
    if (b.NODE_ENV !== "production" && pt && (l = !1, C = null), t == null) {
      const R = e.el = b.NODE_ENV !== "production" ? y("teleport start") : E(""), U = e.anchor = b.NODE_ENV !== "production" ? y("teleport end") : E("");
      h(R, s, n), h(U, s, n);
      const le = (W, re) => {
        N & 16 && c(
          _,
          W,
          re,
          i,
          o,
          r,
          a,
          l
        );
      }, he = () => {
        const W = e.target = $i(e.props, g), re = Ai(W, e, E, h);
        W ? (r !== "svg" && Mo(W) ? r = "svg" : r !== "mathml" && Io(W) && (r = "mathml"), i && i.isCE && (i.ce._teleportTargets || (i.ce._teleportTargets = /* @__PURE__ */ new Set())).add(W), T || (le(W, re), $n(e, !1))) : b.NODE_ENV !== "production" && !T && I(
          "Invalid Teleport target on mount:",
          W,
          `(${typeof W})`
        );
      };
      T && (le(s, U), $n(e, !0)), Vo(e.props) ? (e.el.__isMounted = !1, ze(() => {
        he(), delete e.el.__isMounted;
      }, o)) : he();
    } else {
      if (Vo(e.props) && t.el.__isMounted === !1) {
        ze(() => {
          ba.process(
            t,
            e,
            s,
            n,
            i,
            o,
            r,
            a,
            l,
            u
          );
        }, o);
        return;
      }
      e.el = t.el, e.targetStart = t.targetStart;
      const R = e.anchor = t.anchor, U = e.target = t.target, le = e.targetAnchor = t.targetAnchor, he = vs(t.props), W = he ? s : U, re = he ? R : le;
      if (r === "svg" || Mo(U) ? r = "svg" : (r === "mathml" || Io(U)) && (r = "mathml"), C ? (m(
        t.dynamicChildren,
        C,
        W,
        i,
        o,
        r,
        a
      ), Ys(t, e, b.NODE_ENV === "production")) : l || d(
        t,
        e,
        W,
        re,
        i,
        o,
        r,
        a,
        !1
      ), T)
        he ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : Tn(
          e,
          s,
          R,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
        const me = e.target = $i(
          e.props,
          g
        );
        me ? Tn(
          e,
          me,
          null,
          u,
          0
        ) : b.NODE_ENV !== "production" && I(
          "Invalid Teleport target on update:",
          U,
          `(${typeof U})`
        );
      } else he && Tn(
        e,
        U,
        le,
        u,
        1
      );
      $n(e, T);
    }
  },
  remove(t, e, s, { um: n, o: { remove: i } }, o) {
    const {
      shapeFlag: r,
      children: a,
      anchor: l,
      targetStart: u,
      targetAnchor: c,
      target: d,
      props: m
    } = t;
    if (d && (i(u), i(c)), o && i(l), r & 16) {
      const h = o || !vs(m);
      for (let g = 0; g < a.length; g++) {
        const E = a[g];
        n(
          E,
          e,
          s,
          h,
          !!E.dynamicChildren
        );
      }
    }
  },
  move: Tn,
  hydrate: Vc
};
function Tn(t, e, s, { o: { insert: n }, m: i }, o = 2) {
  o === 0 && n(t.targetAnchor, e, s);
  const { el: r, anchor: a, shapeFlag: l, children: u, props: c } = t, d = o === 2;
  if (d && n(r, e, s), (!d || vs(c)) && l & 16)
    for (let m = 0; m < u.length; m++)
      i(
        u[m],
        e,
        s,
        2
      );
  d && n(a, e, s);
}
function Vc(t, e, s, n, i, o, {
  o: { nextSibling: r, parentNode: a, querySelector: l, insert: u, createText: c }
}, d) {
  function m(y, T) {
    let N = T;
    for (; N; ) {
      if (N && N.nodeType === 8) {
        if (N.data === "teleport start anchor")
          e.targetStart = N;
        else if (N.data === "teleport anchor") {
          e.targetAnchor = N, y._lpa = e.targetAnchor && r(e.targetAnchor);
          break;
        }
      }
      N = r(N);
    }
  }
  function h(y, T) {
    T.anchor = d(
      r(y),
      T,
      a(y),
      s,
      n,
      i,
      o
    );
  }
  const g = e.target = $i(
    e.props,
    l
  ), E = vs(e.props);
  if (g) {
    const y = g._lpa || g.firstChild;
    e.shapeFlag & 16 && (E ? (h(t, e), m(g, y), e.targetAnchor || Ai(
      g,
      e,
      c,
      u,
      // if target is the same as the main view, insert anchors before current node
      // to avoid hydrating mismatch
      a(t) === g ? t : null
    )) : (e.anchor = r(t), m(g, y), e.targetAnchor || Ai(g, e, c, u), d(
      y && r(y),
      e,
      g,
      s,
      n,
      i,
      o
    ))), $n(e, E);
  } else E && e.shapeFlag & 16 && (h(t, e), e.targetStart = t, e.targetAnchor = r(t));
  return e.anchor && r(e.anchor);
}
const ga = ba;
function $n(t, e) {
  const s = t.ctx;
  if (s && s.ut) {
    let n, i;
    for (e ? (n = t.el, i = t.anchor) : (n = t.targetStart, i = t.targetAnchor); n && n !== i; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", s.uid), n = n.nextSibling;
    s.ut();
  }
}
function Ai(t, e, s, n, i = null) {
  const o = e.targetStart = s(""), r = e.targetAnchor = s("");
  return o[ma] = r, t && (n(o, t, i), n(r, t, i)), r;
}
const Ot = /* @__PURE__ */ Symbol("_leaveCb"), Fs = /* @__PURE__ */ Symbol("_enterCb");
function Mc() {
  const t = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return nt(() => {
    t.isMounted = !0;
  }), Pt(() => {
    t.isUnmounting = !0;
  }), t;
}
const ct = [Function, Array], Ea = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: ct,
  onEnter: ct,
  onAfterEnter: ct,
  onEnterCancelled: ct,
  // leave
  onBeforeLeave: ct,
  onLeave: ct,
  onAfterLeave: ct,
  onLeaveCancelled: ct,
  // appear
  onBeforeAppear: ct,
  onAppear: ct,
  onAfterAppear: ct,
  onAppearCancelled: ct
}, ya = (t) => {
  const e = t.subTree;
  return e.component ? ya(e.component) : e;
}, Ic = {
  name: "BaseTransition",
  props: Ea,
  setup(t, { slots: e }) {
    const s = oi(), n = Mc();
    return () => {
      const i = e.default && Na(e.default(), !0);
      if (!i || !i.length)
        return;
      const o = _a(i), r = /* @__PURE__ */ ue(t), { mode: a } = r;
      if (b.NODE_ENV !== "production" && a && a !== "in-out" && a !== "out-in" && a !== "default" && I(`invalid <transition> mode: ${a}`), n.isLeaving)
        return gi(o);
      const l = Ro(o);
      if (!l)
        return gi(o);
      let u = Vi(
        l,
        r,
        n,
        s,
        // #11061, ensure enterHooks is fresh after clone
        (d) => u = d
      );
      l.type !== Be && tn(l, u);
      let c = s.subTree && Ro(s.subTree);
      if (c && c.type !== Be && !fs(c, l) && ya(s).type !== Be) {
        let d = Vi(
          c,
          r,
          n,
          s
        );
        if (tn(c, d), a === "out-in" && l.type !== Be)
          return n.isLeaving = !0, d.afterLeave = () => {
            n.isLeaving = !1, s.job.flags & 8 || s.update(), delete d.afterLeave, c = void 0;
          }, gi(o);
        a === "in-out" && l.type !== Be ? d.delayLeave = (m, h, g) => {
          const E = Ta(
            n,
            c
          );
          E[String(c.key)] = c, m[Ot] = () => {
            h(), m[Ot] = void 0, delete u.delayedLeave, c = void 0;
          }, u.delayedLeave = () => {
            g(), delete u.delayedLeave, c = void 0;
          };
        } : c = void 0;
      } else c && (c = void 0);
      return o;
    };
  }
};
function _a(t) {
  let e = t[0];
  if (t.length > 1) {
    let s = !1;
    for (const n of t)
      if (n.type !== Be) {
        if (b.NODE_ENV !== "production" && s) {
          I(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        if (e = n, s = !0, b.NODE_ENV === "production") break;
      }
  }
  return e;
}
const Rc = Ic;
function Ta(t, e) {
  const { leavingVNodes: s } = t;
  let n = s.get(e.type);
  return n || (n = /* @__PURE__ */ Object.create(null), s.set(e.type, n)), n;
}
function Vi(t, e, s, n, i) {
  const {
    appear: o,
    mode: r,
    persisted: a = !1,
    onBeforeEnter: l,
    onEnter: u,
    onAfterEnter: c,
    onEnterCancelled: d,
    onBeforeLeave: m,
    onLeave: h,
    onAfterLeave: g,
    onLeaveCancelled: E,
    onBeforeAppear: y,
    onAppear: T,
    onAfterAppear: N,
    onAppearCancelled: _
  } = e, C = String(t.key), R = Ta(s, t), U = (W, re) => {
    W && Tt(
      W,
      n,
      9,
      re
    );
  }, le = (W, re) => {
    const me = re[1];
    U(W, re), z(W) ? W.every((D) => D.length <= 1) && me() : W.length <= 1 && me();
  }, he = {
    mode: r,
    persisted: a,
    beforeEnter(W) {
      let re = l;
      if (!s.isMounted)
        if (o)
          re = y || l;
        else
          return;
      W[Ot] && W[Ot](
        !0
        /* cancelled */
      );
      const me = R[C];
      me && fs(t, me) && me.el[Ot] && me.el[Ot](), U(re, [W]);
    },
    enter(W) {
      let re = u, me = c, D = d;
      if (!s.isMounted)
        if (o)
          re = T || u, me = N || c, D = _ || d;
        else
          return;
      let K = !1;
      W[Fs] = (be) => {
        K || (K = !0, be ? U(D, [W]) : U(me, [W]), he.delayedLeave && he.delayedLeave(), W[Fs] = void 0);
      };
      const oe = W[Fs].bind(null, !1);
      re ? le(re, [W, oe]) : oe();
    },
    leave(W, re) {
      const me = String(t.key);
      if (W[Fs] && W[Fs](
        !0
        /* cancelled */
      ), s.isUnmounting)
        return re();
      U(m, [W]);
      let D = !1;
      W[Ot] = (oe) => {
        D || (D = !0, re(), oe ? U(E, [W]) : U(g, [W]), W[Ot] = void 0, R[me] === t && delete R[me]);
      };
      const K = W[Ot].bind(null, !1);
      R[me] = t, h ? le(h, [W, K]) : K();
    },
    clone(W) {
      const re = Vi(
        W,
        e,
        s,
        n,
        i
      );
      return i && i(re), re;
    }
  };
  return he;
}
function gi(t) {
  if (fn(t))
    return t = kt(t), t.children = null, t;
}
function Ro(t) {
  if (!fn(t))
    return va(t.type) && t.children ? _a(t.children) : t;
  if (t.component)
    return t.component.subTree;
  const { shapeFlag: e, children: s } = t;
  if (s) {
    if (e & 16)
      return s[0];
    if (e & 32 && Z(s.default))
      return s.default();
  }
}
function tn(t, e) {
  t.shapeFlag & 6 && t.component ? (t.transition = e, tn(t.component.subTree, e)) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
}
function Na(t, e = !1, s) {
  let n = [], i = 0;
  for (let o = 0; o < t.length; o++) {
    let r = t[o];
    const a = s == null ? r.key : String(s) + String(r.key != null ? r.key : o);
    r.type === Ae ? (r.patchFlag & 128 && i++, n = n.concat(
      Na(r.children, e, a)
    )) : (e || r.type !== Be) && n.push(a != null ? kt(r, { key: a }) : r);
  }
  if (i > 1)
    for (let o = 0; o < n.length; o++)
      n[o].patchFlag = -2;
  return n;
}
// @__NO_SIDE_EFFECTS__
function Te(t, e) {
  return Z(t) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Ve({ name: t.name }, e, { setup: t })
  ) : t;
}
function xa(t) {
  t.ids = [t.ids[0] + t.ids[2]++ + "-", 0, 0];
}
const Lo = /* @__PURE__ */ new WeakSet();
function ko(t, e) {
  let s;
  return !!((s = Object.getOwnPropertyDescriptor(t, e)) && !s.configurable);
}
const Un = /* @__PURE__ */ new WeakMap();
function Gs(t, e, s, n, i = !1) {
  if (z(t)) {
    t.forEach(
      (E, y) => Gs(
        E,
        e && (z(e) ? e[y] : e),
        s,
        n,
        i
      )
    );
    return;
  }
  if (ws(n) && !i) {
    n.shapeFlag & 512 && n.type.__asyncResolved && n.component.subTree.component && Gs(t, e, s, n.component.subTree);
    return;
  }
  const o = n.shapeFlag & 4 ? ri(n.component) : n.el, r = i ? null : o, { i: a, r: l } = t;
  if (b.NODE_ENV !== "production" && !a) {
    I(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const u = e && e.r, c = a.refs === ye ? a.refs = {} : a.refs, d = a.setupState, m = /* @__PURE__ */ ue(d), h = d === ye ? Mr : (E) => b.NODE_ENV !== "production" && (Ee(m, E) && !/* @__PURE__ */ Fe(m[E]) && I(
    `Template ref "${E}" used on a non-ref value. It will not work in the production build.`
  ), Lo.has(m[E])) || ko(c, E) ? !1 : Ee(m, E), g = (E, y) => !(b.NODE_ENV !== "production" && Lo.has(E) || y && ko(c, y));
  if (u != null && u !== l) {
    if (Po(e), Me(u))
      c[u] = null, h(u) && (d[u] = null);
    else if (/* @__PURE__ */ Fe(u)) {
      const E = e;
      g(u, E.k) && (u.value = null), E.k && (c[E.k] = null);
    }
  }
  if (Z(l))
    Rs(l, a, 12, [r, c]);
  else {
    const E = Me(l), y = /* @__PURE__ */ Fe(l);
    if (E || y) {
      const T = () => {
        if (t.f) {
          const N = E ? h(l) ? d[l] : c[l] : g(l) || !t.k ? l.value : c[t.k];
          if (i)
            z(N) && Hi(N, o);
          else if (z(N))
            N.includes(o) || N.push(o);
          else if (E)
            c[l] = [o], h(l) && (d[l] = c[l]);
          else {
            const _ = [o];
            g(l, t.k) && (l.value = _), t.k && (c[t.k] = _);
          }
        } else E ? (c[l] = r, h(l) && (d[l] = r)) : y ? (g(l, t.k) && (l.value = r), t.k && (c[t.k] = r)) : b.NODE_ENV !== "production" && I("Invalid template ref type:", l, `(${typeof l})`);
      };
      if (r) {
        const N = () => {
          T(), Un.delete(t);
        };
        N.id = -1, Un.set(t, N), ze(N, s);
      } else
        Po(t), T();
    } else b.NODE_ENV !== "production" && I("Invalid template ref type:", l, `(${typeof l})`);
  }
}
function Po(t) {
  const e = Un.get(t);
  e && (e.flags |= 8, Un.delete(t));
}
cn().requestIdleCallback;
cn().cancelIdleCallback;
const ws = (t) => !!t.type.__asyncLoader, fn = (t) => t.type.__isKeepAlive;
function Lc(t, e) {
  Sa(t, "a", e);
}
function kc(t, e) {
  Sa(t, "da", e);
}
function Sa(t, e, s = Ue) {
  const n = t.__wdc || (t.__wdc = () => {
    let i = s;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return t();
  });
  if (ni(e, n, s), s) {
    let i = s.parent;
    for (; i && i.parent; )
      fn(i.parent.vnode) && Pc(n, e, s, i), i = i.parent;
  }
}
function Pc(t, e, s, n) {
  const i = ni(
    e,
    t,
    n,
    !0
    /* prepend */
  );
  pn(() => {
    Hi(n[e], i);
  }, s);
}
function ni(t, e, s = Ue, n = !1) {
  if (s) {
    const i = s[t] || (s[t] = []), o = e.__weh || (e.__weh = (...r) => {
      gt();
      const a = mn(s), l = Tt(e, s, t, r);
      return a(), Et(), l;
    });
    return n ? i.unshift(o) : i.push(o), o;
  } else if (b.NODE_ENV !== "production") {
    const i = cs(Xi[t].replace(/ hook$/, ""));
    I(
      `${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const Qt = (t) => (e, s = Ue) => {
  (!nn || t === "sp") && ni(t, (...n) => e(...n), s);
}, Bc = Qt("bm"), nt = Qt("m"), Fc = Qt(
  "bu"
), Uc = Qt("u"), Pt = Qt(
  "bum"
), pn = Qt("um"), jc = Qt(
  "sp"
), qc = Qt("rtg"), Hc = Qt("rtc");
function Wc(t, e = Ue) {
  ni("ec", t, e);
}
const Kc = /* @__PURE__ */ Symbol.for("v-ndc");
function Wt(t, e, s, n) {
  let i;
  const o = s, r = z(t);
  if (r || Me(t)) {
    const a = r && /* @__PURE__ */ ns(t);
    let l = !1, u = !1;
    a && (l = !/* @__PURE__ */ Xe(t), u = /* @__PURE__ */ yt(t), t = Zn(t)), i = new Array(t.length);
    for (let c = 0, d = t.length; c < d; c++)
      i[c] = e(
        l ? u ? $s(_t(t[c])) : _t(t[c]) : t[c],
        c,
        void 0,
        o
      );
  } else if (typeof t == "number") {
    b.NODE_ENV !== "production" && !Number.isInteger(t) && I(`The v-for range expect an integer value but got ${t}.`), i = new Array(t);
    for (let a = 0; a < t; a++)
      i[a] = e(a + 1, a, void 0, o);
  } else if (ve(t))
    if (t[Symbol.iterator])
      i = Array.from(
        t,
        (a, l) => e(a, l, void 0, o)
      );
    else {
      const a = Object.keys(t);
      i = new Array(a.length);
      for (let l = 0, u = a.length; l < u; l++) {
        const c = a[l];
        i[l] = e(t[c], c, l, o);
      }
    }
  else
    i = [];
  return i;
}
function mt(t, e, s = {}, n, i) {
  if (He.ce || He.parent && ws(He.parent) && He.parent.ce) {
    const u = Object.keys(s).length > 0;
    return e !== "default" && (s.name = e), S(), Ie(
      Ae,
      null,
      [w("slot", s, n)],
      u ? -2 : 64
    );
  }
  let o = t[e];
  b.NODE_ENV !== "production" && o && o.length > 1 && (I(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), o = () => []), o && o._c && (o._d = !1), S();
  const r = o && Ca(o(s)), a = s.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  r && r.key, l = Ie(
    Ae,
    {
      key: (a && !vt(a) ? a : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!r && n ? "_fb" : "")
    },
    r || [],
    r && t._ === 1 ? 64 : -2
  );
  return !i && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), o && o._c && (o._d = !0), l;
}
function Ca(t) {
  return t.some((e) => Es(e) ? !(e.type === Be || e.type === Ae && !Ca(e.children)) : !0) ? t : null;
}
const Mi = (t) => t ? Qa(t) ? ri(t) : Mi(t.parent) : null, bs = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Ve(/* @__PURE__ */ Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(t.props) : t.props,
    $attrs: (t) => b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(t.attrs) : t.attrs,
    $slots: (t) => b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(t.slots) : t.slots,
    $refs: (t) => b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(t.refs) : t.refs,
    $parent: (t) => Mi(t.parent),
    $root: (t) => Mi(t.root),
    $host: (t) => t.ce,
    $emit: (t) => t.emit,
    $options: (t) => Oa(t),
    $forceUpdate: (t) => t.f || (t.f = () => {
      si(t.update);
    }),
    $nextTick: (t) => t.n || (t.n = It.bind(t.proxy)),
    $watch: (t) => Ac.bind(t)
  })
), so = (t) => t === "_" || t === "$", Ei = (t, e) => t !== ye && !t.__isScriptSetup && Ee(t, e), wa = {
  get({ _: t }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: s, setupState: n, data: i, props: o, accessCache: r, type: a, appContext: l } = t;
    if (b.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    if (e[0] !== "$") {
      const m = r[e];
      if (m !== void 0)
        switch (m) {
          case 1:
            return n[e];
          case 2:
            return i[e];
          case 4:
            return s[e];
          case 3:
            return o[e];
        }
      else {
        if (Ei(n, e))
          return r[e] = 1, n[e];
        if (i !== ye && Ee(i, e))
          return r[e] = 2, i[e];
        if (Ee(o, e))
          return r[e] = 3, o[e];
        if (s !== ye && Ee(s, e))
          return r[e] = 4, s[e];
        Ii && (r[e] = 0);
      }
    }
    const u = bs[e];
    let c, d;
    if (u)
      return e === "$attrs" ? (je(t.attrs, "get", ""), b.NODE_ENV !== "production" && Hn()) : b.NODE_ENV !== "production" && e === "$slots" && je(t, "get", e), u(t);
    if (
      // css module (injected by vue-loader)
      (c = a.__cssModules) && (c = c[e])
    )
      return c;
    if (s !== ye && Ee(s, e))
      return r[e] = 4, s[e];
    if (
      // global properties
      d = l.config.globalProperties, Ee(d, e)
    )
      return d[e];
    b.NODE_ENV !== "production" && He && (!Me(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (i !== ye && so(e[0]) && Ee(i, e) ? I(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : t === He && I(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: t }, e, s) {
    const { data: n, setupState: i, ctx: o } = t;
    return Ei(i, e) ? (i[e] = s, !0) : b.NODE_ENV !== "production" && i.__isScriptSetup && Ee(i, e) ? (I(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : n !== ye && Ee(n, e) ? (n[e] = s, !0) : Ee(t.props, e) ? (b.NODE_ENV !== "production" && I(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (b.NODE_ENV !== "production" && I(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : (b.NODE_ENV !== "production" && e in t.appContext.config.globalProperties ? Object.defineProperty(o, e, {
      enumerable: !0,
      configurable: !0,
      value: s
    }) : o[e] = s, !0);
  },
  has({
    _: { data: t, setupState: e, accessCache: s, ctx: n, appContext: i, props: o, type: r }
  }, a) {
    let l;
    return !!(s[a] || t !== ye && a[0] !== "$" && Ee(t, a) || Ei(e, a) || Ee(o, a) || Ee(n, a) || Ee(bs, a) || Ee(i.config.globalProperties, a) || (l = r.__cssModules) && l[a]);
  },
  defineProperty(t, e, s) {
    return s.get != null ? t._.accessCache[e] = 0 : Ee(s, "value") && this.set(t, e, s.value, null), Reflect.defineProperty(t, e, s);
  }
};
b.NODE_ENV !== "production" && (wa.ownKeys = (t) => (I(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(t)));
function zc(t) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => t
  }), Object.keys(bs).forEach((s) => {
    Object.defineProperty(e, s, {
      configurable: !0,
      enumerable: !1,
      get: () => bs[s](t),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: qe
    });
  }), e;
}
function Gc(t) {
  const {
    ctx: e,
    propsOptions: [s]
  } = t;
  s && Object.keys(s).forEach((n) => {
    Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[n],
      set: qe
    });
  });
}
function Yc(t) {
  const { ctx: e, setupState: s } = t;
  Object.keys(/* @__PURE__ */ ue(s)).forEach((n) => {
    if (!s.__isScriptSetup) {
      if (so(n[0])) {
        I(
          `setup() return property ${JSON.stringify(
            n
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, n, {
        enumerable: !0,
        configurable: !0,
        get: () => s[n],
        set: qe
      });
    }
  });
}
function jn(t) {
  return z(t) ? t.reduce(
    (e, s) => (e[s] = null, e),
    {}
  ) : t;
}
function no(t, e) {
  return !t || !e ? t || e : z(t) && z(e) ? t.concat(e) : Ve({}, jn(t), jn(e));
}
function Qc() {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, s) => {
    t[s] ? I(`${e} property "${s}" is already defined in ${t[s]}.`) : t[s] = e;
  };
}
let Ii = !0;
function Jc(t) {
  const e = Oa(t), s = t.proxy, n = t.ctx;
  Ii = !1, e.beforeCreate && Bo(e.beforeCreate, t, "bc");
  const {
    // state
    data: i,
    computed: o,
    methods: r,
    watch: a,
    provide: l,
    inject: u,
    // lifecycle
    created: c,
    beforeMount: d,
    mounted: m,
    beforeUpdate: h,
    updated: g,
    activated: E,
    deactivated: y,
    beforeDestroy: T,
    beforeUnmount: N,
    destroyed: _,
    unmounted: C,
    render: R,
    renderTracked: U,
    renderTriggered: le,
    errorCaptured: he,
    serverPrefetch: W,
    // public API
    expose: re,
    inheritAttrs: me,
    // assets
    components: D,
    directives: K,
    filters: oe
  } = e, be = b.NODE_ENV !== "production" ? Qc() : null;
  if (b.NODE_ENV !== "production") {
    const [ce] = t.propsOptions;
    if (ce)
      for (const fe in ce)
        be("Props", fe);
  }
  if (u && Xc(u, n, be), r)
    for (const ce in r) {
      const fe = r[ce];
      Z(fe) ? (b.NODE_ENV !== "production" ? Object.defineProperty(n, ce, {
        value: fe.bind(s),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : n[ce] = fe.bind(s), b.NODE_ENV !== "production" && be("Methods", ce)) : b.NODE_ENV !== "production" && I(
        `Method "${ce}" has type "${typeof fe}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (i) {
    b.NODE_ENV !== "production" && !Z(i) && I(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const ce = i.call(s, s);
    if (b.NODE_ENV !== "production" && Wi(ce) && I(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !ve(ce))
      b.NODE_ENV !== "production" && I("data() should return an object.");
    else if (t.data = /* @__PURE__ */ is(ce), b.NODE_ENV !== "production")
      for (const fe in ce)
        be("Data", fe), so(fe[0]) || Object.defineProperty(n, fe, {
          configurable: !0,
          enumerable: !0,
          get: () => ce[fe],
          set: qe
        });
  }
  if (Ii = !0, o)
    for (const ce in o) {
      const fe = o[ce], J = Z(fe) ? fe.bind(s, s) : Z(fe.get) ? fe.get.bind(s, s) : qe;
      b.NODE_ENV !== "production" && J === qe && I(`Computed property "${ce}" has no getter.`);
      const k = !Z(fe) && Z(fe.set) ? fe.set.bind(s) : b.NODE_ENV !== "production" ? () => {
        I(
          `Write operation failed: computed property "${ce}" is readonly.`
        );
      } : qe, Oe = se({
        get: J,
        set: k
      });
      Object.defineProperty(n, ce, {
        enumerable: !0,
        configurable: !0,
        get: () => Oe.value,
        set: (We) => Oe.value = We
      }), b.NODE_ENV !== "production" && be("Computed", ce);
    }
  if (a)
    for (const ce in a)
      Da(a[ce], n, s, ce);
  if (l) {
    const ce = Z(l) ? l.call(s) : l;
    Reflect.ownKeys(ce).forEach((fe) => {
      wc(fe, ce[fe]);
    });
  }
  c && Bo(c, t, "c");
  function pe(ce, fe) {
    z(fe) ? fe.forEach((J) => ce(J.bind(s))) : fe && ce(fe.bind(s));
  }
  if (pe(Bc, d), pe(nt, m), pe(Fc, h), pe(Uc, g), pe(Lc, E), pe(kc, y), pe(Wc, he), pe(Hc, U), pe(qc, le), pe(Pt, N), pe(pn, C), pe(jc, W), z(re))
    if (re.length) {
      const ce = t.exposed || (t.exposed = {});
      re.forEach((fe) => {
        Object.defineProperty(ce, fe, {
          get: () => s[fe],
          set: (J) => s[fe] = J,
          enumerable: !0
        });
      });
    } else t.exposed || (t.exposed = {});
  R && t.render === qe && (t.render = R), me != null && (t.inheritAttrs = me), D && (t.components = D), K && (t.directives = K), W && xa(t);
}
function Xc(t, e, s = qe) {
  z(t) && (t = Ri(t));
  for (const n in t) {
    const i = t[n];
    let o;
    ve(i) ? "default" in i ? o = On(
      i.from || n,
      i.default,
      !0
    ) : o = On(i.from || n) : o = On(i), /* @__PURE__ */ Fe(o) ? Object.defineProperty(e, n, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (r) => o.value = r
    }) : e[n] = o, b.NODE_ENV !== "production" && s("Inject", n);
  }
}
function Bo(t, e, s) {
  Tt(
    z(t) ? t.map((n) => n.bind(e.proxy)) : t.bind(e.proxy),
    e,
    s
  );
}
function Da(t, e, s, n) {
  let i = n.includes(".") ? ha(s, n) : () => s[n];
  if (Me(t)) {
    const o = e[t];
    Z(o) ? lt(i, o) : b.NODE_ENV !== "production" && I(`Invalid watch handler specified by key "${t}"`, o);
  } else if (Z(t))
    lt(i, t.bind(s));
  else if (ve(t))
    if (z(t))
      t.forEach((o) => Da(o, e, s, n));
    else {
      const o = Z(t.handler) ? t.handler.bind(s) : e[t.handler];
      Z(o) ? lt(i, o, t) : b.NODE_ENV !== "production" && I(`Invalid watch handler specified by key "${t.handler}"`, o);
    }
  else b.NODE_ENV !== "production" && I(`Invalid watch option: "${n}"`, t);
}
function Oa(t) {
  const e = t.type, { mixins: s, extends: n } = e, {
    mixins: i,
    optionsCache: o,
    config: { optionMergeStrategies: r }
  } = t.appContext, a = o.get(e);
  let l;
  return a ? l = a : !i.length && !s && !n ? l = e : (l = {}, i.length && i.forEach(
    (u) => qn(l, u, r, !0)
  ), qn(l, e, r)), ve(e) && o.set(e, l), l;
}
function qn(t, e, s, n = !1) {
  const { mixins: i, extends: o } = e;
  o && qn(t, o, s, !0), i && i.forEach(
    (r) => qn(t, r, s, !0)
  );
  for (const r in e)
    if (n && r === "expose")
      b.NODE_ENV !== "production" && I(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const a = Zc[r] || s && s[r];
      t[r] = a ? a(t[r], e[r]) : e[r];
    }
  return t;
}
const Zc = {
  data: Fo,
  props: Uo,
  emits: Uo,
  // objects
  methods: Hs,
  computed: Hs,
  // lifecycle
  beforeCreate: Qe,
  created: Qe,
  beforeMount: Qe,
  mounted: Qe,
  beforeUpdate: Qe,
  updated: Qe,
  beforeDestroy: Qe,
  beforeUnmount: Qe,
  destroyed: Qe,
  unmounted: Qe,
  activated: Qe,
  deactivated: Qe,
  errorCaptured: Qe,
  serverPrefetch: Qe,
  // assets
  components: Hs,
  directives: Hs,
  // watch
  watch: tu,
  // provide / inject
  provide: Fo,
  inject: eu
};
function Fo(t, e) {
  return e ? t ? function() {
    return Ve(
      Z(t) ? t.call(this, this) : t,
      Z(e) ? e.call(this, this) : e
    );
  } : e : t;
}
function eu(t, e) {
  return Hs(Ri(t), Ri(e));
}
function Ri(t) {
  if (z(t)) {
    const e = {};
    for (let s = 0; s < t.length; s++)
      e[t[s]] = t[s];
    return e;
  }
  return t;
}
function Qe(t, e) {
  return t ? [...new Set([].concat(t, e))] : e;
}
function Hs(t, e) {
  return t ? Ve(/* @__PURE__ */ Object.create(null), t, e) : e;
}
function Uo(t, e) {
  return t ? z(t) && z(e) ? [.../* @__PURE__ */ new Set([...t, ...e])] : Ve(
    /* @__PURE__ */ Object.create(null),
    jn(t),
    jn(e ?? {})
  ) : e;
}
function tu(t, e) {
  if (!t) return e;
  if (!e) return t;
  const s = Ve(/* @__PURE__ */ Object.create(null), t);
  for (const n in e)
    s[n] = Qe(t[n], e[n]);
  return s;
}
function $a() {
  return {
    app: null,
    config: {
      isNativeTag: Mr,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let su = 0;
function nu(t, e) {
  return function(n, i = null) {
    Z(n) || (n = Ve({}, n)), i != null && !ve(i) && (b.NODE_ENV !== "production" && I("root props passed to app.mount() must be an object."), i = null);
    const o = $a(), r = /* @__PURE__ */ new WeakSet(), a = [];
    let l = !1;
    const u = o.app = {
      _uid: su++,
      _component: n,
      _props: i,
      _container: null,
      _context: o,
      _instance: null,
      version: Xo,
      get config() {
        return o.config;
      },
      set config(c) {
        b.NODE_ENV !== "production" && I(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(c, ...d) {
        return r.has(c) ? b.NODE_ENV !== "production" && I("Plugin has already been applied to target app.") : c && Z(c.install) ? (r.add(c), c.install(u, ...d)) : Z(c) ? (r.add(c), c(u, ...d)) : b.NODE_ENV !== "production" && I(
          'A plugin must either be a function or an object with an "install" function.'
        ), u;
      },
      mixin(c) {
        return o.mixins.includes(c) ? b.NODE_ENV !== "production" && I(
          "Mixin has already been applied to target app" + (c.name ? `: ${c.name}` : "")
        ) : o.mixins.push(c), u;
      },
      component(c, d) {
        return b.NODE_ENV !== "production" && Fi(c, o.config), d ? (b.NODE_ENV !== "production" && o.components[c] && I(`Component "${c}" has already been registered in target app.`), o.components[c] = d, u) : o.components[c];
      },
      directive(c, d) {
        return b.NODE_ENV !== "production" && pa(c), d ? (b.NODE_ENV !== "production" && o.directives[c] && I(`Directive "${c}" has already been registered in target app.`), o.directives[c] = d, u) : o.directives[c];
      },
      mount(c, d, m) {
        if (l)
          b.NODE_ENV !== "production" && I(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          b.NODE_ENV !== "production" && c.__vue_app__ && I(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const h = u._ceVNode || w(n, i);
          return h.appContext = o, m === !0 ? m = "svg" : m === !1 && (m = void 0), b.NODE_ENV !== "production" && (o.reload = () => {
            const g = kt(h);
            g.el = null, t(g, c, m);
          }), t(h, c, m), l = !0, u._container = c, c.__vue_app__ = u, b.NODE_ENV !== "production" && (u._instance = h.component, Ec(u, Xo)), ri(h.component);
        }
      },
      onUnmount(c) {
        b.NODE_ENV !== "production" && typeof c != "function" && I(
          `Expected function as first argument to app.onUnmount(), but got ${typeof c}`
        ), a.push(c);
      },
      unmount() {
        l ? (Tt(
          a,
          u._instance,
          16
        ), t(null, u._container), b.NODE_ENV !== "production" && (u._instance = null, yc(u)), delete u._container.__vue_app__) : b.NODE_ENV !== "production" && I("Cannot unmount an app that is not mounted.");
      },
      provide(c, d) {
        return b.NODE_ENV !== "production" && c in o.provides && (Ee(o.provides, c) ? I(
          `App already provides property with key "${String(c)}". It will be overwritten with the new value.`
        ) : I(
          `App already provides property with key "${String(c)}" inherited from its parent element. It will be overwritten with the new value.`
        )), o.provides[c] = d, u;
      },
      runWithContext(c) {
        const d = Ds;
        Ds = u;
        try {
          return c();
        } finally {
          Ds = d;
        }
      }
    };
    return u;
  };
}
let Ds = null;
function io(t, e, s = ye) {
  const n = oi();
  if (b.NODE_ENV !== "production" && !n)
    return I("useModel() called without active instance."), /* @__PURE__ */ H();
  const i = ut(e);
  if (b.NODE_ENV !== "production" && !n.propsOptions[0][i])
    return I(`useModel() called with prop "${e}" which is not declared.`), /* @__PURE__ */ H();
  const o = Gt(e), r = Aa(t, i), a = sc((l, u) => {
    let c, d = ye, m;
    return $c(() => {
      const h = t[i];
      st(c, h) && (c = h, u());
    }), {
      get() {
        return l(), s.get ? s.get(c) : c;
      },
      set(h) {
        const g = s.set ? s.set(h) : h;
        if (!st(g, c) && !(d !== ye && st(h, d)))
          return;
        const E = n.vnode.props;
        E && // check if parent has passed v-model
        (e in E || i in E || o in E) && (`onUpdate:${e}` in E || `onUpdate:${i}` in E || `onUpdate:${o}` in E) || (c = h, u()), n.emit(`update:${e}`, g), st(h, g) && st(h, d) && !st(g, m) && u(), d = h, m = g;
      }
    };
  });
  return a[Symbol.iterator] = () => {
    let l = 0;
    return {
      next() {
        return l < 2 ? { value: l++ ? r || ye : a, done: !1 } : { done: !0 };
      }
    };
  }, a;
}
const Aa = (t, e) => e === "modelValue" || e === "model-value" ? t.modelModifiers : t[`${e}Modifiers`] || t[`${ut(e)}Modifiers`] || t[`${Gt(e)}Modifiers`];
function iu(t, e, ...s) {
  if (t.isUnmounted) return;
  const n = t.vnode.props || ye;
  if (b.NODE_ENV !== "production") {
    const {
      emitsOptions: c,
      propsOptions: [d]
    } = t;
    if (c)
      if (!(e in c))
        (!d || !(cs(ut(e)) in d)) && I(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${cs(ut(e))}" prop.`
        );
      else {
        const m = c[e];
        Z(m) && (m(...s) || I(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let i = s;
  const o = e.startsWith("update:"), r = o && Aa(n, e.slice(7));
  if (r && (r.trim && (i = s.map((c) => Me(c) ? c.trim() : c)), r.number && (i = s.map(Jn))), b.NODE_ENV !== "production" && Cc(t, e, i), b.NODE_ENV !== "production") {
    const c = e.toLowerCase();
    c !== e && n[cs(c)] && I(
      `Event "${c}" is emitted in component ${vn(
        t,
        t.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Gt(
        e
      )}" instead of "${e}".`
    );
  }
  let a, l = n[a = cs(e)] || // also try camelCase event handler (#2249)
  n[a = cs(ut(e))];
  !l && o && (l = n[a = cs(Gt(e))]), l && Tt(
    l,
    t,
    6,
    i
  );
  const u = n[a + "Once"];
  if (u) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[a])
      return;
    t.emitted[a] = !0, Tt(
      u,
      t,
      6,
      i
    );
  }
}
const ou = /* @__PURE__ */ new WeakMap();
function Va(t, e, s = !1) {
  const n = s ? ou : e.emitsCache, i = n.get(t);
  if (i !== void 0)
    return i;
  const o = t.emits;
  let r = {}, a = !1;
  if (!Z(t)) {
    const l = (u) => {
      const c = Va(u, e, !0);
      c && (a = !0, Ve(r, c));
    };
    !s && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l);
  }
  return !o && !a ? (ve(t) && n.set(t, null), null) : (z(o) ? o.forEach((l) => r[l] = null) : Ve(r, o), ve(t) && n.set(t, r), r);
}
function ii(t, e) {
  return !t || !an(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Ee(t, e[0].toLowerCase() + e.slice(1)) || Ee(t, Gt(e)) || Ee(t, e));
}
let Li = !1;
function Hn() {
  Li = !0;
}
function jo(t) {
  const {
    type: e,
    vnode: s,
    proxy: n,
    withProxy: i,
    propsOptions: [o],
    slots: r,
    attrs: a,
    emit: l,
    render: u,
    renderCache: c,
    props: d,
    data: m,
    setupState: h,
    ctx: g,
    inheritAttrs: E
  } = t, y = Fn(t);
  let T, N;
  b.NODE_ENV !== "production" && (Li = !1);
  try {
    if (s.shapeFlag & 4) {
      const R = i || n, U = b.NODE_ENV !== "production" && h.__isScriptSetup ? new Proxy(R, {
        get(le, he, W) {
          return I(
            `Property '${String(
              he
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(le, he, W);
        }
      }) : R;
      T = ft(
        u.call(
          U,
          R,
          c,
          b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(d) : d,
          h,
          m,
          g
        )
      ), N = a;
    } else {
      const R = e;
      b.NODE_ENV !== "production" && a === d && Hn(), T = ft(
        R.length > 1 ? R(
          b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(d) : d,
          b.NODE_ENV !== "production" ? {
            get attrs() {
              return Hn(), /* @__PURE__ */ Vt(a);
            },
            slots: r,
            emit: l
          } : { attrs: a, slots: r, emit: l }
        ) : R(
          b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(d) : d,
          null
        )
      ), N = e.props ? a : ru(a);
    }
  } catch (R) {
    Qs.length = 0, un(R, t, 1), T = w(Be);
  }
  let _ = T, C;
  if (b.NODE_ENV !== "production" && T.patchFlag > 0 && T.patchFlag & 2048 && ([_, C] = Ma(T)), N && E !== !1) {
    const R = Object.keys(N), { shapeFlag: U } = _;
    if (R.length) {
      if (U & 7)
        o && R.some(In) && (N = au(
          N,
          o
        )), _ = kt(_, N, !1, !0);
      else if (b.NODE_ENV !== "production" && !Li && _.type !== Be) {
        const le = Object.keys(a), he = [], W = [];
        for (let re = 0, me = le.length; re < me; re++) {
          const D = le[re];
          an(D) ? In(D) || he.push(D[2].toLowerCase() + D.slice(3)) : W.push(D);
        }
        W.length && I(
          `Extraneous non-props attributes (${W.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
        ), he.length && I(
          `Extraneous non-emits event listeners (${he.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return s.dirs && (b.NODE_ENV !== "production" && !qo(_) && I(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), _ = kt(_, null, !1, !0), _.dirs = _.dirs ? _.dirs.concat(s.dirs) : s.dirs), s.transition && (b.NODE_ENV !== "production" && !qo(_) && I(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), tn(_, s.transition)), b.NODE_ENV !== "production" && C ? C(_) : T = _, Fn(y), T;
}
const Ma = (t) => {
  const e = t.children, s = t.dynamicChildren, n = oo(e, !1);
  if (n) {
    if (b.NODE_ENV !== "production" && n.patchFlag > 0 && n.patchFlag & 2048)
      return Ma(n);
  } else return [t, void 0];
  const i = e.indexOf(n), o = s ? s.indexOf(n) : -1, r = (a) => {
    e[i] = a, s && (o > -1 ? s[o] = a : a.patchFlag > 0 && (t.dynamicChildren = [...s, a]));
  };
  return [ft(n), r];
};
function oo(t, e = !0) {
  let s;
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    if (Es(i)) {
      if (i.type !== Be || i.children === "v-if") {
        if (s)
          return;
        if (s = i, b.NODE_ENV !== "production" && e && s.patchFlag > 0 && s.patchFlag & 2048)
          return oo(s.children);
      }
    } else
      return;
  }
  return s;
}
const ru = (t) => {
  let e;
  for (const s in t)
    (s === "class" || s === "style" || an(s)) && ((e || (e = {}))[s] = t[s]);
  return e;
}, au = (t, e) => {
  const s = {};
  for (const n in t)
    (!In(n) || !(n.slice(9) in e)) && (s[n] = t[n]);
  return s;
}, qo = (t) => t.shapeFlag & 7 || t.type === Be;
function lu(t, e, s) {
  const { props: n, children: i, component: o } = t, { props: r, children: a, patchFlag: l } = e, u = o.emitsOptions;
  if (b.NODE_ENV !== "production" && (i || a) && pt || e.dirs || e.transition)
    return !0;
  if (s && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return n ? Ho(n, r, u) : !!r;
    if (l & 8) {
      const c = e.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        const m = c[d];
        if (Ia(r, n, m) && !ii(u, m))
          return !0;
      }
    }
  } else
    return (i || a) && (!a || !a.$stable) ? !0 : n === r ? !1 : n ? r ? Ho(n, r, u) : !0 : !!r;
  return !1;
}
function Ho(t, e, s) {
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !0;
  for (let i = 0; i < n.length; i++) {
    const o = n[i];
    if (Ia(e, t, o) && !ii(s, o))
      return !0;
  }
  return !1;
}
function Ia(t, e, s) {
  const n = t[s], i = e[s];
  return s === "style" && ve(n) && ve(i) ? !Is(n, i) : n !== i;
}
function cu({ vnode: t, parent: e }, s) {
  for (; e; ) {
    const n = e.subTree;
    if (n.suspense && n.suspense.activeBranch === t && (n.el = t.el), n === t)
      (t = e.vnode).el = s, e = e.parent;
    else
      break;
  }
}
const Ra = {}, La = () => Object.create(Ra), ka = (t) => Object.getPrototypeOf(t) === Ra;
function uu(t, e, s, n = !1) {
  const i = {}, o = La();
  t.propsDefaults = /* @__PURE__ */ Object.create(null), Pa(t, e, i, o);
  for (const r in t.propsOptions[0])
    r in i || (i[r] = void 0);
  b.NODE_ENV !== "production" && Fa(e || {}, i, t), s ? t.props = n ? i : /* @__PURE__ */ Ql(i) : t.type.props ? t.props = i : t.props = o, t.attrs = o;
}
function du(t) {
  for (; t; ) {
    if (t.type.__hmrId) return !0;
    t = t.parent;
  }
}
function fu(t, e, s, n) {
  const {
    props: i,
    attrs: o,
    vnode: { patchFlag: r }
  } = t, a = /* @__PURE__ */ ue(i), [l] = t.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(b.NODE_ENV !== "production" && du(t)) && (n || r > 0) && !(r & 16)
  ) {
    if (r & 8) {
      const c = t.vnode.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        let m = c[d];
        if (ii(t.emitsOptions, m))
          continue;
        const h = e[m];
        if (l)
          if (Ee(o, m))
            h !== o[m] && (o[m] = h, u = !0);
          else {
            const g = ut(m);
            i[g] = ki(
              l,
              a,
              g,
              h,
              t,
              !1
            );
          }
        else
          h !== o[m] && (o[m] = h, u = !0);
      }
    }
  } else {
    Pa(t, e, i, o) && (u = !0);
    let c;
    for (const d in a)
      (!e || // for camelCase
      !Ee(e, d) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((c = Gt(d)) === d || !Ee(e, c))) && (l ? s && // for camelCase
      (s[d] !== void 0 || // for kebab-case
      s[c] !== void 0) && (i[d] = ki(
        l,
        a,
        d,
        void 0,
        t,
        !0
      )) : delete i[d]);
    if (o !== a)
      for (const d in o)
        (!e || !Ee(e, d)) && (delete o[d], u = !0);
  }
  u && $t(t.attrs, "set", ""), b.NODE_ENV !== "production" && Fa(e || {}, i, t);
}
function Pa(t, e, s, n) {
  const [i, o] = t.propsOptions;
  let r = !1, a;
  if (e)
    for (let l in e) {
      if (Ws(l))
        continue;
      const u = e[l];
      let c;
      i && Ee(i, c = ut(l)) ? !o || !o.includes(c) ? s[c] = u : (a || (a = {}))[c] = u : ii(t.emitsOptions, l) || (!(l in n) || u !== n[l]) && (n[l] = u, r = !0);
    }
  if (o) {
    const l = /* @__PURE__ */ ue(s), u = a || ye;
    for (let c = 0; c < o.length; c++) {
      const d = o[c];
      s[d] = ki(
        i,
        l,
        d,
        u[d],
        t,
        !Ee(u, d)
      );
    }
  }
  return r;
}
function ki(t, e, s, n, i, o) {
  const r = t[s];
  if (r != null) {
    const a = Ee(r, "default");
    if (a && n === void 0) {
      const l = r.default;
      if (r.type !== Function && !r.skipFactory && Z(l)) {
        const { propsDefaults: u } = i;
        if (s in u)
          n = u[s];
        else {
          const c = mn(i);
          n = u[s] = l.call(
            null,
            e
          ), c();
        }
      } else
        n = l;
      i.ce && i.ce._setProp(s, n);
    }
    r[
      0
      /* shouldCast */
    ] && (o && !a ? n = !1 : r[
      1
      /* shouldCastTrue */
    ] && (n === "" || n === Gt(s)) && (n = !0));
  }
  return n;
}
const pu = /* @__PURE__ */ new WeakMap();
function Ba(t, e, s = !1) {
  const n = s ? pu : e.propsCache, i = n.get(t);
  if (i)
    return i;
  const o = t.props, r = {}, a = [];
  let l = !1;
  if (!Z(t)) {
    const c = (d) => {
      l = !0;
      const [m, h] = Ba(d, e, !0);
      Ve(r, m), h && a.push(...h);
    };
    !s && e.mixins.length && e.mixins.forEach(c), t.extends && c(t.extends), t.mixins && t.mixins.forEach(c);
  }
  if (!o && !l)
    return ve(t) && n.set(t, Ss), Ss;
  if (z(o))
    for (let c = 0; c < o.length; c++) {
      b.NODE_ENV !== "production" && !Me(o[c]) && I("props must be strings when using array syntax.", o[c]);
      const d = ut(o[c]);
      Wo(d) && (r[d] = ye);
    }
  else if (o) {
    b.NODE_ENV !== "production" && !ve(o) && I("invalid props options", o);
    for (const c in o) {
      const d = ut(c);
      if (Wo(d)) {
        const m = o[c], h = r[d] = z(m) || Z(m) ? { type: m } : Ve({}, m), g = h.type;
        let E = !1, y = !0;
        if (z(g))
          for (let T = 0; T < g.length; ++T) {
            const N = g[T], _ = Z(N) && N.name;
            if (_ === "Boolean") {
              E = !0;
              break;
            } else _ === "String" && (y = !1);
          }
        else
          E = Z(g) && g.name === "Boolean";
        h[
          0
          /* shouldCast */
        ] = E, h[
          1
          /* shouldCastTrue */
        ] = y, (E || Ee(h, "default")) && a.push(d);
      }
    }
  }
  const u = [r, a];
  return ve(t) && n.set(t, u), u;
}
function Wo(t) {
  return t[0] !== "$" && !Ws(t) ? !0 : (b.NODE_ENV !== "production" && I(`Invalid prop name: "${t}" is a reserved property.`), !1);
}
function hu(t) {
  return t === null ? "null" : typeof t == "function" ? t.name || "" : typeof t == "object" && t.constructor && t.constructor.name || "";
}
function Fa(t, e, s) {
  const n = /* @__PURE__ */ ue(e), i = s.propsOptions[0], o = Object.keys(t).map((r) => ut(r));
  for (const r in i) {
    let a = i[r];
    a != null && mu(
      r,
      n[r],
      a,
      b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(n) : n,
      !o.includes(r)
    );
  }
}
function mu(t, e, s, n, i) {
  const { type: o, required: r, validator: a, skipCheck: l } = s;
  if (r && i) {
    I('Missing required prop: "' + t + '"');
    return;
  }
  if (!(e == null && !r)) {
    if (o != null && o !== !0 && !l) {
      let u = !1;
      const c = z(o) ? o : [o], d = [];
      for (let m = 0; m < c.length && !u; m++) {
        const { valid: h, expectedType: g } = bu(e, c[m]);
        d.push(g || ""), u = h;
      }
      if (!u) {
        I(gu(t, e, d));
        return;
      }
    }
    a && !a(e, n) && I('Invalid prop: custom validator check failed for prop "' + t + '".');
  }
}
const vu = /* @__PURE__ */ Yt(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function bu(t, e) {
  let s;
  const n = hu(e);
  if (n === "null")
    s = t === null;
  else if (vu(n)) {
    const i = typeof t;
    s = i === n.toLowerCase(), !s && i === "object" && (s = t instanceof e);
  } else n === "Object" ? s = ve(t) : n === "Array" ? s = z(t) : s = t instanceof e;
  return {
    valid: s,
    expectedType: n
  };
}
function gu(t, e, s) {
  if (s.length === 0)
    return `Prop type [] for prop "${t}" won't match anything. Did you mean to use type Array instead?`;
  let n = `Invalid prop: type check failed for prop "${t}". Expected ${s.map(Qn).join(" | ")}`;
  const i = s[0], o = Ki(e), r = Ko(e, i), a = Ko(e, o);
  return s.length === 1 && zo(i) && !Eu(i, o) && (n += ` with value ${r}`), n += `, got ${o} `, zo(o) && (n += `with value ${a}.`), n;
}
function Ko(t, e) {
  return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`;
}
function zo(t) {
  return ["string", "number", "boolean"].some((s) => t.toLowerCase() === s);
}
function Eu(...t) {
  return t.some((e) => e.toLowerCase() === "boolean");
}
const ro = (t) => t === "_" || t === "_ctx" || t === "$stable", ao = (t) => z(t) ? t.map(ft) : [ft(t)], yu = (t, e, s) => {
  if (e._n)
    return e;
  const n = B((...i) => (b.NODE_ENV !== "production" && Ue && !(s === null && He) && !(s && s.root !== Ue.root) && I(
    `Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), ao(e(...i))), s);
  return n._c = !1, n;
}, Ua = (t, e, s) => {
  const n = t._ctx;
  for (const i in t) {
    if (ro(i)) continue;
    const o = t[i];
    if (Z(o))
      e[i] = yu(i, o, n);
    else if (o != null) {
      b.NODE_ENV !== "production" && I(
        `Non-function value encountered for slot "${i}". Prefer function slots for better performance.`
      );
      const r = ao(o);
      e[i] = () => r;
    }
  }
}, ja = (t, e) => {
  b.NODE_ENV !== "production" && !fn(t.vnode) && I(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const s = ao(e);
  t.slots.default = () => s;
}, Pi = (t, e, s) => {
  for (const n in e)
    (s || !ro(n)) && (t[n] = e[n]);
}, _u = (t, e, s) => {
  const n = t.slots = La();
  if (t.vnode.shapeFlag & 32) {
    const i = e._;
    i ? (Pi(n, e, s), s && Rn(n, "_", i, !0)) : Ua(e, n);
  } else e && ja(t, e);
}, Tu = (t, e, s) => {
  const { vnode: n, slots: i } = t;
  let o = !0, r = ye;
  if (n.shapeFlag & 32) {
    const a = e._;
    a ? b.NODE_ENV !== "production" && pt ? (Pi(i, e, s), $t(t, "set", "$slots")) : s && a === 1 ? o = !1 : Pi(i, e, s) : (o = !e.$stable, Ua(e, i)), r = e;
  } else e && (ja(t, e), r = { default: 1 });
  if (o)
    for (const a in i)
      !ro(a) && r[a] == null && delete i[a];
};
let Us, jt;
function _s(t, e) {
  t.appContext.config.performance && Wn() && jt.mark(`vue-${e}-${t.uid}`), b.NODE_ENV !== "production" && xc(t, e, Wn() ? jt.now() : Date.now());
}
function Ts(t, e) {
  if (t.appContext.config.performance && Wn()) {
    const s = `vue-${e}-${t.uid}`, n = s + ":end", i = `<${vn(t, t.type)}> ${e}`;
    jt.mark(n), jt.measure(i, s, n), jt.clearMeasures(i), jt.clearMarks(s), jt.clearMarks(n);
  }
  b.NODE_ENV !== "production" && Sc(t, e, Wn() ? jt.now() : Date.now());
}
function Wn() {
  return Us !== void 0 || (typeof window < "u" && window.performance ? (Us = !0, jt = window.performance) : Us = !1), Us;
}
function Nu() {
  const t = [];
  if (b.NODE_ENV !== "production" && t.length) {
    const e = t.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${t.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const ze = Du;
function xu(t) {
  return Su(t);
}
function Su(t, e) {
  Nu();
  const s = cn();
  s.__VUE__ = !0, b.NODE_ENV !== "production" && ca(s.__VUE_DEVTOOLS_GLOBAL_HOOK__, s);
  const {
    insert: n,
    remove: i,
    patchProp: o,
    createElement: r,
    createText: a,
    createComment: l,
    setText: u,
    setElementText: c,
    parentNode: d,
    nextSibling: m,
    setScopeId: h = qe,
    insertStaticContent: g
  } = t, E = (p, v, x, M = null, O = null, A = null, j = void 0, F = null, P = b.NODE_ENV !== "production" && pt ? !1 : !!v.dynamicChildren) => {
    if (p === v)
      return;
    p && !fs(p, v) && (M = gn(p), dt(p, O, A, !0), p = null), v.patchFlag === -2 && (P = !1, v.dynamicChildren = null);
    const { type: V, ref: X, shapeFlag: q } = v;
    switch (V) {
      case hn:
        y(p, v, x, M);
        break;
      case Be:
        T(p, v, x, M);
        break;
      case An:
        p == null ? N(v, x, M, j) : b.NODE_ENV !== "production" && _(p, v, x, j);
        break;
      case Ae:
        K(
          p,
          v,
          x,
          M,
          O,
          A,
          j,
          F,
          P
        );
        break;
      default:
        q & 1 ? U(
          p,
          v,
          x,
          M,
          O,
          A,
          j,
          F,
          P
        ) : q & 6 ? oe(
          p,
          v,
          x,
          M,
          O,
          A,
          j,
          F,
          P
        ) : q & 64 || q & 128 ? V.process(
          p,
          v,
          x,
          M,
          O,
          A,
          j,
          F,
          P,
          ks
        ) : b.NODE_ENV !== "production" && I("Invalid VNode type:", V, `(${typeof V})`);
    }
    X != null && O ? Gs(X, p && p.ref, A, v || p, !v) : X == null && p && p.ref != null && Gs(p.ref, null, A, p, !0);
  }, y = (p, v, x, M) => {
    if (p == null)
      n(
        v.el = a(v.children),
        x,
        M
      );
    else {
      const O = v.el = p.el;
      v.children !== p.children && u(O, v.children);
    }
  }, T = (p, v, x, M) => {
    p == null ? n(
      v.el = l(v.children || ""),
      x,
      M
    ) : v.el = p.el;
  }, N = (p, v, x, M) => {
    [p.el, p.anchor] = g(
      p.children,
      v,
      x,
      M,
      p.el,
      p.anchor
    );
  }, _ = (p, v, x, M) => {
    if (v.children !== p.children) {
      const O = m(p.anchor);
      R(p), [v.el, v.anchor] = g(
        v.children,
        x,
        O,
        M
      );
    } else
      v.el = p.el, v.anchor = p.anchor;
  }, C = ({ el: p, anchor: v }, x, M) => {
    let O;
    for (; p && p !== v; )
      O = m(p), n(p, x, M), p = O;
    n(v, x, M);
  }, R = ({ el: p, anchor: v }) => {
    let x;
    for (; p && p !== v; )
      x = m(p), i(p), p = x;
    i(v);
  }, U = (p, v, x, M, O, A, j, F, P) => {
    if (v.type === "svg" ? j = "svg" : v.type === "math" && (j = "mathml"), p == null)
      le(
        v,
        x,
        M,
        O,
        A,
        j,
        F,
        P
      );
    else {
      const V = p.el && p.el._isVueCE ? p.el : null;
      try {
        V && V._beginPatch(), re(
          p,
          v,
          O,
          A,
          j,
          F,
          P
        );
      } finally {
        V && V._endPatch();
      }
    }
  }, le = (p, v, x, M, O, A, j, F) => {
    let P, V;
    const { props: X, shapeFlag: q, transition: G, dirs: ie } = p;
    if (P = p.el = r(
      p.type,
      A,
      X && X.is,
      X
    ), q & 8 ? c(P, p.children) : q & 16 && W(
      p.children,
      P,
      null,
      M,
      O,
      yi(p, A),
      j,
      F
    ), ie && os(p, null, M, "created"), he(P, p, p.scopeId, j, M), X) {
      for (const we in X)
        we !== "value" && !Ws(we) && o(P, we, null, X[we], A, M);
      "value" in X && o(P, "value", null, X.value, A), (V = X.onVnodeBeforeMount) && wt(V, M, p);
    }
    b.NODE_ENV !== "production" && (Rn(P, "__vnode", p, !0), Rn(P, "__vueParentComponent", M, !0)), ie && os(p, null, M, "beforeMount");
    const ge = Cu(O, G);
    ge && G.beforeEnter(P), n(P, v, x), ((V = X && X.onVnodeMounted) || ge || ie) && ze(() => {
      V && wt(V, M, p), ge && G.enter(P), ie && os(p, null, M, "mounted");
    }, O);
  }, he = (p, v, x, M, O) => {
    if (x && h(p, x), M)
      for (let A = 0; A < M.length; A++)
        h(p, M[A]);
    if (O) {
      let A = O.subTree;
      if (b.NODE_ENV !== "production" && A.patchFlag > 0 && A.patchFlag & 2048 && (A = oo(A.children) || A), v === A || Wa(A.type) && (A.ssContent === v || A.ssFallback === v)) {
        const j = O.vnode;
        he(
          p,
          j,
          j.scopeId,
          j.slotScopeIds,
          O.parent
        );
      }
    }
  }, W = (p, v, x, M, O, A, j, F, P = 0) => {
    for (let V = P; V < p.length; V++) {
      const X = p[V] = F ? qt(p[V]) : ft(p[V]);
      E(
        null,
        X,
        v,
        x,
        M,
        O,
        A,
        j,
        F
      );
    }
  }, re = (p, v, x, M, O, A, j) => {
    const F = v.el = p.el;
    b.NODE_ENV !== "production" && (F.__vnode = v);
    let { patchFlag: P, dynamicChildren: V, dirs: X } = v;
    P |= p.patchFlag & 16;
    const q = p.props || ye, G = v.props || ye;
    let ie;
    if (x && rs(x, !1), (ie = G.onVnodeBeforeUpdate) && wt(ie, x, v, p), X && os(v, p, x, "beforeUpdate"), x && rs(x, !0), b.NODE_ENV !== "production" && pt && (P = 0, j = !1, V = null), (q.innerHTML && G.innerHTML == null || q.textContent && G.textContent == null) && c(F, ""), V ? (me(
      p.dynamicChildren,
      V,
      F,
      x,
      M,
      yi(v, O),
      A
    ), b.NODE_ENV !== "production" && Ys(p, v)) : j || J(
      p,
      v,
      F,
      null,
      x,
      M,
      yi(v, O),
      A,
      !1
    ), P > 0) {
      if (P & 16)
        D(F, q, G, x, O);
      else if (P & 2 && q.class !== G.class && o(F, "class", null, G.class, O), P & 4 && o(F, "style", q.style, G.style, O), P & 8) {
        const ge = v.dynamicProps;
        for (let we = 0; we < ge.length; we++) {
          const xe = ge[we], Ze = q[xe], et = G[xe];
          (et !== Ze || xe === "value") && o(F, xe, Ze, et, O, x);
        }
      }
      P & 1 && p.children !== v.children && c(F, v.children);
    } else !j && V == null && D(F, q, G, x, O);
    ((ie = G.onVnodeUpdated) || X) && ze(() => {
      ie && wt(ie, x, v, p), X && os(v, p, x, "updated");
    }, M);
  }, me = (p, v, x, M, O, A, j) => {
    for (let F = 0; F < v.length; F++) {
      const P = p[F], V = v[F], X = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        P.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (P.type === Ae || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !fs(P, V) || // - In the case of a component, it could contain anything.
        P.shapeFlag & 198) ? d(P.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          x
        )
      );
      E(
        P,
        V,
        X,
        null,
        M,
        O,
        A,
        j,
        !0
      );
    }
  }, D = (p, v, x, M, O) => {
    if (v !== x) {
      if (v !== ye)
        for (const A in v)
          !Ws(A) && !(A in x) && o(
            p,
            A,
            v[A],
            null,
            O,
            M
          );
      for (const A in x) {
        if (Ws(A)) continue;
        const j = x[A], F = v[A];
        j !== F && A !== "value" && o(p, A, F, j, O, M);
      }
      "value" in x && o(p, "value", v.value, x.value, O);
    }
  }, K = (p, v, x, M, O, A, j, F, P) => {
    const V = v.el = p ? p.el : a(""), X = v.anchor = p ? p.anchor : a("");
    let { patchFlag: q, dynamicChildren: G, slotScopeIds: ie } = v;
    b.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (pt || q & 2048) && (q = 0, P = !1, G = null), ie && (F = F ? F.concat(ie) : ie), p == null ? (n(V, x, M), n(X, x, M), W(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      v.children || [],
      x,
      X,
      O,
      A,
      j,
      F,
      P
    )) : q > 0 && q & 64 && G && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    p.dynamicChildren && p.dynamicChildren.length === G.length ? (me(
      p.dynamicChildren,
      G,
      x,
      O,
      A,
      j,
      F
    ), b.NODE_ENV !== "production" ? Ys(p, v) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (v.key != null || O && v === O.subTree) && Ys(
        p,
        v,
        !0
        /* shallow */
      )
    )) : J(
      p,
      v,
      x,
      X,
      O,
      A,
      j,
      F,
      P
    );
  }, oe = (p, v, x, M, O, A, j, F, P) => {
    v.slotScopeIds = F, p == null ? v.shapeFlag & 512 ? O.ctx.activate(
      v,
      x,
      M,
      j,
      P
    ) : be(
      v,
      x,
      M,
      O,
      A,
      j,
      P
    ) : pe(p, v, P);
  }, be = (p, v, x, M, O, A, j) => {
    const F = p.component = Ru(
      p,
      M,
      O
    );
    if (b.NODE_ENV !== "production" && F.type.__hmrId && mc(F), b.NODE_ENV !== "production" && (Cn(p), _s(F, "mount")), fn(p) && (F.ctx.renderer = ks), b.NODE_ENV !== "production" && _s(F, "init"), ku(F, !1, j), b.NODE_ENV !== "production" && Ts(F, "init"), b.NODE_ENV !== "production" && pt && (p.el = null), F.asyncDep) {
      if (O && O.registerDep(F, ce, j), !p.el) {
        const P = F.subTree = w(Be);
        T(null, P, v, x), p.placeholder = P.el;
      }
    } else
      ce(
        F,
        p,
        v,
        x,
        O,
        A,
        j
      );
    b.NODE_ENV !== "production" && (wn(), Ts(F, "mount"));
  }, pe = (p, v, x) => {
    const M = v.component = p.component;
    if (lu(p, v, x))
      if (M.asyncDep && !M.asyncResolved) {
        b.NODE_ENV !== "production" && Cn(v), fe(M, v, x), b.NODE_ENV !== "production" && wn();
        return;
      } else
        M.next = v, M.update();
    else
      v.el = p.el, M.vnode = v;
  }, ce = (p, v, x, M, O, A, j) => {
    const F = () => {
      if (p.isMounted) {
        let { next: q, bu: G, u: ie, parent: ge, vnode: we } = p;
        {
          const St = qa(p);
          if (St) {
            q && (q.el = we.el, fe(p, q, j)), St.asyncDep.then(() => {
              ze(() => {
                p.isUnmounted || V();
              }, O);
            });
            return;
          }
        }
        let xe = q, Ze;
        b.NODE_ENV !== "production" && Cn(q || p.vnode), rs(p, !1), q ? (q.el = we.el, fe(p, q, j)) : q = we, G && Ns(G), (Ze = q.props && q.props.onVnodeBeforeUpdate) && wt(Ze, ge, q, we), rs(p, !0), b.NODE_ENV !== "production" && _s(p, "render");
        const et = jo(p);
        b.NODE_ENV !== "production" && Ts(p, "render");
        const xt = p.subTree;
        p.subTree = et, b.NODE_ENV !== "production" && _s(p, "patch"), E(
          xt,
          et,
          // parent may have changed if it's in a teleport
          d(xt.el),
          // anchor may have changed if it's in a fragment
          gn(xt),
          p,
          O,
          A
        ), b.NODE_ENV !== "production" && Ts(p, "patch"), q.el = et.el, xe === null && cu(p, et.el), ie && ze(ie, O), (Ze = q.props && q.props.onVnodeUpdated) && ze(
          () => wt(Ze, ge, q, we),
          O
        ), b.NODE_ENV !== "production" && ua(p), b.NODE_ENV !== "production" && wn();
      } else {
        let q;
        const { el: G, props: ie } = v, { bm: ge, m: we, parent: xe, root: Ze, type: et } = p, xt = ws(v);
        rs(p, !1), ge && Ns(ge), !xt && (q = ie && ie.onVnodeBeforeMount) && wt(q, xe, v), rs(p, !0);
        {
          Ze.ce && Ze.ce._hasShadowRoot() && Ze.ce._injectChildStyle(et), b.NODE_ENV !== "production" && _s(p, "render");
          const St = p.subTree = jo(p);
          b.NODE_ENV !== "production" && Ts(p, "render"), b.NODE_ENV !== "production" && _s(p, "patch"), E(
            null,
            St,
            x,
            M,
            p,
            O,
            A
          ), b.NODE_ENV !== "production" && Ts(p, "patch"), v.el = St.el;
        }
        if (we && ze(we, O), !xt && (q = ie && ie.onVnodeMounted)) {
          const St = v;
          ze(
            () => wt(q, xe, St),
            O
          );
        }
        (v.shapeFlag & 256 || xe && ws(xe.vnode) && xe.vnode.shapeFlag & 256) && p.a && ze(p.a, O), p.isMounted = !0, b.NODE_ENV !== "production" && _c(p), v = x = M = null;
      }
    };
    p.scope.on();
    const P = p.effect = new Br(F);
    p.scope.off();
    const V = p.update = P.run.bind(P), X = p.job = P.runIfDirty.bind(P);
    X.i = p, X.id = p.uid, P.scheduler = () => si(X), rs(p, !0), b.NODE_ENV !== "production" && (P.onTrack = p.rtc ? (q) => Ns(p.rtc, q) : void 0, P.onTrigger = p.rtg ? (q) => Ns(p.rtg, q) : void 0), V();
  }, fe = (p, v, x) => {
    v.component = p;
    const M = p.vnode.props;
    p.vnode = v, p.next = null, fu(p, v.props, M, x), Tu(p, v.children, x), gt(), $o(p), Et();
  }, J = (p, v, x, M, O, A, j, F, P = !1) => {
    const V = p && p.children, X = p ? p.shapeFlag : 0, q = v.children, { patchFlag: G, shapeFlag: ie } = v;
    if (G > 0) {
      if (G & 128) {
        Oe(
          V,
          q,
          x,
          M,
          O,
          A,
          j,
          F,
          P
        );
        return;
      } else if (G & 256) {
        k(
          V,
          q,
          x,
          M,
          O,
          A,
          j,
          F,
          P
        );
        return;
      }
    }
    ie & 8 ? (X & 16 && Ls(V, O, A), q !== V && c(x, q)) : X & 16 ? ie & 16 ? Oe(
      V,
      q,
      x,
      M,
      O,
      A,
      j,
      F,
      P
    ) : Ls(V, O, A, !0) : (X & 8 && c(x, ""), ie & 16 && W(
      q,
      x,
      M,
      O,
      A,
      j,
      F,
      P
    ));
  }, k = (p, v, x, M, O, A, j, F, P) => {
    p = p || Ss, v = v || Ss;
    const V = p.length, X = v.length, q = Math.min(V, X);
    let G;
    for (G = 0; G < q; G++) {
      const ie = v[G] = P ? qt(v[G]) : ft(v[G]);
      E(
        p[G],
        ie,
        x,
        null,
        O,
        A,
        j,
        F,
        P
      );
    }
    V > X ? Ls(
      p,
      O,
      A,
      !0,
      !1,
      q
    ) : W(
      v,
      x,
      M,
      O,
      A,
      j,
      F,
      P,
      q
    );
  }, Oe = (p, v, x, M, O, A, j, F, P) => {
    let V = 0;
    const X = v.length;
    let q = p.length - 1, G = X - 1;
    for (; V <= q && V <= G; ) {
      const ie = p[V], ge = v[V] = P ? qt(v[V]) : ft(v[V]);
      if (fs(ie, ge))
        E(
          ie,
          ge,
          x,
          null,
          O,
          A,
          j,
          F,
          P
        );
      else
        break;
      V++;
    }
    for (; V <= q && V <= G; ) {
      const ie = p[q], ge = v[G] = P ? qt(v[G]) : ft(v[G]);
      if (fs(ie, ge))
        E(
          ie,
          ge,
          x,
          null,
          O,
          A,
          j,
          F,
          P
        );
      else
        break;
      q--, G--;
    }
    if (V > q) {
      if (V <= G) {
        const ie = G + 1, ge = ie < X ? v[ie].el : M;
        for (; V <= G; )
          E(
            null,
            v[V] = P ? qt(v[V]) : ft(v[V]),
            x,
            ge,
            O,
            A,
            j,
            F,
            P
          ), V++;
      }
    } else if (V > G)
      for (; V <= q; )
        dt(p[V], O, A, !0), V++;
    else {
      const ie = V, ge = V, we = /* @__PURE__ */ new Map();
      for (V = ge; V <= G; V++) {
        const Ye = v[V] = P ? qt(v[V]) : ft(v[V]);
        Ye.key != null && (b.NODE_ENV !== "production" && we.has(Ye.key) && I(
          "Duplicate keys found during update:",
          JSON.stringify(Ye.key),
          "Make sure keys are unique."
        ), we.set(Ye.key, V));
      }
      let xe, Ze = 0;
      const et = G - ge + 1;
      let xt = !1, St = 0;
      const Ps = new Array(et);
      for (V = 0; V < et; V++) Ps[V] = 0;
      for (V = ie; V <= q; V++) {
        const Ye = p[V];
        if (Ze >= et) {
          dt(Ye, O, A, !0);
          continue;
        }
        let Ct;
        if (Ye.key != null)
          Ct = we.get(Ye.key);
        else
          for (xe = ge; xe <= G; xe++)
            if (Ps[xe - ge] === 0 && fs(Ye, v[xe])) {
              Ct = xe;
              break;
            }
        Ct === void 0 ? dt(Ye, O, A, !0) : (Ps[Ct - ge] = V + 1, Ct >= St ? St = Ct : xt = !0, E(
          Ye,
          v[Ct],
          x,
          null,
          O,
          A,
          j,
          F,
          P
        ), Ze++);
      }
      const To = xt ? wu(Ps) : Ss;
      for (xe = To.length - 1, V = et - 1; V >= 0; V--) {
        const Ye = ge + V, Ct = v[Ye], No = v[Ye + 1], xo = Ye + 1 < X ? (
          // #13559, #14173 fallback to el placeholder for unresolved async component
          No.el || Ha(No)
        ) : M;
        Ps[V] === 0 ? E(
          null,
          Ct,
          x,
          xo,
          O,
          A,
          j,
          F,
          P
        ) : xt && (xe < 0 || V !== To[xe] ? We(Ct, x, xo, 2) : xe--);
      }
    }
  }, We = (p, v, x, M, O = null) => {
    const { el: A, type: j, transition: F, children: P, shapeFlag: V } = p;
    if (V & 6) {
      We(p.component.subTree, v, x, M);
      return;
    }
    if (V & 128) {
      p.suspense.move(v, x, M);
      return;
    }
    if (V & 64) {
      j.move(p, v, x, ks);
      return;
    }
    if (j === Ae) {
      n(A, v, x);
      for (let q = 0; q < P.length; q++)
        We(P[q], v, x, M);
      n(p.anchor, v, x);
      return;
    }
    if (j === An) {
      C(p, v, x);
      return;
    }
    if (M !== 2 && V & 1 && F)
      if (M === 0)
        F.beforeEnter(A), n(A, v, x), ze(() => F.enter(A), O);
      else {
        const { leave: q, delayLeave: G, afterLeave: ie } = F, ge = () => {
          p.ctx.isUnmounted ? i(A) : n(A, v, x);
        }, we = () => {
          A._isLeaving && A[Ot](
            !0
            /* cancelled */
          ), q(A, () => {
            ge(), ie && ie();
          });
        };
        G ? G(A, ge, we) : we();
      }
    else
      n(A, v, x);
  }, dt = (p, v, x, M = !1, O = !1) => {
    const {
      type: A,
      props: j,
      ref: F,
      children: P,
      dynamicChildren: V,
      shapeFlag: X,
      patchFlag: q,
      dirs: G,
      cacheIndex: ie
    } = p;
    if (q === -2 && (O = !1), F != null && (gt(), Gs(F, null, x, p, !0), Et()), ie != null && (v.renderCache[ie] = void 0), X & 256) {
      v.ctx.deactivate(p);
      return;
    }
    const ge = X & 1 && G, we = !ws(p);
    let xe;
    if (we && (xe = j && j.onVnodeBeforeUnmount) && wt(xe, v, p), X & 6)
      dl(p.component, x, M);
    else {
      if (X & 128) {
        p.suspense.unmount(x, M);
        return;
      }
      ge && os(p, null, v, "beforeUnmount"), X & 64 ? p.type.remove(
        p,
        v,
        x,
        ks,
        M
      ) : V && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !V.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (A !== Ae || q > 0 && q & 64) ? Ls(
        V,
        v,
        x,
        !1,
        !0
      ) : (A === Ae && q & 384 || !O && X & 16) && Ls(P, v, x), M && ui(p);
    }
    (we && (xe = j && j.onVnodeUnmounted) || ge) && ze(() => {
      xe && wt(xe, v, p), ge && os(p, null, v, "unmounted");
    }, x);
  }, ui = (p) => {
    const { type: v, el: x, anchor: M, transition: O } = p;
    if (v === Ae) {
      b.NODE_ENV !== "production" && p.patchFlag > 0 && p.patchFlag & 2048 && O && !O.persisted ? p.children.forEach((j) => {
        j.type === Be ? i(j.el) : ui(j);
      }) : ul(x, M);
      return;
    }
    if (v === An) {
      R(p);
      return;
    }
    const A = () => {
      i(x), O && !O.persisted && O.afterLeave && O.afterLeave();
    };
    if (p.shapeFlag & 1 && O && !O.persisted) {
      const { leave: j, delayLeave: F } = O, P = () => j(x, A);
      F ? F(p.el, A, P) : P();
    } else
      A();
  }, ul = (p, v) => {
    let x;
    for (; p !== v; )
      x = m(p), i(p), p = x;
    i(v);
  }, dl = (p, v, x) => {
    b.NODE_ENV !== "production" && p.type.__hmrId && vc(p);
    const { bum: M, scope: O, job: A, subTree: j, um: F, m: P, a: V } = p;
    Go(P), Go(V), M && Ns(M), O.stop(), A && (A.flags |= 8, dt(j, p, v, x)), F && ze(F, v), ze(() => {
      p.isUnmounted = !0;
    }, v), b.NODE_ENV !== "production" && Nc(p);
  }, Ls = (p, v, x, M = !1, O = !1, A = 0) => {
    for (let j = A; j < p.length; j++)
      dt(p[j], v, x, M, O);
  }, gn = (p) => {
    if (p.shapeFlag & 6)
      return gn(p.component.subTree);
    if (p.shapeFlag & 128)
      return p.suspense.next();
    const v = m(p.anchor || p.el), x = v && v[ma];
    return x ? m(x) : v;
  };
  let di = !1;
  const _o = (p, v, x) => {
    let M;
    p == null ? v._vnode && (dt(v._vnode, null, null, !0), M = v._vnode.component) : E(
      v._vnode || null,
      p,
      v,
      null,
      null,
      null,
      x
    ), v._vnode = p, di || (di = !0, $o(M), ra(), di = !1);
  }, ks = {
    p: E,
    um: dt,
    m: We,
    r: ui,
    mt: be,
    mc: W,
    pc: J,
    pbc: me,
    n: gn,
    o: t
  };
  return {
    render: _o,
    hydrate: void 0,
    createApp: nu(_o)
  };
}
function yi({ type: t, props: e }, s) {
  return s === "svg" && t === "foreignObject" || s === "mathml" && t === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : s;
}
function rs({ effect: t, job: e }, s) {
  s ? (t.flags |= 32, e.flags |= 4) : (t.flags &= -33, e.flags &= -5);
}
function Cu(t, e) {
  return (!t || t && !t.pendingBranch) && e && !e.persisted;
}
function Ys(t, e, s = !1) {
  const n = t.children, i = e.children;
  if (z(n) && z(i))
    for (let o = 0; o < n.length; o++) {
      const r = n[o];
      let a = i[o];
      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[o] = qt(i[o]), a.el = r.el), !s && a.patchFlag !== -2 && Ys(r, a)), a.type === hn && (a.patchFlag === -1 && (a = i[o] = qt(a)), a.el = r.el), a.type === Be && !a.el && (a.el = r.el), b.NODE_ENV !== "production" && a.el && (a.el.__vnode = a);
    }
}
function wu(t) {
  const e = t.slice(), s = [0];
  let n, i, o, r, a;
  const l = t.length;
  for (n = 0; n < l; n++) {
    const u = t[n];
    if (u !== 0) {
      if (i = s[s.length - 1], t[i] < u) {
        e[n] = i, s.push(n);
        continue;
      }
      for (o = 0, r = s.length - 1; o < r; )
        a = o + r >> 1, t[s[a]] < u ? o = a + 1 : r = a;
      u < t[s[o]] && (o > 0 && (e[n] = s[o - 1]), s[o] = n);
    }
  }
  for (o = s.length, r = s[o - 1]; o-- > 0; )
    s[o] = r, r = e[r];
  return s;
}
function qa(t) {
  const e = t.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : qa(e);
}
function Go(t) {
  if (t)
    for (let e = 0; e < t.length; e++)
      t[e].flags |= 8;
}
function Ha(t) {
  if (t.placeholder)
    return t.placeholder;
  const e = t.component;
  return e ? Ha(e.subTree) : null;
}
const Wa = (t) => t.__isSuspense;
function Du(t, e) {
  e && e.pendingBranch ? z(t) ? e.effects.push(...t) : e.effects.push(t) : oa(t);
}
const Ae = /* @__PURE__ */ Symbol.for("v-fgt"), hn = /* @__PURE__ */ Symbol.for("v-txt"), Be = /* @__PURE__ */ Symbol.for("v-cmt"), An = /* @__PURE__ */ Symbol.for("v-stc"), Qs = [];
let at = null;
function S(t = !1) {
  Qs.push(at = t ? null : []);
}
function Ou() {
  Qs.pop(), at = Qs[Qs.length - 1] || null;
}
let sn = 1;
function Kn(t, e = !1) {
  sn += t, t < 0 && at && e && (at.hasOnce = !0);
}
function Ka(t) {
  return t.dynamicChildren = sn > 0 ? at || Ss : null, Ou(), sn > 0 && at && at.push(t), t;
}
function L(t, e, s, n, i, o) {
  return Ka(
    f(
      t,
      e,
      s,
      n,
      i,
      o,
      !0
    )
  );
}
function Ie(t, e, s, n, i) {
  return Ka(
    w(
      t,
      e,
      s,
      n,
      i,
      !0
    )
  );
}
function Es(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function fs(t, e) {
  if (b.NODE_ENV !== "production" && e.shapeFlag & 6 && t.component) {
    const s = Dn.get(e.type);
    if (s && s.has(t.component))
      return t.shapeFlag &= -257, e.shapeFlag &= -513, !1;
  }
  return t.type === e.type && t.key === e.key;
}
const $u = (...t) => Ga(
  ...t
), za = ({ key: t }) => t ?? null, Vn = ({
  ref: t,
  ref_key: e,
  ref_for: s
}) => (typeof t == "number" && (t = "" + t), t != null ? Me(t) || /* @__PURE__ */ Fe(t) || Z(t) ? { i: He, r: t, k: e, f: !!s } : t : null);
function f(t, e = null, s = null, n = 0, i = null, o = t === Ae ? 0 : 1, r = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: e,
    key: e && za(e),
    ref: e && Vn(e),
    scopeId: fa,
    slotScopeIds: null,
    children: s,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: n,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: He
  };
  return a ? (lo(l, s), o & 128 && t.normalize(l)) : s && (l.shapeFlag |= Me(s) ? 8 : 16), b.NODE_ENV !== "production" && l.key !== l.key && I("VNode created with invalid key (NaN). VNode type:", l.type), sn > 0 && // avoid a block node from tracking itself
  !r && // has current parent block
  at && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && at.push(l), l;
}
const w = b.NODE_ENV !== "production" ? $u : Ga;
function Ga(t, e = null, s = null, n = 0, i = null, o = !1) {
  if ((!t || t === Kc) && (b.NODE_ENV !== "production" && !t && I(`Invalid vnode type when creating vnode: ${t}.`), t = Be), Es(t)) {
    const a = kt(
      t,
      e,
      !0
      /* mergeRef: true */
    );
    return s && lo(a, s), sn > 0 && !o && at && (a.shapeFlag & 6 ? at[at.indexOf(t)] = a : at.push(a)), a.patchFlag = -2, a;
  }
  if (Za(t) && (t = t.__vccOpts), e) {
    e = Au(e);
    let { class: a, style: l } = e;
    a && !Me(a) && (e.class = Re(a)), ve(l) && (/* @__PURE__ */ Ln(l) && !z(l) && (l = Ve({}, l)), e.style = Ke(l));
  }
  const r = Me(t) ? 1 : Wa(t) ? 128 : va(t) ? 64 : ve(t) ? 4 : Z(t) ? 2 : 0;
  return b.NODE_ENV !== "production" && r & 4 && /* @__PURE__ */ Ln(t) && (t = /* @__PURE__ */ ue(t), I(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    t
  )), f(
    t,
    e,
    s,
    n,
    i,
    r,
    o,
    !0
  );
}
function Au(t) {
  return t ? /* @__PURE__ */ Ln(t) || ka(t) ? Ve({}, t) : t : null;
}
function kt(t, e, s = !1, n = !1) {
  const { props: i, ref: o, patchFlag: r, children: a, transition: l } = t, u = e ? Vu(i || {}, e) : i, c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: u,
    key: u && za(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      s && o ? z(o) ? o.concat(Vn(e)) : [o, Vn(e)] : Vn(e)
    ) : o,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: b.NODE_ENV !== "production" && r === -1 && z(a) ? a.map(Ya) : a,
    target: t.target,
    targetStart: t.targetStart,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && t.type !== Ae ? r === -1 ? 16 : r | 16 : r,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: l,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && kt(t.ssContent),
    ssFallback: t.ssFallback && kt(t.ssFallback),
    placeholder: t.placeholder,
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
  return l && n && tn(
    c,
    l.clone(c)
  ), c;
}
function Ya(t) {
  const e = kt(t);
  return z(t.children) && (e.children = t.children.map(Ya)), e;
}
function ne(t = " ", e = 0) {
  return w(hn, null, t, e);
}
function te(t = "", e = !1) {
  return e ? (S(), Ie(Be, null, t)) : w(Be, null, t);
}
function ft(t) {
  return t == null || typeof t == "boolean" ? w(Be) : z(t) ? w(
    Ae,
    null,
    // #3666, avoid reference pollution when reusing vnode
    t.slice()
  ) : Es(t) ? qt(t) : w(hn, null, String(t));
}
function qt(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : kt(t);
}
function lo(t, e) {
  let s = 0;
  const { shapeFlag: n } = t;
  if (e == null)
    e = null;
  else if (z(e))
    s = 16;
  else if (typeof e == "object")
    if (n & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), lo(t, i()), i._c && (i._d = !0));
      return;
    } else {
      s = 32;
      const i = e._;
      !i && !ka(e) ? e._ctx = He : i === 3 && He && (He.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
  else Z(e) ? (e = { default: e, _ctx: He }, s = 32) : (e = String(e), n & 64 ? (s = 16, e = [ne(e)]) : s = 8);
  t.children = e, t.shapeFlag |= s;
}
function Vu(...t) {
  const e = {};
  for (let s = 0; s < t.length; s++) {
    const n = t[s];
    for (const i in n)
      if (i === "class")
        e.class !== n.class && (e.class = Re([e.class, n.class]));
      else if (i === "style")
        e.style = Ke([e.style, n.style]);
      else if (an(i)) {
        const o = e[i], r = n[i];
        r && o !== r && !(z(o) && o.includes(r)) && (e[i] = o ? [].concat(o, r) : r);
      } else i !== "" && (e[i] = n[i]);
  }
  return e;
}
function wt(t, e, s, n = null) {
  Tt(t, e, 7, [
    s,
    n
  ]);
}
const Mu = $a();
let Iu = 0;
function Ru(t, e, s) {
  const n = t.type, i = (e ? e.appContext : t.appContext) || Mu, o = {
    uid: Iu++,
    vnode: t,
    type: n,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new $l(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Ba(n, i),
    emitsOptions: Va(n, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: ye,
    // inheritAttrs
    inheritAttrs: n.inheritAttrs,
    // state
    ctx: ye,
    data: ye,
    props: ye,
    attrs: ye,
    slots: ye,
    refs: ye,
    setupState: ye,
    setupContext: null,
    // suspense related
    suspense: s,
    suspenseId: s ? s.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return b.NODE_ENV !== "production" ? o.ctx = zc(o) : o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = iu.bind(null, o), t.ce && t.ce(o), o;
}
let Ue = null;
const oi = () => Ue || He;
let zn, Bi;
{
  const t = cn(), e = (s, n) => {
    let i;
    return (i = t[s]) || (i = t[s] = []), i.push(n), (o) => {
      i.length > 1 ? i.forEach((r) => r(o)) : i[0](o);
    };
  };
  zn = e(
    "__VUE_INSTANCE_SETTERS__",
    (s) => Ue = s
  ), Bi = e(
    "__VUE_SSR_SETTERS__",
    (s) => nn = s
  );
}
const mn = (t) => {
  const e = Ue;
  return zn(t), t.scope.on(), () => {
    t.scope.off(), zn(e);
  };
}, Yo = () => {
  Ue && Ue.scope.off(), zn(null);
}, Lu = /* @__PURE__ */ Yt("slot,component");
function Fi(t, { isNativeTag: e }) {
  (Lu(t) || e(t)) && I(
    "Do not use built-in or reserved HTML elements as component id: " + t
  );
}
function Qa(t) {
  return t.vnode.shapeFlag & 4;
}
let nn = !1;
function ku(t, e = !1, s = !1) {
  e && Bi(e);
  const { props: n, children: i } = t.vnode, o = Qa(t);
  uu(t, n, o, e), _u(t, i, s || e);
  const r = o ? Pu(t, e) : void 0;
  return e && Bi(!1), r;
}
function Pu(t, e) {
  const s = t.type;
  if (b.NODE_ENV !== "production") {
    if (s.name && Fi(s.name, t.appContext.config), s.components) {
      const i = Object.keys(s.components);
      for (let o = 0; o < i.length; o++)
        Fi(i[o], t.appContext.config);
    }
    if (s.directives) {
      const i = Object.keys(s.directives);
      for (let o = 0; o < i.length; o++)
        pa(i[o]);
    }
    s.compilerOptions && Bu() && I(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = new Proxy(t.ctx, wa), b.NODE_ENV !== "production" && Gc(t);
  const { setup: n } = s;
  if (n) {
    gt();
    const i = t.setupContext = n.length > 1 ? Uu(t) : null, o = mn(t), r = Rs(
      n,
      t,
      0,
      [
        b.NODE_ENV !== "production" ? /* @__PURE__ */ Vt(t.props) : t.props,
        i
      ]
    ), a = Wi(r);
    if (Et(), o(), (a || t.sp) && !ws(t) && xa(t), a) {
      if (r.then(Yo, Yo), e)
        return r.then((l) => {
          Qo(t, l, e);
        }).catch((l) => {
          un(l, t, 0);
        });
      if (t.asyncDep = r, b.NODE_ENV !== "production" && !t.suspense) {
        const l = vn(t, s);
        I(
          `Component <${l}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      Qo(t, r, e);
  } else
    Ja(t, e);
}
function Qo(t, e, s) {
  Z(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : ve(e) ? (b.NODE_ENV !== "production" && Es(e) && I(
    "setup() should not return VNodes directly - return a render function instead."
  ), b.NODE_ENV !== "production" && (t.devtoolsRawSetupState = e), t.setupState = ta(e), b.NODE_ENV !== "production" && Yc(t)) : b.NODE_ENV !== "production" && e !== void 0 && I(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), Ja(t, s);
}
const Bu = () => !0;
function Ja(t, e, s) {
  const n = t.type;
  t.render || (t.render = n.render || qe);
  {
    const i = mn(t);
    gt();
    try {
      Jc(t);
    } finally {
      Et(), i();
    }
  }
  b.NODE_ENV !== "production" && !n.render && t.render === qe && !e && (n.template ? I(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : I("Component is missing template or render function: ", n));
}
const Jo = b.NODE_ENV !== "production" ? {
  get(t, e) {
    return Hn(), je(t, "get", ""), t[e];
  },
  set() {
    return I("setupContext.attrs is readonly."), !1;
  },
  deleteProperty() {
    return I("setupContext.attrs is readonly."), !1;
  }
} : {
  get(t, e) {
    return je(t, "get", ""), t[e];
  }
};
function Fu(t) {
  return new Proxy(t.slots, {
    get(e, s) {
      return je(t, "get", "$slots"), e[s];
    }
  });
}
function Uu(t) {
  const e = (s) => {
    if (b.NODE_ENV !== "production" && (t.exposed && I("expose() should be called only once per setup()."), s != null)) {
      let n = typeof s;
      n === "object" && (z(s) ? n = "array" : /* @__PURE__ */ Fe(s) && (n = "ref")), n !== "object" && I(
        `expose() should be passed a plain object, received ${n}.`
      );
    }
    t.exposed = s || {};
  };
  if (b.NODE_ENV !== "production") {
    let s, n;
    return Object.freeze({
      get attrs() {
        return s || (s = new Proxy(t.attrs, Jo));
      },
      get slots() {
        return n || (n = Fu(t));
      },
      get emit() {
        return (i, ...o) => t.emit(i, ...o);
      },
      expose: e
    });
  } else
    return {
      attrs: new Proxy(t.attrs, Jo),
      slots: t.slots,
      emit: t.emit,
      expose: e
    };
}
function ri(t) {
  return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(ta(Jl(t.exposed)), {
    get(e, s) {
      if (s in e)
        return e[s];
      if (s in bs)
        return bs[s](t);
    },
    has(e, s) {
      return s in e || s in bs;
    }
  })) : t.proxy;
}
const ju = /(?:^|[-_])\w/g, qu = (t) => t.replace(ju, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function Xa(t, e = !0) {
  return Z(t) ? t.displayName || t.name : t.name || e && t.__name;
}
function vn(t, e, s = !1) {
  let n = Xa(e);
  if (!n && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (n = i[1]);
  }
  if (!n && t) {
    const i = (o) => {
      for (const r in o)
        if (o[r] === e)
          return r;
    };
    n = i(t.components) || t.parent && i(
      t.parent.type.components
    ) || i(t.appContext.components);
  }
  return n ? qu(n) : s ? "App" : "Anonymous";
}
function Za(t) {
  return Z(t) && "__vccOpts" in t;
}
const se = (t, e) => {
  const s = /* @__PURE__ */ ic(t, e, nn);
  if (b.NODE_ENV !== "production") {
    const n = oi();
    n && n.appContext.config.warnRecursiveComputed && (s._warnRecursive = !0);
  }
  return s;
};
function Hu(t, e, s) {
  try {
    Kn(-1);
    const n = arguments.length;
    return n === 2 ? ve(e) && !z(e) ? Es(e) ? w(t, null, [e]) : w(t, e) : w(t, null, e) : (n > 3 ? s = Array.prototype.slice.call(arguments, 2) : n === 3 && Es(s) && (s = [s]), w(t, e, s));
  } finally {
    Kn(1);
  }
}
function Wu() {
  if (b.NODE_ENV === "production" || typeof window > "u")
    return;
  const t = { style: "color:#3ba776" }, e = { style: "color:#1677ff" }, s = { style: "color:#f5222d" }, n = { style: "color:#eb2f96" }, i = {
    __vue_custom_formatter: !0,
    header(d) {
      if (!ve(d))
        return null;
      if (d.__isVue)
        return ["div", t, "VueInstance"];
      if (/* @__PURE__ */ Fe(d)) {
        gt();
        const m = d.value;
        return Et(), [
          "div",
          {},
          ["span", t, c(d)],
          "<",
          a(m),
          ">"
        ];
      } else {
        if (/* @__PURE__ */ ns(d))
          return [
            "div",
            {},
            ["span", t, /* @__PURE__ */ Xe(d) ? "ShallowReactive" : "Reactive"],
            "<",
            a(d),
            `>${/* @__PURE__ */ yt(d) ? " (readonly)" : ""}`
          ];
        if (/* @__PURE__ */ yt(d))
          return [
            "div",
            {},
            ["span", t, /* @__PURE__ */ Xe(d) ? "ShallowReadonly" : "Readonly"],
            "<",
            a(d),
            ">"
          ];
      }
      return null;
    },
    hasBody(d) {
      return d && d.__isVue;
    },
    body(d) {
      if (d && d.__isVue)
        return [
          "div",
          {},
          ...o(d.$)
        ];
    }
  };
  function o(d) {
    const m = [];
    d.type.props && d.props && m.push(r("props", /* @__PURE__ */ ue(d.props))), d.setupState !== ye && m.push(r("setup", d.setupState)), d.data !== ye && m.push(r("data", /* @__PURE__ */ ue(d.data)));
    const h = l(d, "computed");
    h && m.push(r("computed", h));
    const g = l(d, "inject");
    return g && m.push(r("injected", g)), m.push([
      "div",
      {},
      [
        "span",
        {
          style: n.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: d }]
    ]), m;
  }
  function r(d, m) {
    return m = Ve({}, m), Object.keys(m).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        d
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(m).map((h) => [
          "div",
          {},
          ["span", n, h + ": "],
          a(m[h], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function a(d, m = !0) {
    return typeof d == "number" ? ["span", e, d] : typeof d == "string" ? ["span", s, JSON.stringify(d)] : typeof d == "boolean" ? ["span", n, d] : ve(d) ? ["object", { object: m ? /* @__PURE__ */ ue(d) : d }] : ["span", s, String(d)];
  }
  function l(d, m) {
    const h = d.type;
    if (Z(h))
      return;
    const g = {};
    for (const E in d.ctx)
      u(h, E, m) && (g[E] = d.ctx[E]);
    return g;
  }
  function u(d, m, h) {
    const g = d[h];
    if (z(g) && g.includes(m) || ve(g) && m in g || d.extends && u(d.extends, m, h) || d.mixins && d.mixins.some((E) => u(E, m, h)))
      return !0;
  }
  function c(d) {
    return /* @__PURE__ */ Xe(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];
}
const Xo = "3.5.28", Rt = b.NODE_ENV !== "production" ? I : qe;
var Nt = {};
let Ui;
const Zo = typeof window < "u" && window.trustedTypes;
if (Zo)
  try {
    Ui = /* @__PURE__ */ Zo.createPolicy("vue", {
      createHTML: (t) => t
    });
  } catch (t) {
    Nt.NODE_ENV !== "production" && Rt(`Error creating trusted types policy: ${t}`);
  }
const el = Ui ? (t) => Ui.createHTML(t) : (t) => t, Ku = "http://www.w3.org/2000/svg", zu = "http://www.w3.org/1998/Math/MathML", Ut = typeof document < "u" ? document : null, er = Ut && /* @__PURE__ */ Ut.createElement("template"), Gu = {
  insert: (t, e, s) => {
    e.insertBefore(t, s || null);
  },
  remove: (t) => {
    const e = t.parentNode;
    e && e.removeChild(t);
  },
  createElement: (t, e, s, n) => {
    const i = e === "svg" ? Ut.createElementNS(Ku, t) : e === "mathml" ? Ut.createElementNS(zu, t) : s ? Ut.createElement(t, { is: s }) : Ut.createElement(t);
    return t === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple), i;
  },
  createText: (t) => Ut.createTextNode(t),
  createComment: (t) => Ut.createComment(t),
  setText: (t, e) => {
    t.nodeValue = e;
  },
  setElementText: (t, e) => {
    t.textContent = e;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Ut.querySelector(t),
  setScopeId(t, e) {
    t.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(t, e, s, n, i, o) {
    const r = s ? s.previousSibling : e.lastChild;
    if (i && (i === o || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), s), !(i === o || !(i = i.nextSibling)); )
        ;
    else {
      er.innerHTML = el(
        n === "svg" ? `<svg>${t}</svg>` : n === "mathml" ? `<math>${t}</math>` : t
      );
      const a = er.content;
      if (n === "svg" || n === "mathml") {
        const l = a.firstChild;
        for (; l.firstChild; )
          a.appendChild(l.firstChild);
        a.removeChild(l);
      }
      e.insertBefore(a, s);
    }
    return [
      // first
      r ? r.nextSibling : e.firstChild,
      // last
      s ? s.previousSibling : e.lastChild
    ];
  }
}, Jt = "transition", js = "animation", on = /* @__PURE__ */ Symbol("_vtc"), tl = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, Yu = /* @__PURE__ */ Ve(
  {},
  Ea,
  tl
), Qu = (t) => (t.displayName = "Transition", t.props = Yu, t), co = /* @__PURE__ */ Qu(
  (t, { slots: e }) => Hu(Rc, Ju(t), e)
), as = (t, e = []) => {
  z(t) ? t.forEach((s) => s(...e)) : t && t(...e);
}, tr = (t) => t ? z(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;
function Ju(t) {
  const e = {};
  for (const D in t)
    D in tl || (e[D] = t[D]);
  if (t.css === !1)
    return e;
  const {
    name: s = "v",
    type: n,
    duration: i,
    enterFromClass: o = `${s}-enter-from`,
    enterActiveClass: r = `${s}-enter-active`,
    enterToClass: a = `${s}-enter-to`,
    appearFromClass: l = o,
    appearActiveClass: u = r,
    appearToClass: c = a,
    leaveFromClass: d = `${s}-leave-from`,
    leaveActiveClass: m = `${s}-leave-active`,
    leaveToClass: h = `${s}-leave-to`
  } = t, g = Xu(i), E = g && g[0], y = g && g[1], {
    onBeforeEnter: T,
    onEnter: N,
    onEnterCancelled: _,
    onLeave: C,
    onLeaveCancelled: R,
    onBeforeAppear: U = T,
    onAppear: le = N,
    onAppearCancelled: he = _
  } = e, W = (D, K, oe, be) => {
    D._enterCancelled = be, ls(D, K ? c : a), ls(D, K ? u : r), oe && oe();
  }, re = (D, K) => {
    D._isLeaving = !1, ls(D, d), ls(D, h), ls(D, m), K && K();
  }, me = (D) => (K, oe) => {
    const be = D ? le : N, pe = () => W(K, D, oe);
    as(be, [K, pe]), sr(() => {
      ls(K, D ? l : o), Ft(K, D ? c : a), tr(be) || nr(K, n, E, pe);
    });
  };
  return Ve(e, {
    onBeforeEnter(D) {
      as(T, [D]), Ft(D, o), Ft(D, r);
    },
    onBeforeAppear(D) {
      as(U, [D]), Ft(D, l), Ft(D, u);
    },
    onEnter: me(!1),
    onAppear: me(!0),
    onLeave(D, K) {
      D._isLeaving = !0;
      const oe = () => re(D, K);
      Ft(D, d), D._enterCancelled ? (Ft(D, m), rr(D)) : (rr(D), Ft(D, m)), sr(() => {
        D._isLeaving && (ls(D, d), Ft(D, h), tr(C) || nr(D, n, y, oe));
      }), as(C, [D, oe]);
    },
    onEnterCancelled(D) {
      W(D, !1, void 0, !0), as(_, [D]);
    },
    onAppearCancelled(D) {
      W(D, !0, void 0, !0), as(he, [D]);
    },
    onLeaveCancelled(D) {
      re(D), as(R, [D]);
    }
  });
}
function Xu(t) {
  if (t == null)
    return null;
  if (ve(t))
    return [_i(t.enter), _i(t.leave)];
  {
    const e = _i(t);
    return [e, e];
  }
}
function _i(t) {
  const e = vl(t);
  return Nt.NODE_ENV !== "production" && dc(e, "<transition> explicit duration"), e;
}
function Ft(t, e) {
  e.split(/\s+/).forEach((s) => s && t.classList.add(s)), (t[on] || (t[on] = /* @__PURE__ */ new Set())).add(e);
}
function ls(t, e) {
  e.split(/\s+/).forEach((n) => n && t.classList.remove(n));
  const s = t[on];
  s && (s.delete(e), s.size || (t[on] = void 0));
}
function sr(t) {
  requestAnimationFrame(() => {
    requestAnimationFrame(t);
  });
}
let Zu = 0;
function nr(t, e, s, n) {
  const i = t._endId = ++Zu, o = () => {
    i === t._endId && n();
  };
  if (s != null)
    return setTimeout(o, s);
  const { type: r, timeout: a, propCount: l } = ed(t, e);
  if (!r)
    return n();
  const u = r + "end";
  let c = 0;
  const d = () => {
    t.removeEventListener(u, m), o();
  }, m = (h) => {
    h.target === t && ++c >= l && d();
  };
  setTimeout(() => {
    c < l && d();
  }, a + 1), t.addEventListener(u, m);
}
function ed(t, e) {
  const s = window.getComputedStyle(t), n = (g) => (s[g] || "").split(", "), i = n(`${Jt}Delay`), o = n(`${Jt}Duration`), r = ir(i, o), a = n(`${js}Delay`), l = n(`${js}Duration`), u = ir(a, l);
  let c = null, d = 0, m = 0;
  e === Jt ? r > 0 && (c = Jt, d = r, m = o.length) : e === js ? u > 0 && (c = js, d = u, m = l.length) : (d = Math.max(r, u), c = d > 0 ? r > u ? Jt : js : null, m = c ? c === Jt ? o.length : l.length : 0);
  const h = c === Jt && /\b(?:transform|all)(?:,|$)/.test(
    n(`${Jt}Property`).toString()
  );
  return {
    type: c,
    timeout: d,
    propCount: m,
    hasTransform: h
  };
}
function ir(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((s, n) => or(s) + or(t[n])));
}
function or(t) {
  return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function rr(t) {
  return (t ? t.ownerDocument : document).body.offsetHeight;
}
function td(t, e, s) {
  const n = t[on];
  n && (e = (e ? [e, ...n] : [...n]).join(" ")), e == null ? t.removeAttribute("class") : s ? t.setAttribute("class", e) : t.className = e;
}
const ar = /* @__PURE__ */ Symbol("_vod"), sd = /* @__PURE__ */ Symbol("_vsh"), nd = /* @__PURE__ */ Symbol(Nt.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""), id = /(?:^|;)\s*display\s*:/;
function od(t, e, s) {
  const n = t.style, i = Me(s);
  let o = !1;
  if (s && !i) {
    if (e)
      if (Me(e))
        for (const r of e.split(";")) {
          const a = r.slice(0, r.indexOf(":")).trim();
          s[a] == null && Mn(n, a, "");
        }
      else
        for (const r in e)
          s[r] == null && Mn(n, r, "");
    for (const r in s)
      r === "display" && (o = !0), Mn(n, r, s[r]);
  } else if (i) {
    if (e !== s) {
      const r = n[nd];
      r && (s += ";" + r), n.cssText = s, o = id.test(s);
    }
  } else e && t.removeAttribute("style");
  ar in t && (t[ar] = o ? n.display : "", t[sd] && (n.display = "none"));
}
const rd = /[^\\];\s*$/, lr = /\s*!important$/;
function Mn(t, e, s) {
  if (z(s))
    s.forEach((n) => Mn(t, e, n));
  else if (s == null && (s = ""), Nt.NODE_ENV !== "production" && rd.test(s) && Rt(
    `Unexpected semicolon at the end of '${e}' style value: '${s}'`
  ), e.startsWith("--"))
    t.setProperty(e, s);
  else {
    const n = ad(t, e);
    lr.test(s) ? t.setProperty(
      Gt(n),
      s.replace(lr, ""),
      "important"
    ) : t[n] = s;
  }
}
const cr = ["Webkit", "Moz", "ms"], Ti = {};
function ad(t, e) {
  const s = Ti[e];
  if (s)
    return s;
  let n = ut(e);
  if (n !== "filter" && n in t)
    return Ti[e] = n;
  n = Qn(n);
  for (let i = 0; i < cr.length; i++) {
    const o = cr[i] + n;
    if (o in t)
      return Ti[e] = o;
  }
  return e;
}
const ur = "http://www.w3.org/1999/xlink";
function dr(t, e, s, n, i, o = Dl(e)) {
  n && e.startsWith("xlink:") ? s == null ? t.removeAttributeNS(ur, e.slice(6, e.length)) : t.setAttributeNS(ur, e, s) : s == null || o && !Lr(s) ? t.removeAttribute(e) : t.setAttribute(
    e,
    o ? "" : vt(s) ? String(s) : s
  );
}
function fr(t, e, s, n, i) {
  if (e === "innerHTML" || e === "textContent") {
    s != null && (t[e] = e === "innerHTML" ? el(s) : s);
    return;
  }
  const o = t.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const a = o === "OPTION" ? t.getAttribute("value") || "" : t.value, l = s == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      t.type === "checkbox" ? "on" : ""
    ) : String(s);
    (a !== l || !("_value" in t)) && (t.value = l), s == null && t.removeAttribute(e), t._value = s;
    return;
  }
  let r = !1;
  if (s === "" || s == null) {
    const a = typeof t[e];
    a === "boolean" ? s = Lr(s) : s == null && a === "string" ? (s = "", r = !0) : a === "number" && (s = 0, r = !0);
  }
  try {
    t[e] = s;
  } catch (a) {
    Nt.NODE_ENV !== "production" && !r && Rt(
      `Failed setting prop "${e}" on <${o.toLowerCase()}>: value ${s} is invalid.`,
      a
    );
  }
  r && t.removeAttribute(i || e);
}
function ts(t, e, s, n) {
  t.addEventListener(e, s, n);
}
function ld(t, e, s, n) {
  t.removeEventListener(e, s, n);
}
const pr = /* @__PURE__ */ Symbol("_vei");
function cd(t, e, s, n, i = null) {
  const o = t[pr] || (t[pr] = {}), r = o[e];
  if (n && r)
    r.value = Nt.NODE_ENV !== "production" ? mr(n, e) : n;
  else {
    const [a, l] = ud(e);
    if (n) {
      const u = o[e] = pd(
        Nt.NODE_ENV !== "production" ? mr(n, e) : n,
        i
      );
      ts(t, a, u, l);
    } else r && (ld(t, a, r, l), o[e] = void 0);
  }
}
const hr = /(?:Once|Passive|Capture)$/;
function ud(t) {
  let e;
  if (hr.test(t)) {
    e = {};
    let n;
    for (; n = t.match(hr); )
      t = t.slice(0, t.length - n[0].length), e[n[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : Gt(t.slice(2)), e];
}
let Ni = 0;
const dd = /* @__PURE__ */ Promise.resolve(), fd = () => Ni || (dd.then(() => Ni = 0), Ni = Date.now());
function pd(t, e) {
  const s = (n) => {
    if (!n._vts)
      n._vts = Date.now();
    else if (n._vts <= s.attached)
      return;
    Tt(
      hd(n, s.value),
      e,
      5,
      [n]
    );
  };
  return s.value = t, s.attached = fd(), s;
}
function mr(t, e) {
  return Z(t) || z(t) ? t : (Rt(
    `Wrong type passed as event handler to ${e} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof t}.`
  ), qe);
}
function hd(t, e) {
  if (z(e)) {
    const s = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      s.call(t), t._stopped = !0;
    }, e.map(
      (n) => (i) => !i._stopped && n && n(i)
    );
  } else
    return e;
}
const vr = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // lowercase letter
t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, md = (t, e, s, n, i, o) => {
  const r = i === "svg";
  e === "class" ? td(t, n, r) : e === "style" ? od(t, s, n) : an(e) ? In(e) || cd(t, e, s, n, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : vd(t, e, n, r)) ? (fr(t, e, n), !t.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && dr(t, e, n, r, o, e !== "value")) : /* #11081 force set props for possible async custom element */ t._isVueCE && (/[A-Z]/.test(e) || !Me(n)) ? fr(t, ut(e), n, o, e) : (e === "true-value" ? t._trueValue = n : e === "false-value" && (t._falseValue = n), dr(t, e, n, r));
};
function vd(t, e, s, n) {
  if (n)
    return !!(e === "innerHTML" || e === "textContent" || e in t && vr(e) && Z(s));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && t.tagName === "IFRAME" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = t.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return vr(e) && Me(s) ? !1 : e in t;
}
const As = (t) => {
  const e = t.props["onUpdate:modelValue"] || !1;
  return z(e) ? (s) => Ns(e, s) : e;
};
function bd(t) {
  t.target.composing = !0;
}
function br(t) {
  const e = t.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const Kt = /* @__PURE__ */ Symbol("_assign");
function gr(t, e, s) {
  return e && (t = t.trim()), s && (t = Jn(t)), t;
}
const zt = {
  created(t, { modifiers: { lazy: e, trim: s, number: n } }, i) {
    t[Kt] = As(i);
    const o = n || i.props && i.props.type === "number";
    ts(t, e ? "change" : "input", (r) => {
      r.target.composing || t[Kt](gr(t.value, s, o));
    }), (s || o) && ts(t, "change", () => {
      t.value = gr(t.value, s, o);
    }), e || (ts(t, "compositionstart", bd), ts(t, "compositionend", br), ts(t, "change", br));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(t, { value: e }) {
    t.value = e ?? "";
  },
  beforeUpdate(t, { value: e, oldValue: s, modifiers: { lazy: n, trim: i, number: o } }, r) {
    if (t[Kt] = As(r), t.composing) return;
    const a = (o || t.type === "number") && !/^0\d/.test(t.value) ? Jn(t.value) : t.value, l = e ?? "";
    a !== l && (document.activeElement === t && t.type !== "range" && (n && e === s || i && t.value.trim() === l) || (t.value = l));
  }
}, sl = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(t, e, s) {
    t[Kt] = As(s), ts(t, "change", () => {
      const n = t._modelValue, i = rn(t), o = t.checked, r = t[Kt];
      if (z(n)) {
        const a = Gi(n, i), l = a !== -1;
        if (o && !l)
          r(n.concat(i));
        else if (!o && l) {
          const u = [...n];
          u.splice(a, 1), r(u);
        }
      } else if (Ms(n)) {
        const a = new Set(n);
        o ? a.add(i) : a.delete(i), r(a);
      } else
        r(il(t, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Er,
  beforeUpdate(t, e, s) {
    t[Kt] = As(s), Er(t, e, s);
  }
};
function Er(t, { value: e, oldValue: s }, n) {
  t._modelValue = e;
  let i;
  if (z(e))
    i = Gi(e, n.props.value) > -1;
  else if (Ms(e))
    i = e.has(n.props.value);
  else {
    if (e === s) return;
    i = Is(e, il(t, !0));
  }
  t.checked !== i && (t.checked = i);
}
const nl = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(t, { value: e, modifiers: { number: s } }, n) {
    const i = Ms(e);
    ts(t, "change", () => {
      const o = Array.prototype.filter.call(t.options, (r) => r.selected).map(
        (r) => s ? Jn(rn(r)) : rn(r)
      );
      t[Kt](
        t.multiple ? i ? new Set(o) : o : o[0]
      ), t._assigning = !0, It(() => {
        t._assigning = !1;
      });
    }), t[Kt] = As(n);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(t, { value: e }) {
    yr(t, e);
  },
  beforeUpdate(t, e, s) {
    t[Kt] = As(s);
  },
  updated(t, { value: e }) {
    t._assigning || yr(t, e);
  }
};
function yr(t, e) {
  const s = t.multiple, n = z(e);
  if (s && !n && !Ms(e)) {
    Nt.NODE_ENV !== "production" && Rt(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let i = 0, o = t.options.length; i < o; i++) {
    const r = t.options[i], a = rn(r);
    if (s)
      if (n) {
        const l = typeof a;
        l === "string" || l === "number" ? r.selected = e.some((u) => String(u) === String(a)) : r.selected = Gi(e, a) > -1;
      } else
        r.selected = e.has(a);
    else if (Is(rn(r), e)) {
      t.selectedIndex !== i && (t.selectedIndex = i);
      return;
    }
  }
  !s && t.selectedIndex !== -1 && (t.selectedIndex = -1);
}
function rn(t) {
  return "_value" in t ? t._value : t.value;
}
function il(t, e) {
  const s = e ? "_trueValue" : "_falseValue";
  return s in t ? t[s] : e;
}
const gd = ["ctrl", "shift", "alt", "meta"], Ed = {
  stop: (t) => t.stopPropagation(),
  prevent: (t) => t.preventDefault(),
  self: (t) => t.target !== t.currentTarget,
  ctrl: (t) => !t.ctrlKey,
  shift: (t) => !t.shiftKey,
  alt: (t) => !t.altKey,
  meta: (t) => !t.metaKey,
  left: (t) => "button" in t && t.button !== 0,
  middle: (t) => "button" in t && t.button !== 1,
  right: (t) => "button" in t && t.button !== 2,
  exact: (t, e) => gd.some((s) => t[`${s}Key`] && !e.includes(s))
}, yd = (t, e) => {
  if (!t) return t;
  const s = t._withMods || (t._withMods = {}), n = e.join(".");
  return s[n] || (s[n] = ((i, ...o) => {
    for (let r = 0; r < e.length; r++) {
      const a = Ed[e[r]];
      if (a && a(i, e)) return;
    }
    return t(i, ...o);
  }));
}, _d = /* @__PURE__ */ Ve({ patchProp: md }, Gu);
let _r;
function Td() {
  return _r || (_r = xu(_d));
}
const Nd = ((...t) => {
  const e = Td().createApp(...t);
  Nt.NODE_ENV !== "production" && (Sd(e), Cd(e));
  const { mount: s } = e;
  return e.mount = (n) => {
    const i = wd(n);
    if (!i) return;
    const o = e._component;
    !Z(o) && !o.render && !o.template && (o.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
    const r = s(i, !1, xd(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), r;
  }, e;
});
function xd(t) {
  if (t instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && t instanceof MathMLElement)
    return "mathml";
}
function Sd(t) {
  Object.defineProperty(t.config, "isNativeTag", {
    value: (e) => xl(e) || Sl(e) || Cl(e),
    writable: !1
  });
}
function Cd(t) {
  {
    const e = t.config.isCustomElement;
    Object.defineProperty(t.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        Rt(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const s = t.config.compilerOptions, n = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(t.config, "compilerOptions", {
      get() {
        return Rt(n), s;
      },
      set() {
        Rt(n);
      }
    });
  }
}
function wd(t) {
  if (Me(t)) {
    const e = document.querySelector(t);
    return Nt.NODE_ENV !== "production" && !e && Rt(
      `Failed to mount app: mount target selector "${t}" returned null.`
    ), e;
  }
  return Nt.NODE_ENV !== "production" && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && Rt(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), t;
}
var Dd = {};
function Od() {
  Wu();
}
Dd.NODE_ENV !== "production" && Od();
const De = (t, e) => {
  const s = t.__vccOpts || t;
  for (const [n, i] of e)
    s[n] = i;
  return s;
}, $d = {}, Ad = { class: "card st-card-unified" }, Vd = { style: { display: "flex", "align-items": "center", "justify-content": "space-between" } };
function Md(t, e) {
  return S(), L("div", Ad, [
    f("div", Vd, [
      mt(t.$slots, "left", {}, void 0, !0),
      mt(t.$slots, "right", {}, void 0, !0)
    ])
  ]);
}
const Nn = /* @__PURE__ */ De($d, [["render", Md], ["__scopeId", "data-v-5b66fbc1"]]), Id = { class: "st-toggle-switch" }, Rd = ["checked"], Ld = /* @__PURE__ */ Te({
  __name: "ToggleSwitch",
  props: {
    checked: { type: Boolean }
  },
  emits: ["change"],
  setup(t) {
    return (e, s) => (S(), L("label", Id, [
      f("input", {
        type: "checkbox",
        checked: t.checked,
        onChange: s[0] || (s[0] = (n) => e.$emit("change", n.target.checked))
      }, null, 40, Rd),
      s[1] || (s[1] = f("span", { class: "st-toggle-slider" }, null, -1))
    ]));
  }
}), Tr = /* @__PURE__ */ De(Ld, [["__scopeId", "data-v-f73e4a93"]]), kd = { class: "button-content" }, Pd = /* @__PURE__ */ Te({
  __name: "Button",
  emits: ["click"],
  setup(t) {
    return (e, s) => (S(), L("button", {
      class: "menu_button button-wrapper",
      onClick: s[0] || (s[0] = (n) => e.$emit("click"))
    }, [
      f("span", kd, [
        mt(e.$slots, "default", {}, void 0, !0)
      ])
    ]));
  }
}), ae = /* @__PURE__ */ De(Pd, [["__scopeId", "data-v-8b9ccff3"]]), Bd = {
  key: 0,
  class: "popup-modal-header"
}, Fd = { class: "popup-modal-title" }, Ud = { class: "popup-modal-body" }, jd = {
  key: 1,
  class: "popup-modal-footer"
}, qd = /* @__PURE__ */ Te({
  __name: "PopupModal",
  props: {
    visible: { type: Boolean },
    title: {},
    closable: { type: Boolean, default: !0 },
    maskClosable: { type: Boolean, default: !0 },
    height: {},
    width: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = se(() => {
      const a = {};
      return s.height && (a.height = s.height, a["max-height"] = s.height), s.width && (a.width = s.width, a["max-width"] = s.width), a;
    }), i = e, o = () => {
      i("close");
    }, r = () => {
      s.maskClosable && o();
    };
    return (a, l) => (S(), Ie(ga, { to: "body" }, [
      w(co, { name: "modal" }, {
        default: B(() => [
          t.visible ? (S(), L("div", {
            key: 0,
            class: "popup-modal-overlay",
            onClick: yd(r, ["self"])
          }, [
            f("div", {
              class: "popup-modal",
              style: Ke(n.value)
            }, [
              t.title || t.closable || a.$slots.titlePrefix ? (S(), L("div", Bd, [
                f("div", Fd, [
                  mt(a.$slots, "titlePrefix", {}, void 0, !0),
                  f("span", null, de(t.title), 1)
                ]),
                t.closable ? (S(), L("div", {
                  key: 0,
                  class: "popup-modal-close",
                  onClick: o
                }, [...l[0] || (l[0] = [
                  f("i", { class: "fa-solid fa-xmark" }, null, -1)
                ])])) : te("", !0)
              ])) : te("", !0),
              f("div", Ud, [
                mt(a.$slots, "default", {}, void 0, !0)
              ]),
              a.$slots.footer ? (S(), L("div", jd, [
                mt(a.$slots, "footer", {}, void 0, !0)
              ])) : te("", !0)
            ], 4)
          ])) : te("", !0)
        ]),
        _: 3
      })
    ]));
  }
}), Ge = /* @__PURE__ */ De(qd, [["__scopeId", "data-v-546209e7"]]), Hd = { class: "drawer-header" }, Wd = { class: "header-actions" }, Kd = { class: "drawer-body" }, zd = {
  key: 0,
  class: "empty-state"
}, Gd = {
  key: 1,
  class: "table-list"
}, Yd = ["onClick"], Qd = { class: "table-item-main" }, Jd = { class: "table-name" }, Xd = {
  key: 0,
  class: "table-comment"
}, Zd = /* @__PURE__ */ Te({
  __name: "TableListDrawer",
  props: {
    tables: {},
    selectedTable: {},
    isDrawer: { type: Boolean, default: !0 },
    showSyncButtons: { type: Boolean, default: !1 }
  },
  emits: ["select", "create", "closeDrawer", "sync", "push"],
  setup(t, { emit: e }) {
    const s = e, n = /* @__PURE__ */ H(window.innerWidth), i = () => {
      n.value = window.innerWidth;
    };
    nt(() => {
      window.addEventListener("resize", i);
    }), pn(() => {
      window.removeEventListener("resize", i);
    });
    const o = () => n.value <= 768, r = (c) => {
      s("select", c), o() && s("closeDrawer");
    }, a = () => {
      s("create");
    }, l = () => {
      s("sync");
    }, u = () => {
      s("push");
    };
    return (c, d) => (S(), L("div", {
      class: Re(["table-list-drawer", { "is-drawer": t.isDrawer }])
    }, [
      f("div", Hd, [
        d[3] || (d[3] = f("span", { class: "drawer-title" }, "", -1)),
        f("div", Wd, [
          t.showSyncButtons ? (S(), L("button", {
            key: 0,
            class: "sync-btn",
            title: "",
            onClick: l
          }, [...d[0] || (d[0] = [
            f("i", { class: "fa-solid fa-rotate" }, null, -1)
          ])])) : te("", !0),
          t.showSyncButtons ? (S(), L("button", {
            key: 1,
            class: "push-btn",
            title: "",
            onClick: u
          }, [...d[1] || (d[1] = [
            f("i", { class: "fa-solid fa-share-from-square" }, null, -1)
          ])])) : te("", !0),
          f("button", {
            class: "create-table-btn",
            title: "",
            onClick: a
          }, [...d[2] || (d[2] = [
            f("i", { class: "fa-solid fa-plus" }, null, -1)
          ])])
        ])
      ]),
      f("div", Kd, [
        t.tables.length === 0 ? (S(), L("div", zd, [
          d[5] || (d[5] = f("i", { class: "fa-solid fa-table" }, null, -1)),
          d[6] || (d[6] = f("span", null, "", -1)),
          f("button", {
            class: "empty-create-btn",
            onClick: a
          }, [...d[4] || (d[4] = [
            f("i", { class: "fa-solid fa-plus" }, null, -1),
            ne("  ", -1)
          ])])
        ])) : (S(), L("div", Gd, [
          (S(!0), L(Ae, null, Wt(t.tables, (m) => (S(), L("div", {
            key: m.tableName,
            class: Re(["table-item", { active: t.selectedTable === m.tableName }]),
            onClick: (h) => r(m.tableName)
          }, [
            f("div", Qd, [
              d[7] || (d[7] = f("i", { class: "fa-solid fa-table table-icon" }, null, -1)),
              f("span", Jd, de(m.tableName), 1)
            ]),
            m.comment ? (S(), L("div", Xd, de(m.comment), 1)) : te("", !0)
          ], 10, Yd))), 128))
        ]))
      ])
    ], 2));
  }
}), ef = /* @__PURE__ */ De(Zd, [["__scopeId", "data-v-85bfbdca"]]), tf = { class: "table-drawer-layout" }, sf = { class: "layout-content" }, nf = {
  key: 0,
  class: "layout-drawer"
}, of = { class: "layout-main" }, rf = /* @__PURE__ */ Te({
  __name: "TableDrawerLayout",
  props: {
    drawerExpanded: { type: Boolean },
    tables: {},
    selectedTable: {},
    showSyncButtons: { type: Boolean, default: !1 }
  },
  emits: ["update:drawerExpanded", "selectTable", "createTable", "sync", "push"],
  setup(t, { emit: e }) {
    const s = e, n = (l) => {
      s("selectTable", l);
    }, i = () => {
      s("createTable");
    }, o = () => {
      s("update:drawerExpanded", !1);
    }, r = () => {
      s("sync");
    }, a = () => {
      s("push");
    };
    return (l, u) => (S(), L("div", tf, [
      f("div", sf, [
        w(co, { name: "drawer-slide" }, {
          default: B(() => [
            t.drawerExpanded ? (S(), L("div", nf, [
              w(ef, {
                tables: t.tables,
                "selected-table": t.selectedTable,
                "show-sync-buttons": t.showSyncButtons,
                onSelect: n,
                onCreate: i,
                onCloseDrawer: o,
                onSync: r,
                onPush: a
              }, null, 8, ["tables", "selected-table", "show-sync-buttons"])
            ])) : te("", !0)
          ]),
          _: 1
        }),
        f("div", of, [
          mt(l.$slots, "default", {}, void 0, !0)
        ])
      ])
    ]));
  }
}), uo = /* @__PURE__ */ De(rf, [["__scopeId", "data-v-3e0df31e"]]), af = { class: "tab-container" }, lf = { class: "tab-header" }, cf = ["onClick"], uf = { class: "tab-body" }, df = /* @__PURE__ */ Te({
  __name: "TabContainer",
  props: {
    tabs: {},
    activeTab: {}
  },
  emits: ["update:activeTab"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ H(window.innerWidth), o = () => {
      i.value = window.innerWidth;
    };
    nt(() => {
      window.addEventListener("resize", o);
    }), pn(() => {
      window.removeEventListener("resize", o);
    });
    const r = se(() => {
      const l = i.value <= 768;
      return s.tabs.filter((u) => !(u.mobileOnly && !l || u.desktopOnly && l));
    }), a = (l) => {
      n("update:activeTab", l);
    };
    return (l, u) => (S(), L("div", af, [
      f("div", lf, [
        (S(!0), L(Ae, null, Wt(r.value, (c) => (S(), L("div", {
          key: c.key,
          class: Re(["tab-item", { active: t.activeTab === c.key }]),
          onClick: (d) => a(c.key)
        }, [
          c.icon ? (S(), L("i", {
            key: 0,
            class: Re(c.icon)
          }, null, 2)) : te("", !0),
          f("span", null, de(c.label), 1)
        ], 10, cf))), 128))
      ]),
      f("div", uf, [
        (S(!0), L(Ae, null, Wt(t.tabs, (c) => (S(), L(Ae, {
          key: c.key
        }, [
          t.activeTab === c.key ? mt(l.$slots, c.key, { key: 0 }, void 0, !0) : te("", !0)
        ], 64))), 128))
      ])
    ]));
  }
}), fo = /* @__PURE__ */ De(df, [["__scopeId", "data-v-9d94b988"]]), ff = /* @__PURE__ */ Te({
  __name: "DrawerToggle",
  props: {
    expanded: { type: Boolean },
    fab: { type: Boolean, default: !1 }
  },
  emits: ["toggle"],
  setup(t, { emit: e }) {
    const s = e, n = () => {
      s("toggle");
    };
    return (i, o) => (S(), L("button", {
      class: Re(["drawer-toggle", { fab: t.fab }]),
      onClick: n
    }, [...o[0] || (o[0] = [
      f("div", { class: "hamburger-icon" }, [
        f("span", { class: "line" }),
        f("span", { class: "line" }),
        f("span", { class: "line" })
      ], -1)
    ])], 2));
  }
}), po = /* @__PURE__ */ De(ff, [["__scopeId", "data-v-04d4da93"]]), pf = /* @__PURE__ */ Te({
  __name: "ToastNotification",
  props: {
    visible: { type: Boolean },
    message: {},
    type: {},
    icon: {}
  },
  setup(t) {
    return (e, s) => (S(), Ie(co, { name: "toast" }, {
      default: B(() => [
        t.visible ? (S(), L("div", {
          key: 0,
          class: Re(["toast-notification", t.type])
        }, [
          f("i", {
            class: Re(t.icon)
          }, null, 2),
          f("span", null, de(t.message), 1)
        ], 2)) : te("", !0)
      ]),
      _: 1
    }));
  }
}), ol = /* @__PURE__ */ De(pf, [["__scopeId", "data-v-76c92735"]]), hf = /* @__PURE__ */ Te({
  __name: "EmptyState",
  props: {
    icon: {},
    text: {},
    iconSize: { default: 48 },
    variant: { default: "default" }
  },
  setup(t) {
    return (e, s) => (S(), L("div", {
      class: Re([t.variant, "empty-state"])
    }, [
      f("i", {
        class: Re(t.icon),
        style: Ke({ fontSize: `${t.iconSize}px` })
      }, null, 6),
      f("span", null, de(t.text), 1)
    ], 2));
  }
}), Gn = /* @__PURE__ */ De(hf, [["__scopeId", "data-v-5ddb0dfd"]]);
function rl() {
  const t = /* @__PURE__ */ is({
    visible: !1,
    message: "",
    type: "success",
    icon: "fa-solid fa-check-circle"
  });
  let e = null;
  return {
    toast: t,
    showToast: (n, i = "success") => {
      e && clearTimeout(e), t.message = n, t.type = i, t.icon = i === "success" ? "fa-solid fa-check-circle" : "fa-solid fa-circle-xmark", t.visible = !0, e = setTimeout(() => {
        t.visible = !1;
      }, 3e3);
    }
  };
}
function mf() {
  return {
    showCreateTableModal: /* @__PURE__ */ H(!1),
    showEditTableNameModal: /* @__PURE__ */ H(!1),
    showEditTableCommentModal: /* @__PURE__ */ H(!1),
    showDropTableModal: /* @__PURE__ */ H(!1),
    showAddColumnModal: /* @__PURE__ */ H(!1),
    showEditColumnNameModal: /* @__PURE__ */ H(!1),
    showEditColumnCommentModal: /* @__PURE__ */ H(!1),
    showDropColumnModal: /* @__PURE__ */ H(!1),
    showDDLModal: /* @__PURE__ */ H(!1),
    editingColumn: /* @__PURE__ */ H(null),
    exportedDDL: /* @__PURE__ */ H("")
  };
}
const vf = ["value", "placeholder", "disabled", "readonly", "maxlength"], bf = {
  key: 0,
  class: "textarea-footer"
}, gf = /* @__PURE__ */ Te({
  __name: "AutoResizeTextarea",
  props: {
    modelValue: { default: "" },
    placeholder: { default: "..." },
    minRows: { default: 1 },
    maxRows: { default: 15 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    maxlength: { default: void 0 },
    showCount: { type: Boolean, default: !1 },
    submitOnEnter: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "focus", "blur", "submit"],
  setup(t, { expose: e, emit: s }) {
    const n = t, i = s, o = /* @__PURE__ */ H(null), r = /* @__PURE__ */ H(null), a = /* @__PURE__ */ H(!1), l = /* @__PURE__ */ H(24), u = se(() => (n.modelValue || "").length);
    function c() {
      const N = o.value, _ = r.value;
      if (!N || !_) return;
      const C = window.getComputedStyle(N), R = parseFloat(C.lineHeight) || 24;
      l.value = R;
      const U = parseFloat(C.paddingTop) || 0, le = parseFloat(C.paddingBottom) || 0, he = parseFloat(C.borderTopWidth) || 0, W = parseFloat(C.borderBottomWidth) || 0;
      _.style.width = `${N.clientWidth}px`, _.style.fontSize = C.fontSize, _.style.fontFamily = C.fontFamily, _.style.fontWeight = C.fontWeight, _.style.letterSpacing = C.letterSpacing, _.style.wordSpacing = C.wordSpacing, _.style.lineHeight = C.lineHeight, _.style.paddingTop = C.paddingTop, _.style.paddingBottom = C.paddingBottom, _.style.paddingLeft = C.paddingLeft, _.style.paddingRight = C.paddingRight, _.style.wordBreak = C.wordBreak, _.style.whiteSpace = "pre-wrap", _.style.overflowWrap = "break-word", _.style.boxSizing = "border-box";
      const re = n.modelValue || "";
      _.textContent = re + `
`;
      const me = _.scrollHeight, D = R * n.minRows + U + le, K = R * n.maxRows + U + le, oe = Math.min(Math.max(me, D), K);
      N.style.height = `${oe + he + W}px`, N.style.overflowY = me > K ? "auto" : "hidden";
    }
    function d(N) {
      const _ = N.target;
      i("update:modelValue", _.value), c(), It(c);
    }
    function m(N) {
      a.value = !0, i("focus", N);
    }
    function h(N) {
      a.value = !1, i("blur", N);
    }
    function g(N) {
      n.submitOnEnter && N.key === "Enter" && !N.shiftKey && (N.preventDefault(), i("submit", n.modelValue || ""));
    }
    function E() {
      o.value?.focus();
    }
    function y() {
      o.value?.blur();
    }
    e({ focus: E, blur: y, adjustHeight: c }), lt(() => n.modelValue, () => {
      It(c);
    }), lt([() => n.minRows, () => n.maxRows], () => {
      It(c);
    });
    let T = null;
    return nt(() => {
      c(), window.ResizeObserver && o.value && (T = new ResizeObserver(() => c()), T.observe(o.value.parentElement));
    }), Pt(() => {
      T?.disconnect();
    }), (N, _) => (S(), L("div", {
      class: Re(["auto-resize-wrapper", { focused: a.value, disabled: t.disabled }])
    }, [
      f("div", {
        ref_key: "mirrorRef",
        ref: r,
        class: "textarea-mirror",
        "aria-hidden": "true"
      }, null, 512),
      f("textarea", {
        ref_key: "textareaRef",
        ref: o,
        class: "auto-resize-textarea",
        value: t.modelValue,
        placeholder: t.placeholder,
        disabled: t.disabled,
        readonly: t.readonly,
        maxlength: t.maxlength,
        rows: 1,
        onInput: d,
        onFocus: m,
        onBlur: h,
        onKeydown: g
      }, null, 40, vf),
      t.showCount && t.maxlength ? (S(), L("div", bf, [
        f("span", {
          class: Re(["char-count", { warning: u.value > t.maxlength * 0.9 }])
        }, de(u.value) + " / " + de(t.maxlength), 3)
      ])) : te("", !0)
    ], 2));
  }
}), Vs = /* @__PURE__ */ De(gf, [["__scopeId", "data-v-fd129974"]]);
var Lt = /* @__PURE__ */ ((t) => (t.NUMBER = "NUMBER", t.STRING = "STRING", t))(Lt || {});
function ai() {
  const t = /* @__PURE__ */ H([]), e = se(() => t.value.length > 0), s = (h) => t.value.find((g) => g.field === h)?.message, n = () => {
    t.value = [];
  }, i = (h, g) => {
    t.value.push({ field: h, message: g });
  }, o = (h, g) => {
    const E = h.trim();
    return E ? E.length > 64 ? (i("tableName", "64"), !1) : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(E) ? g?.checkTableNameExists && g.checkTableNameExists(E) ? g.excludeName && E === g.excludeName ? !0 : (i("tableName", ` "${E}" `), !1) : !0 : (i("tableName", ""), !1) : (i("tableName", ""), !1);
  }, r = (h, g) => {
    const E = h.trim();
    return E ? E.length > 64 ? (i("columnName", "64"), !1) : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(E) ? g?.checkColumnNameExists && g.checkColumnNameExists(E) ? g.excludeName && E === g.excludeName ? !0 : (i("columnName", ` "${E}" `), !1) : !0 : (i("columnName", ""), !1) : (i("columnName", ""), !1);
  }, a = (h) => {
    const g = h.map((T) => T.name.trim()).filter((T) => T), E = [], y = /* @__PURE__ */ new Set();
    for (const T of g)
      y.has(T) && (E.includes(T) || E.push(T)), y.add(T);
    return E.length > 0 ? (i("columns", `: ${E.join(", ")}`), !1) : !0;
  };
  return {
    errors: t,
    hasErrors: e,
    getFieldError: s,
    clearErrors: n,
    addError: i,
    validateTableName: o,
    validateColumnName: r,
    validateDuplicateColumnNames: a,
    validateCreateTableForm: (h, g, E) => {
      n();
      const y = E.map((T) => T.tableName);
      return o(h, {
        checkTableNameExists: (T) => y.includes(T)
      }), g.length === 0 && i("columns", ""), g.forEach((T, N) => {
        const _ = T.name.trim();
        _ ? /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(_) || i(`column_${N}`, ` "${_}" `) : i(`column_${N}`, ` ${N + 1} `);
      }), a(g), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateAddColumnForm: (h, g) => {
      n();
      const E = g.map((y) => y.name);
      return r(h, {
        checkColumnNameExists: (y) => E.includes(y)
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateEditTableNameForm: (h, g, E) => {
      n();
      const y = E.map((T) => T.tableName);
      return o(h, {
        checkTableNameExists: (T) => y.includes(T),
        excludeName: g
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateEditColumnNameForm: (h, g, E) => {
      n();
      const y = E.map((T) => T.name);
      return r(h, {
        checkColumnNameExists: (T) => y.includes(T),
        excludeName: g
      }), {
        valid: t.value.length === 0,
        errors: t.value
      };
    },
    validateComment: (h, g = 500) => h && h.length > g ? (i("comment", ` ${g} `), !1) : !0
  };
}
const Ef = { class: "form-container" }, yf = { class: "form-section" }, _f = { class: "form-item" }, Tf = {
  key: 0,
  class: "field-error"
}, Nf = { class: "form-item" }, xf = { class: "form-section columns-section" }, Sf = { class: "section-header" }, Cf = { class: "column-count" }, wf = {
  key: 0,
  class: "field-error section-error"
}, Df = { class: "columns-list" }, Of = { class: "column-card-header" }, $f = { class: "column-number" }, Af = ["onClick"], Vf = { class: "column-card-body" }, Mf = { class: "form-row" }, If = { class: "form-col form-col-name" }, Rf = ["onUpdate:modelValue"], Lf = { class: "form-col form-col-type" }, kf = ["onUpdate:modelValue"], Pf = ["value"], Bf = ["value"], Ff = {
  key: 0,
  class: "field-error"
}, Uf = { class: "form-row" }, jf = { class: "form-col form-col-default" }, qf = ["onUpdate:modelValue"], Hf = { class: "form-col form-col-comment" }, Wf = { class: "checkbox-label" }, Kf = ["onUpdate:modelValue"], zf = { class: "form-actions" }, Gf = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Yf = "auto", Qf = /* @__PURE__ */ Te({
  __name: "CreateTableForm",
  props: {
    existingTables: { default: () => [] }
  },
  emits: ["create", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateCreateTableForm: o, clearErrors: r } = ai(), a = /* @__PURE__ */ H(!1), l = /* @__PURE__ */ H(!1), u = () => {
      l.value = window.innerWidth <= 768;
    };
    nt(() => {
      u(), window.addEventListener("resize", u);
    }), Pt(() => {
      window.removeEventListener("resize", u);
    });
    const c = se(() => l.value ? "100%" : "50vw"), d = se(() => {
      const N = {};
      return N["--form-modal-width"] = l.value ? "100%" : "50vw", N;
    });
    let m = 0;
    const h = /* @__PURE__ */ is({
      tableName: "",
      comment: "",
      columns: []
    }), g = () => {
      h.columns.push({
        id: ++m,
        name: "",
        type: Lt.STRING,
        primitiveKey: !1,
        comment: ""
      });
    }, E = (N) => {
      h.columns.splice(N, 1);
    }, y = () => {
      if (r(), a.value = !0, !o(
        h.tableName,
        h.columns,
        s.existingTables
      ).valid) {
        a.value = !1;
        return;
      }
      const _ = h.columns.map((C) => ({
        name: C.name.trim(),
        type: C.type,
        primitiveKey: C.primitiveKey,
        defaultValue: C.defaultValue || void 0,
        comment: C.comment || void 0
      }));
      n("create", {
        tableName: h.tableName.trim(),
        columns: _,
        comment: h.comment.trim() || void 0
      }), a.value = !1;
    }, T = () => {
      r(), n("cancel");
    };
    return h.columns.length === 0 && g(), (N, _) => (S(), L("div", {
      class: "form-wrapper",
      style: Ke(d.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: c.value,
        height: Yf,
        closable: !1,
        onClose: T
      }, {
        default: B(() => [
          f("div", Ef, [
            f("div", yf, [
              f("div", _f, [
                _[3] || (_[3] = f("label", { class: "form-label" }, [
                  ne("  "),
                  f("span", { class: "required" }, "*")
                ], -1)),
                rt(f("input", {
                  "onUpdate:modelValue": _[0] || (_[0] = (C) => h.tableName = C),
                  class: Re(["form-input", { "has-error": Q(i)("tableName") }]),
                  type: "text",
                  placeholder: "user_info"
                }, null, 2), [
                  [zt, h.tableName]
                ]),
                Q(i)("tableName") ? (S(), L("div", Tf, [
                  _[2] || (_[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                  ne(" " + de(Q(i)("tableName")), 1)
                ])) : te("", !0),
                _[4] || (_[4] = f("div", { class: "field-hint" }, "", -1))
              ]),
              f("div", Nf, [
                _[5] || (_[5] = f("label", { class: "form-label" }, "", -1)),
                w(Vs, {
                  modelValue: h.comment,
                  "onUpdate:modelValue": _[1] || (_[1] = (C) => h.comment = C),
                  placeholder: "",
                  "min-rows": 2,
                  "max-rows": 6
                }, null, 8, ["modelValue"]),
                _[6] || (_[6] = f("div", { class: "field-hint" }, "", -1))
              ])
            ]),
            f("div", xf, [
              f("div", Sf, [
                _[7] || (_[7] = f("label", { class: "form-label" }, [
                  ne("  "),
                  f("span", { class: "required" }, "*")
                ], -1)),
                f("span", Cf, de(h.columns.length) + " ", 1)
              ]),
              Q(i)("columns") ? (S(), L("div", wf, [
                _[8] || (_[8] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                ne(" " + de(Q(i)("columns")), 1)
              ])) : te("", !0),
              f("div", Df, [
                (S(!0), L(Ae, null, Wt(h.columns, (C, R) => (S(), L("div", {
                  key: C.id,
                  class: Re(["column-card", { "has-error": Q(i)(`column_${R}`) }])
                }, [
                  f("div", Of, [
                    f("span", $f, "#" + de(R + 1), 1),
                    f("button", {
                      class: "remove-btn",
                      onClick: (U) => E(R),
                      title: ""
                    }, [..._[9] || (_[9] = [
                      f("i", { class: "fa-solid fa-trash" }, null, -1)
                    ])], 8, Af)
                  ]),
                  f("div", Vf, [
                    f("div", Mf, [
                      f("div", If, [
                        _[10] || (_[10] = f("label", { class: "field-label" }, [
                          ne(" "),
                          f("span", { class: "required" }, "*")
                        ], -1)),
                        rt(f("input", {
                          "onUpdate:modelValue": (U) => C.name = U,
                          class: "form-input",
                          type: "text",
                          placeholder: ""
                        }, null, 8, Rf), [
                          [zt, C.name]
                        ])
                      ]),
                      f("div", Lf, [
                        _[11] || (_[11] = f("label", { class: "field-label" }, "", -1)),
                        rt(f("select", {
                          "onUpdate:modelValue": (U) => C.type = U,
                          class: "form-select"
                        }, [
                          f("option", {
                            value: Q(Lt).STRING
                          }, "STRING", 8, Pf),
                          f("option", {
                            value: Q(Lt).NUMBER
                          }, "NUMBER", 8, Bf)
                        ], 8, kf), [
                          [nl, C.type]
                        ])
                      ])
                    ]),
                    Q(i)(`column_${R}`) ? (S(), L("div", Ff, [
                      _[12] || (_[12] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                      ne(" " + de(Q(i)(`column_${R}`)), 1)
                    ])) : te("", !0),
                    f("div", Uf, [
                      f("div", jf, [
                        _[13] || (_[13] = f("label", { class: "field-label" }, "", -1)),
                        rt(f("input", {
                          "onUpdate:modelValue": (U) => C.defaultValue = U,
                          class: "form-input",
                          type: "text",
                          placeholder: ""
                        }, null, 8, qf), [
                          [zt, C.defaultValue]
                        ])
                      ]),
                      f("div", Hf, [
                        _[14] || (_[14] = f("label", { class: "field-label" }, "", -1)),
                        w(Vs, {
                          modelValue: C.comment,
                          "onUpdate:modelValue": (U) => C.comment = U,
                          placeholder: "",
                          "min-rows": 1,
                          "max-rows": 4
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ])
                    ]),
                    f("label", Wf, [
                      rt(f("input", {
                        "onUpdate:modelValue": (U) => C.primitiveKey = U,
                        type: "checkbox"
                      }, null, 8, Kf), [
                        [sl, C.primitiveKey]
                      ]),
                      _[15] || (_[15] = f("span", null, "", -1))
                    ])
                  ])
                ], 2))), 128)),
                f("button", {
                  class: "add-column-btn",
                  onClick: g
                }, [..._[16] || (_[16] = [
                  f("i", { class: "fa-solid fa-plus" }, null, -1),
                  f("span", null, "", -1)
                ])])
              ])
            ]),
            f("div", zf, [
              w(ae, { onClick: T }, {
                default: B(() => [..._[17] || (_[17] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: a.value,
                onClick: y
              }, {
                default: B(() => [
                  a.value ? (S(), L("i", Gf)) : te("", !0),
                  _[18] || (_[18] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Jf = /* @__PURE__ */ De(Qf, [["__scopeId", "data-v-08eccbfb"]]), Xf = { class: "form-container" }, Zf = { class: "form-item" }, ep = ["value"], tp = { class: "form-item" }, sp = {
  key: 0,
  class: "field-error"
}, np = { class: "form-actions" }, ip = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, op = "auto", rp = /* @__PURE__ */ Te({
  __name: "EditTableNameForm",
  props: {
    tableName: {},
    existingTables: { default: () => [] }
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateEditTableNameForm: o, clearErrors: r } = ai(), a = /* @__PURE__ */ H(!1), l = /* @__PURE__ */ H(s.tableName), u = /* @__PURE__ */ H(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    nt(() => {
      c(), window.addEventListener("resize", c);
    }), Pt(() => {
      window.removeEventListener("resize", c);
    });
    const d = se(() => u.value ? "100%" : "50vw"), m = se(() => {
      const y = {};
      return y["--form-modal-width"] = u.value ? "100%" : "50vw", y;
    }), h = se(() => l.value.trim() !== s.tableName);
    lt(() => s.tableName, (y) => {
      l.value = y, r();
    });
    const g = () => {
      if (r(), a.value = !0, !o(
        l.value,
        s.tableName,
        s.existingTables
      ).valid) {
        a.value = !1;
        return;
      }
      n("save", l.value.trim()), a.value = !1;
    }, E = () => {
      l.value = s.tableName, r(), n("cancel");
    };
    return (y, T) => (S(), L("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: op,
        closable: !1,
        onClose: E
      }, {
        default: B(() => [
          f("div", Xf, [
            f("div", Zf, [
              T[1] || (T[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.tableName,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, ep)
            ]),
            f("div", tp, [
              T[3] || (T[3] = f("label", { class: "form-label" }, [
                ne("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              rt(f("input", {
                "onUpdate:modelValue": T[0] || (T[0] = (N) => l.value = N),
                class: Re(["form-input", { "has-error": Q(i)("tableName") }]),
                type: "text",
                placeholder: ""
              }, null, 2), [
                [zt, l.value]
              ]),
              Q(i)("tableName") ? (S(), L("div", sp, [
                T[2] || (T[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                ne(" " + de(Q(i)("tableName")), 1)
              ])) : te("", !0),
              T[4] || (T[4] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", np, [
              w(ae, { onClick: E }, {
                default: B(() => [...T[5] || (T[5] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: a.value || !h.value,
                onClick: g
              }, {
                default: B(() => [
                  a.value ? (S(), L("i", ip)) : te("", !0),
                  T[6] || (T[6] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), ap = /* @__PURE__ */ De(rp, [["__scopeId", "data-v-58e374f4"]]), lp = { class: "form-container" }, cp = { class: "form-item" }, up = { class: "form-actions" }, dp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, fp = "auto", pp = /* @__PURE__ */ Te({
  __name: "EditTableCommentForm",
  props: {
    comment: {}
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ H(s.comment || ""), o = /* @__PURE__ */ H(!1), r = /* @__PURE__ */ H(!1), a = () => {
      r.value = window.innerWidth <= 768;
    };
    nt(() => {
      a(), window.addEventListener("resize", a);
    }), Pt(() => {
      window.removeEventListener("resize", a);
    });
    const l = se(() => r.value ? "100%" : "50vw"), u = se(() => {
      const m = {};
      return m["--form-modal-width"] = r.value ? "100%" : "50vw", m;
    }), c = () => {
      o.value = !0, n("save", i.value), o.value = !1;
    }, d = () => {
      i.value = s.comment || "", n("cancel");
    };
    return (m, h) => (S(), L("div", {
      class: "form-wrapper",
      style: Ke(u.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: l.value,
        height: fp,
        closable: !1,
        onClose: d
      }, {
        default: B(() => [
          f("div", lp, [
            f("div", cp, [
              h[1] || (h[1] = f("label", { class: "form-label" }, "", -1)),
              w(Vs, {
                modelValue: i.value,
                "onUpdate:modelValue": h[0] || (h[0] = (g) => i.value = g),
                placeholder: "",
                maxlength: 500,
                "show-count": !0,
                "min-rows": 3,
                "max-rows": 10
              }, null, 8, ["modelValue"])
            ]),
            f("div", up, [
              w(ae, { onClick: d }, {
                default: B(() => [...h[2] || (h[2] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: o.value,
                onClick: c
              }, {
                default: B(() => [
                  o.value ? (S(), L("i", dp)) : te("", !0),
                  h[3] || (h[3] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), hp = /* @__PURE__ */ De(pp, [["__scopeId", "data-v-03532044"]]), mp = { class: "confirm-container" }, vp = { class: "confirm-content" }, bp = { class: "confirm-message" }, gp = { class: "form-actions" }, Ep = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, yp = /* @__PURE__ */ Te({
  __name: "DropTableConfirm",
  props: {
    tableName: {},
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ H(!1), o = se(() => {
      const l = {};
      return s.modalWidth && (l["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (l["--confirm-modal-height"] = s.modalHeight), l;
    }), r = () => {
      i.value = !0, n("confirm");
    }, a = () => {
      n("cancel");
    };
    return (l, u) => (S(), L("div", {
      class: "drop-table-confirm-wrapper",
      style: Ke(o.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: a
      }, {
        default: B(() => [
          f("div", mp, [
            u[5] || (u[5] = f("div", { class: "confirm-icon-wrapper" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" })
            ], -1)),
            f("div", vp, [
              f("div", bp, [
                u[0] || (u[0] = ne("  ", -1)),
                f("strong", null, de(t.tableName), 1),
                u[1] || (u[1] = ne("  ", -1))
              ]),
              u[2] || (u[2] = f("div", { class: "confirm-warning" }, [
                f("i", { class: "fa-solid fa-circle-info" }),
                f("span", null, "")
              ], -1))
            ]),
            f("div", gp, [
              w(ae, { onClick: a }, {
                default: B(() => [...u[3] || (u[3] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "danger",
                disabled: i.value,
                onClick: r
              }, {
                default: B(() => [
                  i.value ? (S(), L("i", Ep)) : te("", !0),
                  u[4] || (u[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), _p = /* @__PURE__ */ De(yp, [["__scopeId", "data-v-4629727b"]]), Tp = { class: "form-container" }, Np = { class: "form-item" }, xp = {
  key: 0,
  class: "field-error"
}, Sp = { class: "form-item" }, Cp = ["value"], wp = ["value"], Dp = { class: "form-item" }, Op = { class: "checkbox-label" }, $p = { class: "form-item" }, Ap = { class: "form-item" }, Vp = { class: "form-actions" }, Mp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Ip = "auto", Rp = /* @__PURE__ */ Te({
  __name: "AddColumnForm",
  props: {
    existingColumns: { default: () => [] }
  },
  emits: ["create", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateAddColumnForm: o, clearErrors: r } = ai(), a = /* @__PURE__ */ H(!1), l = /* @__PURE__ */ is({
      name: "",
      type: Lt.STRING,
      primitiveKey: !1
    }), u = /* @__PURE__ */ H(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    nt(() => {
      c(), window.addEventListener("resize", c);
    }), Pt(() => {
      window.removeEventListener("resize", c);
    });
    const d = se(() => u.value ? "100%" : "50vw"), m = se(() => {
      const E = {};
      return E["--form-modal-width"] = u.value ? "100%" : "50vw", E;
    }), h = () => {
      if (r(), a.value = !0, !o(l.name, s.existingColumns).valid) {
        a.value = !1;
        return;
      }
      const y = {
        name: l.name.trim(),
        type: l.type,
        primitiveKey: l.primitiveKey,
        defaultValue: l.defaultValue || void 0,
        comment: l.comment || void 0
      };
      n("create", y), a.value = !1;
    }, g = () => {
      r(), n("cancel");
    };
    return (E, y) => (S(), L("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: Ip,
        closable: !1,
        onClose: g
      }, {
        default: B(() => [
          f("div", Tp, [
            f("div", Np, [
              y[6] || (y[6] = f("label", { class: "form-label" }, [
                ne("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              rt(f("input", {
                "onUpdate:modelValue": y[0] || (y[0] = (T) => l.name = T),
                class: Re(["form-input", { "has-error": Q(i)("columnName") }]),
                type: "text",
                placeholder: "username"
              }, null, 2), [
                [zt, l.name]
              ]),
              Q(i)("columnName") ? (S(), L("div", xp, [
                y[5] || (y[5] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                ne(" " + de(Q(i)("columnName")), 1)
              ])) : te("", !0),
              y[7] || (y[7] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Sp, [
              y[8] || (y[8] = f("label", { class: "form-label" }, "", -1)),
              rt(f("select", {
                "onUpdate:modelValue": y[1] || (y[1] = (T) => l.type = T),
                class: "form-select"
              }, [
                f("option", {
                  value: Q(Lt).STRING
                }, "STRING", 8, Cp),
                f("option", {
                  value: Q(Lt).NUMBER
                }, "NUMBER", 8, wp)
              ], 512), [
                [nl, l.type]
              ])
            ]),
            f("div", Dp, [
              f("label", Op, [
                rt(f("input", {
                  "onUpdate:modelValue": y[2] || (y[2] = (T) => l.primitiveKey = T),
                  type: "checkbox"
                }, null, 512), [
                  [sl, l.primitiveKey]
                ]),
                y[9] || (y[9] = f("span", null, "", -1))
              ])
            ]),
            f("div", $p, [
              y[10] || (y[10] = f("label", { class: "form-label" }, "", -1)),
              rt(f("input", {
                "onUpdate:modelValue": y[3] || (y[3] = (T) => l.defaultValue = T),
                class: "form-input",
                type: "text",
                placeholder: ""
              }, null, 512), [
                [zt, l.defaultValue]
              ]),
              y[11] || (y[11] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", Ap, [
              y[12] || (y[12] = f("label", { class: "form-label" }, "", -1)),
              w(Vs, {
                modelValue: l.comment,
                "onUpdate:modelValue": y[4] || (y[4] = (T) => l.comment = T),
                placeholder: "",
                "min-rows": 1,
                "max-rows": 4
              }, null, 8, ["modelValue"])
            ]),
            f("div", Vp, [
              w(ae, { onClick: g }, {
                default: B(() => [...y[13] || (y[13] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: a.value,
                onClick: h
              }, {
                default: B(() => [
                  a.value ? (S(), L("i", Mp)) : te("", !0),
                  y[14] || (y[14] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Lp = /* @__PURE__ */ De(Rp, [["__scopeId", "data-v-019138f2"]]), kp = { class: "form-container" }, Pp = { class: "form-item" }, Bp = ["value"], Fp = { class: "form-item" }, Up = {
  key: 0,
  class: "field-error"
}, jp = { class: "form-actions" }, qp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Hp = "auto", Wp = /* @__PURE__ */ Te({
  __name: "EditColumnNameForm",
  props: {
    column: {},
    existingColumns: { default: () => [] }
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, { getFieldError: i, validateEditColumnNameForm: o, clearErrors: r } = ai(), a = /* @__PURE__ */ H(!1), l = /* @__PURE__ */ H(s.column.name), u = /* @__PURE__ */ H(!1), c = () => {
      u.value = window.innerWidth <= 768;
    };
    nt(() => {
      c(), window.addEventListener("resize", c);
    }), Pt(() => {
      window.removeEventListener("resize", c);
    });
    const d = se(() => u.value ? "100%" : "50vw"), m = se(() => {
      const y = {};
      return y["--form-modal-width"] = u.value ? "100%" : "50vw", y;
    }), h = se(() => l.value.trim() !== s.column.name);
    lt(() => s.column, (y) => {
      l.value = y.name, r();
    }, { deep: !0 });
    const g = () => {
      if (r(), a.value = !0, !o(
        l.value,
        s.column.name,
        s.existingColumns
      ).valid) {
        a.value = !1;
        return;
      }
      n("save", l.value.trim()), a.value = !1;
    }, E = () => {
      l.value = s.column.name, r(), n("cancel");
    };
    return (y, T) => (S(), L("div", {
      class: "form-wrapper",
      style: Ke(m.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: d.value,
        height: Hp,
        closable: !1,
        onClose: E
      }, {
        default: B(() => [
          f("div", kp, [
            f("div", Pp, [
              T[1] || (T[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.column.name,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, Bp)
            ]),
            f("div", Fp, [
              T[3] || (T[3] = f("label", { class: "form-label" }, [
                ne("  "),
                f("span", { class: "required" }, "*")
              ], -1)),
              rt(f("input", {
                "onUpdate:modelValue": T[0] || (T[0] = (N) => l.value = N),
                class: Re(["form-input", { "has-error": Q(i)("columnName") }]),
                type: "text",
                placeholder: ""
              }, null, 2), [
                [zt, l.value]
              ]),
              Q(i)("columnName") ? (S(), L("div", Up, [
                T[2] || (T[2] = f("i", { class: "fa-solid fa-circle-exclamation" }, null, -1)),
                ne(" " + de(Q(i)("columnName")), 1)
              ])) : te("", !0),
              T[4] || (T[4] = f("div", { class: "field-hint" }, "", -1))
            ]),
            f("div", jp, [
              w(ae, { onClick: E }, {
                default: B(() => [...T[5] || (T[5] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: a.value || !h.value,
                onClick: g
              }, {
                default: B(() => [
                  a.value ? (S(), L("i", qp)) : te("", !0),
                  T[6] || (T[6] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), Kp = /* @__PURE__ */ De(Wp, [["__scopeId", "data-v-36708f97"]]), zp = { class: "form-container" }, Gp = { class: "form-item" }, Yp = ["value"], Qp = { class: "form-item" }, Jp = { class: "form-actions" }, Xp = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, Zp = "auto", eh = /* @__PURE__ */ Te({
  __name: "EditColumnCommentForm",
  props: {
    column: {}
  },
  emits: ["save", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ H(s.column.comment || ""), o = /* @__PURE__ */ H(!1), r = /* @__PURE__ */ H(!1), a = () => {
      r.value = window.innerWidth <= 768;
    };
    nt(() => {
      a(), window.addEventListener("resize", a);
    }), Pt(() => {
      window.removeEventListener("resize", a);
    });
    const l = se(() => r.value ? "100%" : "50vw"), u = se(() => {
      const m = {};
      return m["--form-modal-width"] = r.value ? "100%" : "50vw", m;
    }), c = () => {
      o.value = !0, n("save", i.value), o.value = !1;
    }, d = () => {
      i.value = s.column.comment || "", n("cancel");
    };
    return (m, h) => (S(), L("div", {
      class: "form-wrapper",
      style: Ke(u.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: l.value,
        height: Zp,
        closable: !1,
        onClose: d
      }, {
        default: B(() => [
          f("div", zp, [
            f("div", Gp, [
              h[1] || (h[1] = f("label", { class: "form-label" }, "", -1)),
              f("input", {
                value: t.column.name,
                class: "form-input",
                type: "text",
                disabled: ""
              }, null, 8, Yp)
            ]),
            f("div", Qp, [
              h[2] || (h[2] = f("label", { class: "form-label" }, "", -1)),
              w(Vs, {
                modelValue: i.value,
                "onUpdate:modelValue": h[0] || (h[0] = (g) => i.value = g),
                placeholder: "",
                maxlength: 500,
                "show-count": !0,
                "min-rows": 3,
                "max-rows": 10
              }, null, 8, ["modelValue"])
            ]),
            f("div", Jp, [
              w(ae, { onClick: d }, {
                default: B(() => [...h[3] || (h[3] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                disabled: o.value,
                onClick: c
              }, {
                default: B(() => [
                  o.value ? (S(), L("i", Xp)) : te("", !0),
                  h[4] || (h[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width"])
    ], 4));
  }
}), th = /* @__PURE__ */ De(eh, [["__scopeId", "data-v-1f79f493"]]), sh = { class: "confirm-container" }, nh = { class: "confirm-content" }, ih = { class: "confirm-message" }, oh = { class: "form-actions" }, rh = {
  key: 0,
  class: "fa-solid fa-spinner fa-spin"
}, ah = /* @__PURE__ */ Te({
  __name: "DropColumnConfirm",
  props: {
    column: {},
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ H(!1), o = se(() => {
      const l = {};
      return s.modalWidth && (l["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (l["--confirm-modal-height"] = s.modalHeight), l;
    }), r = () => {
      i.value = !0, n("confirm");
    }, a = () => {
      n("cancel");
    };
    return (l, u) => (S(), L("div", {
      class: "drop-column-confirm-wrapper",
      style: Ke(o.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: a
      }, {
        default: B(() => [
          f("div", sh, [
            u[5] || (u[5] = f("div", { class: "confirm-icon-wrapper" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" })
            ], -1)),
            f("div", nh, [
              f("div", ih, [
                u[0] || (u[0] = ne("  ", -1)),
                f("strong", null, de(t.column.name), 1),
                u[1] || (u[1] = ne("  ", -1))
              ]),
              u[2] || (u[2] = f("div", { class: "confirm-warning" }, [
                f("i", { class: "fa-solid fa-circle-info" }),
                f("span", null, "")
              ], -1))
            ]),
            f("div", oh, [
              w(ae, { onClick: a }, {
                default: B(() => [...u[3] || (u[3] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "danger",
                disabled: i.value,
                onClick: r
              }, {
                default: B(() => [
                  i.value ? (S(), L("i", rh)) : te("", !0),
                  u[4] || (u[4] = f("span", null, "", -1))
                ]),
                _: 1
              }, 8, ["disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), lh = /* @__PURE__ */ De(ah, [["__scopeId", "data-v-7565defa"]]), ch = { class: "ddl-container" }, uh = { class: "ddl-header" }, dh = { class: "ddl-content" }, fh = { class: "ddl-code" }, ph = { class: "form-actions" }, hh = /* @__PURE__ */ Te({
  __name: "DDLDisplay",
  props: {
    ddl: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ H(!1);
    let o = null;
    const r = async () => {
      try {
        await navigator.clipboard.writeText(s.ddl), i.value = !0, o && clearTimeout(o), o = setTimeout(() => {
          i.value = !1;
        }, 2e3);
      } catch (l) {
        console.error(":", l);
      }
    }, a = () => {
      n("close");
    };
    return (l, u) => (S(), L("div", ch, [
      f("div", uh, [
        u[0] || (u[0] = f("span", { class: "ddl-title" }, "DDL ", -1)),
        f("button", {
          class: "copy-btn",
          onClick: r
        }, [
          f("i", {
            class: Re(i.value ? "fa-solid fa-check" : "fa-solid fa-copy")
          }, null, 2),
          ne(" " + de(i.value ? "" : ""), 1)
        ])
      ]),
      f("div", dh, [
        f("pre", fh, de(t.ddl), 1)
      ]),
      f("div", ph, [
        w(ae, { onClick: a }, {
          default: B(() => [...u[1] || (u[1] = [
            ne("", -1)
          ])]),
          _: 1
        })
      ])
    ]));
  }
}), mh = /* @__PURE__ */ De(hh, [["__scopeId", "data-v-da039aee"]]), vh = { class: "table-management-tab" }, bh = {
  key: 1,
  class: "table-detail"
}, gh = { class: "table-header" }, Eh = { class: "table-title-section" }, yh = { class: "table-name-row" }, _h = { class: "table-name" }, Th = {
  key: 0,
  class: "table-comment-row"
}, Nh = { class: "table-comment" }, xh = {
  key: 1,
  class: "table-comment-row"
}, Sh = { class: "table-actions" }, Ch = { class: "columns-section" }, wh = { class: "section-header" }, Dh = { class: "columns-list" }, Oh = { key: 1 }, $h = { class: "column-main" }, Ah = { class: "column-first-row" }, Vh = { class: "column-name-wrapper" }, Mh = { class: "column-name" }, Ih = { class: "type-badge" }, Rh = {
  key: 0,
  class: "primary-key-badge",
  title: ""
}, Lh = {
  key: 0,
  class: "column-comment"
}, kh = {
  key: 1,
  class: "default-value"
}, Ph = { class: "column-actions" }, Bh = /* @__PURE__ */ Te({
  __name: "TableManagementTab",
  props: {
    tableService: {},
    tables: {},
    selectedTable: {}
  },
  emits: ["refresh", "update:selectedTable"],
  setup(t, { expose: e, emit: s }) {
    const n = t, i = s, o = se(() => n.tables.find((J) => J.tableName === n.selectedTable) || {}), r = se(() => o.value.columnSchemas ? Object.entries(o.value.columnSchemas).map(([J, k]) => [parseInt(J), k]) : []), a = se(() => o.value.columnSchemas ? Object.values(o.value.columnSchemas) : []), l = se(() => !o.value.columnSchemas || !C.value ? [] : Object.values(o.value.columnSchemas).filter((J) => J.name !== C.value?.column.name)), { toast: u, showToast: c } = rl(), {
      showCreateTableModal: d,
      showEditTableNameModal: m,
      showEditTableCommentModal: h,
      showDropTableModal: g,
      showAddColumnModal: E,
      showEditColumnNameModal: y,
      showEditColumnCommentModal: T,
      showDropColumnModal: N,
      showDDLModal: _,
      editingColumn: C,
      exportedDDL: R
    } = mf(), U = (J) => J === null ? "NULL" : J === void 0 ? "" : String(J), le = (J) => {
      const k = n.tableService.createTable(J.tableName, J.columns, J.comment);
      k.success ? (d.value = !1, i("refresh"), c(` "${J.tableName}" `)) : c(k.message || "", "error");
    }, he = (J) => {
      if (o.value.tableName) {
        const k = n.tableService.alterTableName(o.value.tableName, J);
        k.success ? (m.value = !1, i("update:selectedTable", J), i("refresh"), c("")) : c(k.message || "", "error");
      }
    }, W = (J) => {
      if (o.value.tableName) {
        const k = n.tableService.alterTableComment(o.value.tableName, J);
        k.success ? (h.value = !1, i("refresh"), c("")) : c(k.message || "", "error");
      }
    }, re = () => {
      if (o.value.tableName) {
        const J = n.tableService.dropTable(o.value.tableName);
        J.success ? (g.value = !1, i("update:selectedTable", ""), i("refresh"), c("")) : c(J.message || "", "error");
      }
    }, me = (J) => {
      if (o.value.tableName) {
        const k = n.tableService.addColumn(o.value.tableName, J.name, J);
        k.success ? (E.value = !1, i("refresh"), c(` "${J.name}" `)) : c(k.message || "", "error");
      }
    }, D = (J, k) => {
      C.value = { fieldId: J, column: k }, y.value = !0;
    }, K = (J) => {
      if (o.value.tableName && C.value) {
        const k = n.tableService.alterColumnName(
          o.value.tableName,
          C.value.column.name,
          J
        );
        k.success ? (y.value = !1, C.value = null, i("refresh"), c("")) : c(k.message || "", "error");
      }
    }, oe = (J, k) => {
      C.value = { fieldId: J, column: k }, T.value = !0;
    }, be = (J) => {
      if (o.value.tableName && C.value) {
        const k = n.tableService.alterColumnComment(
          o.value.tableName,
          C.value.column.name,
          J
        );
        k.success ? (T.value = !1, C.value = null, i("refresh"), c("")) : c(k.message || "", "error");
      }
    }, pe = (J, k) => {
      C.value = { fieldId: J, column: k }, N.value = !0;
    }, ce = () => {
      if (o.value.tableName && C.value) {
        const J = n.tableService.dropColumn(
          o.value.tableName,
          C.value.column.name
        );
        J.success ? (N.value = !1, C.value = null, i("refresh"), c("")) : c(J.message || "", "error");
      }
    }, fe = () => {
      o.value.tableName && (R.value = n.tableService.exportDDL(o.value.tableName), _.value = !0);
    };
    return e({
      openCreateTableModal: () => {
        d.value = !0;
      }
    }), (J, k) => (S(), L("div", vh, [
      t.selectedTable ? (S(), L("div", bh, [
        f("div", gh, [
          f("div", Eh, [
            f("div", yh, [
              k[16] || (k[16] = f("span", { class: "table-label" }, "", -1)),
              f("span", _h, de(o.value.tableName), 1),
              w(ae, {
                size: "small",
                onClick: k[0] || (k[0] = (Oe) => m.value = !0)
              }, {
                default: B(() => [...k[15] || (k[15] = [
                  f("i", { class: "fa-solid fa-pen" }, null, -1)
                ])]),
                _: 1
              })
            ]),
            o.value.comment ? (S(), L("div", Th, [
              k[18] || (k[18] = f("span", { class: "table-label" }, "", -1)),
              f("span", Nh, de(o.value.comment), 1),
              w(ae, {
                size: "small",
                onClick: k[1] || (k[1] = (Oe) => h.value = !0)
              }, {
                default: B(() => [...k[17] || (k[17] = [
                  f("i", { class: "fa-solid fa-pen" }, null, -1)
                ])]),
                _: 1
              })
            ])) : (S(), L("div", xh, [
              k[20] || (k[20] = f("span", { class: "table-label" }, "", -1)),
              k[21] || (k[21] = f("span", { class: "table-comment placeholder" }, "", -1)),
              w(ae, {
                size: "small",
                onClick: k[2] || (k[2] = (Oe) => h.value = !0)
              }, {
                default: B(() => [...k[19] || (k[19] = [
                  f("i", { class: "fa-solid fa-plus" }, null, -1)
                ])]),
                _: 1
              })
            ]))
          ]),
          f("div", Sh, [
            w(ae, { onClick: fe }, {
              default: B(() => [...k[22] || (k[22] = [
                f("i", {
                  class: "fa-solid fa-download",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne(" DDL ", -1)
              ])]),
              _: 1
            }),
            w(ae, {
              type: "danger",
              onClick: k[3] || (k[3] = (Oe) => g.value = !0)
            }, {
              default: B(() => [...k[23] || (k[23] = [
                f("i", {
                  class: "fa-solid fa-trash",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            })
          ])
        ]),
        f("div", Ch, [
          f("div", wh, [
            k[25] || (k[25] = f("span", { class: "section-title" }, "", -1)),
            w(ae, {
              size: "small",
              onClick: k[4] || (k[4] = (Oe) => E.value = !0)
            }, {
              default: B(() => [...k[24] || (k[24] = [
                f("i", {
                  class: "fa-solid fa-plus",
                  style: { "margin-right": "4px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            })
          ]),
          f("div", Dh, [
            r.value.length === 0 ? (S(), Ie(Gn, {
              key: 0,
              icon: "fa-solid fa-columns",
              text: "",
              variant: "compact"
            })) : (S(), L("div", Oh, [
              (S(!0), L(Ae, null, Wt(r.value, ([Oe, We]) => (S(), L("div", {
                key: Oe,
                class: "column-item"
              }, [
                f("div", $h, [
                  f("div", Ah, [
                    f("div", Vh, [
                      k[26] || (k[26] = f("i", { class: "fa-solid fa-hashtag column-icon" }, null, -1)),
                      f("span", Mh, de(We.name), 1)
                    ]),
                    f("span", Ih, de(We.type), 1),
                    We.primitiveKey ? (S(), L("span", Rh, [...k[27] || (k[27] = [
                      f("i", { class: "fa-solid fa-key" }, null, -1)
                    ])])) : te("", !0)
                  ]),
                  We.comment ? (S(), L("div", Lh, de(We.comment), 1)) : te("", !0),
                  We.defaultValue !== void 0 ? (S(), L("div", kh, " : " + de(U(We.defaultValue)), 1)) : te("", !0)
                ]),
                f("div", Ph, [
                  w(ae, {
                    size: "small",
                    title: "",
                    onClick: (dt) => D(Oe, We)
                  }, {
                    default: B(() => [...k[28] || (k[28] = [
                      f("i", { class: "fa-solid fa-pen" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"]),
                  w(ae, {
                    size: "small",
                    title: "",
                    onClick: (dt) => oe(Oe, We)
                  }, {
                    default: B(() => [...k[29] || (k[29] = [
                      f("i", { class: "fa-solid fa-comment" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"]),
                  w(ae, {
                    type: "danger",
                    size: "small",
                    title: "",
                    onClick: (dt) => pe(Oe, We)
                  }, {
                    default: B(() => [...k[30] || (k[30] = [
                      f("i", { class: "fa-solid fa-trash" }, null, -1)
                    ])]),
                    _: 1
                  }, 8, ["onClick"])
                ])
              ]))), 128))
            ]))
          ])
        ])
      ])) : (S(), Ie(Gn, {
        key: 0,
        icon: "fa-solid fa-table",
        text: ""
      })),
      w(ol, {
        visible: Q(u).visible,
        message: Q(u).message,
        type: Q(u).type,
        icon: Q(u).icon
      }, null, 8, ["visible", "message", "type", "icon"]),
      Q(d) ? (S(), Ie(Jf, {
        key: 2,
        "existing-tables": t.tables,
        onCreate: le,
        onCancel: k[5] || (k[5] = (Oe) => d.value = !1)
      }, null, 8, ["existing-tables"])) : te("", !0),
      Q(m) ? (S(), Ie(ap, {
        key: 3,
        "table-name": o.value.tableName,
        "existing-tables": t.tables,
        onSave: he,
        onCancel: k[6] || (k[6] = (Oe) => m.value = !1)
      }, null, 8, ["table-name", "existing-tables"])) : te("", !0),
      Q(h) ? (S(), Ie(hp, {
        key: 4,
        comment: o.value.comment,
        onSave: W,
        onCancel: k[7] || (k[7] = (Oe) => h.value = !1)
      }, null, 8, ["comment"])) : te("", !0),
      Q(g) ? (S(), Ie(_p, {
        key: 5,
        "table-name": o.value.tableName,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: re,
        onCancel: k[8] || (k[8] = (Oe) => g.value = !1)
      }, null, 8, ["table-name"])) : te("", !0),
      Q(E) ? (S(), Ie(Lp, {
        key: 6,
        "existing-columns": a.value,
        onCreate: me,
        onCancel: k[9] || (k[9] = (Oe) => E.value = !1)
      }, null, 8, ["existing-columns"])) : te("", !0),
      Q(y) && Q(C) ? (S(), Ie(Kp, {
        key: 7,
        column: Q(C).column,
        "existing-columns": l.value,
        onSave: K,
        onCancel: k[10] || (k[10] = (Oe) => y.value = !1)
      }, null, 8, ["column", "existing-columns"])) : te("", !0),
      Q(T) && Q(C) ? (S(), Ie(th, {
        key: 8,
        column: Q(C).column,
        onSave: be,
        onCancel: k[11] || (k[11] = (Oe) => T.value = !1)
      }, null, 8, ["column"])) : te("", !0),
      Q(N) && Q(C) ? (S(), Ie(lh, {
        key: 9,
        column: Q(C).column,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: ce,
        onCancel: k[12] || (k[12] = (Oe) => N.value = !1)
      }, null, 8, ["column"])) : te("", !0),
      Q(_) ? (S(), Ie(Ge, {
        key: 10,
        visible: "",
        title: "DDL",
        onClose: k[14] || (k[14] = (Oe) => _.value = !1)
      }, {
        default: B(() => [
          w(mh, {
            ddl: Q(R),
            onClose: k[13] || (k[13] = (Oe) => _.value = !1)
          }, null, 8, ["ddl"])
        ]),
        _: 1
      })) : te("", !0)
    ]));
  }
}), ho = /* @__PURE__ */ De(Bh, [["__scopeId", "data-v-f00e195b"]]), Fh = { class: "sql-panel-tab" }, Uh = { class: "sql-editor-container" }, jh = { class: "sql-toolbar" }, qh = { class: "sql-footer" }, Hh = { class: "editor-stats" }, Wh = { class: "stat-item" }, Kh = { class: "stat-item" }, zh = {
  key: 0,
  class: "result-status"
}, Gh = { key: 0 }, Yh = { key: 1 }, Qh = /* @__PURE__ */ Te({
  __name: "SqlPanelTab",
  props: {
    sqlExecutorService: {}
  },
  emits: ["refresh"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ H(""), o = /* @__PURE__ */ H({ success: !1, message: "", data: 0, type: "DQL" }), r = se(() => i.value.split(`
`).length), a = se(() => i.value.length), l = se(() => u.value && Array.isArray(o.value.data) ? o.value.data : []), u = se(() => Array.isArray(o.value.data)), c = se(() => o.value.success || o.value.message !== ""), d = () => {
      if (!i.value.trim()) {
        o.value = { success: !1, message: "SQL", data: 0, type: "DQL" };
        return;
      }
      try {
        o.value = s.sqlExecutorService.execute(i.value), o.value.success && n("refresh");
      } catch (m) {
        o.value = {
          success: !1,
          message: m instanceof Error ? m.message : "",
          data: 0,
          type: "DQL"
        };
      }
    };
    return (m, h) => (S(), L("div", Fh, [
      f("div", Uh, [
        f("div", jh, [
          h[2] || (h[2] = f("span", { class: "toolbar-title" }, "SQL", -1)),
          w(ae, { onClick: d }, {
            default: B(() => [...h[1] || (h[1] = [
              f("i", {
                class: "fa-solid fa-play",
                style: { "margin-right": "6px" }
              }, null, -1),
              ne("  ", -1)
            ])]),
            _: 1
          })
        ]),
        rt(f("textarea", {
          "onUpdate:modelValue": h[0] || (h[0] = (g) => i.value = g),
          class: "sql-editor",
          placeholder: "SQL...",
          spellcheck: "false"
        }, null, 512), [
          [zt, i.value]
        ]),
        f("div", qh, [
          f("div", Hh, [
            f("span", Wh, ": " + de(r.value), 1),
            f("span", Kh, ": " + de(a.value), 1)
          ]),
          c.value ? (S(), L("div", zh, [
            u.value ? (S(), L("span", Gh, ": " + de(l.value.length) + " ", 1)) : (S(), L("span", Yh, ": " + de(o.value.data) + " ", 1))
          ])) : te("", !0)
        ]),
        o.value.message ? (S(), L("div", {
          key: 0,
          class: Re(["result-message", { error: !o.value.success }])
        }, de(o.value.message), 3)) : te("", !0)
      ])
    ]));
  }
}), mo = /* @__PURE__ */ De(Qh, [["__scopeId", "data-v-34ac73ac"]]);
var ee = /* @__PURE__ */ ((t) => (t.DDL = "DDL", t.DML = "DML", t.DQL = "DQL", t.ROW = "ROW", t))(ee || {}), ot = /* @__PURE__ */ ((t) => (t.INSERT_SQL = "INSERT_SQL", t.TABLE_SCHEMA = "TABLE_SCHEMA", t.DDL = "DDL", t.MARKDOWN = "MARKDOWN", t.STANDARD_DATA = "STANDARD_DATA", t))(ot || {}), ji = /* @__PURE__ */ ((t) => (t.INNER = "INNER", t.LEFT = "LEFT", t))(ji || {}), li = /* @__PURE__ */ ((t) => (t.SYNTAX_ERROR = "SYNTAX_ERROR", t.VALIDATION_ERROR = "VALIDATION_ERROR", t.EXECUTION_ERROR = "EXECUTION_ERROR", t.TABLE_NOT_FOUND = "TABLE_NOT_FOUND", t.COLUMN_NOT_FOUND = "COLUMN_NOT_FOUND", t.TYPE_MISMATCH = "TYPE_MISMATCH", t))(li || {});
class vo extends Error {
  /**  */
  code;
  /** SQL */
  position;
  /** SQL */
  sql;
  constructor(e, s, n, i) {
    super(s), this.name = "SqlError", this.code = e, this.position = n, this.sql = i;
  }
}
class xn extends vo {
  constructor(e, s, n) {
    super(li.SYNTAX_ERROR, e, s, n), this.name = "SqlSyntaxError";
  }
}
class Le extends vo {
  constructor(e, s) {
    super(li.VALIDATION_ERROR, e, void 0, s), this.name = "SqlValidationError";
  }
}
class ss extends vo {
  constructor(e, s) {
    super(li.EXECUTION_ERROR, e, void 0, s), this.name = "SqlExecutionError";
  }
}
var Y = /* @__PURE__ */ ((t) => (t.KEYWORD = "KEYWORD", t.IDENTIFIER = "IDENTIFIER", t.STRING = "STRING", t.NUMBER = "NUMBER", t.OPERATOR = "OPERATOR", t.COMMA = "COMMA", t.SEMICOLON = "SEMICOLON", t.LPAREN = "LPAREN", t.RPAREN = "RPAREN", t.DOT = "DOT", t.EOF = "EOF", t))(Y || {}), $e = /* @__PURE__ */ ((t) => (t.CREATE_TABLE = "CREATE_TABLE", t.ALTER_TABLE = "ALTER_TABLE", t.DROP_TABLE = "DROP_TABLE", t.INSERT = "INSERT", t.UPDATE = "UPDATE", t.DELETE = "DELETE", t.APPEND = "APPEND", t.SELECT = "SELECT", t.ROW = "ROW", t))($e || {}), Xt = /* @__PURE__ */ ((t) => (t.ADD_COLUMN = "ADD_COLUMN", t.DROP_COLUMN = "DROP_COLUMN", t.RENAME = "RENAME", t.RENAME_COLUMN = "RENAME_COLUMN", t.MODIFY_COLUMN_COMMENT = "MODIFY_COLUMN_COMMENT", t.MODIFY_COLUMN_PRIMITIVE_KEY = "MODIFY_COLUMN_PRIMITIVE_KEY", t.ALTER_TABLE_COMMENT = "ALTER_TABLE_COMMENT", t))(Xt || {});
const Jh = /* @__PURE__ */ new Set([
  "SELECT",
  "FROM",
  "WHERE",
  "INSERT",
  "INTO",
  "VALUES",
  "UPDATE",
  "SET",
  "DELETE",
  "CREATE",
  "TABLE",
  "ALTER",
  "DROP",
  "ADD",
  "COLUMN",
  "RENAME",
  "TO",
  "APPEND",
  "AND",
  "OR",
  "NOT",
  "NULL",
  "IS",
  "BETWEEN",
  "IN",
  "ORDER",
  "BY",
  "ASC",
  "DESC",
  "INNER",
  "LEFT",
  "JOIN",
  "ON",
  "DISTINCT",
  "STRING",
  "NUMBER",
  "PRIMARY",
  "KEY",
  "DEFAULT",
  "COMMENT",
  "MODIFY"
]), Nr = ["=", "!=", "<>", ">", "<", ">=", "<="];
class Xh {
  input;
  pos = 0;
  length;
  constructor(e) {
    this.input = e, this.length = e.length;
  }
  /**
   * 
   */
  peek(e = 0) {
    const s = this.pos + e;
    return this.input[s] ?? "";
  }
  /**
   * 
   */
  advance() {
    return this.pos >= this.length ? "" : this.input[this.pos++] ?? "";
  }
  /**
   * 
   */
  skipWhitespace() {
    for (; this.pos < this.length && /\s/.test(this.peek()); )
      this.pos++;
  }
  /**
   * 
   */
  skipComment() {
    for (; this.peek() === "-" && this.peek(1) === "-"; ) {
      for (this.pos += 2; this.pos < this.length && this.peek() !== `
`; )
        this.pos++;
      this.pos < this.length && this.peek() === `
` && this.pos++, this.skipWhitespace();
    }
  }
  /**
   * 
   */
  readIdentifier() {
    let e = "";
    for (; this.pos < this.length && /[\w]/.test(this.peek()); )
      e += this.advance();
    return e;
  }
  /**
   * 
   */
  readString(e) {
    let s = "";
    for (this.advance(); this.pos < this.length; ) {
      const n = this.peek();
      if (n === e)
        if (this.advance(), this.peek() === e)
          s += e, this.advance();
        else
          break;
      else n === "\\" ? (this.advance(), s += this.advance()) : s += this.advance();
    }
    return s;
  }
  /**
   * 
   */
  readNumber() {
    let e = "";
    for (; this.pos < this.length && /[\d.]/.test(this.peek()); )
      e += this.advance();
    return e;
  }
  /**
   * 
   */
  readOperator() {
    const e = this.peek() + this.peek(1);
    return Nr.includes(e) ? (this.advance(), this.advance(), e) : this.advance();
  }
  /**
   * Token
   */
  nextToken() {
    if (this.skipWhitespace(), this.skipComment(), this.pos >= this.length)
      return { type: Y.EOF, value: "", position: this.pos };
    const e = this.pos, s = this.peek();
    if (s === "(")
      return this.advance(), { type: Y.LPAREN, value: "(", position: e };
    if (s === ")")
      return this.advance(), { type: Y.RPAREN, value: ")", position: e };
    if (s === ",")
      return this.advance(), { type: Y.COMMA, value: ",", position: e };
    if (s === ";")
      return this.advance(), { type: Y.SEMICOLON, value: ";", position: e };
    if (s === ".")
      return this.advance(), { type: Y.DOT, value: ".", position: e };
    if (s === "'") {
      const n = this.readString(s);
      return { type: Y.STRING, value: n, position: e };
    }
    if (s === '"') {
      const n = this.readString(s);
      return { type: Y.STRING, value: n, position: e };
    }
    if (s === "*")
      return this.advance(), { type: Y.KEYWORD, value: "*", position: e };
    if (/[\d]/.test(s)) {
      const n = this.readNumber();
      return { type: Y.NUMBER, value: n, position: e };
    }
    if (/[a-zA-Z_]/.test(s)) {
      const n = this.readIdentifier(), i = n.toUpperCase();
      return Jh.has(i) ? { type: Y.KEYWORD, value: i, position: e } : { type: Y.IDENTIFIER, value: n, position: e };
    }
    if (Nr.some((n) => n.startsWith(s))) {
      const n = this.readOperator();
      return { type: Y.OPERATOR, value: n, position: e };
    }
    throw new Error(`Unexpected character: ${s} at position ${e}`);
  }
  /**
   * Token
   */
  tokenize() {
    const e = [];
    let s;
    do
      s = this.nextToken(), e.push(s);
    while (s.type !== Y.EOF);
    return e;
  }
}
class ci {
  lexer;
  current;
  peekToken;
  errors = [];
  constructor(e) {
    this.lexer = e, this.current = this.lexer.nextToken(), this.peekToken = this.lexer.nextToken();
  }
  /**
   * Token
   */
  nextToken() {
    this.current = this.peekToken, this.peekToken = this.lexer.nextToken();
  }
  /**
   * Token
   */
  isCurrentType(e) {
    return this.current.type === e;
  }
  /**
   * Token
   */
  isCurrentValue(e) {
    return (this.current.type === Y.KEYWORD || this.current.type === Y.OPERATOR) && this.current.value === e;
  }
  /**
   * Token
   */
  expectType(e) {
    if (!this.isCurrentType(e))
      throw this.errors.push(`Expected ${e}, got ${this.current.type} at position ${this.current.position}`), new Error(`Parse error at position ${this.current.position}`);
    const s = this.current;
    return this.nextToken(), s;
  }
  /**
   * Token
   */
  expectValue(e) {
    if (!this.isCurrentValue(e))
      throw this.errors.push(`Expected ${e}, got ${this.current.value} at position ${this.current.position}`), new Error(`Parse error at position ${this.current.position}`);
    const s = this.current;
    return this.nextToken(), s;
  }
  /**
   * Token
   */
  matchValue(e) {
    return this.current.value === e && (this.current.type === Y.KEYWORD || this.current.type === Y.OPERATOR || this.current.type === Y.COMMA || this.current.type === Y.SEMICOLON) ? (this.nextToken(), !0) : !1;
  }
  /**
   * 
   */
  parseIdentifier() {
    if (this.isCurrentType(Y.IDENTIFIER) || this.isCurrentType(Y.KEYWORD)) {
      const e = this.current.value;
      return this.nextToken(), e;
    }
    throw new Error(`Expected identifier at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseFieldType() {
    if (this.isCurrentValue("STRING"))
      return this.nextToken(), Lt.STRING;
    if (this.isCurrentValue("NUMBER"))
      return this.nextToken(), Lt.NUMBER;
    throw new Error(`Expected field type at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseColumnDef() {
    const e = this.parseIdentifier(), s = this.parseFieldType(), n = { name: e, type: s };
    if (this.matchValue("PRIMARY") && (this.expectValue("KEY"), n.primitiveKey = !0), this.matchValue("DEFAULT"))
      if (this.isCurrentType(Y.STRING))
        n.defaultValue = this.current.value, this.nextToken();
      else if (this.isCurrentType(Y.NUMBER))
        n.defaultValue = Number(this.current.value), this.nextToken();
      else if (this.matchValue("NULL"))
        n.defaultValue = null;
      else
        throw new Error(`Expected default value at position ${this.current.position}`);
    if (this.matchValue("COMMENT"))
      if (this.isCurrentType(Y.STRING))
        n.comment = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    return n;
  }
  /**
   * 
   */
  parseExpression() {
    return this.parseLogicalOr();
  }
  /**
   * OR
   */
  parseLogicalOr() {
    let e = this.parseLogicalAnd();
    for (; this.matchValue("OR"); ) {
      const s = this.parseLogicalAnd();
      e = { type: "binary", operator: "OR", left: e, right: s };
    }
    return e;
  }
  /**
   * AND
   */
  parseLogicalAnd() {
    let e = this.parseNot();
    for (; this.matchValue("AND"); ) {
      const s = this.parseNot();
      e = { type: "binary", operator: "AND", left: e, right: s };
    }
    return e;
  }
  /**
   * NOT
   */
  parseNot() {
    if (this.matchValue("NOT")) {
      const e = this.parseNot();
      return e.type === "binary" ? { ...e, operator: `NOT ${e.operator}` } : e;
    }
    return this.parseComparison();
  }
  /**
   * 
   */
  parseComparison() {
    let e = this.parseIs();
    const s = ["=", "!=", "<>", ">", "<", ">=", "<="];
    for (; s.includes(this.current.value); ) {
      const n = this.current.value;
      this.nextToken();
      const i = this.parseIs();
      e = { type: "binary", operator: n, left: e, right: i };
    }
    if (this.matchValue("IN")) {
      this.expectType(Y.LPAREN);
      const n = [];
      for (n.push(this.parseExpression()); this.matchValue(","); )
        n.push(this.parseExpression());
      return this.expectType(Y.RPAREN), { type: "in", value: e, values: n };
    }
    if (this.matchValue("BETWEEN")) {
      const n = this.parseAdditive();
      this.expectValue("AND");
      const i = this.parseAdditive();
      return { type: "between", value: e, min: n, max: i };
    }
    return e;
  }
  /**
   * IS
   */
  parseIs() {
    const e = this.parseAdditive();
    if (this.matchValue("IS"))
      if (this.matchValue("NOT")) {
        const s = this.parseAdditive();
        return s.type === "null" ? { type: "null", value: e, not: !0 } : { type: "binary", operator: "IS NOT", left: e, right: s };
      } else {
        const s = this.parseAdditive();
        return s.type === "null" ? { type: "null", value: e } : { type: "binary", operator: "IS", left: e, right: s };
      }
    return e;
  }
  /**
   * 
   */
  parseAdditive() {
    let e = this.parseMultiplicative();
    for (; this.current.value === "+" || this.current.value === "-"; ) {
      const s = this.current.value;
      this.nextToken();
      const n = this.parseMultiplicative();
      e = { type: "binary", operator: s, left: e, right: n };
    }
    return e;
  }
  /**
   * 
   */
  parseMultiplicative() {
    let e = this.parsePrimary();
    for (; this.current.value === "*" || this.current.value === "/"; ) {
      const s = this.current.value;
      this.nextToken();
      const n = this.parsePrimary();
      e = { type: "binary", operator: s, left: e, right: n };
    }
    return e;
  }
  /**
   * 
   */
  parsePrimary() {
    if (this.isCurrentType(Y.NUMBER)) {
      const e = Number(this.current.value);
      return this.nextToken(), { type: "value", value: e };
    }
    if (this.isCurrentType(Y.STRING)) {
      const e = this.current.value;
      return this.nextToken(), { type: "value", value: e };
    }
    if (this.matchValue("NULL"))
      return { type: "null", value: { type: "value", value: null } };
    if (this.isCurrentType(Y.IDENTIFIER) || this.isCurrentType(Y.KEYWORD))
      return this.parseColumnExpression();
    if (this.isCurrentType(Y.LPAREN)) {
      this.nextToken();
      const e = this.parseExpression();
      return this.expectType(Y.RPAREN), e;
    }
    throw new Error(`Unexpected token at position ${this.current.position}`);
  }
  /**
   * 
   */
  parseColumnExpression() {
    const e = this.parseIdentifier();
    if (this.matchValue(".")) {
      const s = e, n = this.parseIdentifier();
      return { type: "column", tableName: s, name: n };
    }
    return { type: "column", name: e };
  }
  /**
   * CREATE TABLE
   */
  parseCreateTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    this.expectType(Y.LPAREN);
    const s = [];
    for (s.push(this.parseColumnDef()); this.matchValue(","); )
      s.push(this.parseColumnDef());
    this.expectType(Y.RPAREN);
    const n = {
      type: $e.CREATE_TABLE,
      tableName: e,
      columns: s,
      position: this.current.position
    };
    if (this.matchValue("COMMENT"))
      if (this.isCurrentType(Y.STRING))
        n.comment = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    return n;
  }
  /**
   * ALTER TABLE
   */
  parseAlterTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    let s, n, i, o, r, a;
    if (this.matchValue("ADD"))
      this.expectValue("COLUMN"), s = Xt.ADD_COLUMN, i = this.parseColumnDef();
    else if (this.matchValue("DROP"))
      this.expectValue("COLUMN"), s = Xt.DROP_COLUMN, n = this.parseIdentifier();
    else if (this.matchValue("RENAME"))
      this.matchValue("COLUMN") ? (s = Xt.RENAME_COLUMN, n = this.parseIdentifier(), this.expectValue("TO"), r = this.parseIdentifier()) : (this.expectValue("TO"), s = Xt.RENAME, o = this.parseIdentifier());
    else if (this.matchValue("MODIFY")) {
      this.expectValue("COLUMN"), n = this.parseIdentifier();
      const l = this.parseFieldType();
      let u = !1;
      if (this.matchValue("PRIMARY") && (this.expectValue("KEY"), u = !0), this.matchValue("COMMENT"))
        if (this.isCurrentType(Y.STRING))
          a = this.current.value, this.nextToken();
        else
          throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
      if (u)
        s = Xt.MODIFY_COLUMN_PRIMITIVE_KEY, i = { name: n, type: l, primitiveKey: u, comment: a };
      else if (a !== void 0)
        s = Xt.MODIFY_COLUMN_COMMENT;
      else
        throw new Error(`Expected PRIMARY KEY or COMMENT after MODIFY COLUMN at position ${this.current.position}`);
    } else if (this.matchValue("COMMENT"))
      if (s = Xt.ALTER_TABLE_COMMENT, this.isCurrentType(Y.STRING))
        a = this.current.value, this.nextToken();
      else
        throw new Error(`Expected string value for COMMENT at position ${this.current.position}`);
    else
      throw new Error(`Expected ADD, DROP, RENAME, MODIFY COLUMN or COMMENT after ALTER TABLE at position ${this.current.position}`);
    return {
      type: $e.ALTER_TABLE,
      tableName: e,
      opType: s,
      columnName: n,
      columnDef: i,
      newTableName: o,
      newColumnName: r,
      comment: a,
      position: this.current.position
    };
  }
  /**
   * DROP TABLE
   */
  parseDropTable() {
    this.expectValue("TABLE");
    const e = this.parseIdentifier();
    return {
      type: $e.DROP_TABLE,
      tableName: e,
      position: this.current.position
    };
  }
  /**
   * INSERT
   */
  parseInsert() {
    this.expectValue("INTO");
    const e = this.parseIdentifier();
    let s;
    if (this.isCurrentType(Y.LPAREN)) {
      for (this.nextToken(), s = [], s.push(this.parseIdentifier()); this.matchValue(","); )
        s.push(this.parseIdentifier());
      this.expectType(Y.RPAREN);
    }
    this.expectValue("VALUES"), this.expectType(Y.LPAREN);
    const n = [], i = [];
    for (i.push(this.parseExpression()); this.matchValue(","); )
      i.push(this.parseExpression());
    for (n.push(i), this.expectType(Y.RPAREN); this.matchValue(","); ) {
      this.expectType(Y.LPAREN);
      const o = [];
      for (o.push(this.parseExpression()); this.matchValue(","); )
        o.push(this.parseExpression());
      n.push(o), this.expectType(Y.RPAREN);
    }
    return {
      type: $e.INSERT,
      tableName: e,
      columns: s,
      values: n,
      position: this.current.position
    };
  }
  /**
   * UPDATE
   */
  parseUpdate() {
    const e = this.parseIdentifier();
    this.expectValue("SET");
    const s = [], n = this.parseIdentifier();
    this.expectValue("=");
    const i = this.parseExpression();
    for (s.push({ column: n, value: i }); this.matchValue(","); ) {
      const r = this.parseIdentifier();
      this.expectValue("=");
      const a = this.parseExpression();
      s.push({ column: r, value: a });
    }
    let o;
    return this.matchValue("WHERE") && (o = this.parseExpression()), {
      type: $e.UPDATE,
      tableName: e,
      sets: s,
      where: o,
      position: this.current.position
    };
  }
  /**
   * DELETE
   */
  parseDelete() {
    this.expectValue("FROM");
    const e = this.parseIdentifier();
    let s;
    return this.matchValue("WHERE") && (s = this.parseExpression()), {
      type: $e.DELETE,
      tableName: e,
      where: s,
      position: this.current.position
    };
  }
  /**
   * APPEND
   */
  parseAppend() {
    this.expectValue("INTO");
    const e = this.parseIdentifier();
    this.expectType(Y.LPAREN);
    const s = [];
    for (s.push(this.parseIdentifier()); this.matchValue(","); )
      s.push(this.parseIdentifier());
    this.expectType(Y.RPAREN), this.expectValue("VALUES"), this.expectType(Y.LPAREN);
    const n = [];
    for (n.push(this.parseExpression()); this.matchValue(","); )
      n.push(this.parseExpression());
    this.expectType(Y.RPAREN);
    let i;
    return this.matchValue("WHERE") && (i = this.parseExpression()), {
      type: $e.APPEND,
      tableName: e,
      columns: s,
      values: n,
      where: i,
      position: this.current.position
    };
  }
  /**
   * SELECT
   */
  parseSelectList() {
    const e = [];
    if (this.matchValue("*"))
      e.push({ type: "star" });
    else
      for (e.push(this.parseSelectItem()); this.matchValue(","); )
        e.push(this.parseSelectItem());
    return e;
  }
  /**
   * SELECT
   */
  parseSelectItem() {
    return this.parseColumnExpression();
  }
  /**
   * JOIN
   */
  parseJoin() {
    if (this.matchValue("INNER")) {
      this.expectValue("JOIN");
      const e = this.parseIdentifier();
      this.expectValue("ON");
      const s = this.parseColumnExpression(), n = this.parseColumnExpression();
      return {
        type: ji.INNER,
        tableName: e,
        on: { left: s, right: n }
      };
    }
    if (this.matchValue("LEFT")) {
      this.expectValue("JOIN");
      const e = this.parseIdentifier();
      this.expectValue("ON");
      const s = this.parseColumnExpression(), n = this.parseColumnExpression();
      return {
        type: ji.LEFT,
        tableName: e,
        on: { left: s, right: n }
      };
    }
  }
  /**
   * ORDER BY
   */
  parseOrderBy() {
    if (!this.matchValue("ORDER")) return;
    this.expectValue("BY");
    const e = [];
    if (e.push({
      column: this.parseIdentifier(),
      ascending: !this.matchValue("DESC")
    }), this.matchValue("ASC")) {
      const s = e[e.length - 1];
      s && (s.ascending = !0);
    }
    for (; this.matchValue(","); )
      if (e.push({
        column: this.parseIdentifier(),
        ascending: !this.matchValue("DESC")
      }), this.matchValue("ASC")) {
        const s = e[e.length - 1];
        s && (s.ascending = !0);
      }
    return e;
  }
  /**
   * SELECT
   */
  parseSelect() {
    let e = !1;
    this.matchValue("DISTINCT") && (e = !0);
    const s = this.parseSelectList();
    this.expectValue("FROM");
    const n = this.parseIdentifier(), i = [];
    for (; ; ) {
      const a = this.parseJoin();
      if (!a) break;
      i.push(a);
    }
    let o;
    this.matchValue("WHERE") && (o = this.parseExpression());
    let r;
    return this.isCurrentValue("ORDER") && (r = this.parseOrderBy()), {
      type: $e.SELECT,
      distinct: e,
      columns: s,
      from: n,
      joins: i,
      where: o,
      orderBy: r,
      position: this.current.position
    };
  }
  /**
   * 
   */
  parseStatement() {
    return this.isCurrentValue("CREATE") ? (this.nextToken(), this.parseCreateTable()) : this.isCurrentValue("ALTER") ? (this.nextToken(), this.parseAlterTable()) : this.isCurrentValue("DROP") ? (this.nextToken(), this.parseDropTable()) : this.isCurrentValue("INSERT") ? (this.nextToken(), this.parseInsert()) : this.isCurrentValue("UPDATE") ? (this.nextToken(), this.parseUpdate()) : this.isCurrentValue("DELETE") ? (this.nextToken(), this.parseDelete()) : this.isCurrentValue("APPEND") ? (this.nextToken(), this.parseAppend()) : this.isCurrentValue("SELECT") ? (this.nextToken(), this.parseSelect()) : null;
  }
  /**
   * 
   */
  parse() {
    const e = [], s = [];
    for (; !this.isCurrentType(Y.EOF); )
      try {
        const n = this.parseStatement();
        n && e.push(n), this.matchValue(";") || this.isCurrentType(Y.EOF) || s.push(`Expected ';' at position ${this.current.position}`);
      } catch (n) {
        for (s.push(n.message); !this.isCurrentType(Y.EOF) && !this.isCurrentType(Y.SEMICOLON); )
          this.nextToken();
        this.isCurrentType(Y.SEMICOLON) && this.nextToken();
      }
    return { statements: e, errors: s };
  }
  /**
   * SQL
   */
  static parse(e) {
    const s = new Xh(e);
    return new ci(s).parse();
  }
}
class al {
  evaluateExpression(e, s, n, i) {
    if (e.type === "value")
      return e.value;
    if (e.type === "column") {
      if (i === null)
        throw new Error("Cannot evaluate column expression without row context");
      const o = e.name, r = s.fieldName2id[o];
      if (r === void 0)
        throw new Error(`Column '${o}' does not exist`);
      return i[r];
    }
    if (e.type === "binary") {
      const o = this.evaluateExpression(e.left, s, n, i), r = this.evaluateExpression(e.right, s, n, i);
      switch (e.operator) {
        case "+":
          return Number(o) + Number(r);
        case "-":
          return Number(o) - Number(r);
        case "*":
          return Number(o) * Number(r);
        case "/":
          return Number(o) / Number(r);
        case "=":
          return o === r;
        case "!=":
        case "<>":
          return o !== r;
        case ">":
          return Number(o) > Number(r);
        case "<":
          return Number(o) < Number(r);
        case ">=":
          return Number(o) >= Number(r);
        case "<=":
          return Number(o) <= Number(r);
        case "AND":
          return !!o && !!r;
        case "OR":
          return !!o || !!r;
        case "IS":
          return o === r;
        case "IS NOT":
          return o !== r;
        default:
          throw new Error(`Unknown operator: ${e.operator}`);
      }
    }
    if (e.type === "null") {
      if (e.value && e.value.type === "value" && e.value.value === null)
        return null;
      const o = this.evaluateExpression(e.value, s, n, i);
      return e.not ? o !== null : o === null;
    }
    if (e.type === "in") {
      const o = this.evaluateExpression(e.value, s, n, i);
      return e.values.map((a) => this.evaluateExpression(a, s, n, i)).some((a) => a === o);
    }
    if (e.type === "between") {
      const o = this.evaluateExpression(e.value, s, n, i), r = this.evaluateExpression(e.min, s, n, i), a = this.evaluateExpression(e.max, s, n, i);
      return o >= r && o <= a;
    }
    throw new Error(`Unknown expression type: ${e.type}`);
  }
  evaluateWhere(e, s, n, i) {
    return !!this.evaluateExpression(e, s, n, i);
  }
}
class bo {
  static exportTable(e, s) {
    if (s.length === 0)
      return `**${e.tableName}**

*()*`;
    const n = Object.keys(e.id2fieldName).map((a) => parseInt(a)), i = n.map((a) => e.id2fieldName[a]), o = i.map(() => "---"), r = [];
    for (const a of s) {
      const l = [];
      for (const u of n) {
        const c = a[u];
        l.push(bo.formatValue(c));
      }
      r.push(l.join(" | "));
    }
    return `**${e.tableName}**

| ${i.join(" | ")} |
| ${o.join(" | ")} |
${r.map((a) => `| ${a} |`).join(`
`)}`;
  }
  static formatValue(e) {
    return e === null ? "*NULL*" : typeof e == "string" ? e.replace(/\n/g, "<br>") : String(e);
  }
}
class Zh {
  export(e, s, n, i, o) {
    if (i) {
      if (!o)
        throw new ss("getTableIdxByName function is required when exporting a specific table");
      const a = o(i);
      if (a === void 0)
        throw new ss(`Table '${i}' does not exist`);
      const l = s[a];
      if (!l)
        throw new ss(`Schema for table '${i}' not found`);
      const u = e.getTableData(a);
      return this.exportTable(l, u, n, a);
    }
    if (n === ot.STANDARD_DATA) {
      const a = {};
      for (const [l, u] of Object.entries(s)) {
        const c = parseInt(l), d = e.getTableData(c), m = this.exportAsStandardData(u, d), h = JSON.parse(m);
        Object.assign(a, h);
      }
      return JSON.stringify(a, null, 2);
    }
    const r = [];
    for (const [a, l] of Object.entries(s)) {
      const u = parseInt(a), c = e.getTableData(u);
      r.push(this.exportTable(l, c, n, u));
    }
    return r.join(`

`);
  }
  exportTable(e, s, n, i) {
    switch (n) {
      case ot.INSERT_SQL:
        return this.exportAsInsertSql(e, s);
      case ot.TABLE_SCHEMA:
        return JSON.stringify(e, null, 2);
      case ot.DDL:
        return this.exportAsDDL(e);
      case ot.MARKDOWN:
        return this.exportAsMarkdown(e, s);
      case ot.STANDARD_DATA:
        return this.exportAsStandardData(e, s);
      default:
        throw new ss(`Unknown export format: ${n}`);
    }
  }
  exportAsInsertSql(e, s) {
    const n = [];
    for (const i of s) {
      const o = [];
      for (const [a] of Object.entries(e.id2fieldName)) {
        const l = parseInt(a), u = i[l];
        if (u === null)
          o.push("NULL");
        else if (typeof u == "string") {
          const c = u.replace(/\\/g, "\\\\").replace(/'/g, "''").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
          o.push(`'${c}'`);
        } else
          o.push(String(u));
      }
      const r = Object.values(e.id2fieldName).join(", ");
      n.push(`INSERT INTO ${e.tableName} (${r}) VALUES (${o.join(", ")});`);
    }
    return n.join(`
`);
  }
  exportAsMarkdown(e, s) {
    return bo.exportTable(e, s);
  }
  exportAsStandardData(e, s) {
    const n = {}, i = [];
    for (const o of s) {
      const r = {};
      for (const [a, l] of Object.entries(e.id2fieldName)) {
        const u = parseInt(a);
        r[l] = o[u] ?? null;
      }
      i.push(r);
    }
    return n[e.tableName] = i, JSON.stringify(n, null, 2);
  }
  exportAsDDL(e) {
    const s = {}, n = {};
    for (const [r] of Object.entries(e.id2fieldName)) {
      const a = parseInt(r), l = e.columnSchemas[a];
      if (l) {
        const u = l.type + (l.primitiveKey ? " PRIMARY KEY" : "");
        s[l.name] = u, l.comment && (n[l.name] = l.comment);
      }
    }
    const i = new Map(Object.entries(s)), o = new Map(Object.entries(n));
    return it.ddl().createTable(e.tableName, i, e.comment, o);
  }
}
class go {
  structure;
  dataStorage;
  ddlExecutor;
  dmlExecutor;
  dqlExecutor;
  dataExporter;
  constructor(e, s) {
    this.dataStorage = e || ds.newStorage(), this.structure = s || this.createEmptyStructure(), this.ddlExecutor = new xr(
      this.structure,
      this.dataStorage,
      this.getTableIdxByName.bind(this)
    ), this.dmlExecutor = new Sr(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dqlExecutor = new Cr(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dataExporter = new Zh();
  }
  createEmptyStructure() {
    return {
      tableSchemas: {},
      tableName2Idx: {},
      tableIdxCounter: 0
    };
  }
  getTables() {
    return Object.values(this.structure.tableSchemas).map((s) => ({
      ...s,
      id2fieldName: { ...s.id2fieldName },
      fieldName2id: { ...s.fieldName2id },
      columnSchemas: { ...s.columnSchemas }
    }));
  }
  execute(e, s) {
    try {
      const n = ci.parse(e);
      if (n.errors.length > 0)
        throw new xn(
          n.errors.join("; "),
          0,
          e
        );
      const i = n.statements;
      if (i.length === 0)
        throw new xn("No valid SQL statement found", 0, e);
      let o;
      for (let r = 0; r < i.length; r++) {
        const a = i[r];
        if (!a) continue;
        const l = this.getStatementType(a);
        if (!s.includes(l))
          throw new Le(
            `Expected SQL type ${s.join(" or ")}, got ${l}`,
            e
          );
        o = this.executeStatement(a);
      }
      if (!o)
        throw new xn("No valid statement executed", 0, e);
      return o;
    } catch (n) {
      throw n instanceof xn || n instanceof Le || n instanceof ss ? n : new ss(n.message, e);
    }
  }
  getStatementType(e) {
    const s = e.type;
    switch (s) {
      case $e.CREATE_TABLE:
      case $e.ALTER_TABLE:
      case $e.DROP_TABLE:
        return ee.DDL;
      case $e.INSERT:
      case $e.UPDATE:
      case $e.DELETE:
      case $e.APPEND:
        return ee.DML;
      case $e.SELECT:
        return ee.DQL;
      default:
        throw new ss(`Unknown statement type: ${s}`);
    }
  }
  executeStatement(e) {
    switch (e.type) {
      case $e.CREATE_TABLE:
        return this.ddlExecutor.executeCreateTable(e);
      case $e.ALTER_TABLE:
        return this.ddlExecutor.executeAlterTable(e);
      case $e.DROP_TABLE:
        return this.ddlExecutor.executeDropTable(e);
      case $e.INSERT:
        return this.dmlExecutor.executeInsert(e);
      case $e.UPDATE:
        return this.dmlExecutor.executeUpdate(e);
      case $e.DELETE:
        return this.dmlExecutor.executeDelete(e);
      case $e.APPEND:
        return this.dmlExecutor.executeAppend(e);
      case $e.SELECT:
        return this.dqlExecutor.executeSelect(e);
      default:
        throw new ss("Unsupported statement type");
    }
  }
  getTableIdxByName(e) {
    return this.structure.tableName2Idx[e];
  }
  getTableNameByIdx(e) {
    return this.structure.tableSchemas[e]?.tableName;
  }
  validateTableExists(e) {
    const s = this.getTableIdxByName(e);
    if (s === void 0)
      throw new Le(
        `Table '${e}' does not exist`,
        `Table '${e}' does not exist`
      );
    return s;
  }
  getDataStorage() {
    return this.dataStorage;
  }
  setDataStorage(e) {
    this.dataStorage = e;
  }
  export(e, s) {
    return this.dataExporter.export(
      this.dataStorage,
      this.structure.tableSchemas,
      e,
      s,
      this.getTableIdxByName.bind(this)
    );
  }
  clone() {
    const e = JSON.parse(JSON.stringify(this.structure));
    return new go(void 0, e);
  }
  serialize() {
    return {
      structure: this.structure,
      dataStorage: this.dataStorage.serialize()
    };
  }
  deserialize(e) {
    const s = e;
    s.structure ? this.structure = s.structure : this.structure = this.createEmptyStructure(), s.dataStorage ? this.dataStorage.deserialize(s.dataStorage) : this.dataStorage.clear(), this.rebuildExecutors();
  }
  rebuildExecutors() {
    this.ddlExecutor = new xr(
      this.structure,
      this.dataStorage,
      this.getTableIdxByName.bind(this)
    ), this.dmlExecutor = new Sr(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    ), this.dqlExecutor = new Cr(
      this.structure,
      this.dataStorage,
      this.validateTableExists.bind(this)
    );
  }
}
class Eo {
  data = {};
  constructor(e) {
    e && Object.keys(e).forEach((s) => {
      const n = parseInt(s), i = e[n];
      i && (this.data[n] = i.map((o) => ({ ...o })));
    });
  }
  /**
   * 
   */
  clone() {
    const e = {};
    return Object.keys(this.data).forEach((s) => {
      const n = parseInt(s), i = this.data[n];
      i && (e[n] = i.map((o) => ({ ...o })));
    }), new Eo(e);
  }
  /**
   * 
   */
  getTableData(e) {
    return this.data[e] || [];
  }
  /**
   * 
   */
  setTableData(e, s) {
    this.data[e] = s.map((n) => ({ ...n }));
  }
  /**
   * 
   */
  clear() {
    this.data = {};
  }
  /**
   * 
   */
  serialize() {
    return this.data;
  }
  /**
   * 
   */
  deserialize(e) {
    this.data = {};
    const s = e;
    Object.keys(s).forEach((n) => {
      const i = parseInt(n), o = s[n];
      Array.isArray(o) ? this.data[i] = o.map((r) => ({ ...r })) : this.data[i] = [];
    });
  }
}
class xr {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.getTableIdxByName = n;
  }
  executeCreateTable(e) {
    const s = e.tableName;
    this.validateTableNotExists(s);
    const n = this.allocateTableIdx(), i = e.columns, o = {}, r = {}, a = {};
    let l = 0;
    for (const c of i) {
      const d = l++;
      o[d] = c.name, r[c.name] = d;
      const m = {
        name: c.name,
        type: c.type,
        primitiveKey: c.primitiveKey || !1,
        defaultValue: c.defaultValue,
        comment: c.comment || ""
      };
      a[d] = m;
    }
    const u = {
      tableName: s,
      id2fieldName: o,
      fieldName2id: r,
      columnSchemas: a,
      counter: l,
      comment: e.comment || ""
    };
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [n]: u }, this.structure.tableName2Idx = { ...this.structure.tableName2Idx, [s]: n }, {
      success: !0,
      message: `Table '${s}' created successfully`,
      data: 0,
      type: ee.DDL
    };
  }
  executeAlterTable(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.structure.tableSchemas[n];
    switch (e.opType) {
      case "ADD_COLUMN":
        return this.addColumn(i, s, e.columnDef);
      case "DROP_COLUMN":
        return this.removeColumn(i, s, e.columnName);
      case "RENAME":
        return this.renameTable(i, n, s, e.newTableName);
      case "RENAME_COLUMN":
        return this.renameColumn(i, s, e.columnName, e.newColumnName);
      case "MODIFY_COLUMN_COMMENT":
        return this.modifyColumnComment(i, s, e.columnName, e.comment);
      case "MODIFY_COLUMN_PRIMITIVE_KEY":
        return this.modifyColumnPrimitiveKey(i, s, e.columnName, e.columnDef);
      case "ALTER_TABLE_COMMENT":
        return this.modifyTableComment(i, s, e.comment);
    }
    throw new Error("Invalid ALTER TABLE statement");
  }
  executeDropTable(e) {
    const s = e.tableName, n = this.validateTableExists(s), { [n]: i, ...o } = this.structure.tableSchemas, { [s]: r, ...a } = this.structure.tableName2Idx;
    return this.structure.tableSchemas = o, this.structure.tableName2Idx = a, this.dataStorage.setTableData(n, []), Object.keys(this.structure.tableSchemas).length === 0 && (this.structure.tableIdxCounter = 0), {
      success: !0,
      message: `Table '${s}' dropped`,
      data: 0,
      type: ee.DDL
    };
  }
  addColumn(e, s, n) {
    if (e.fieldName2id[n.name] !== void 0)
      throw new Le(
        `Column '${n.name}' already exists in table '${s}'`,
        `ALTER TABLE ${s} ADD COLUMN ${n.name}`
      );
    const i = e.counter, o = {
      name: n.name,
      type: n.type,
      primitiveKey: n.primitiveKey || !1,
      defaultValue: n.defaultValue,
      comment: n.comment || ""
    };
    e.id2fieldName = { ...e.id2fieldName, [i]: o.name }, e.fieldName2id = { ...e.fieldName2id, [o.name]: i }, e.columnSchemas = { ...e.columnSchemas, [i]: o }, e.counter = i + 1;
    const r = { ...e }, a = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [a]: r }, {
      success: !0,
      message: `Column '${n.name}' added to table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  removeColumn(e, s, n) {
    const i = e.fieldName2id[n];
    if (i === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} DROP COLUMN ${n}`
      );
    const { [i]: o, ...r } = e.id2fieldName, { [n]: a, ...l } = e.fieldName2id, { [i]: u, ...c } = e.columnSchemas;
    e.id2fieldName = r, e.fieldName2id = l, e.columnSchemas = c;
    const d = { ...e }, m = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [m]: d }, {
      success: !0,
      message: `Column '${n}' dropped from table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  renameTable(e, s, n, i) {
    if (!i)
      throw new Le("New table name is required", `ALTER TABLE ${n} RENAME TO`);
    if (this.getTableIdxByName(i) !== void 0)
      throw new Le(
        `Table '${i}' already exists`,
        `ALTER TABLE ${n} RENAME TO ${i}`
      );
    const o = { ...e, tableName: i }, { [n]: r, ...a } = this.structure.tableName2Idx;
    return this.structure.tableName2Idx = { ...a, [i]: s }, this.structure.tableSchemas = { ...this.structure.tableSchemas, [s]: o }, {
      success: !0,
      message: `Table renamed from '${n}' to '${i}'`,
      data: 0,
      type: ee.DDL
    };
  }
  renameColumn(e, s, n, i) {
    if (!n || !i)
      throw new Le("Column names are required", `ALTER TABLE ${s} RENAME COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} RENAME COLUMN ${n} TO ${i}`
      );
    if (e.fieldName2id[i] !== void 0)
      throw new Le(
        `Column '${i}' already exists in table '${s}'`,
        `ALTER TABLE ${s} RENAME COLUMN ${n} TO ${i}`
      );
    const { [n]: r, ...a } = e.fieldName2id, l = { ...e.id2fieldName, [o]: i }, u = e.columnSchemas[o], c = {
      name: i,
      type: u.type,
      primitiveKey: u.primitiveKey,
      defaultValue: u.defaultValue,
      comment: u.comment
    }, { [o]: d, ...m } = e.columnSchemas, h = { ...m, [o]: c };
    e.fieldName2id = { ...a, [i]: o }, e.id2fieldName = l, e.columnSchemas = h;
    const g = { ...e }, E = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [E]: g }, {
      success: !0,
      message: `Column '${n}' renamed to '${i}' in table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  modifyColumnComment(e, s, n, i) {
    if (!n)
      throw new Le("Column name is required", `ALTER TABLE ${s} MODIFY COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} MODIFY COLUMN ${n}`
      );
    const r = e.columnSchemas[o], a = {
      name: r.name,
      type: r.type,
      primitiveKey: r.primitiveKey,
      defaultValue: r.defaultValue,
      comment: i
    }, { [o]: l, ...u } = e.columnSchemas;
    e.columnSchemas = { ...u, [o]: a };
    const c = { ...e }, d = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [d]: c }, {
      success: !0,
      message: `Column '${n}' comment updated in table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  modifyTableComment(e, s, n) {
    const i = { ...e, comment: n }, o = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [o]: i }, {
      success: !0,
      message: `Table '${s}' comment updated`,
      data: 0,
      type: ee.DDL
    };
  }
  modifyColumnPrimitiveKey(e, s, n, i) {
    if (!n)
      throw new Le("Column name is required", `ALTER TABLE ${s} MODIFY COLUMN`);
    const o = e.fieldName2id[n];
    if (o === void 0)
      throw new Le(
        `Column '${n}' does not exist in table '${s}'`,
        `ALTER TABLE ${s} MODIFY COLUMN ${n}`
      );
    const r = e.columnSchemas[o], a = {
      name: r.name,
      type: r.type,
      primitiveKey: i.primitiveKey,
      defaultValue: r.defaultValue,
      comment: i.comment !== void 0 ? i.comment : r.comment
    }, { [o]: l, ...u } = e.columnSchemas;
    e.columnSchemas = { ...u, [o]: a };
    const c = { ...e }, d = this.structure.tableName2Idx[s];
    return this.structure.tableSchemas = { ...this.structure.tableSchemas, [d]: c }, {
      success: !0,
      message: `Column '${n}' primary key updated in table '${s}'`,
      data: 0,
      type: ee.DDL
    };
  }
  allocateTableIdx() {
    return this.structure.tableIdxCounter++;
  }
  validateTableExists(e) {
    const s = this.getTableIdxByName(e);
    if (s === void 0)
      throw new Le(
        `Table '${e}' does not exist`,
        `Table '${e}' does not exist`
      );
    return s;
  }
  validateTableNotExists(e) {
    if (this.getTableIdxByName(e) !== void 0)
      throw new Le(
        `Table '${e}' already exists`,
        `Table '${e}' already exists`
      );
  }
}
class Sr {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.validateTableExists = n, this.expressionEvaluator = new al();
  }
  expressionEvaluator;
  get tableSchemas() {
    return this.structure.tableSchemas;
  }
  executeInsert(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = 0;
    const r = Object.entries(i.columnSchemas).filter(([a, l]) => l.primitiveKey).map(([a, l]) => parseInt(a)).sort((a, l) => a - l);
    for (const a of e.values) {
      const l = {}, u = {}, c = e.columns;
      if (c && c.length > 0)
        for (let d = 0; d < c.length; d++) {
          const m = c[d];
          if (i.fieldName2id[m] === void 0)
            throw new Le(
              `Column '${m}' does not exist in table '${s}'`,
              `INSERT INTO ${s}`
            );
          u[m] = d;
        }
      else {
        const d = Object.entries(i.columnSchemas).filter(([m]) => !isNaN(parseInt(m))).sort((m, h) => parseInt(m[0]) - parseInt(h[0]));
        for (let m = 0; m < d.length; m++) {
          const h = d[m];
          if (!h) continue;
          const [g, E] = h;
          u[E.name] = m;
        }
      }
      for (const [d, m] of Object.entries(i.columnSchemas)) {
        const h = parseInt(d), g = m.name, E = u[g];
        if (E !== void 0) {
          const y = a[E], T = this.expressionEvaluator.evaluateExpression(y, i, n, null);
          T === null && m.defaultValue !== void 0 ? l[h] = m.defaultValue : l[h] = T;
        } else m.defaultValue !== void 0 ? l[h] = m.defaultValue : l[h] = null;
      }
      if (r.length > 0) {
        const d = this.dataStorage.getTableData(n), m = d.find((h) => r.every((g) => JSON.stringify(h[g]) === JSON.stringify(l[g])));
        if (m) {
          for (const [h] of Object.entries(u)) {
            const g = i.fieldName2id[h];
            if (g !== void 0) {
              const E = l[g];
              m[g] = E !== void 0 ? E : null;
            }
          }
          this.dataStorage.setTableData(n, d);
        } else
          d.push(l), this.dataStorage.setTableData(n, d);
      } else {
        const d = this.dataStorage.getTableData(n);
        d.push(l), this.dataStorage.setTableData(n, d);
      }
      o++;
    }
    return {
      success: !0,
      message: `Inserted ${o} row(s) into '${s}'`,
      data: o,
      type: ee.DML
    };
  }
  executeUpdate(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = 0;
    const r = this.dataStorage.getTableData(n);
    for (const a of r)
      if (e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, a)) {
        for (const u of e.sets) {
          const c = i.fieldName2id[u.column];
          if (c === void 0)
            throw new Le(
              `Column '${u.column}' does not exist in table '${s}'`,
              `UPDATE ${s}`
            );
          const d = this.expressionEvaluator.evaluateExpression(u.value, i, n, a);
          a[c] = d;
        }
        o++;
      }
    return this.dataStorage.setTableData(n, r), {
      success: !0,
      message: `Updated ${o} row(s) in '${s}'`,
      data: o,
      type: ee.DML
    };
  }
  executeDelete(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n], o = this.dataStorage.getTableData(n), r = [];
    for (const l of o)
      e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, l) || r.push(l);
    const a = o.length - r.length;
    return this.dataStorage.setTableData(n, r), {
      success: !0,
      message: `Deleted ${a} row(s) from '${s}'`,
      data: a,
      type: ee.DML
    };
  }
  executeAppend(e) {
    const s = e.tableName, n = this.validateTableExists(s), i = this.tableSchemas[n], o = e.columns, r = e.values;
    if (o.length !== r.length)
      throw new Le(
        `Number of columns (${o.length}) does not match number of values (${r.length})`,
        `APPEND INTO ${s}`
      );
    const a = [];
    for (let c = 0; c < o.length; c++) {
      const d = o[c], m = i.fieldName2id[d];
      if (m === void 0)
        throw new Le(
          `Column '${d}' does not exist in table '${s}'`,
          `APPEND INTO ${s}`
        );
      const h = i.columnSchemas[m];
      if (!h)
        throw new Le(
          `Column '${d}' does not exist in table '${s}'`,
          `APPEND INTO ${s}`
        );
      if (h.primitiveKey)
        throw new Le(
          `Cannot APPEND to primary key column '${d}'`,
          `APPEND INTO ${s}`
        );
      if (h.type !== Lt.STRING)
        throw new Le(
          `Column '${d}' must be STRING type for APPEND operation`,
          `APPEND INTO ${s}`
        );
      a.push({
        fieldIdx: m,
        colSchema: h,
        valueExpr: r[c]
      });
    }
    let l = 0;
    const u = this.dataStorage.getTableData(n);
    for (const c of u)
      if (e.where === void 0 || e.where === null || this.expressionEvaluator.evaluateWhere(e.where, i, n, c)) {
        for (const m of a) {
          let h = c[m.fieldIdx];
          h == null && (h = "");
          const g = this.expressionEvaluator.evaluateExpression(m.valueExpr, i, n, c);
          c[m.fieldIdx] = h + g;
        }
        l++;
      }
    return this.dataStorage.setTableData(n, u), {
      success: !0,
      message: `Appended to ${l} row(s) in '${s}'`,
      data: l,
      type: ee.DML
    };
  }
}
class Cr {
  constructor(e, s, n) {
    this.structure = e, this.dataStorage = s, this.validateTableExists = n, this.expressionEvaluator = new al();
  }
  expressionEvaluator;
  get tableSchemas() {
    return this.structure.tableSchemas;
  }
  executeSelect(e) {
    const s = e.from, n = this.validateTableExists(s), i = this.tableSchemas[n];
    let o = this.dataStorage.getTableData(n);
    e.where && (o = o.filter(
      (a) => this.expressionEvaluator.evaluateWhere(e.where, i, n, a)
    ));
    const r = [];
    for (const a of o) {
      const l = {};
      for (const u of e.columns)
        if (u.type === "star")
          for (const [c, d] of Object.entries(i.id2fieldName)) {
            const m = parseInt(c);
            l[d] = a[m];
          }
        else if (u.type === "column") {
          const c = (u.tableName, u.name), d = i.fieldName2id[c];
          d !== void 0 && (l[c] = a[d]);
        }
      r.push(l);
    }
    if (e.orderBy) {
      const a = e.orderBy[0];
      if (a) {
        const l = a.column;
        i.fieldName2id[l] !== void 0 && r.sort((c, d) => {
          const m = c[l], h = d[l];
          return m === null && h === null ? 0 : m === null ? a.ascending ? -1 : 1 : h === null ? a.ascending ? 1 : -1 : m < h ? a.ascending ? -1 : 1 : m > h ? a.ascending ? 1 : -1 : 0;
        });
      }
    }
    return {
      success: !0,
      message: `Selected ${r.length} row(s)`,
      data: r,
      type: ee.DQL
    };
  }
}
class ds {
  static newExecutor() {
    return new go();
  }
  static newStorage() {
    return new Eo();
  }
}
class _e {
  static COMMITTED_START_TAG = "<committed>";
  static COMMITTED_END_TAG = "</committed>";
  static COMMIT_START_TAG = "<commit>";
  static COMMIT_END_TAG = "</commit>";
  static ERROR_START_TAG = "<error>";
  static ERROR_END_TAG = "</error>";
  static getCommitted() {
    const s = SillyTavern.getContext()?.chat || [], n = /* @__PURE__ */ new Map();
    for (let i = 0; i < s.length; i++) {
      const o = s[i];
      if (o?.mes) {
        const r = this.extractTagContent(o.mes, _e.COMMITTED_START_TAG, _e.COMMITTED_END_TAG);
        r && n.set(i, r);
      }
    }
    return n;
  }
  static processMessage(e, s, n, i) {
    const o = SillyTavern.getContext(), a = (o?.chat || [])[e];
    if (!a)
      return;
    const l = a.mes || "", u = this.extractTagContent(l, s, n), c = i(u);
    if (u === null)
      a.mes = l + c;
    else {
      const d = l.lastIndexOf(n), m = l.lastIndexOf(s, d), h = l.substring(0, m), g = l.substring(d + n.length);
      a.mes = h + c + g;
    }
    o?.saveChat();
  }
  static processCommit(e, s) {
    return _e.processMessage(e, _e.COMMIT_START_TAG, _e.COMMIT_END_TAG, s);
  }
  static processCommitted(e, s) {
    return _e.processMessage(e, _e.COMMITTED_START_TAG, _e.COMMITTED_END_TAG, s);
  }
  static processLastCommitted(e) {
    const s = SillyTavern.getContext();
    (s?.chat || []).length == 0 && s?.chat.push({
      id: 0,
      name: "",
      role: "assistant",
      mes: "",
      date: Date.now()
    }), this.processCommitted(s?.chat.length - 1, e);
  }
  static processLastError(e) {
    const s = SillyTavern.getContext();
    return (s?.chat || []).length == 0 && s?.chat.push({
      id: 0,
      name: "",
      role: "assistant",
      mes: "",
      date: Date.now()
    }), _e.processMessage(s?.chat.length - 1, _e.ERROR_START_TAG, _e.ERROR_END_TAG, e);
  }
  static extractCommit(e) {
    return this.extractTagContent(e, _e.COMMIT_START_TAG, _e.COMMIT_END_TAG);
  }
  static extractCommitted(e) {
    return this.extractTagContent(e, _e.COMMITTED_START_TAG, _e.COMMITTED_END_TAG);
  }
  static replaceCommitWithCommitted(e, s) {
    const n = SillyTavern.getContext(), o = (n?.chat || [])[e];
    if (!o)
      return;
    let r = o.mes || "";
    const a = r.lastIndexOf(_e.COMMIT_END_TAG);
    if (a !== -1) {
      const u = r.lastIndexOf(_e.COMMIT_START_TAG, a);
      if (u !== -1) {
        const c = r.substring(0, u), d = r.substring(a + _e.COMMIT_END_TAG.length), m = /\s$/.test(c), h = /^\s/.test(d);
        m && h ? r = c.replace(/\s$/, "") + d : r = c + d;
      }
    }
    const l = r.lastIndexOf(_e.COMMITTED_END_TAG);
    if (l !== -1) {
      const u = r.lastIndexOf(_e.COMMITTED_START_TAG, l);
      if (u !== -1) {
        const c = r.substring(0, u), d = r.substring(l + _e.COMMITTED_END_TAG.length);
        r = c + _e.COMMITTED_START_TAG + s + _e.COMMITTED_END_TAG + d;
      }
    } else
      r = r + _e.COMMITTED_START_TAG + s + _e.COMMITTED_END_TAG;
    o.mes = r, n?.saveChat();
  }
  static extractTagContent(e, s, n) {
    const i = e.lastIndexOf(n);
    if (i === -1) return null;
    const o = e.lastIndexOf(s, i);
    return o === -1 ? null : e.substring(o + s.length, i).trim() || null;
  }
}
class wr {
  static validateSql(e) {
    const s = [], n = ci.parse(e);
    for (const o of n.errors)
      s.push(o);
    const i = e.split(";").map((o) => o.trim()).filter((o) => o.length > 0);
    for (const o of i) {
      const r = this.checkBasicSyntax(o);
      s.push(...r);
    }
    return s;
  }
  static checkBasicSyntax(e) {
    const s = [];
    (e.match(/'/g) || []).length % 2 !== 0 && s.push(`SQL : ${e}`);
    const i = [];
    let o = !1, r = 0;
    for (; r < e.length; ) {
      const a = e[r], l = e[r + 1];
      if (a === "'" && (!o || o && (l !== "'" || e[r - 1] === "'")) && (o = !o), !o) {
        if (a === "(")
          i.push("(");
        else if (a === ")") {
          if (i.length === 0)
            return s.push(`SQL : ${e}`), s;
          i.pop();
        }
      }
      r++;
    }
    return i.length > 0 && s.push(`SQL : ${e}`), s;
  }
  static compressDml(e, s) {
    let n = e;
    const i = Object.entries(s);
    i.sort((o, r) => {
      const [, a] = o, [, l] = r;
      return l.tableName.length - a.tableName.length;
    });
    for (const [o, r] of i) {
      const a = parseInt(o), l = r.tableName, u = `@t${a}`, c = Object.entries(r.columnSchemas);
      c.sort((d, m) => {
        const [, h] = d, [, g] = m;
        return g.name.length - h.name.length;
      });
      for (const [d, m] of c) {
        const h = parseInt(d), g = m.name, E = `@t${a}c${h}`;
        n = n.replace(new RegExp(`\\b${g.replace(/@/g, "\\@")}\\b`, "g"), E);
      }
      n = n.replace(new RegExp(`\\b${l.replace(/@/g, "\\@")}\\b`, "g"), u);
    }
    return n;
  }
  static decompressDml(e, s) {
    let n = e;
    const i = Object.entries(s);
    i.sort((o, r) => {
      const [a] = o, [l] = r;
      return l.length - a.length;
    });
    for (const [o, r] of i) {
      const a = parseInt(o), l = r.tableName, u = `@t${a}`, c = Object.entries(r.columnSchemas);
      c.sort((d, m) => {
        const [h] = d, [g] = m;
        return g.length - h.length;
      });
      for (const [d, m] of c) {
        const h = parseInt(d), g = m.name, E = `@t${a}c${h}`;
        n = n.replace(new RegExp(E.replace(/@/g, "\\@"), "g"), g);
      }
      n = n.replace(new RegExp(u.replace(/@/g, "\\@"), "g"), l);
    }
    return n;
  }
}
class Dr {
  tableTemplate;
  cachedStorage = null;
  cachedCommittedHash = "";
  constructor(e) {
    this.tableTemplate = e.clone();
  }
  getTables() {
    return this.tableTemplate.getTables();
  }
  clone() {
    return this.tableTemplate.clone();
  }
  compressDml(e) {
    const s = this.getTableSchemas();
    return wr.compressDml(e, s);
  }
  decompressDml(e) {
    const s = this.getTableSchemas();
    return wr.decompressDml(e, s);
  }
  getTableSchemas() {
    const e = this.getTables(), s = {};
    for (const n of e) {
      const i = this.getTableIdxByName(n.tableName);
      i !== void 0 && (s[i] = n);
    }
    return s;
  }
  execute(e, s) {
    const n = e.split(";").map((a) => a.trim()).filter((a) => a.length > 0);
    if (n.length === 0)
      return { success: !0, message: "SQL", data: 0, type: ee.DML };
    let i = 0, o = [], r = [];
    for (const a of n) {
      const l = this.detectSqlType(a);
      if (!s.includes(l))
        throw new Error(`SQL ${s.join("  ")} ${l}`);
      if (l === ee.DML)
        r.length > 0 && (this.tableTemplate.execute(r.join(`;
`), [ee.DDL]), r = []), o.push(a);
      else if (l === ee.DDL)
        o.length > 0 && (i += this.executeDml(o.join(`;
`)), o = []), r.push(a);
      else if (l === ee.DQL)
        return r.length > 0 && (this.tableTemplate.execute(r.join(`;
`), [ee.DDL]), r = []), o.length > 0 && (i += this.executeDml(o.join(`;
`)), o = []), this.storage.execute(a, [ee.DQL]);
    }
    return r.length > 0 && this.tableTemplate.execute(r.join(`;
`), [ee.DDL]), o.length > 0 && (i += this.executeDml(o.join(`;
`))), { success: !0, message: "", data: i, type: ee.DML };
  }
  detectSqlType(e) {
    const s = e.trim().toUpperCase();
    if (/^CREATE\s+TABLE|^ALTER\s+TABLE|^DROP\s+TABLE/i.test(s))
      return ee.DDL;
    if (/^SELECT/i.test(s))
      return ee.DQL;
    if (/^INSERT|^UPDATE|^DELETE|^APPEND/i.test(s))
      return ee.DML;
    throw new Error(`SQL: ${e}`);
  }
  executeDml(e) {
    const s = this.filterUnsupportedSyntax(e), n = this.compressDml(s);
    return e !== s && console.log("[ChatSqlExecutor] executeDml: SQL was filtered to remove unsupported syntax"), _e.processLastCommitted((i) => {
      const o = i || "";
      return `<committed>${o ? `${o};
${n}` : n}</committed>`;
    }), this.invalidateStorageCache(), e.split(";").map((i) => i.trim()).filter((i) => i.length > 0).length;
  }
  filterUnsupportedSyntax(e) {
    let s = e;
    return s = s.replace(/\s+ON\s+CONFLICT\s+\([^)]+\)\s+DO\s+UPDATE\s+SET\s+[^;]+/gi, ""), s = s.replace(/\s+OR\s+REPLACE/gi, ""), s = s.replace(/\s+OR\s+IGNORE/gi, ""), s.trim();
  }
  invalidateStorageCache() {
    this.cachedStorage = null, this.cachedCommittedHash = "";
  }
  export(e, s) {
    return this.storage.export(e, s);
  }
  get storage() {
    const e = _e.getCommitted(), s = [];
    for (const [o, r] of e.entries())
      s.push(`${o}:${r.length}`);
    const n = s.join("|");
    if (this.cachedStorage && this.cachedCommittedHash === n)
      return this.cachedStorage;
    const i = this.tableTemplate.clone();
    if (e.size === 0)
      return this.cachedStorage = i, this.cachedCommittedHash = n, i;
    for (const [o, r] of e.entries())
      try {
        i.execute(this.decompressDml(r), [ee.DML]);
      } catch {
        _e.processCommitted(o, () => `<error>${r}</error>`);
      }
    return this.cachedStorage = i, this.cachedCommittedHash = n, i;
  }
  getDataStorage() {
    return this.storage.getDataStorage();
  }
  getTableIdxByName(e) {
    return this.tableTemplate.getTableIdxByName(e);
  }
  getTableNameByIdx(e) {
    return this.tableTemplate.getTableNameByIdx(e);
  }
  setDataStorage(e) {
  }
  serialize() {
    return this.tableTemplate.serialize();
  }
  deserialize(e) {
    this.tableTemplate.deserialize(e);
  }
}
function qi(t, e) {
  return new Proxy(t, {
    get(s, n) {
      const i = s[n];
      return typeof i == "function" && n === "execute" ? function(...o) {
        const r = i.apply(s, o);
        return e(), r;
      } : i;
    }
  });
}
class Se {
  static MODULE_NAME = "ST_BETTER_DATABASE";
  static _instance = new Se();
  _tableTemplateCache = null;
  _tableTemplateProxy = null;
  _chatStatusBarSwitch = !1;
  _chatStatusBarCode = "";
  _extensionSwitch = !1;
  _systemSqlExecutorCache = null;
  _systemSqlExecutorProxy = null;
  _chatStatusBarChangeListeners = /* @__PURE__ */ new Set();
  constructor() {
    const { extensionSettings: e } = SillyTavern.getContext();
    e[Se.MODULE_NAME] || (e[Se.MODULE_NAME] = {
      tableTemplate: null,
      chatStatusBarSwitch: !1,
      chatStatusBarCode: "",
      extensionSwitch: !1,
      systemSqlExecutor: null
    }), this._loadFromSettings();
  }
  _loadFromSettings() {
    const { extensionSettings: e } = SillyTavern.getContext(), s = e[Se.MODULE_NAME];
    if (s) {
      if (s.tableTemplate)
        try {
          this._tableTemplateCache = ds.newExecutor(), this._tableTemplateCache.deserialize(s.tableTemplate);
        } catch {
          this._tableTemplateCache = null;
        }
      if (this._chatStatusBarSwitch = s.chatStatusBarSwitch ?? !1, this._chatStatusBarCode = s.chatStatusBarCode ?? "", this._extensionSwitch = s.extensionSwitch ?? !1, s.systemSqlExecutor)
        try {
          this._systemSqlExecutorCache = ds.newExecutor(), this._systemSqlExecutorCache.deserialize(s.systemSqlExecutor);
        } catch {
          this._systemSqlExecutorCache = null;
        }
    }
  }
  _saveToSettings() {
    const { extensionSettings: e } = SillyTavern.getContext();
    let s = e[Se.MODULE_NAME];
    s || (s = {
      tableTemplate: null,
      chatStatusBarSwitch: !1,
      chatStatusBarCode: "",
      extensionSwitch: !1,
      systemSqlExecutor: null
    }, e[Se.MODULE_NAME] = s), s.tableTemplate = this._tableTemplateCache?.serialize(), s.chatStatusBarSwitch = this._chatStatusBarSwitch, s.chatStatusBarCode = this._chatStatusBarCode, s.extensionSwitch = this._extensionSwitch, s.systemSqlExecutor = this._systemSqlExecutorCache?.serialize(), SillyTavern.getContext().saveSettingsDebounced();
  }
  get tableTemplate() {
    return this._tableTemplateCache || (this._tableTemplateCache = ds.newExecutor()), this._tableTemplateProxy || (this._tableTemplateProxy = qi(this._tableTemplateCache, () => this._saveToSettings())), this._tableTemplateProxy;
  }
  set tableTemplate(e) {
    if (typeof e == "object" && "serialize" in e) {
      const s = e.serialize();
      this._tableTemplateCache = ds.newExecutor(), this._tableTemplateCache.deserialize(s);
    } else
      this._tableTemplateCache = e;
    this._tableTemplateProxy = null, this._saveToSettings();
  }
  get chatStatusBarSwitch() {
    return this._chatStatusBarSwitch;
  }
  set chatStatusBarSwitch(e) {
    this._chatStatusBarSwitch !== e && (this._chatStatusBarSwitch = e, this._saveToSettings(), this._notifyChatStatusBarChange());
  }
  onChatStatusBarChange(e) {
    return this._chatStatusBarChangeListeners.add(e), () => this._chatStatusBarChangeListeners.delete(e);
  }
  _notifyChatStatusBarChange() {
    this._chatStatusBarChangeListeners.forEach((e) => e());
  }
  get chatStatusBarCode() {
    return this._chatStatusBarCode;
  }
  set chatStatusBarCode(e) {
    this._chatStatusBarCode = e, this._saveToSettings(), this._notifyChatStatusBarChange();
  }
  get extensionSwitch() {
    return this._extensionSwitch;
  }
  set extensionSwitch(e) {
    this._extensionSwitch = e, this._saveToSettings();
  }
  get systemSqlExecutor() {
    return this._systemSqlExecutorCache || (this._systemSqlExecutorCache = ds.newExecutor()), this._systemSqlExecutorProxy || (this._systemSqlExecutorProxy = qi(this._systemSqlExecutorCache, () => this._saveToSettings())), this._systemSqlExecutorProxy;
  }
  set systemSqlExecutor(e) {
    if (typeof e == "object" && "serialize" in e) {
      const s = e.serialize();
      this._systemSqlExecutorCache = ds.newExecutor(), this._systemSqlExecutorCache.deserialize(s);
    } else
      this._systemSqlExecutorCache = e;
    this._systemSqlExecutorProxy = null, this._saveToSettings();
  }
  static get instance() {
    return Se._instance;
  }
}
class Pe {
  static MODULE_NAME = "ST_BETTER_DATABASE";
  /**
   *  null 
   *
   * 
   * -  readonly _instance = new ChatMetaManager()
   * -  SillyTavern.getContext() 
   * -  chatMetadata 
   */
  static _instance = null;
  /**
   * 
   *  object  SimpleSqlExecutor.serialize() 
   * 
   */
  _serializedTemplateCache = null;
  /**
   * SqlExecutor 
   *  tableTemplate  _serializedTemplateCache 
   * 
   */
  _tableTemplateCache = null;
  /**
   * 
   *  execute  _saveToMetadata()
   */
  _tableTemplateProxy = null;
  constructor() {
    const { chatMetadata: e } = SillyTavern.getContext();
    e[Pe.MODULE_NAME] || (e[Pe.MODULE_NAME] = {
      tableTemplate: null
    }), this._loadFromMetadata();
  }
  /**
   *  chatMetadata 
   *
   *  SillyTavern.getContext().chatMetadata
   * chatMetadata 
   */
  _loadFromMetadata() {
    const { chatMetadata: e } = SillyTavern.getContext(), s = e[Pe.MODULE_NAME];
    if (!s || !s.tableTemplate) {
      const n = Se.instance.tableTemplate, i = new Dr(n);
      this._serializedTemplateCache = i.serialize();
    } else
      this._serializedTemplateCache = s.tableTemplate;
    this._tableTemplateCache = null, this._tableTemplateProxy = null;
  }
  /**
   *  chatMetadata
   *
   *  SillyTavern.getContext().chatMetadata
   * chatMetadata 
   */
  _saveToMetadata() {
    const { chatMetadata: e } = SillyTavern.getContext(), s = e[Pe.MODULE_NAME] || {};
    s.tableTemplate = this._serializedTemplateCache, e[Pe.MODULE_NAME] = s, SillyTavern.getContext().saveMetadata();
  }
  get tableTemplate() {
    if (!this._tableTemplateCache && this._serializedTemplateCache) {
      const e = Se.instance.tableTemplate;
      this._tableTemplateCache = new Dr(e), this._tableTemplateCache.deserialize(this._serializedTemplateCache);
    }
    return !this._tableTemplateProxy && this._tableTemplateCache && (this._tableTemplateProxy = qi(this._tableTemplateCache, () => {
      this._saveToMetadata();
    })), this._tableTemplateProxy || Se.instance.tableTemplate;
  }
  set tableTemplate(e) {
    typeof e == "object" && "serialize" in e ? this._serializedTemplateCache = e.serialize() : this._serializedTemplateCache = e, this._tableTemplateCache = null, this._tableTemplateProxy = null, this._saveToMetadata();
  }
  /**
   * 
   *
   * 
   *  SillyTavern.getContext() 
   */
  static get instance() {
    return Pe._instance || (Pe._instance = new Pe()), Pe._instance;
  }
  /**
   * 
   *
   *  chatMetadata 
   *
   * chatMetadata 
   * 
   */
  reload() {
    this._tableTemplateCache = null, this._tableTemplateProxy = null, this._loadFromMetadata();
  }
}
const Sn = "chatTemplateContainer", em = "chat";
class Mt {
  static _instance = null;
  constructor() {
  }
  static getInstance() {
    return Mt._instance || (Mt._instance = new Mt()), Mt._instance;
  }
  updateChatTemplateDisplay() {
    const e = Se.instance;
    if (!e.chatStatusBarSwitch) {
      this.removeTemplateContainer();
      return;
    }
    const s = e.chatStatusBarCode.trim();
    if (!s) {
      this.removeTemplateContainer();
      return;
    }
    this.renderTemplateToChat(s);
  }
  removeTemplateContainer() {
    const e = document.getElementById(Sn);
    e && e.remove();
  }
  renderTemplateToChat(e) {
    const s = this.escapeIframeContent(e), n = document.getElementById(em);
    if (!n) return;
    const i = document.getElementById(Sn);
    i && i.remove(), n.insertAdjacentHTML("beforeend", `<div class="wide100p" id="${Sn}">${s}</div>`);
    const o = document.getElementById(Sn);
    o && this.attachTouchEventHandlers(o);
  }
  attachTouchEventHandlers(e) {
    const s = (n) => n.stopPropagation();
    e.addEventListener("touchstart", s, { passive: !1 }), e.addEventListener("touchmove", s, { passive: !1 }), e.addEventListener("touchend", s, { passive: !1 });
  }
  escapeIframeContent(e) {
    return e.replace(/<iframe\b([^>]*)>([\s\S]*?)<\/iframe>/gi, (s, n, i) => {
      if (/\bsrcdoc=/i.test(n))
        return s;
      const o = i.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      return `<iframe${n} srcdoc="${o}"></iframe>`;
    });
  }
}
class Js {
  static instance;
  constructor() {
  }
  static init() {
    if (Se.instance.extensionSwitch && !Js.instance) {
      const e = new Js();
      e.registerEventListeners(), Js.instance = e;
    }
  }
  registerEventListeners() {
    const e = SillyTavern.getContext(), { eventSource: s, event_types: n } = e;
    s.on(n.MESSAGE_RECEIVED, (i) => this.onMessageReceived(i)), s.on(n.MESSAGE_EDITED, (i) => this.onMessageEdited(i)), s.on(n.MESSAGE_DELETED, (i) => this.onMessageDeleted()), s.on(n.CHAT_CHANGED, () => this.onChatChanged());
  }
  onMessageReceived(e) {
    this.processMessage(e), Mt.getInstance().updateChatTemplateDisplay();
  }
  onMessageEdited(e) {
    this.processMessage(e), Mt.getInstance().updateChatTemplateDisplay();
  }
  onMessageDeleted() {
    Mt.getInstance().updateChatTemplateDisplay();
  }
  onChatChanged() {
    Pe.instance.reload(), Mt.getInstance().updateChatTemplateDisplay();
  }
  processMessage(e) {
    const i = (SillyTavern.getContext().chat || [])[e];
    if (!i || !i.mes)
      return;
    const o = _e.extractCommit(i.mes);
    if (o)
      try {
        const a = Pe.instance.tableTemplate.compressDml(o), l = _e.extractCommitted(i.mes);
        let u = "";
        l && (u = l);
        const c = u ? `${u};
${a}` : a;
        _e.replaceCommitWithCommitted(e, c);
      } catch (r) {
        console.error("[ChatMessageHandler] Failed to compress commit:", r);
        return;
      }
  }
}
class Os {
  root;
  currentCondition;
  static of() {
    return new Os();
  }
  eq(e, s) {
    const n = `${e} = ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  ne(e, s) {
    const n = `${e} != ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  gt(e, s) {
    const n = `${e} > ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  lt(e, s) {
    const n = `${e} < ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  ge(e, s) {
    const n = `${e} >= ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  le(e, s) {
    const n = `${e} <= ${this.formatValue(s)}`;
    return this.addCondition({ type: "condition", sql: n });
  }
  between(e, s, n) {
    const i = `${e} BETWEEN ${this.formatValue(s)} AND ${this.formatValue(n)}`;
    return this.addCondition({ type: "condition", sql: i });
  }
  notBetween(e, s, n) {
    const i = `${e} NOT BETWEEN ${this.formatValue(s)} AND ${this.formatValue(n)}`;
    return this.addCondition({ type: "condition", sql: i });
  }
  in(e, s) {
    const n = s.map((o) => this.formatValue(o)).join(", "), i = `${e} IN (${n})`;
    return this.addCondition({ type: "condition", sql: i });
  }
  notIn(e, s) {
    const n = s.map((o) => this.formatValue(o)).join(", "), i = `${e} NOT IN (${n})`;
    return this.addCondition({ type: "condition", sql: i });
  }
  isNull(e) {
    const s = `${e} IS NULL`;
    return this.addCondition({ type: "condition", sql: s });
  }
  isNotNull(e) {
    const s = `${e} IS NOT NULL`;
    return this.addCondition({ type: "condition", sql: s });
  }
  and(e) {
    return this.combine("and", e);
  }
  or(e) {
    return this.combine("or", e);
  }
  addCondition(e) {
    return this.currentCondition ? this.currentCondition = { type: "and", left: this.currentCondition, right: e } : this.currentCondition = e, this.root = this.currentCondition, this;
  }
  combine(e, s) {
    const n = s.root || s.currentCondition;
    return n ? (this.currentCondition ? this.currentCondition = { type: e, left: this.currentCondition, right: n } : this.currentCondition = n, this.root = this.currentCondition, this) : this;
  }
  formatValue(e) {
    return e === null ? "NULL" : typeof e == "string" ? `"${e}"` : String(e);
  }
  build() {
    const e = this.root || this.currentCondition;
    return e ? this.buildNode(e) : "";
  }
  buildNode(e) {
    if (e.type === "condition")
      return e.sql;
    const s = this.buildNode(e.left), n = this.buildNode(e.right), i = e.type.toUpperCase();
    return `(${s} ${i} ${n})`;
  }
}
class bn {
  whereCondition;
  orderByClauses = [];
  joins = [];
  where(e) {
    return this.whereCondition = e, this;
  }
  orderBy(e, s = !0) {
    return this.orderByClauses.push(`${e} ${s ? "ASC" : "DESC"}`), this;
  }
  formatValue(e) {
    return e === null ? "NULL" : typeof e == "string" ? `"${e}"` : String(e);
  }
  buildWhere() {
    if (!this.whereCondition) return "";
    const e = this.whereCondition.build();
    return e ? ` WHERE ${e}` : "";
  }
}
class tm extends bn {
  tableName;
  columns = [];
  from(e) {
    return this.tableName = e, this;
  }
  select(...e) {
    return this.columns = e, this;
  }
  join(e, s, n, i) {
    return this.joins.push({ type: e.toString(), table: s, on: `${n} = ${i}` }), this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    let s = `SELECT ${this.columns.length > 0 ? this.columns.join(", ") : "*"} FROM ${this.tableName}`;
    return this.joins.length > 0 && (s += this.joins.map((n) => ` ${n.type} JOIN ${n.table} ON ${n.on}`).join("")), s += this.buildWhere(), this.orderByClauses.length > 0 && (s += ` ORDER BY ${this.orderByClauses.join(", ")}`), s;
  }
}
class sm extends bn {
  tableName;
  values = /* @__PURE__ */ new Map();
  batchValues = [];
  into(e) {
    return this.tableName = e, this;
  }
  set(e, s) {
    return this.values.set(e, s), this;
  }
  setValues(e) {
    return e.forEach((s, n) => this.values.set(n, s)), this;
  }
  batch(e) {
    return this.batchValues = e, this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    const e = this.batchValues.length > 0 ? this.batchValues : [this.values], s = e[0];
    if (!s || s.size === 0)
      throw new Error("No data to insert");
    const n = Array.from(s.keys()).join(", "), i = e.map((o) => `(${Array.from(s.keys()).map((a) => {
      const l = o.get(a);
      return this.formatValue(l !== void 0 ? l : null);
    }).join(", ")})`).join(", ");
    return `INSERT INTO ${this.tableName} (${n}) VALUES ${i}`;
  }
}
class nm extends bn {
  tableName;
  sets = /* @__PURE__ */ new Map();
  table(e) {
    return this.tableName = e, this;
  }
  set(e, s) {
    return this.sets.set(e, s), this;
  }
  setValues(e) {
    return e.forEach((s, n) => this.sets.set(n, s)), this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    if (this.sets.size === 0)
      throw new Error("At least one SET clause is required");
    const e = Array.from(this.sets.entries()).map(([s, n]) => `${s} = ${this.formatValue(n)}`).join(", ");
    return `UPDATE ${this.tableName} SET ${e}${this.buildWhere()}`;
  }
}
class im extends bn {
  tableName;
  from(e) {
    return this.tableName = e, this;
  }
  build() {
    if (!this.tableName)
      throw new Error("Table name is required");
    return `DELETE FROM ${this.tableName}${this.buildWhere()}`;
  }
}
class om extends bn {
  tableName;
  columnName;
  appendValue;
  into(e) {
    return this.tableName = e, this;
  }
  column(e) {
    return this.columnName = e, this;
  }
  value(e) {
    return this.appendValue = e, this;
  }
  build() {
    if (!this.tableName || !this.columnName || this.appendValue === void 0)
      throw new Error("Table name, column, and value are required");
    const e = this.formatValue(this.appendValue);
    return `APPEND INTO ${this.tableName} (${this.columnName}) VALUES (${e})${this.buildWhere()}`;
  }
}
class rm {
  static createTable(e, s, n, i) {
    const o = Array.from(s.entries()).map(([a, l]) => {
      let u = `    ${a} ${l}`;
      return i && i.has(a) && (u += ` COMMENT ${this.formatValue(i.get(a))}`), u;
    }).join(`,
`);
    let r = `CREATE TABLE ${e} (
${o}
)`;
    return n && (r += ` COMMENT ${this.formatValue(n)}`), r;
  }
  static alterTableAddColumn(e, s, n, i) {
    let o = `ALTER TABLE ${e} ADD COLUMN ${s} ${n}`;
    return i && (o += ` COMMENT ${this.formatValue(i)}`), o;
  }
  static alterTableDropColumn(e, s) {
    return `ALTER TABLE ${e} DROP COLUMN ${s}`;
  }
  static alterTableRename(e, s) {
    return `ALTER TABLE ${e} RENAME TO ${s}`;
  }
  static alterTableModifyColumnComment(e, s, n, i) {
    return `ALTER TABLE ${e} MODIFY COLUMN ${s} ${n} COMMENT ${this.formatValue(i)}`;
  }
  static alterTableRenameColumn(e, s, n) {
    return `ALTER TABLE ${e} RENAME COLUMN ${s} TO ${n}`;
  }
  static alterTableComment(e, s) {
    return `ALTER TABLE ${e} COMMENT ${this.formatValue(s)}`;
  }
  static dropTable(e) {
    return `DROP TABLE ${e}`;
  }
  static formatValue(e) {
    return `"${e}"`;
  }
}
class it {
  static select() {
    return new tm();
  }
  static insert() {
    return new sm();
  }
  static update() {
    return new nm();
  }
  static delete() {
    return new im();
  }
  static append() {
    return new om();
  }
  static ddl() {
    return rm;
  }
}
class ll {
  queryData(e, s) {
    const n = it.select().from(e).where(s || Os.of()).build();
    return this.executor.execute(n, [ee.DQL]);
  }
  insertData(e, s) {
    const n = it.insert().into(e);
    Array.isArray(s) ? n.batch(s) : n.setValues(s);
    const i = n.build();
    return this.executor.execute(i, [ee.DML]);
  }
  deleteData(e, s) {
    const n = it.delete().from(e).where(s).build();
    return this.executor.execute(n, [ee.DML]);
  }
  updateData(e, s, n) {
    const i = it.update().table(e).setValues(s).where(n).build();
    return this.executor.execute(i, [ee.DML]);
  }
  export(e) {
    return this.executor.export(ot.INSERT_SQL, e);
  }
}
class am extends ll {
  get executor() {
    return Pe.instance.tableTemplate;
  }
}
class yo {
  createTable(e, s, n) {
    const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    s.forEach((a) => {
      const l = a.type + (a.primitiveKey ? " PRIMARY KEY" : "");
      i.set(a.name, l), a.comment && o.set(a.name, a.comment);
    });
    const r = it.ddl().createTable(e, i, n, o);
    return this.executor.execute(r, [ee.DDL]);
  }
  dropTable(e) {
    const s = it.ddl().dropTable(e);
    return this.executor.execute(s, [ee.DDL]);
  }
  addColumn(e, s, n) {
    const i = n.type + (n.primitiveKey ? " PRIMARY KEY" : ""), o = it.ddl().alterTableAddColumn(e, s, i, n.comment);
    return this.executor.execute(o, [ee.DDL]);
  }
  dropColumn(e, s) {
    const n = it.ddl().alterTableDropColumn(e, s);
    return this.executor.execute(n, [ee.DDL]);
  }
  alterTableName(e, s) {
    const n = it.ddl().alterTableRename(e, s);
    return this.executor.execute(n, [ee.DDL]);
  }
  alterTableComment(e, s) {
    const n = it.ddl().alterTableComment(e, s);
    return this.executor.execute(n, [ee.DDL]);
  }
  alterColumnComment(e, s, n) {
    if (this.executor.getTableIdxByName(e) === void 0)
      return {
        success: !1,
        message: `Table ${e} not found`,
        data: 0,
        type: ee.DDL
      };
    const o = it.ddl().alterTableModifyColumnComment(e, s, "STRING", n);
    return this.executor.execute(o, [ee.DDL]);
  }
  alterColumnName(e, s, n) {
    const i = it.ddl().alterTableRenameColumn(e, s, n);
    return this.executor.execute(i, [ee.DDL]);
  }
  exportData(e) {
    return this.executor.export(ot.INSERT_SQL, e);
  }
  exportDDL(e) {
    return this.executor.export(ot.DDL, e);
  }
  getTables() {
    return this.executor.getTables();
  }
}
class lm extends yo {
  get executor() {
    return Pe.instance.tableTemplate;
  }
}
class cm extends yo {
  get executor() {
    return Se.instance.tableTemplate;
  }
}
class um extends ll {
  get executor() {
    return Se.instance.systemSqlExecutor;
  }
}
class dm extends yo {
  get executor() {
    return Se.instance.systemSqlExecutor;
  }
}
class fm {
  execute(e) {
    return Se.instance.systemSqlExecutor.execute(e, [ee.DDL, ee.DML]);
  }
}
class pm {
  syncTableFromTemplate() {
    Se.instance.systemSqlExecutor = Se.instance.tableTemplate.clone();
  }
  pushTableToTemplate() {
    const e = Se.instance.systemSqlExecutor, s = Se.instance.tableTemplate, n = e.serialize();
    s.deserialize({ structure: n.tableTemplate.structure });
  }
}
class hm {
  execute(e) {
    return Pe.instance.tableTemplate.execute(e, [ee.DDL]);
  }
}
class mm {
  execute(e) {
    return Se.instance.tableTemplate.execute(e, [ee.DDL]);
  }
}
class vm {
  /**
   * 
   */
  pushTableToTemplate() {
    const e = Pe.instance.tableTemplate, s = Se.instance.tableTemplate, n = e.serialize();
    s.deserialize({ structure: n.tableTemplate.structure });
  }
  /**
   * 
   */
  syncTableFromTemplate() {
    Pe.instance.tableTemplate = Se.instance.tableTemplate.clone();
  }
}
class ke {
  static _chatDataManagementService = new am();
  static _chatTableManagementService = new lm();
  static _chatSqlExecutorService = new hm();
  static _templateSqlExecutorService = new mm();
  static _templateTableManagementService = new cm();
  static _chatDatabaseSyncService = new vm();
  static _systemDataManagementService = new um();
  static _systemTableManagementService = new dm();
  static _systemSqlExecutorService = new fm();
  static _systemDatabaseSyncService = new pm();
  static get chatDataManagementService() {
    return ke._chatDataManagementService;
  }
  static get chatTableManagementService() {
    return ke._chatTableManagementService;
  }
  static get chatSqlExecutorService() {
    return ke._chatSqlExecutorService;
  }
  static get templateSqlExecutorService() {
    return ke._templateSqlExecutorService;
  }
  static get templateTableManagementService() {
    return ke._templateTableManagementService;
  }
  static get chatDatabaseSyncService() {
    return ke._chatDatabaseSyncService;
  }
  static get systemDataManagementService() {
    return ke._systemDataManagementService;
  }
  static get systemTableManagementService() {
    return ke._systemTableManagementService;
  }
  static get systemSqlExecutorService() {
    return ke._systemSqlExecutorService;
  }
  static get systemDatabaseSyncService() {
    return ke._systemDatabaseSyncService;
  }
}
function bm() {
  const t = se(() => ke.chatDataManagementService), e = se(() => ke.chatTableManagementService), s = se(() => ke.chatSqlExecutorService), n = se(() => ke.chatDatabaseSyncService);
  return {
    dataManagementService: t,
    tableManagementService: e,
    sqlExecutorService: s,
    databaseSyncService: n
  };
}
function gm() {
  const t = se(() => ke.templateTableManagementService), e = se(() => ke.templateSqlExecutorService);
  return {
    tableManagementService: t,
    sqlExecutorService: e
  };
}
function Em() {
  const t = se(() => ke.systemDataManagementService), e = se(() => ke.systemTableManagementService), s = se(() => ke.systemSqlExecutorService), n = se(() => ke.systemDatabaseSyncService);
  return {
    dataManagementService: t,
    tableManagementService: e,
    sqlExecutorService: s,
    databaseSyncService: n
  };
}
const ym = /* @__PURE__ */ Te({
  __name: "TemplateManagementPanel",
  props: /* @__PURE__ */ no({
    defaultTabOnTableSelect: { default: "template" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { tableManagementService: n, sqlExecutorService: i } = gm(), o = io(t, "visible"), r = /* @__PURE__ */ H(!1), a = /* @__PURE__ */ H("template"), l = /* @__PURE__ */ H(""), u = /* @__PURE__ */ H([]), c = /* @__PURE__ */ H(null), d = [
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], m = () => {
      u.value = n.value.getTables();
    }, h = (T) => {
      l.value = T, a.value = s.defaultTabOnTableSelect;
    }, g = () => {
      r.value = !r.value;
    }, E = async () => {
      a.value = "template", await It(), c.value?.openCreateTableModal();
    }, y = () => {
      o.value = !1;
    };
    return lt(o, (T) => {
      T && m();
    }), e({
      open: () => {
        o.value = !0;
      }
    }), (T, N) => (S(), L("div", null, [
      mt(T.$slots, "default"),
      w(Ge, {
        visible: o.value,
        "onUpdate:visible": N[2] || (N[2] = (_) => o.value = _),
        title: "",
        closable: !0,
        height: "650px",
        onClose: y
      }, {
        titlePrefix: B(() => [
          w(po, {
            expanded: r.value,
            onToggle: g
          }, null, 8, ["expanded"])
        ]),
        default: B(() => [
          w(uo, {
            "drawer-expanded": r.value,
            "onUpdate:drawerExpanded": N[1] || (N[1] = (_) => r.value = _),
            tables: u.value,
            "selected-table": l.value,
            onSelectTable: h,
            onCreateTable: E
          }, {
            default: B(() => [
              w(fo, {
                "active-tab": a.value,
                "onUpdate:activeTab": N[0] || (N[0] = (_) => a.value = _),
                tabs: d
              }, {
                template: B(() => [
                  w(ho, {
                    ref_key: "tableTabRef",
                    ref: c,
                    "table-service": Q(n),
                    tables: u.value,
                    "selected-table": l.value,
                    onRefresh: m,
                    "onUpdate:selectedTable": h
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: B(() => [
                  w(mo, {
                    "sql-executor-service": Q(i),
                    onRefresh: m
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), _m = {
  key: 0,
  class: "data-form"
}, Tm = { class: "form-content" }, Nm = { class: "form-label" }, xm = {
  key: 0,
  class: "required-mark"
}, Sm = ["value", "onInput", "type"], Cm = { class: "form-actions" }, wm = {
  key: 1,
  class: "loading-container"
}, Dm = /* @__PURE__ */ Te({
  __name: "DataForm",
  props: {
    columns: {},
    initialData: {},
    title: { default: "" },
    modalWidth: { default: "50vw" },
    modalHeight: { default: "auto" }
  },
  emits: ["submit", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ H(!1), o = () => {
      i.value = window.innerWidth <= 768;
    };
    nt(() => {
      o(), window.addEventListener("resize", o);
    }), Pt(() => {
      window.removeEventListener("resize", o);
    });
    const r = se(() => i.value ? "100%" : s.modalWidth), a = se(() => {
      const N = {};
      return s.modalWidth && (N["--form-modal-width"] = i.value ? "100%" : s.modalWidth), s.modalHeight && (N["--form-modal-height"] = s.modalHeight), N;
    }), l = /* @__PURE__ */ is({}), u = /* @__PURE__ */ is({}), c = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ H(!1), m = () => {
      c.clear(), d.value = !1, requestAnimationFrame(() => {
        s.columns.forEach((N) => {
          let _;
          s.initialData && s.initialData[N.name] !== void 0 ? _ = s.initialData[N.name] : N.defaultValue !== void 0 ? _ = N.defaultValue : _ = "", l[N.name] = _, u[N.name] = _;
        }), requestAnimationFrame(() => {
          d.value = !0;
        });
      });
    }, h = (N) => {
      const _ = N.toUpperCase();
      return _.includes("STRING") || _.includes("TEXT");
    }, g = (N) => N.toUpperCase().includes("INT") || N.toUpperCase().includes("REAL") || N.toUpperCase().includes("FLOA") || N.toUpperCase().includes("DOUB") ? "number" : "text", E = (N, _) => {
      let C;
      if (typeof _ == "string")
        C = _;
      else {
        const U = _.target;
        C = U.type === "number" ? parseFloat(U.value) : U.value;
      }
      l[N] = C;
      const R = u[N];
      String(C) !== String(R) ? c.add(N) : c.delete(N);
    }, y = () => {
      const N = /* @__PURE__ */ new Map(), _ = s.initialData !== void 0;
      s.columns.forEach((C) => {
        if (_ && !c.has(C.name))
          return;
        let R = l[C.name], U;
        R === "" || R === void 0 ? C.primitiveKey && C.defaultValue !== void 0 ? U = C.defaultValue : U = null : U = R;
        const le = C.type.toUpperCase();
        le.includes("INT") && U !== null ? U = parseInt(String(U)) : (le.includes("REAL") || le.includes("FLOA") || le.includes("DOUB")) && U !== null && (U = parseFloat(String(U))), N.set(C.name, U);
      }), n("submit", N);
    }, T = () => {
      n("cancel");
    };
    return lt(() => s.initialData, () => {
      m();
    }, { immediate: !0 }), (N, _) => (S(), L("div", {
      class: "data-form-wrapper",
      style: Ke(a.value)
    }, [
      w(Ge, {
        visible: !0,
        title: t.title,
        width: r.value,
        height: t.modalHeight,
        closable: !1,
        onClose: T
      }, {
        default: B(() => [
          d.value ? (S(), L("div", _m, [
            f("div", Tm, [
              (S(!0), L(Ae, null, Wt(t.columns, (C) => (S(), L("div", {
                key: C.name,
                class: "form-item"
              }, [
                f("label", Nm, [
                  ne(de(C.name) + " ", 1),
                  C.primitiveKey ? (S(), L("span", xm, "*")) : te("", !0)
                ]),
                h(C.type) ? (S(), Ie(Vs, {
                  key: 1,
                  "model-value": String(l[C.name] || ""),
                  "onUpdate:modelValue": (R) => E(C.name, R),
                  "min-rows": 1,
                  "max-rows": 10
                }, null, 8, ["model-value", "onUpdate:modelValue"])) : (S(), L("input", {
                  key: 0,
                  value: l[C.name],
                  onInput: (R) => E(C.name, R),
                  type: g(C.type),
                  class: "form-input"
                }, null, 40, Sm))
              ]))), 128))
            ]),
            f("div", Cm, [
              w(ae, { onClick: T }, {
                default: B(() => [..._[0] || (_[0] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "primary",
                onClick: y
              }, {
                default: B(() => [..._[1] || (_[1] = [
                  ne("", -1)
                ])]),
                _: 1
              })
            ])
          ])) : (S(), L("div", wm, [..._[2] || (_[2] = [
            f("div", { class: "loading-spinner" }, null, -1)
          ])]))
        ]),
        _: 1
      }, 8, ["title", "width", "height"])
    ], 4));
  }
}), Or = /* @__PURE__ */ De(Dm, [["__scopeId", "data-v-a92ff958"]]), Om = { class: "confirm-container" }, $m = { class: "form-actions" }, Am = /* @__PURE__ */ Te({
  __name: "DeleteDataConfirm",
  props: {
    modalWidth: {},
    modalHeight: {}
  },
  emits: ["confirm", "cancel"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = se(() => {
      const a = {};
      return s.modalWidth && (a["--confirm-modal-width"] = s.modalWidth), s.modalHeight && (a["--confirm-modal-height"] = s.modalHeight), a;
    }), o = () => {
      n("confirm");
    }, r = () => {
      n("cancel");
    };
    return (a, l) => (S(), L("div", {
      class: "delete-data-confirm-wrapper",
      style: Ke(i.value)
    }, [
      w(Ge, {
        visible: !0,
        title: "",
        width: t.modalWidth,
        height: t.modalHeight,
        closable: !1,
        onClose: r
      }, {
        default: B(() => [
          f("div", Om, [
            l[2] || (l[2] = f("div", { class: "confirm-content" }, [
              f("i", { class: "fa-solid fa-triangle-exclamation warning-icon" }),
              f("p", { class: "confirm-message" }, "")
            ], -1)),
            f("div", $m, [
              w(ae, { onClick: r }, {
                default: B(() => [...l[0] || (l[0] = [
                  ne("", -1)
                ])]),
                _: 1
              }),
              w(ae, {
                type: "danger",
                onClick: o
              }, {
                default: B(() => [...l[1] || (l[1] = [
                  ne("", -1)
                ])]),
                _: 1
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["width", "height"])
    ], 4));
  }
}), Vm = /* @__PURE__ */ De(Am, [["__scopeId", "data-v-b672c047"]]), Mm = { class: "export-container" }, Im = { class: "export-header" }, Rm = { class: "export-content" }, Lm = { class: "export-code" }, km = { class: "form-actions" }, Pm = /* @__PURE__ */ Te({
  __name: "ExportDisplay",
  props: {
    sql: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const s = t, n = e, i = /* @__PURE__ */ H(!1);
    let o = null;
    const r = async () => {
      try {
        await navigator.clipboard.writeText(s.sql), i.value = !0, o && clearTimeout(o), o = setTimeout(() => {
          i.value = !1;
        }, 2e3);
      } catch (l) {
        console.error(":", l);
      }
    }, a = () => {
      n("close");
    };
    return (l, u) => (S(), L("div", Mm, [
      f("div", Im, [
        u[0] || (u[0] = f("span", { class: "export-title" }, "SQL", -1)),
        f("button", {
          class: "copy-btn",
          onClick: r
        }, [
          f("i", {
            class: Re(i.value ? "fa-solid fa-check" : "fa-solid fa-copy")
          }, null, 2),
          ne(" " + de(i.value ? "" : ""), 1)
        ])
      ]),
      f("div", Rm, [
        f("pre", Lm, de(t.sql), 1)
      ]),
      f("div", km, [
        w(ae, { onClick: a }, {
          default: B(() => [...u[1] || (u[1] = [
            ne("", -1)
          ])]),
          _: 1
        })
      ])
    ]));
  }
}), Bm = /* @__PURE__ */ De(Pm, [["__scopeId", "data-v-affef56e"]]), Fm = { class: "chat-data-management-tab" }, Um = {
  key: 1,
  class: "data-detail"
}, jm = { class: "data-toolbar" }, qm = { class: "data-title" }, Hm = { class: "table-name" }, Wm = {
  key: 0,
  class: "table-comment"
}, Km = { class: "data-actions" }, zm = { class: "data-list" }, Gm = {
  key: 1,
  class: "table-container"
}, Ym = { class: "data-table" }, Qm = {
  key: 0,
  class: "checkbox-header sticky-col",
  style: { left: "0" }
}, Jm = { class: "checkbox-wrapper" }, Xm = ["checked"], Zm = {
  key: 0,
  class: "checkbox-cell sticky-col",
  style: { left: "0" }
}, ev = { class: "checkbox-wrapper" }, tv = ["checked", "onChange"], sv = { class: "row-actions" }, nv = { class: "cell-value" }, iv = /* @__PURE__ */ Te({
  __name: "ChatDataManagementTab",
  props: {
    dataService: {},
    tables: {},
    selectedTable: {}
  },
  setup(t) {
    const e = t, s = se(() => e.tables.find((D) => D.tableName === e.selectedTable) || {}), n = se(() => s.value.columnSchemas ? Object.values(s.value.columnSchemas) : []), i = se(() => l.value === "none" ? "" : l.value === "selecting" ? "" : l.value === "confirming" ? "" : ""), o = /* @__PURE__ */ H([]), r = /* @__PURE__ */ H(/* @__PURE__ */ new Set()), a = /* @__PURE__ */ H(!1), l = /* @__PURE__ */ H("none"), { toast: u, showToast: c } = rl(), d = /* @__PURE__ */ H(!1), m = /* @__PURE__ */ H(!1), h = /* @__PURE__ */ H(!1), g = /* @__PURE__ */ H(!1), E = /* @__PURE__ */ H(null), y = /* @__PURE__ */ H(""), T = (D) => D === null ? "NULL" : D === void 0 ? "" : String(D).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "\\n").replace(/<br>/gi, "&lt;br&gt;"), N = () => {
      if (s.value.tableName) {
        const D = e.dataService.queryData(s.value.tableName);
        D.success && Array.isArray(D.data) ? o.value = D.data : o.value = [];
      }
    }, _ = (D) => {
      if (s.value.tableName) {
        const K = e.dataService.insertData(s.value.tableName, D);
        K.success ? (d.value = !1, N(), c("")) : c(K.message || "", "error");
      }
    }, C = (D, K) => {
      E.value = { index: D, row: K }, m.value = !0;
    }, R = (D) => {
      if (s.value.tableName && E.value) {
        const K = n.value.find((ce) => ce.primitiveKey), oe = o.value[E.value.index];
        let be = Os.of();
        if (K) {
          const ce = oe[K.name];
          be = be.eq(K.name, ce);
        }
        const pe = e.dataService.updateData(s.value.tableName, D, be);
        pe.success ? (m.value = !1, E.value = null, N(), c("")) : c(pe.message || "", "error");
      }
    }, U = (D) => {
      E.value = { index: D, row: o.value[D] }, h.value = !0;
    }, le = () => {
      if (s.value.tableName && E.value) {
        const D = n.value.find((pe) => pe.primitiveKey), K = o.value[E.value.index];
        let oe = Os.of();
        if (D) {
          const pe = K[D.name];
          oe = oe.eq(D.name, pe);
        }
        const be = e.dataService.deleteData(s.value.tableName, oe);
        be.success ? (h.value = !1, E.value = null, N(), c("")) : c(be.message || "", "error");
      }
    }, he = (D) => {
      r.value.has(D) ? r.value.delete(D) : r.value.add(D), r.value.size > 0 ? l.value = "confirming" : l.value = "selecting";
    }, W = (D) => {
      D.target.checked ? o.value.forEach((oe, be) => r.value.add(be)) : r.value.clear(), r.value.size > 0 ? l.value = "confirming" : l.value = "selecting";
    }, re = () => {
      if (l.value === "none")
        l.value = "selecting", a.value = !0, r.value.clear();
      else if (l.value === "selecting")
        l.value = "none", a.value = !1, r.value.clear();
      else if (l.value === "confirming") {
        if (r.value.size === 0) {
          c("", "error");
          return;
        }
        if (s.value.tableName) {
          let D = 0;
          const K = n.value.find((oe) => oe.primitiveKey);
          r.value.forEach((oe) => {
            const be = o.value[oe];
            let pe = Os.of();
            if (K) {
              const fe = be[K.name];
              pe = pe.eq(K.name, fe);
            }
            e.dataService.deleteData(s.value.tableName, pe).success && D++;
          }), r.value.clear(), N(), c(` ${D} `), l.value = "none", a.value = !1;
        }
      }
    }, me = () => {
      s.value.tableName && (y.value = e.dataService.export(s.value.tableName), g.value = !0);
    };
    return lt(() => e.selectedTable, () => {
      N();
    }), nt(() => {
      N();
    }), (D, K) => (S(), L("div", Fm, [
      t.selectedTable ? (S(), L("div", Um, [
        f("div", jm, [
          f("div", qm, [
            f("span", Hm, de(s.value.tableName), 1),
            s.value.comment ? (S(), L("span", Wm, de(s.value.comment), 1)) : te("", !0)
          ]),
          f("div", Km, [
            w(ae, {
              onClick: K[0] || (K[0] = (oe) => d.value = !0)
            }, {
              default: B(() => [...K[6] || (K[6] = [
                f("i", {
                  class: "fa-solid fa-plus",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            }),
            w(ae, {
              type: "danger",
              onClick: re
            }, {
              default: B(() => [
                K[7] || (K[7] = f("i", {
                  class: "fa-solid fa-trash",
                  style: { "margin-right": "6px" }
                }, null, -1)),
                ne(" " + de(i.value), 1)
              ]),
              _: 1
            }),
            w(ae, { onClick: me }, {
              default: B(() => [...K[8] || (K[8] = [
                f("i", {
                  class: "fa-solid fa-download",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            })
          ])
        ]),
        f("div", zm, [
          o.value.length === 0 ? (S(), Ie(Gn, {
            key: 0,
            icon: "fa-solid fa-database",
            text: ""
          })) : (S(), L("div", Gm, [
            f("table", Ym, [
              f("thead", null, [
                f("tr", null, [
                  a.value ? (S(), L("th", Qm, [
                    f("label", Jm, [
                      f("input", {
                        type: "checkbox",
                        checked: r.value.size === o.value.length && o.value.length > 0,
                        onChange: W
                      }, null, 40, Xm)
                    ])
                  ])) : te("", !0),
                  f("th", {
                    class: "actions-header sticky-col",
                    style: Ke({ left: a.value ? "50px" : "0" })
                  }, "  ", 4),
                  (S(!0), L(Ae, null, Wt(n.value, (oe) => (S(), L("th", {
                    key: oe.name,
                    class: Re(["column-header", oe.primitiveKey ? "primary-key" : ""])
                  }, de(oe.name), 3))), 128))
                ])
              ]),
              f("tbody", null, [
                (S(!0), L(Ae, null, Wt(o.value, (oe, be) => (S(), L("tr", {
                  key: be,
                  class: "table-row"
                }, [
                  a.value ? (S(), L("td", Zm, [
                    f("label", ev, [
                      f("input", {
                        type: "checkbox",
                        checked: r.value.has(be),
                        onChange: (pe) => he(be)
                      }, null, 40, tv)
                    ])
                  ])) : te("", !0),
                  f("td", {
                    class: "actions-cell sticky-col",
                    style: Ke({ left: a.value ? "50px" : "0" })
                  }, [
                    f("div", sv, [
                      w(ae, {
                        size: "small",
                        onClick: (pe) => C(be, oe)
                      }, {
                        default: B(() => [...K[9] || (K[9] = [
                          f("i", { class: "fa-solid fa-pen" }, null, -1)
                        ])]),
                        _: 1
                      }, 8, ["onClick"]),
                      w(ae, {
                        type: "danger",
                        size: "small",
                        onClick: (pe) => U(be)
                      }, {
                        default: B(() => [...K[10] || (K[10] = [
                          f("i", { class: "fa-solid fa-trash" }, null, -1)
                        ])]),
                        _: 1
                      }, 8, ["onClick"])
                    ])
                  ], 4),
                  (S(!0), L(Ae, null, Wt(n.value, (pe) => (S(), L("td", {
                    key: pe.name,
                    class: Re(["table-cell", pe.primitiveKey ? "primary-key" : ""])
                  }, [
                    f("span", nv, de(T(oe[pe.name])), 1)
                  ], 2))), 128))
                ]))), 128))
              ])
            ])
          ]))
        ])
      ])) : (S(), Ie(Gn, {
        key: 0,
        icon: "fa-solid fa-table",
        text: ""
      })),
      w(ol, {
        visible: Q(u).visible,
        message: Q(u).message,
        type: Q(u).type,
        icon: Q(u).icon
      }, null, 8, ["visible", "message", "type", "icon"]),
      d.value ? (S(), Ie(Or, {
        key: 2,
        title: "",
        columns: n.value,
        "modal-width": "50vw",
        onSubmit: _,
        onCancel: K[1] || (K[1] = (oe) => d.value = !1)
      }, null, 8, ["columns"])) : te("", !0),
      m.value && E.value ? (S(), Ie(Or, {
        key: 3,
        title: "",
        columns: n.value,
        "initial-data": E.value.row,
        "modal-width": "50vw",
        onSubmit: R,
        onCancel: K[2] || (K[2] = (oe) => m.value = !1)
      }, null, 8, ["columns", "initial-data"])) : te("", !0),
      h.value ? (S(), Ie(Vm, {
        key: 4,
        "modal-width": "500px",
        "modal-height": "auto",
        onConfirm: le,
        onCancel: K[3] || (K[3] = (oe) => h.value = !1)
      })) : te("", !0),
      g.value ? (S(), Ie(Ge, {
        key: 5,
        visible: "",
        title: "",
        onClose: K[5] || (K[5] = (oe) => g.value = !1)
      }, {
        default: B(() => [
          w(Bm, {
            sql: y.value,
            onClose: K[4] || (K[4] = (oe) => g.value = !1)
          }, null, 8, ["sql"])
        ]),
        _: 1
      })) : te("", !0)
    ]));
  }
}), cl = /* @__PURE__ */ De(iv, [["__scopeId", "data-v-c1523f72"]]), ov = /* @__PURE__ */ Te({
  __name: "SystemDataManagementPanel",
  props: /* @__PURE__ */ no({
    defaultTabOnTableSelect: { default: "data" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { dataManagementService: n, tableManagementService: i, sqlExecutorService: o } = Em(), r = io(t, "visible"), a = /* @__PURE__ */ H(!1), l = /* @__PURE__ */ H("data"), u = /* @__PURE__ */ H(""), c = /* @__PURE__ */ H([]), d = /* @__PURE__ */ H(null), m = [
      { key: "data", label: "", icon: "fa-solid fa-database" },
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], h = () => {
      c.value = i.value.getTables();
    }, g = (N) => {
      u.value = N, l.value = s.defaultTabOnTableSelect;
    }, E = () => {
      a.value = !a.value;
    }, y = async () => {
      l.value = "template", await It(), d.value?.openCreateTableModal();
    }, T = () => {
      r.value = !1;
    };
    return lt(r, (N) => {
      N && h();
    }), e({
      open: () => {
        r.value = !0;
      }
    }), (N, _) => (S(), L("div", null, [
      mt(N.$slots, "default"),
      w(Ge, {
        visible: r.value,
        "onUpdate:visible": _[2] || (_[2] = (C) => r.value = C),
        title: "",
        closable: !0,
        height: "650px",
        onClose: T
      }, {
        titlePrefix: B(() => [
          w(po, {
            expanded: a.value,
            onToggle: E
          }, null, 8, ["expanded"])
        ]),
        default: B(() => [
          w(uo, {
            "drawer-expanded": a.value,
            "onUpdate:drawerExpanded": _[1] || (_[1] = (C) => a.value = C),
            tables: c.value,
            "selected-table": u.value,
            "show-sync-buttons": !1,
            onSelectTable: g,
            onCreateTable: y
          }, {
            default: B(() => [
              w(fo, {
                "active-tab": l.value,
                "onUpdate:activeTab": _[0] || (_[0] = (C) => l.value = C),
                tabs: m
              }, {
                data: B(() => [
                  w(cl, {
                    "data-service": Q(n),
                    tables: c.value,
                    "selected-table": u.value,
                    onRefresh: h
                  }, null, 8, ["data-service", "tables", "selected-table"])
                ]),
                template: B(() => [
                  w(ho, {
                    ref_key: "tableTabRef",
                    ref: d,
                    "table-service": Q(i),
                    tables: c.value,
                    "selected-table": u.value,
                    onRefresh: h,
                    "onUpdate:selectedTable": g
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: B(() => [
                  w(mo, {
                    "sql-executor-service": Q(o),
                    onRefresh: h
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), rv = { class: "category_container" }, av = { style: { display: "flex", "align-items": "center", gap: "10px" } }, lv = { class: "category_container" }, cv = { class: "category_container" }, uv = { style: { display: "flex", "flex-direction": "column", gap: "12px" } }, dv = /* @__PURE__ */ Te({
  __name: "SettingsPanel",
  setup(t) {
    const e = Se.instance, s = se({
      get: () => e.extensionSwitch,
      set: (E) => e.extensionSwitch = E
    }), n = se({
      get: () => e.chatStatusBarSwitch,
      set: (E) => e.chatStatusBarSwitch = E
    }), i = /* @__PURE__ */ H(!1), o = /* @__PURE__ */ H(""), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H(0);
    lt(i, async (E) => {
      if (E) {
        a.value++, await It();
        const y = e.chatStatusBarCode;
        o.value = y, await It(), r.value && (r.value.value = y);
      }
    });
    const l = () => {
      i.value = !0;
    }, u = () => {
      i.value = !1;
    }, c = () => {
      e.chatStatusBarCode = o.value, i.value = !1;
    }, d = /* @__PURE__ */ H(), m = /* @__PURE__ */ H(), h = () => {
      d.value?.open();
    }, g = () => {
      m.value?.open();
    };
    return (E, y) => (S(), L(Ae, null, [
      f("div", rv, [
        w(Nn, null, {
          left: B(() => [...y[4] || (y[4] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-sliders",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: B(() => [
            w(Tr, {
              checked: s.value,
              onChange: y[0] || (y[0] = (T) => s.value = T)
            }, null, 8, ["checked"])
          ]),
          _: 1
        }),
        w(Nn, null, {
          left: B(() => [...y[5] || (y[5] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-paper-plane",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: B(() => [
            f("div", av, [
              w(Tr, {
                checked: n.value,
                onChange: y[1] || (y[1] = (T) => n.value = T)
              }, null, 8, ["checked"]),
              w(ae, { onClick: l }, {
                default: B(() => [...y[6] || (y[6] = [
                  f("i", {
                    class: "fa-solid fa-pen-to-square",
                    style: { "margin-right": "6px" }
                  }, null, -1),
                  ne("  ", -1)
                ])]),
                _: 1
              })
            ])
          ]),
          _: 1
        })
      ]),
      f("div", lv, [
        w(Nn, null, {
          left: B(() => [...y[7] || (y[7] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-file-code",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: B(() => [
            w(ae, { onClick: h }, {
              default: B(() => [...y[8] || (y[8] = [
                f("i", {
                  class: "fa-solid fa-gear",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      f("div", cv, [
        w(Nn, null, {
          left: B(() => [...y[9] || (y[9] = [
            f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
              f("i", {
                class: "fa-solid fa-database",
                style: { "margin-right": "6px" }
              }),
              f("span", null, "")
            ], -1)
          ])]),
          right: B(() => [
            w(ae, { onClick: g }, {
              default: B(() => [...y[10] || (y[10] = [
                f("i", {
                  class: "fa-solid fa-gear",
                  style: { "margin-right": "6px" }
                }, null, -1),
                ne("  ", -1)
              ])]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      w(ym, {
        ref_key: "templateManagementPanelRef",
        ref: d
      }, {
        default: B(() => [...y[11] || (y[11] = [])]),
        _: 1
      }, 512),
      w(ov, {
        ref_key: "systemDataManagementPanelRef",
        ref: m
      }, {
        default: B(() => [...y[12] || (y[12] = [])]),
        _: 1
      }, 512),
      w(Ge, {
        visible: i.value,
        "onUpdate:visible": y[3] || (y[3] = (T) => i.value = T),
        title: "",
        closable: !0,
        onClose: u
      }, {
        footer: B(() => [
          w(ae, { onClick: u }, {
            default: B(() => [...y[13] || (y[13] = [
              ne("", -1)
            ])]),
            _: 1
          }),
          w(ae, { onClick: c }, {
            default: B(() => [...y[14] || (y[14] = [
              ne("", -1)
            ])]),
            _: 1
          })
        ]),
        default: B(() => [
          f("div", uv, [
            rt(f("textarea", {
              ref_key: "textareaRef",
              ref: r,
              "onUpdate:modelValue": y[2] || (y[2] = (T) => o.value = T),
              rows: "10",
              style: { width: "100%", padding: "12px", border: "1px solid var(--SmartThemeBorderColor)", "border-radius": "6px", background: "var(--black30a)", color: "var(--SmartThemeBodyColor)", "font-family": "monospace", resize: "vertical" },
              placeholder: "..."
            }, null, 512), [
              [zt, o.value]
            ])
          ])
        ]),
        _: 1
      }, 8, ["visible"])
    ], 64));
  }
}), fv = /* @__PURE__ */ Te({
  __name: "ExtraMesButtons",
  emits: ["click"],
  setup(t, { emit: e }) {
    const s = e;
    function n() {
      s("click");
    }
    return nt(() => {
      $(document).on("click", ".open_database_table", n);
    }), pn(() => {
      $(document).off("click", ".open_database_table", n);
    }), (i, o) => (S(), Ie(ga, { to: ".extraMesButtons" }, [
      o[0] || (o[0] = f("div", {
        class: "mes_button open_database_table",
        title: ""
      }, [
        f("i", { class: "fa-solid fa-table" })
      ], -1))
    ]));
  }
}), pv = /* @__PURE__ */ Te({
  __name: "ChatManagementPanel",
  props: /* @__PURE__ */ no({
    defaultTabOnTableSelect: { default: "data" }
  }, {
    visible: { type: Boolean, default: !1 },
    visibleModifiers: {}
  }),
  emits: ["update:visible"],
  setup(t, { expose: e }) {
    const s = t, { dataManagementService: n, tableManagementService: i, sqlExecutorService: o, databaseSyncService: r } = bm(), a = io(t, "visible"), l = /* @__PURE__ */ H(!1), u = /* @__PURE__ */ H("data"), c = /* @__PURE__ */ H(""), d = /* @__PURE__ */ H([]), m = /* @__PURE__ */ H(null), h = [
      { key: "data", label: "", icon: "fa-solid fa-database" },
      { key: "template", label: "", icon: "fa-solid fa-table" },
      { key: "sql", label: "SQL", icon: "fa-solid fa-code" }
    ], g = () => {
      d.value = i.value.getTables();
    }, E = (R) => {
      c.value = R, u.value = s.defaultTabOnTableSelect;
    }, y = () => {
      l.value = !l.value;
    }, T = async () => {
      u.value = "template", await It(), m.value?.openCreateTableModal();
    }, N = () => {
      r.value.syncTableFromTemplate(), g();
    }, _ = () => {
      r.value.pushTableToTemplate(), g();
    }, C = () => {
      a.value = !1;
    };
    return lt(a, (R) => {
      R && g();
    }), e({
      open: () => {
        a.value = !0;
      }
    }), (R, U) => (S(), L("div", null, [
      mt(R.$slots, "default"),
      w(Ge, {
        visible: a.value,
        "onUpdate:visible": U[2] || (U[2] = (le) => a.value = le),
        title: "",
        closable: !0,
        height: "650px",
        onClose: C
      }, {
        titlePrefix: B(() => [
          w(po, {
            expanded: l.value,
            onToggle: y
          }, null, 8, ["expanded"])
        ]),
        default: B(() => [
          w(uo, {
            "drawer-expanded": l.value,
            "onUpdate:drawerExpanded": U[1] || (U[1] = (le) => l.value = le),
            tables: d.value,
            "selected-table": c.value,
            "show-sync-buttons": !0,
            onSelectTable: E,
            onCreateTable: T,
            onSync: N,
            onPush: _
          }, {
            default: B(() => [
              w(fo, {
                "active-tab": u.value,
                "onUpdate:activeTab": U[0] || (U[0] = (le) => u.value = le),
                tabs: h
              }, {
                data: B(() => [
                  w(cl, {
                    "data-service": Q(n),
                    tables: d.value,
                    "selected-table": c.value,
                    onRefresh: g
                  }, null, 8, ["data-service", "tables", "selected-table"])
                ]),
                template: B(() => [
                  w(ho, {
                    ref_key: "tableTabRef",
                    ref: m,
                    "table-service": Q(i),
                    tables: d.value,
                    "selected-table": c.value,
                    onRefresh: g,
                    "onUpdate:selectedTable": E
                  }, null, 8, ["table-service", "tables", "selected-table"])
                ]),
                sql: B(() => [
                  w(mo, {
                    "sql-executor-service": Q(o),
                    onRefresh: g
                  }, null, 8, ["sql-executor-service"])
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["drawer-expanded", "tables", "selected-table"])
        ]),
        _: 1
      }, 8, ["visible"])
    ]));
  }
}), hv = { class: "translation_settings" }, mv = { class: "inline-drawer" }, vv = { class: "inline-drawer-content" }, bv = { style: { padding: "10px" } }, gv = /* @__PURE__ */ Te({
  __name: "MainView",
  setup(t) {
    const e = /* @__PURE__ */ H(!1), s = () => {
      e.value = !0;
    };
    return (n, i) => (S(), L("div", hv, [
      f("div", mv, [
        i[1] || (i[1] = f("div", { class: "inline-drawer-toggle inline-drawer-header" }, [
          f("div", { style: { display: "flex", "align-items": "center", gap: "10px" } }, [
            f("b", null, "")
          ]),
          f("div", { class: "inline-drawer-icon fa-solid fa-circle-chevron-down down" })
        ], -1)),
        f("div", vv, [
          f("div", bv, [
            w(dv)
          ])
        ])
      ]),
      w(fv, { onClick: s }),
      w(pv, {
        visible: e.value,
        "onUpdate:visible": i[0] || (i[0] = (o) => e.value = o)
      }, null, 8, ["visible"])
    ]));
  }
}), Ev = /* @__PURE__ */ De(gv, [["__scopeId", "data-v-d18c04a2"]]);
class yv {
  static init() {
    if (Se.instance.extensionSwitch) {
      const e = SillyTavern.getContext(), { registerMacro: s, eventSource: n } = e;
      if (typeof window > "u")
        return;
      window.getTemplateSqlExecutor = () => Se.instance.tableTemplate, window.getChatSqlExecutor = () => Pe.instance.tableTemplate, window.chatDatabaseData = () => JSON.parse(Pe.instance.tableTemplate.export(ot.STANDARD_DATA)), n.on("prompt_template_prepare", (i) => {
        i.getTemplateSqlExecutor = () => Se.instance.tableTemplate, i.getChatSqlExecutor = () => Pe.instance.tableTemplate;
      }), this.registerMacros(s);
    }
  }
  static registerMacros(e) {
    const s = ke.chatTableManagementService;
    e("GET_ALL_TABLE_NAMES", () => s.getTables().map((n) => n.tableName)), e("GET_ALL_TABLE_SCHEMAS", () => Pe.instance.tableTemplate.export(ot.DDL)), e("GET_ALL_TABLE_DATA", () => Pe.instance.tableTemplate.export(ot.MARKDOWN));
  }
}
class _v {
  static init() {
    Js.init(), yv.init();
    const e = Mt.getInstance();
    e.updateChatTemplateDisplay(), Se.instance.onChatStatusBarChange(() => {
      e.updateChatTemplateDisplay();
    });
  }
}
_v.init();
const $r = document.createElement("div"), Ar = document.querySelector("#extensions_settings");
Ar && (Ar.appendChild($r), Nd(Ev).mount($r));
//# sourceMappingURL=index.js.map
